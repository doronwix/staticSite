/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.6 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.6',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
            /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttps://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                        scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                            normalize(name, parentName, applyMap) :
                            name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                '_unnormalized' + (unnormalizedCounter += 1) :
                '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                    prefix + '!' + normalizedName :
                    normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function (queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                            this.map.parentMap,
                            true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                'fromText eval for ' + id +
                                ' failed: ' + e,
                                e,
                                [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                            (this.map.isDefine ? this.map : this.map.parentMap),
                            false,
                            !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function (err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function (id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                            .replace(currDirRegExp, '')
                            .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                id +
                                '" has not been loaded yet for context: ' +
                                contextName +
                                (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                            relMap && relMap.id, true), ext, true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function (args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                'No define call for ' + moduleName,
                                null,
                                [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                    url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                    (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function (value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function (depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                        (parents.length ?
                            '", needed by: ' + parents.join(', ') :
                            '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
            document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
            document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                //Check if node.attachEvent is artificially added by custom script or
                //natively supported by browser
                //read https://github.com/requirejs/requirejs/issues/187
                //if we can NOT find [native code] then it must NOT natively supported.
                //in IE8, node.attachEvent does not have toString()
                //Note the test for "[native code" with no closing brace, see:
                //https://github.com/requirejs/requirejs/issues/273
                !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function () { }, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                    'importScripts failed for ' +
                    moduleName + ' at ' + url,
                    e,
                    [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/') + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));
define("vendor/require", function(){});

/*!
 * Knockout JavaScript library v3.5.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var A=this||(0,eval)("this"),w=A.document,R=A.navigator,v=A.jQuery,H=A.JSON;v||"undefined"===typeof jQuery||(v=jQuery);(function(n){"function"===typeof define&&define.amd?define('knockout',["exports","require"],n):"object"===typeof exports&&"object"===typeof module?n(module.exports||exports):n(A.ko={})})(function(S,T){function K(a,c){return null===a||typeof a in W?a===c:!1}function X(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function Y(b,c){var d;return function(){clearTimeout(d);
d=a.a.setTimeout(b,c)}}function Z(a,c){c&&"change"!==c?"beforeChange"===c?this.pc(a):this.gb(a,c):this.qc(a)}function aa(a,c){null!==c&&c.s&&c.s()}function ba(a,c){var d=this.qd,e=d[r];e.ra||(this.Qb&&this.mb[c]?(d.uc(c,a,this.mb[c]),this.mb[c]=null,--this.Qb):e.I[c]||d.uc(c,a,e.J?{da:a}:d.$c(a)),a.Ja&&a.gd())}var a="undefined"!==typeof S?S:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.L=function(a,c,d){a[c]=d};a.version="3.5.1";a.b("version",
a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1};a.a=function(){function b(a,b){for(var c in a)f.call(a,c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)f.call(b,c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var l=b[c].match(q)||[];a.a.D(d.match(q),function(b){a.a.Na(l,b,e)});b[c]=l.join(" ")}var f=Object.prototype.hasOwnProperty,g={__proto__:[]}instanceof Array,h="function"===typeof Symbol,m={},k={};m[R&&/Firefox\/2/i.test(R.userAgent)?
"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];m.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(m,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)k[b[c]]=a});var l={propertychange:!0},p=w&&function(){for(var a=3,b=w.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),q=/\S+/g,t;return{Jc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],
D:function(a,b,c){for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d,a)},A:"function"==typeof Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Lb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d,a))return a[d];return n},Pa:function(b,c){var d=a.a.A(b,c);0<d?b.splice(d,1):0===d&&b.shift()},wc:function(b){var c=[];b&&a.a.D(b,function(b){0>a.a.A(c,b)&&c.push(b)});return c},Mb:function(a,
b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)d.push(b.call(c,a[e],e));return d},jb:function(a,b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)b.call(c,a[e],e)&&d.push(a[e]);return d},Nb:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},Na:function(b,c,d){var e=a.a.A(a.a.bc(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},Ba:g,extend:c,setPrototypeOf:d,Ab:g?d:c,P:b,Ga:function(a,b,c){if(!a)return a;var d={},e;for(e in a)f.call(a,e)&&(d[e]=
b.call(c,a[e],e,a));return d},Tb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Yb:function(b){b=a.a.la(b);for(var c=(b[0]&&b[0].ownerDocument||w).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.oa(b[d]));return c},Ca:function(b,c){for(var d=0,e=b.length,l=[];d<e;d++){var k=b[d].cloneNode(!0);l.push(c?a.oa(k):k)}return l},va:function(b,c){a.a.Tb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},Xc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],
l=e.parentNode,k=0,f=c.length;k<f;k++)l.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ua:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},Zc:function(a,b){7>p?a.setAttribute("selected",b):a.selected=b},Db:function(a){return null===a||a===n?"":a.trim?
a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Ud:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},vd:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(1!==a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},Sb:function(b){return a.a.vd(b,b.ownerDocument.documentElement)},kd:function(b){return!!a.a.Lb(b,a.a.Sb)},R:function(a){return a&&
a.tagName&&a.tagName.toLowerCase()},Ac:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Ac(b),c)},Gc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},B:function(b,c,d){var e=a.a.Ac(d);d=l[c];if(a.options.useOnlyNativeEvents||d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var k=function(a){e.call(b,a)},f="on"+c;b.attachEvent(f,
k);a.a.K.za(b,function(){b.detachEvent(f,k)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else t||(t="function"==typeof v(b).on?"on":"bind"),v(b)[t](c,e)},Fb:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.R(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof w.createEvent)if("function"==
typeof b.dispatchEvent)d=w.createEvent(k[c]||"HTMLEvents"),d.initEvent(c,!0,!0,A,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");else v(b).trigger(c)},f:function(b){return a.O(b)?b():b},bc:function(b){return a.O(b)?b.v():b},Eb:function(b,c,d){var l;c&&("object"===typeof b.classList?
(l=b.classList[d?"add":"remove"],a.a.D(c.match(q),function(a){l.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},Bb:function(b,c){var d=a.a.f(c);if(null===d||d===n)d="";var e=a.h.firstChild(b);!e||3!=e.nodeType||a.h.nextSibling(e)?a.h.va(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Ad(b)},Yc:function(a,b){a.name=b;if(7>=p)try{var c=a.name.replace(/[&<>'"]/g,function(a){return"&#"+a.charCodeAt(0)+";"});a.mergeAttributes(w.createElement("<input name='"+
c+"'/>"),!1)}catch(d){}},Ad:function(a){9<=p&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},wd:function(a){if(p){var b=a.style.width;a.style.width=0;a.style.width=b}},Pd:function(b,c){b=a.a.f(b);c=a.a.f(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},la:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Da:function(a){return h?Symbol(a):a},Zd:6===p,$d:7===p,W:p,Lc:function(b,c){for(var d=a.a.la(b.getElementsByTagName("input")).concat(a.a.la(b.getElementsByTagName("textarea"))),
e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},l=[],k=d.length-1;0<=k;k--)e(d[k])&&l.push(d[k]);return l},Nd:function(b){return"string"==typeof b&&(b=a.a.Db(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},hc:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return H.stringify(a.a.f(b),c,d)},Od:function(c,d,e){e=e||{};var l=e.params||{},k=e.includeFields||this.Jc,f=c;if("object"==typeof c&&"form"===a.a.R(c))for(var f=c.action,h=k.length-1;0<=h;h--)for(var g=a.a.Lc(c,k[h]),m=g.length-1;0<=m;m--)l[g[m].name]=g[m].value;d=a.a.f(d);var p=w.createElement("form");p.style.display="none";p.action=f;p.method="post";for(var q in d)c=w.createElement("input"),c.type="hidden",c.name=q,c.value=a.a.hc(a.a.f(d[q])),p.appendChild(c);b(l,function(a,b){var c=w.createElement("input");
c.type="hidden";c.name=a;c.value=b;p.appendChild(c)});w.body.appendChild(p);e.submitter?e.submitter(p):p.submit();setTimeout(function(){p.parentNode.removeChild(p)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.D);a.b("utils.arrayFirst",a.a.Lb);a.b("utils.arrayFilter",a.a.jb);a.b("utils.arrayGetDistinctValues",a.a.wc);a.b("utils.arrayIndexOf",a.a.A);a.b("utils.arrayMap",a.a.Mb);a.b("utils.arrayPushAll",a.a.Nb);a.b("utils.arrayRemoveItem",a.a.Pa);a.b("utils.cloneNodes",a.a.Ca);a.b("utils.createSymbolOrString",
a.a.Da);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Jc);a.b("utils.getFormFields",a.a.Lc);a.b("utils.objectMap",a.a.Ga);a.b("utils.peekObservable",a.a.bc);a.b("utils.postJson",a.a.Od);a.b("utils.parseJson",a.a.Nd);a.b("utils.registerEventHandler",a.a.B);a.b("utils.stringifyJson",a.a.hc);a.b("utils.range",a.a.Pd);a.b("utils.toggleDomNodeCssClass",a.a.Eb);a.b("utils.triggerEvent",a.a.Fb);a.b("utils.unwrapObservable",a.a.f);a.b("utils.objectForEach",a.a.P);a.b("utils.addOrRemoveItem",
a.a.Na);a.b("utils.setTextContent",a.a.Bb);a.b("unwrap",a.a.f);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.g=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={},e,f;a.a.W?(e=function(a,e){var f=a[c];if(!f||"null"===f||!d[f]){if(!e)return n;f=a[c]="ko"+b++;d[f]=
{}}return d[f]},f=function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}):(e=function(a,b){var d=a[c];!d&&b&&(d=a[c]={});return d},f=function(a){return a[c]?(delete a[c],!0):!1});return{get:function(a,b){var c=e(a,!1);return c&&c[b]},set:function(a,b,c){(a=e(a,c!==n))&&(a[b]=c)},Ub:function(a,b,c){a=e(a,!0);return a[b]||(a[b]=c)},clear:f,Z:function(){return b++ +c}}};a.b("utils.domData",a.a.g);a.b("utils.domData.clear",a.a.g.clear);a.a.K=new function(){function b(b,c){var d=a.a.g.get(b,e);
d===n&&c&&(d=[],a.a.g.set(b,e,d));return d}function c(c){var e=b(c,!1);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);a.a.g.clear(c);a.a.K.cleanExternalData(c);g[c.nodeType]&&d(c.childNodes,!0)}function d(b,d){for(var e=[],l,f=0;f<b.length;f++)if(!d||8===b[f].nodeType)if(c(e[e.length]=l=b[f]),b[f]!==l)for(;f--&&-1==a.a.A(e,b[f]););}var e=a.a.g.Z(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{za:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},yb:function(c,
d){var f=b(c,!1);f&&(a.a.Pa(f,d),0==f.length&&a.a.g.set(c,e,n))},oa:function(b){a.u.G(function(){f[b.nodeType]&&(c(b),g[b.nodeType]&&d(b.getElementsByTagName("*")))});return b},removeNode:function(b){a.oa(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a])}}};a.oa=a.a.K.oa;a.removeNode=a.a.K.removeNode;a.b("cleanNode",a.oa);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.K);a.b("utils.domNodeDisposal.addDisposeCallback",
a.a.K.za);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.K.yb);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},g=8>=a.a.W;a.a.ua=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else{if((e=v.clean([c],d))&&e[0]){for(var l=e[0];l.parentNode&&11!==l.parentNode.nodeType;)l=l.parentNode;
l.parentNode&&l.parentNode.removeChild(l)}}else{(e=d)||(e=w);var l=e.parentWindow||e.defaultView||A,p=a.a.Db(c).toLowerCase(),q=e.createElement("div"),t;t=(p=p.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/))&&f[p[1]]||b;p=t[0];t="ignored<div>"+t[1]+c+t[2]+"</div>";"function"==typeof l.innerShiv?q.appendChild(l.innerShiv(t)):(g&&e.body.appendChild(q),q.innerHTML=t,g&&q.parentNode.removeChild(q));for(;p--;)q=q.lastChild;e=a.a.la(q.lastChild.childNodes)}return e};a.a.Md=function(b,c){var d=a.a.ua(b,
c);return d.length&&d[0].parentElement||a.a.Yb(d)};a.a.fc=function(b,c){a.a.Tb(b);c=a.a.f(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ua(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.ua);a.b("utils.setHtml",a.a.fc);a.aa=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.aa.Uc(c.nodeValue);null!=f&&e.push({ud:c,Kd:f})}else if(1==c.nodeType)for(var f=0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],
e)}var c={};return{Xb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},bd:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),!0}finally{delete c[a]}},cd:function(c,e){var f=
[];b(c,f);for(var g=0,h=f.length;g<h;g++){var m=f[g].ud,k=[m];e&&a.a.Nb(k,e);a.aa.bd(f[g].Kd,k);m.nodeValue="";m.parentNode&&m.parentNode.removeChild(m)}},Uc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.aa);a.b("memoization.memoize",a.aa.Xb);a.b("memoization.unmemoize",a.aa.bd);a.b("memoization.parseMemoText",a.aa.Uc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.aa.cd);a.na=function(){function b(){if(f)for(var b=f,c=0,d;h<f;)if(d=e[h++]){if(h>b){if(5E3<=
++c){h=f;a.a.Gc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=f}try{d()}catch(p){a.a.Gc(p)}}}function c(){b();h=f=e.length=0}var d,e=[],f=0,g=1,h=0;A.MutationObserver?d=function(a){var b=w.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):d=w&&"onreadystatechange"in w.createElement("script")?function(a){var b=w.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;w.documentElement.removeChild(b);
b=null;a()};w.documentElement.appendChild(b)}:function(a){setTimeout(a,0)};return{scheduler:d,zb:function(b){f||a.na.scheduler(c);e[f++]=b;return g++},cancel:function(a){a=a-(g-f);a>=h&&a<f&&(e[a]=null)},resetForTesting:function(){var a=f-h;h=f=e.length=0;return a},Sd:b}}();a.b("tasks",a.na);a.b("tasks.schedule",a.na.zb);a.b("tasks.runEarly",a.na.Sd);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.$({read:b,write:function(e){clearTimeout(d);d=a.a.setTimeout(function(){b(e)},
c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.Hb=!1;f="function"==typeof e?e:"notifyWhenChangesStop"==e?Y:X;a.ub(function(a){return f(a,d,c)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.Hb||(b.Hb=!0,b.ub(function(c){var e,f=!1;return function(){if(!f){a.na.cancel(e);e=a.na.zb(c);try{f=!0,b.notifySubscribers(n,"dirty")}finally{f=
!1}}}}))},notify:function(a,c){a.equalityComparer="always"==c?null:K}};var W={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Ta);a.ic=function(b,c,d){this.da=b;this.lc=c;this.mc=d;this.Ib=!1;this.fb=this.Jb=null;a.L(this,"dispose",this.s);a.L(this,"disposeWhenNodeIsRemoved",this.l)};a.ic.prototype.s=function(){this.Ib||(this.fb&&a.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null)};a.ic.prototype.l=function(b){this.Jb=b;a.a.K.za(b,this.fb=this.s.bind(this))};
a.T=function(){a.a.Ab(this,D);D.qb(this)};var D={qb:function(a){a.U={change:[]};a.sc=1},subscribe:function(b,c,d){var e=this;d=d||"change";var f=new a.ic(e,c?b.bind(c):b,function(){a.a.Pa(e.U[d],f);e.hb&&e.hb(d)});e.Qa&&e.Qa(d);e.U[d]||(e.U[d]=[]);e.U[d].push(f);return f},notifySubscribers:function(b,c){c=c||"change";"change"===c&&this.Gb();if(this.Wa(c)){var d="change"===c&&this.ed||this.U[c].slice(0);try{a.u.xc();for(var e=0,f;f=d[e];++e)f.Ib||f.lc(b)}finally{a.u.end()}}},ob:function(){return this.sc},
Dd:function(a){return this.ob()!==a},Gb:function(){++this.sc},ub:function(b){var c=this,d=a.O(c),e,f,g,h,m;c.gb||(c.gb=c.notifySubscribers,c.notifySubscribers=Z);var k=b(function(){c.Ja=!1;d&&h===c&&(h=c.nc?c.nc():c());var a=f||m&&c.sb(g,h);m=f=e=!1;a&&c.gb(g=h)});c.qc=function(a,b){b&&c.Ja||(m=!b);c.ed=c.U.change.slice(0);c.Ja=e=!0;h=a;k()};c.pc=function(a){e||(g=a,c.gb(a,"beforeChange"))};c.rc=function(){m=!0};c.gd=function(){c.sb(g,c.v(!0))&&(f=!0)}},Wa:function(a){return this.U[a]&&this.U[a].length},
Bd:function(b){if(b)return this.U[b]&&this.U[b].length||0;var c=0;a.a.P(this.U,function(a,b){"dirty"!==a&&(c+=b.length)});return c},sb:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},toString:function(){return"[object Object]"},extend:function(b){var c=this;b&&a.a.P(b,function(b,e){var f=a.Ta[b];"function"==typeof f&&(c=f(c,e)||c)});return c}};a.L(D,"init",D.qb);a.L(D,"subscribe",D.subscribe);a.L(D,"extend",D.extend);a.L(D,"getSubscriptionsCount",D.Bd);a.a.Ba&&a.a.setPrototypeOf(D,
Function.prototype);a.T.fn=D;a.Qc=function(a){return null!=a&&"function"==typeof a.subscribe&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.T);a.b("isSubscribable",a.Qc);a.S=a.u=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{xc:b,end:c,cc:function(b){if(e){if(!a.Qc(b))throw Error("Only subscribable things can act as dependencies");e.od.call(e.pd,b,b.fd||(b.fd=++f))}},G:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},qa:function(){if(e)return e.o.qa()},
Va:function(){if(e)return e.o.Va()},Ya:function(){if(e)return e.Ya},o:function(){if(e)return e.o}}}();a.b("computedContext",a.S);a.b("computedContext.getDependenciesCount",a.S.qa);a.b("computedContext.getDependencies",a.S.Va);a.b("computedContext.isInitial",a.S.Ya);a.b("computedContext.registerDependency",a.S.cc);a.b("ignoreDependencies",a.Yd=a.u.G);var I=a.a.Da("_latestValue");a.ta=function(b){function c(){if(0<arguments.length)return c.sb(c[I],arguments[0])&&(c.ya(),c[I]=arguments[0],c.xa()),this;
a.u.cc(c);return c[I]}c[I]=b;a.a.Ba||a.a.extend(c,a.T.fn);a.T.fn.qb(c);a.a.Ab(c,F);a.options.deferUpdates&&a.Ta.deferred(c,!0);return c};var F={equalityComparer:K,v:function(){return this[I]},xa:function(){this.notifySubscribers(this[I],"spectate");this.notifySubscribers(this[I])},ya:function(){this.notifySubscribers(this[I],"beforeChange")}};a.a.Ba&&a.a.setPrototypeOf(F,a.T.fn);var G=a.ta.Ma="__ko_proto__";F[G]=a.ta;a.O=function(b){if((b="function"==typeof b&&b[G])&&b!==F[G]&&b!==a.o.fn[G])throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");
return!!b};a.Za=function(b){return"function"==typeof b&&(b[G]===F[G]||b[G]===a.o.fn[G]&&b.Nc)};a.b("observable",a.ta);a.b("isObservable",a.O);a.b("isWriteableObservable",a.Za);a.b("isWritableObservable",a.Za);a.b("observable.fn",F);a.L(F,"peek",F.v);a.L(F,"valueHasMutated",F.xa);a.L(F,"valueWillMutate",F.ya);a.Ha=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.ta(b);a.a.Ab(b,
a.Ha.fn);return b.extend({trackArrayChanges:!0})};a.Ha.fn={remove:function(b){for(var c=this.v(),d=[],e="function"!=typeof b||a.O(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];if(e(g)){0===d.length&&this.ya();if(c[f]!==g)throw Error("Array modified during remove; cannot remove item");d.push(g);c.splice(f,1);f--}}d.length&&this.xa();return d},removeAll:function(b){if(b===n){var c=this.v(),d=c.slice(0);this.ya();c.splice(0,c.length);this.xa();return d}return b?this.remove(function(c){return 0<=
a.a.A(b,c)}):[]},destroy:function(b){var c=this.v(),d="function"!=typeof b||a.O(b)?function(a){return a===b}:b;this.ya();for(var e=c.length-1;0<=e;e--){var f=c[e];d(f)&&(f._destroy=!0)}this.xa()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.A(b,c)}):[]},indexOf:function(b){var c=this();return a.a.A(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ya(),this.v()[d]=c,this.xa())},sorted:function(a){var c=this().slice(0);
return a?c.sort(a):c.sort()},reversed:function(){return this().slice(0).reverse()}};a.a.Ba&&a.a.setPrototypeOf(a.Ha.fn,a.ta.fn);a.a.D("pop push reverse shift sort splice unshift".split(" "),function(b){a.Ha.fn[b]=function(){var a=this.v();this.ya();this.zc(a,b,arguments);var d=a[b].apply(a,arguments);this.xa();return d===a?this:d}});a.a.D(["slice"],function(b){a.Ha.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.Pc=function(b){return a.O(b)&&"function"==typeof b.remove&&"function"==
typeof b.push};a.b("observableArray",a.Ha);a.b("isObservableArray",a.Pc);a.Ta.trackArrayChanges=function(b,c){function d(){function c(){if(m){var d=[].concat(b.v()||[]),e;if(b.Wa("arrayChange")){if(!f||1<m)f=a.a.Pb(k,d,b.Ob);e=f}k=d;f=null;m=0;e&&e.length&&b.notifySubscribers(e,"arrayChange")}}e?c():(e=!0,h=b.subscribe(function(){++m},null,"spectate"),k=[].concat(b.v()||[]),f=null,g=b.subscribe(c))}b.Ob={};c&&"object"==typeof c&&a.a.extend(b.Ob,c);b.Ob.sparse=!0;if(!b.zc){var e=!1,f=null,g,h,m=0,
k,l=b.Qa,p=b.hb;b.Qa=function(a){l&&l.call(b,a);"arrayChange"===a&&d()};b.hb=function(a){p&&p.call(b,a);"arrayChange"!==a||b.Wa("arrayChange")||(g&&g.s(),h&&h.s(),h=g=null,e=!1,k=n)};b.zc=function(b,c,d){function l(a,b,c){return k[k.length]={status:a,value:b,index:c}}if(e&&!m){var k=[],p=b.length,g=d.length,h=0;switch(c){case "push":h=p;case "unshift":for(c=0;c<g;c++)l("added",d[c],h+c);break;case "pop":h=p-1;case "shift":p&&l("deleted",b[h],h);break;case "splice":c=Math.min(Math.max(0,0>d[0]?p+d[0]:
d[0]),p);for(var p=1===g?p:Math.min(c+(d[1]||0),p),g=c+g-2,h=Math.max(p,g),U=[],L=[],n=2;c<h;++c,++n)c<p&&L.push(l("deleted",b[c],c)),c<g&&U.push(l("added",d[n],c));a.a.Kc(L,U);break;default:return}f=k}}}};var r=a.a.Da("_state");a.o=a.$=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.nb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}g.ra||
a.u.cc(e);(g.ka||g.J&&e.Xa())&&e.ha();return g.X}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={X:n,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:d.read,nb:c||d.owner,l:d.disposeWhenNodeIsRemoved||d.l||null,Sa:d.disposeWhen||d.Sa,Rb:null,I:{},V:0,Ic:null};e[r]=g;e.Nc="function"===typeof f;a.a.Ba||a.a.extend(e,a.T.fn);a.T.fn.qb(e);a.a.Ab(e,C);d.pure?(g.wb=!0,g.J=!0,a.a.extend(e,da)):
d.deferEvaluation&&a.a.extend(e,ea);a.options.deferUpdates&&a.Ta.deferred(e,!0);g.l&&(g.jc=!0,g.l.nodeType||(g.l=null));g.J||d.deferEvaluation||e.ha();g.l&&e.ja()&&a.a.K.za(g.l,g.Rb=function(){e.s()});return e};var C={equalityComparer:K,qa:function(){return this[r].V},Va:function(){var b=[];a.a.P(this[r].I,function(a,d){b[d.Ka]=d.da});return b},Vb:function(b){if(!this[r].V)return!1;var c=this.Va();return-1!==a.a.A(c,b)?!0:!!a.a.Lb(c,function(a){return a.Vb&&a.Vb(b)})},uc:function(a,c,d){if(this[r].wb&&
c===this)throw Error("A 'pure' computed must not be called recursively");this[r].I[a]=d;d.Ka=this[r].V++;d.La=c.ob()},Xa:function(){var a,c,d=this[r].I;for(a in d)if(Object.prototype.hasOwnProperty.call(d,a)&&(c=d[a],this.Ia&&c.da.Ja||c.da.Dd(c.La)))return!0},Jd:function(){this.Ia&&!this[r].rb&&this.Ia(!1)},ja:function(){var a=this[r];return a.ka||0<a.V},Rd:function(){this.Ja?this[r].ka&&(this[r].sa=!0):this.Hc()},$c:function(a){if(a.Hb){var c=a.subscribe(this.Jd,this,"dirty"),d=a.subscribe(this.Rd,
this);return{da:a,s:function(){c.s();d.s()}}}return a.subscribe(this.Hc,this)},Hc:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[r].Ic),this[r].Ic=a.a.setTimeout(function(){b.ha(!0)},c)):b.Ia?b.Ia(!0):b.ha(!0)},ha:function(b){var c=this[r],d=c.Sa,e=!1;if(!c.rb&&!c.ra){if(c.l&&!a.a.Sb(c.l)||d&&d()){if(!c.jc){this.s();return}}else c.jc=!1;c.rb=!0;try{e=this.zd(b)}finally{c.rb=!1}return e}},zd:function(b){var c=this[r],d=!1,e=c.wb?n:!c.V,d={qd:this,mb:c.I,Qb:c.V};a.u.xc({pd:d,
od:ba,o:this,Ya:e});c.I={};c.V=0;var f=this.yd(c,d);c.V?d=this.sb(c.X,f):(this.s(),d=!0);d&&(c.J?this.Gb():this.notifySubscribers(c.X,"beforeChange"),c.X=f,this.notifySubscribers(c.X,"spectate"),!c.J&&b&&this.notifySubscribers(c.X),this.rc&&this.rc());e&&this.notifySubscribers(c.X,"awake");return d},yd:function(b,c){try{var d=b.Wc;return b.nb?d.call(b.nb):d()}finally{a.u.end(),c.Qb&&!b.J&&a.a.P(c.mb,aa),b.sa=b.ka=!1}},v:function(a){var c=this[r];(c.ka&&(a||!c.V)||c.J&&this.Xa())&&this.ha();return c.X},
ub:function(b){a.T.fn.ub.call(this,b);this.nc=function(){this[r].J||(this[r].sa?this.ha():this[r].ka=!1);return this[r].X};this.Ia=function(a){this.pc(this[r].X);this[r].ka=!0;a&&(this[r].sa=!0);this.qc(this,!a)}},s:function(){var b=this[r];!b.J&&b.I&&a.a.P(b.I,function(a,b){b.s&&b.s()});b.l&&b.Rb&&a.a.K.yb(b.l,b.Rb);b.I=n;b.V=0;b.ra=!0;b.sa=!1;b.ka=!1;b.J=!1;b.l=n;b.Sa=n;b.Wc=n;this.Nc||(b.nb=n)}},da={Qa:function(b){var c=this,d=c[r];if(!d.ra&&d.J&&"change"==b){d.J=!1;if(d.sa||c.Xa())d.I=null,d.V=
0,c.ha()&&c.Gb();else{var e=[];a.a.P(d.I,function(a,b){e[b.Ka]=a});a.a.D(e,function(a,b){var e=d.I[a],m=c.$c(e.da);m.Ka=b;m.La=e.La;d.I[a]=m});c.Xa()&&c.ha()&&c.Gb()}d.ra||c.notifySubscribers(d.X,"awake")}},hb:function(b){var c=this[r];c.ra||"change"!=b||this.Wa("change")||(a.a.P(c.I,function(a,b){b.s&&(c.I[a]={da:b.da,Ka:b.Ka,La:b.La},b.s())}),c.J=!0,this.notifySubscribers(n,"asleep"))},ob:function(){var b=this[r];b.J&&(b.sa||this.Xa())&&this.ha();return a.T.fn.ob.call(this)}},ea={Qa:function(a){"change"!=
a&&"beforeChange"!=a||this.v()}};a.a.Ba&&a.a.setPrototypeOf(C,a.T.fn);var N=a.ta.Ma;C[N]=a.o;a.Oc=function(a){return"function"==typeof a&&a[N]===C[N]};a.Fd=function(b){return a.Oc(b)&&b[r]&&b[r].wb};a.b("computed",a.o);a.b("dependentObservable",a.o);a.b("isComputed",a.Oc);a.b("isPureComputed",a.Fd);a.b("computed.fn",C);a.L(C,"peek",C.v);a.L(C,"dispose",C.s);a.L(C,"isActive",C.ja);a.L(C,"getDependenciesCount",C.qa);a.L(C,"getDependencies",C.Va);a.xb=function(b,c){if("function"===typeof b)return a.o(b,
c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.o(b,c)};a.b("pureComputed",a.xb);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var l=g.get(d);h[c]=l!==
n?l:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.values=[]}a.ad=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.O(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.ad(b);return a.a.hc(b,c,d)};d.prototype={constructor:d,save:function(b,c){var d=a.a.A(this.keys,
b);0<=d?this.values[d]=c:(this.keys.push(b),this.values.push(c))},get:function(b){b=a.a.A(this.keys,b);return 0<=b?this.values[b]:n}}})();a.b("toJS",a.ad);a.b("toJSON",a.toJSON);a.Wd=function(b,c,d){function e(c){var e=a.xb(b,d).extend({ma:"always"}),h=e.subscribe(function(a){a&&(h.s(),c(a))});e.notifySubscribers(e.v());return h}return"function"!==typeof Promise||c?e(c.bind(d)):new Promise(e)};a.b("when",a.Wd);(function(){a.w={M:function(b){switch(a.a.R(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?
a.a.g.get(b,a.c.options.$b):7>=a.a.W?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex]):n;default:return b.value}},cb:function(b,c,d){switch(a.a.R(b)){case "option":"string"===typeof c?(a.a.g.set(b,a.c.options.$b,n),"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__,b.value=c):(a.a.g.set(b,a.c.options.$b,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===
typeof c?c:"");break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.w.M(b.options[f]),h==c||""===h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e,6===a.a.W&&a.a.setTimeout(function(){b.selectedIndex=e},0);break;default:if(null===c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.w);a.b("selectExtensions.readValue",a.w.M);a.b("selectExtensions.writeValue",a.w.cb);a.m=function(){function b(b){b=a.a.Db(b);123===b.charCodeAt(0)&&(b=b.slice(1,
-1));b+="\n,";var c=[],d=b.match(e),p,q=[],h=0;if(1<d.length){for(var x=0,B;B=d[x];++x){var u=B.charCodeAt(0);if(44===u){if(0>=h){c.push(p&&q.length?{key:p,value:q.join("")}:{unknown:p||q.join("")});p=h=0;q=[];continue}}else if(58===u){if(!h&&!p&&1===q.length){p=q.pop();continue}}else if(47===u&&1<B.length&&(47===B.charCodeAt(1)||42===B.charCodeAt(1)))continue;else 47===u&&x&&1<B.length?(u=d[x-1].match(f))&&!g[u[0]]&&(b=b.substr(b.indexOf(B)+1),d=b.match(e),x=-1,B="/"):40===u||123===u||91===u?++h:
41===u||125===u||93===u?--h:p||q.length||34!==u&&39!==u||(B=B.slice(1,-1));q.push(B)}if(0<h)throw Error("Unbalanced parentheses, braces, or brackets");}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|`(?:\\\\.|[^`])*`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*\n|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,\"'`{}()/:[\\]]*[^\\s,\"'`{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},
h={};return{Ra:[],wa:h,ac:b,vb:function(e,f){function l(b,e){var f;if(!x){var k=a.getBindingHandler(b);if(k&&k.preprocess&&!(e=k.preprocess(e,b,l)))return;if(k=h[b])f=e,0<=a.a.A(c,f)?f=!1:(k=f.match(d),f=null===k?!1:k[1]?"Object("+k[1]+")"+k[2]:f),k=f;k&&q.push("'"+("string"==typeof h[b]?h[b]:b)+"':function(_z){"+f+"=_z}")}g&&(e="function(){return "+e+" }");p.push("'"+b+"':"+e)}f=f||{};var p=[],q=[],g=f.valueAccessors,x=f.bindingParams,B="string"===typeof e?b(e):e;a.a.D(B,function(a){l(a.key||a.unknown,
a.value)});q.length&&l("_ko_property_writers","{"+q.join(",")+" }");return p.join(",")},Id:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},eb:function(b,c,d,e,f){if(b&&a.O(b))!a.Za(b)||f&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.m);a.b("expressionRewriting.bindingRewriteValidators",a.m.Ra);a.b("expressionRewriting.parseObjectLiteral",a.m.ac);a.b("expressionRewriting.preProcessBindings",a.m.vb);a.b("expressionRewriting._twoWayBindings",
a.m.wa);a.b("jsonExpressionRewriting",a.m);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.m.vb);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(d,e){for(var f=d,h=1,g=[];f=f.nextSibling;){if(c(f)&&(a.a.g.set(f,k,!0),h--,0===h))return g;g.push(f);b(f)&&h++}if(!e)throw Error("Cannot find closing comment tag to match: "+d.nodeValue);return null}function e(a,b){var c=d(a,b);return c?
0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=w&&"\x3c!--test--\x3e"===w.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,m={ul:!0,ol:!0},k="__ko_matchedEndComment__";a.h={ea:{},childNodes:function(a){return b(a)?d(a):a.childNodes},Ea:function(c){if(b(c)){c=a.h.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.Tb(c)},va:function(c,d){if(b(c)){a.h.Ea(c);for(var e=
c.nextSibling,f=0,k=d.length;f<k;f++)e.parentNode.insertBefore(d[f],e)}else a.a.va(c,d)},Vc:function(a,c){var d;b(a)?(d=a.nextSibling,a=a.parentNode):d=a.firstChild;d?c!==d&&a.insertBefore(c,d):a.appendChild(c)},Wb:function(c,d,e){e?(e=e.nextSibling,b(c)&&(c=c.parentNode),e?d!==e&&c.insertBefore(d,e):c.appendChild(d)):a.h.Vc(c,d)},firstChild:function(a){if(b(a))return!a.nextSibling||c(a.nextSibling)?null:a.nextSibling;if(a.firstChild&&c(a.firstChild))throw Error("Found invalid end comment, as the first child of "+
a);return a.firstChild},nextSibling:function(d){b(d)&&(d=e(d));if(d.nextSibling&&c(d.nextSibling)){var f=d.nextSibling;if(c(f)&&!a.a.g.get(f,k))throw Error("Found end comment without a matching opening comment, as child of "+d);return null}return d.nextSibling},Cd:b,Vd:function(a){return(a=(f?a.text:a.nodeValue).match(g))?a[1]:null},Sc:function(d){if(m[a.a.R(d)]){var f=d.firstChild;if(f){do if(1===f.nodeType){var k;k=f.firstChild;var h=null;if(k){do if(h)h.push(k);else if(b(k)){var g=e(k,!0);g?k=
g:h=[k]}else c(k)&&(h=[k]);while(k=k.nextSibling)}if(k=h)for(h=f.nextSibling,g=0;g<k.length;g++)h?d.insertBefore(k[g],h):d.appendChild(k[g])}while(f=f.nextSibling)}}}}})();a.b("virtualElements",a.h);a.b("virtualElements.allowedBindings",a.h.ea);a.b("virtualElements.emptyNode",a.h.Ea);a.b("virtualElements.insertAfter",a.h.Wb);a.b("virtualElements.prepend",a.h.Vc);a.b("virtualElements.setDomNodeChildren",a.h.va);(function(){a.ga=function(){this.nd={}};a.a.extend(a.ga.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=
b.getAttribute("data-bind")||a.j.getComponentNameForNode(b);case 8:return a.h.Cd(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.j.tc(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.j.tc(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.h.Vd(b);default:return null}},
parseBindingsString:function(b,c,d,e){try{var f=this.nd,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var m,k="with($context){with($data||{}){return{"+a.m.vb(b,e)+"}}}";m=new Function("$context","$element",k);h=f[g]=m}return h(c,d)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.ga.instance=new a.ga})();a.b("bindingProvider",a.ga);(function(){function b(b){var c=(b=a.a.g.get(b,z))&&b.N;c&&(b.N=null,c.Tc())}function c(c,d,e){this.node=c;this.yc=
d;this.kb=[];this.H=!1;d.N||a.a.K.za(c,b);e&&e.N&&(e.N.kb.push(c),this.Kb=e)}function d(a){return function(){return a}}function e(a){return a()}function f(b){return a.a.Ga(a.u.G(b),function(a,c){return function(){return b()[c]}})}function g(b,c,e){return"function"===typeof b?f(b.bind(null,c,e)):a.a.Ga(b,d)}function h(a,b){return f(this.getBindings.bind(this,a,b))}function m(b,c){var d=a.h.firstChild(c);if(d){var e,f=a.ga.instance,l=f.preprocessNode;if(l){for(;e=d;)d=a.h.nextSibling(e),l.call(f,e);
d=a.h.firstChild(c)}for(;e=d;)d=a.h.nextSibling(e),k(b,e)}a.i.ma(c,a.i.H)}function k(b,c){var d=b,e=1===c.nodeType;e&&a.h.Sc(c);if(e||a.ga.instance.nodeHasBindings(c))d=p(c,null,b).bindingContextForDescendants;d&&!u[a.a.R(c)]&&m(d,c)}function l(b){var c=[],d={},e=[];a.a.P(b,function ca(f){if(!d[f]){var k=a.getBindingHandler(f);k&&(k.after&&(e.push(f),a.a.D(k.after,function(c){if(b[c]){if(-1!==a.a.A(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
ca(c)}}),e.length--),c.push({key:f,Mc:k}));d[f]=!0}});return c}function p(b,c,d){var f=a.a.g.Ub(b,z,{}),k=f.hd;if(!c){if(k)throw Error("You cannot apply bindings multiple times to the same element.");f.hd=!0}k||(f.context=d);f.Zb||(f.Zb={});var g;if(c&&"function"!==typeof c)g=c;else{var p=a.ga.instance,q=p.getBindingAccessors||h,m=a.$(function(){if(g=c?c(d,b):q.call(p,b,d)){if(d[t])d[t]();if(d[B])d[B]()}return g},null,{l:b});g&&m.ja()||(m=null)}var x=d,u;if(g){var J=function(){return a.a.Ga(m?m():
g,e)},r=m?function(a){return function(){return e(m()[a])}}:function(a){return g[a]};J.get=function(a){return g[a]&&e(r(a))};J.has=function(a){return a in g};a.i.H in g&&a.i.subscribe(b,a.i.H,function(){var c=(0,g[a.i.H])();if(c){var d=a.h.childNodes(b);d.length&&c(d,a.Ec(d[0]))}});a.i.pa in g&&(x=a.i.Cb(b,d),a.i.subscribe(b,a.i.pa,function(){var c=(0,g[a.i.pa])();c&&a.h.firstChild(b)&&c(b)}));f=l(g);a.a.D(f,function(c){var d=c.Mc.init,e=c.Mc.update,f=c.key;if(8===b.nodeType&&!a.h.ea[f])throw Error("The binding '"+
f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.u.G(function(){var a=d(b,r(f),J,x.$data,x);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f}}),"function"==typeof e&&a.$(function(){e(b,r(f),J,x.$data,x)},null,{l:b})}catch(k){throw k.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+k.message,
k;}})}f=u===n;return{shouldBindDescendants:f,bindingContextForDescendants:f&&x}}function q(b,c){return b&&b instanceof a.fa?b:new a.fa(b,n,n,c)}var t=a.a.Da("_subscribable"),x=a.a.Da("_ancestorBindingInfo"),B=a.a.Da("_dataDependency");a.c={};var u={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.c[b]};var J={};a.fa=function(b,c,d,e,f){function k(){var b=p?h():h,f=a.a.f(b);c?(a.a.extend(l,c),x in c&&(l[x]=c[x])):(l.$parents=[],l.$root=f,l.ko=a);l[t]=q;g?f=l.$data:(l.$rawData=
b,l.$data=f);d&&(l[d]=f);e&&e(l,c,f);if(c&&c[t]&&!a.S.o().Vb(c[t]))c[t]();m&&(l[B]=m);return l.$data}var l=this,g=b===J,h=g?n:b,p="function"==typeof h&&!a.O(h),q,m=f&&f.dataDependency;f&&f.exportDependencies?k():(q=a.xb(k),q.v(),q.ja()?q.equalityComparer=null:l[t]=n)};a.fa.prototype.createChildContext=function(b,c,d,e){!e&&c&&"object"==typeof c&&(e=c,c=e.as,d=e.extend);if(c&&e&&e.noChildContext){var f="function"==typeof b&&!a.O(b);return new a.fa(J,this,null,function(a){d&&d(a);a[c]=f?b():b},e)}return new a.fa(b,
this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)},e)};a.fa.prototype.extend=function(b,c){return new a.fa(J,this,null,function(c){a.a.extend(c,"function"==typeof b?b(c):b)},c)};var z=a.a.g.Z();c.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node)};c.prototype.sd=function(b){a.a.Pa(this.kb,b);!this.kb.length&&this.H&&this.Cc()};c.prototype.Cc=function(){this.H=!0;this.yc.N&&!this.kb.length&&(this.yc.N=
null,a.a.K.yb(this.node,b),a.i.ma(this.node,a.i.pa),this.Tc())};a.i={H:"childrenComplete",pa:"descendantsComplete",subscribe:function(b,c,d,e,f){var k=a.a.g.Ub(b,z,{});k.Fa||(k.Fa=new a.T);f&&f.notifyImmediately&&k.Zb[c]&&a.u.G(d,e,[b]);return k.Fa.subscribe(d,e,c)},ma:function(b,c){var d=a.a.g.get(b,z);if(d&&(d.Zb[c]=!0,d.Fa&&d.Fa.notifySubscribers(b,c),c==a.i.H))if(d.N)d.N.Cc();else if(d.N===n&&d.Fa&&d.Fa.Wa(a.i.pa))throw Error("descendantsComplete event not supported for bindings on this node");
},Cb:function(b,d){var e=a.a.g.Ub(b,z,{});e.N||(e.N=new c(b,e,d[x]));return d[x]==e?d:d.extend(function(a){a[x]=e})}};a.Td=function(b){return(b=a.a.g.get(b,z))&&b.context};a.ib=function(b,c,d){1===b.nodeType&&a.h.Sc(b);return p(b,c,q(d))};a.ld=function(b,c,d){d=q(d);return a.ib(b,g(c,d,b),d)};a.Oa=function(a,b){1!==b.nodeType&&8!==b.nodeType||m(q(a),b)};a.vc=function(a,b,c){!v&&A.jQuery&&(v=A.jQuery);if(2>arguments.length){if(b=w.body,!b)throw Error("ko.applyBindings: could not find document.body; has the document been loaded?");
}else if(!b||1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");k(q(a,c),b)};a.Dc=function(b){return!b||1!==b.nodeType&&8!==b.nodeType?n:a.Td(b)};a.Ec=function(b){return(b=a.Dc(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("bindingEvent",a.i);a.b("bindingEvent.subscribe",a.i.subscribe);a.b("bindingEvent.startPossiblyAsyncContentBinding",a.i.Cb);a.b("applyBindings",a.vc);a.b("applyBindingsToDescendants",a.Oa);
a.b("applyBindingAccessorsToNode",a.ib);a.b("applyBindingsToNode",a.ld);a.b("contextFor",a.Dc);a.b("dataFor",a.Ec)})();(function(b){function c(c,e){var k=Object.prototype.hasOwnProperty.call(f,c)?f[c]:b,l;k?k.subscribe(e):(k=f[c]=new a.T,k.subscribe(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Gd:e};delete f[c];l||e?k.notifySubscribers(b):a.na.zb(function(){k.notifySubscribers(b)})}),l=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,
c)}):b(null,null)})}function e(c,d,f,l){l||(l=a.j.loaders.slice(0));var g=l.shift();if(g){var q=g[c];if(q){var t=!1;if(q.apply(g,d.concat(function(a){t?f(null):null!==a?f(a):e(c,d,f,l)}))!==b&&(t=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,l)}else f(null)}var f={},g={};a.j={get:function(d,e){var f=Object.prototype.hasOwnProperty.call(g,d)?g[d]:b;f?f.Gd?a.u.G(function(){e(f.definition)}):
a.na.zb(function(){e(f.definition)}):c(d,e)},Bc:function(a){delete g[a]},oc:e};a.j.loaders=[];a.b("components",a.j);a.b("components.get",a.j.get);a.b("components.clearCachedDefinition",a.j.Bc)})();(function(){function b(b,c,d,e){function g(){0===--B&&e(h)}var h={},B=2,u=d.template;d=d.viewModel;u?f(c,u,function(c){a.j.oc("loadTemplate",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.j.oc("loadViewModel",[b,c],function(a){h[m]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
else if("function"===typeof b[m])d(b[m]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.R(b)){case "script":return a.a.ua(b.text);case "textarea":return a.a.ua(b.value);case "template":if(e(b.content))return a.a.Ca(b.content.childNodes)}return a.a.Ca(b.childNodes)}function e(a){return A.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
T||A.require?(T||A.require)([b.require],function(a){a&&"object"===typeof a&&a.Xd&&a["default"]&&(a=a["default"]);c(a)}):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.j.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.j.tb(b))throw Error("Component "+b+" is already registered");h[b]=c};a.j.tb=function(a){return Object.prototype.hasOwnProperty.call(h,a)};a.j.unregister=function(b){delete h[b];
a.j.Bc(b)};a.j.Fc={getConfig:function(b,c){c(a.j.tb(b)?h[b]:null)},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ua(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.la(c.childNodes));else if(c.element)if(c=c.element,A.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var h=w.getElementById(c);h?f(d(h)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+
c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),b,d)}};var m="createViewModel";a.b("components.register",a.j.register);a.b("components.isRegistered",a.j.tb);a.b("components.unregister",a.j.unregister);a.b("components.defaultLoader",a.j.Fc);a.j.loaders.push(a.j.Fc);a.j.dd=h})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ga(f,function(c){return a.o(c,null,{l:b})}),g=a.a.Ga(f,
function(c){var e=c.v();return c.ja()?a.o({read:function(){return a.a.f(c())},write:a.Za(e)&&function(a){c()(a)},l:b}):e});Object.prototype.hasOwnProperty.call(g,"$raw")||(g.$raw=f);return g}return{$raw:{}}}a.j.getComponentNameForNode=function(b){var c=a.a.R(b);if(a.j.tb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.W&&b.tagName===c))return c};a.j.tc=function(c,e,f,g){if(1===e.nodeType){var h=a.j.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
var m={name:h,params:b(e,f)};c.component=g?function(){return m}:m}}return c};var c=new a.ga;9>a.a.W&&(a.j.register=function(a){return function(b){return a.apply(this,arguments)}}(a.j.register),w.createDocumentFragment=function(b){return function(){var c=b(),f=a.j.dd,g;for(g in f);return c}}(w.createDocumentFragment))})();(function(){function b(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.Ca(c);a.h.va(d,b)}function c(a,b,c){var d=a.createViewModel;return d?d.call(a,
b,c):b}var d=0;a.c.component={init:function(e,f,g,h,m){function k(){var a=l&&l.dispose;"function"===typeof a&&a.call(l);q&&q.s();p=l=q=null}var l,p,q,t=a.a.la(a.h.childNodes(e));a.h.Ea(e);a.a.K.za(e,k);a.o(function(){var g=a.a.f(f()),h,u;"string"===typeof g?h=g:(h=a.a.f(g.name),u=a.a.f(g.params));if(!h)throw Error("No component name specified");var n=a.i.Cb(e,m),z=p=++d;a.j.get(h,function(d){if(p===z){k();if(!d)throw Error("Unknown component '"+h+"'");b(h,d,e);var f=c(d,u,{element:e,templateNodes:t});
d=n.createChildContext(f,{extend:function(a){a.$component=f;a.$componentTemplateNodes=t}});f&&f.koDescendantsComplete&&(q=a.i.subscribe(e,a.i.pa,f.koDescendantsComplete,f));l=f;a.Oa(d,e)}})},null,{l:e});return{controlsDescendantBindings:!0}}};a.h.ea.component=!0})();var V={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.f(c())||{};a.a.P(d,function(c,d){d=a.a.f(d);var g=c.indexOf(":"),g="lookupNamespaceURI"in b&&0<g&&b.lookupNamespaceURI(c.substr(0,g)),h=!1===d||null===
d||d===n;h?g?b.removeAttributeNS(g,c):b.removeAttribute(c):d=d.toString();8>=a.a.W&&c in V?(c=V[c],h?b.removeAttribute(c):b[c]=d):h||(g?b.setAttributeNS(g,c,d):b.setAttribute(c,d));"name"===c&&a.a.Yc(b,h?"":d)})}};(function(){a.c.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=g();if(!a.S.Ya()&&(e||!m&&!a.S.qa())){var k=a.u.G(c);if(l){var q=p?k.v():k,z=t;t=f;z!==f?e&&(a.a.Na(q,f,!0),a.a.Na(q,z,!1)):a.a.Na(q,f,e);p&&a.Za(k)&&k(q)}else h&&(f===n?f=e:e||(f=n)),a.m.eb(k,
d,"checked",f,!0)}}function f(){var d=a.a.f(c()),e=g();l?(b.checked=0<=a.a.A(d,e),t=e):b.checked=h&&e===n?!!d:g()===d}var g=a.xb(function(){if(d.has("checkedValue"))return a.a.f(d.get("checkedValue"));if(q)return d.has("value")?a.a.f(d.get("value")):b.value}),h="checkbox"==b.type,m="radio"==b.type;if(h||m){var k=c(),l=h&&a.a.f(k)instanceof Array,p=!(l&&k.push&&k.splice),q=m||l,t=l?g():n;m&&!b.name&&a.c.uniqueName.init(b,function(){return!0});a.o(e,null,{l:b});a.a.B(b,"click",e);a.o(f,null,{l:b});
k=n}}};a.m.wa.checked=!0;a.c.checkedValue={update:function(b,c){b.value=a.a.f(c())}}})();a.c["class"]={update:function(b,c){var d=a.a.Db(a.a.f(c()));a.a.Eb(b,b.__ko__cssValue,!1);b.__ko__cssValue=d;a.a.Eb(b,d,!0)}};a.c.css={update:function(b,c){var d=a.a.f(c());null!==d&&"object"==typeof d?a.a.P(d,function(c,d){d=a.a.f(d);a.a.Eb(b,c,d)}):a.c["class"].update(b,c)}};a.c.enable={update:function(b,c){var d=a.a.f(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.c.disable=
{update:function(b,c){a.c.enable.update(b,function(){return!a.a.f(c())})}};a.c.event={init:function(b,c,d,e,f){var g=c()||{};a.a.P(g,function(g){"string"==typeof g&&a.a.B(b,g,function(b){var k,l=c()[g];if(l){try{var p=a.a.la(arguments);e=f.$data;p.unshift(e);k=l.apply(e,p)}finally{!0!==k&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.c.foreach={Rc:function(b){return function(){var c=b(),d=a.a.bc(c);
if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.ba.Ma};a.a.f(c);return{foreach:d.data,as:d.as,noChildContext:d.noChildContext,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.ba.Ma}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.Rc(c))},update:function(b,c,d,e,f){return a.c.template.update(b,a.c.foreach.Rc(c),d,e,f)}};a.m.Ra.foreach=!1;a.h.ea.foreach=
!0;a.c.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(l){g=f.body}e=g===b}f=c();a.m.eb(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.B(b,"focus",f);a.a.B(b,"focusin",f);a.a.B(b,"blur",g);a.a.B(b,"focusout",g);b.__ko_hasfocusLastValue=!1},update:function(b,c){var d=!!a.a.f(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.u.G(a.a.Fb,null,[b,d?"focusin":"focusout"]))}};a.m.wa.hasfocus=!0;a.c.hasFocus=a.c.hasfocus;a.m.wa.hasFocus="hasfocus";a.c.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.fc(b,c())}};(function(){function b(b,d,e){a.c[b]={init:function(b,c,h,m,k){var l,p,q={},t,x,n;if(d){m=h.get("as");var u=h.get("noChildContext");n=!(m&&u);q={as:m,noChildContext:u,exportDependencies:n}}x=(t=
"render"==h.get("completeOn"))||h.has(a.i.pa);a.o(function(){var h=a.a.f(c()),m=!e!==!h,u=!p,r;if(n||m!==l){x&&(k=a.i.Cb(b,k));if(m){if(!d||n)q.dataDependency=a.S.o();r=d?k.createChildContext("function"==typeof h?h:c,q):a.S.qa()?k.extend(null,q):k}u&&a.S.qa()&&(p=a.a.Ca(a.h.childNodes(b),!0));m?(u||a.h.va(b,a.a.Ca(p)),a.Oa(r,b)):(a.h.Ea(b),t||a.i.ma(b,a.i.H));l=m}},null,{l:b});return{controlsDescendantBindings:!0}}};a.m.Ra[b]=!1;a.h.ea[b]=!0}b("if");b("ifnot",!1,!0);b("with",!0)})();a.c.let={init:function(b,
c,d,e,f){c=f.extend(c);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.let=!0;var Q={};a.c.options={init:function(b){if("select"!==a.a.R(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.jb(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,d){if(x&&l)a.i.ma(b,a.i.H);else if(t.length){var e=
0<=a.a.A(t,a.w.M(d[0]));a.a.Zc(d[0],e);x&&!e&&a.u.G(a.a.Fb,null,[b,"change"])}}var h=b.multiple,m=0!=b.length&&h?b.scrollTop:null,k=a.a.f(c()),l=d.get("valueAllowUnset")&&d.has("value"),p=d.get("optionsIncludeDestroyed");c={};var q,t=[];l||(h?t=a.a.Mb(e(),a.w.M):0<=b.selectedIndex&&t.push(a.w.M(b.options[b.selectedIndex])));k&&("undefined"==typeof k.length&&(k=[k]),q=a.a.jb(k,function(b){return p||b===n||null===b||!a.a.f(b._destroy)}),d.has("optionsCaption")&&(k=a.a.f(d.get("optionsCaption")),null!==
k&&k!==n&&q.unshift(Q)));var x=!1;c.beforeRemove=function(a){b.removeChild(a)};k=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(k=function(b,c){g(0,c);a.u.G(d.get("optionsAfterRender"),null,[c[0],b!==Q?b:n])});a.a.ec(b,q,function(c,e,g){g.length&&(t=!l&&g[0].selected?[a.w.M(g[0])]:[],x=!0);e=b.ownerDocument.createElement("option");c===Q?(a.a.Bb(e,d.get("optionsCaption")),a.w.cb(e,n)):(g=f(c,d.get("optionsValue"),c),a.w.cb(e,a.a.f(g)),c=f(c,d.get("optionsText"),g),
a.a.Bb(e,c));return[e]},c,k);if(!l){var B;h?B=t.length&&e().length<t.length:B=t.length&&0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex])!==t[0]:t.length||0<=b.selectedIndex;B&&a.u.G(a.a.Fb,null,[b,"change"])}(l||a.S.Ya())&&a.i.ma(b,a.i.H);a.a.wd(b);m&&20<Math.abs(m-b.scrollTop)&&(b.scrollTop=m)}};a.c.options.$b=a.a.g.Z();a.c.selectedOptions={init:function(b,c,d){function e(){var e=c(),f=[];a.a.D(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.w.M(b))});a.m.eb(e,d,"selectedOptions",
f)}function f(){var d=a.a.f(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.D(b.getElementsByTagName("option"),function(b){var c=0<=a.a.A(d,a.w.M(b));b.selected!=c&&a.a.Zc(b,c)});b.scrollTop=e}if("select"!=a.a.R(b))throw Error("selectedOptions binding applies only to SELECT elements");var g;a.i.subscribe(b,a.i.H,function(){g?e():(a.a.B(b,"change",e),g=a.o(f,null,{l:b}))},null,{notifyImmediately:!0})},update:function(){}};a.m.wa.selectedOptions=!0;a.c.style={update:function(b,c){var d=a.a.f(c()||
{});a.a.P(d,function(c,d){d=a.a.f(d);if(null===d||d===n||!1===d)d="";if(v)v(b).css(c,d);else if(/^--/.test(c))b.style.setProperty(c,d);else{c=c.replace(/-(\w)/g,function(a,b){return b.toUpperCase()});var g=b.style[c];b.style[c]=d;d===g||b.style[c]!=g||isNaN(d)||(b.style[c]=d+"px")}})}};a.c.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.B(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b)}finally{!0!==d&&(a.preventDefault?
a.preventDefault():a.returnValue=!1)}})}};a.c.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Bb(b,c())}};a.h.ea.text=!0;(function(){if(A&&A.navigator){var b=function(a){if(a)return parseFloat(a[1])},c=A.navigator.userAgent,d,e,f,g,h;(d=A.opera&&A.opera.version&&parseInt(A.opera.version()))||(h=b(c.match(/Edge\/([^ ]+)$/)))||b(c.match(/Chrome\/([^ ]+)/))||(e=b(c.match(/Version\/([^ ]+) Safari/)))||(f=b(c.match(/Firefox\/([^ ]+)/)))||(g=a.a.W||b(c.match(/MSIE ([^ ]+)/)))||
(g=b(c.match(/rv:([^ )]+)/)))}if(8<=g&&10>g)var m=a.a.g.Z(),k=a.a.g.Z(),l=function(b){var c=this.activeElement;(c=c&&a.a.g.get(c,k))&&c(b)},p=function(b,c){var d=b.ownerDocument;a.a.g.get(d,m)||(a.a.g.set(d,m,!0),a.a.B(d,"selectionchange",l));a.a.g.set(b,k,c)};a.c.textInput={init:function(b,c,k){function l(c,d){a.a.B(b,c,d)}function m(){var d=a.a.f(c());if(null===d||d===n)d="";L!==n&&d===L?a.a.setTimeout(m,4):b.value!==d&&(y=!0,b.value=d,y=!1,v=b.value)}function r(){w||(L=b.value,w=a.a.setTimeout(z,
4))}function z(){clearTimeout(w);L=w=n;var d=b.value;v!==d&&(v=d,a.m.eb(c(),k,"textInput",d))}var v=b.value,w,L,A=9==a.a.W?r:z,y=!1;g&&l("keypress",z);11>g&&l("propertychange",function(a){y||"value"!==a.propertyName||A(a)});8==g&&(l("keyup",z),l("keydown",z));p&&(p(b,A),l("dragend",r));(!g||9<=g)&&l("input",A);5>e&&"textarea"===a.a.R(b)?(l("keydown",r),l("paste",r),l("cut",r)):11>d?l("keydown",r):4>f?(l("DOMAutoComplete",z),l("dragdrop",z),l("drop",z)):h&&"number"===b.type&&l("keydown",r);l("change",
z);l("blur",z);a.o(m,null,{l:b})}};a.m.wa.textInput=!0;a.c.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.c.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.c.uniqueName.rd;a.a.Yc(b,d)}}};a.c.uniqueName.rd=0;a.c.using={init:function(b,c,d,e,f){var g;d.has("as")&&(g={as:d.get("as"),noChildContext:d.get("noChildContext")});c=f.createChildContext(c,g);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.using=!0;a.c.value={init:function(b,c,d){var e=a.a.R(b),f="input"==
e;if(!f||"checkbox"!=b.type&&"radio"!=b.type){var g=[],h=d.get("valueUpdate"),m=!1,k=null;h&&("string"==typeof h?g=[h]:g=a.a.wc(h),a.a.Pa(g,"change"));var l=function(){k=null;m=!1;var e=c(),f=a.w.M(b);a.m.eb(e,d,"value",f)};!a.a.W||!f||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.A(g,"propertychange")||(a.a.B(b,"propertychange",function(){m=!0}),a.a.B(b,"focus",function(){m=!1}),a.a.B(b,"blur",function(){m&&l()}));a.a.D(g,function(c){var d=l;a.a.Ud(c,"after")&&
(d=function(){k=a.w.M(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.B(b,c,d)});var p;p=f&&"file"==b.type?function(){var d=a.a.f(c());null===d||d===n||""===d?b.value="":a.u.G(l)}:function(){var f=a.a.f(c()),g=a.w.M(b);if(null!==k&&f===k)a.a.setTimeout(p,0);else if(f!==g||g===n)"select"===e?(g=d.get("valueAllowUnset"),a.w.cb(b,f,g),g||f===a.w.M(b)||a.u.G(l)):a.w.cb(b,f)};if("select"===e){var q;a.i.subscribe(b,a.i.H,function(){q?d.get("valueAllowUnset")?p():l():(a.a.B(b,"change",l),q=a.o(p,null,{l:b}))},
null,{notifyImmediately:!0})}else a.a.B(b,"change",l),a.o(p,null,{l:b})}else a.ib(b,{checkedValue:c})},update:function(){}};a.m.wa.value=!0;a.c.visible={update:function(b,c){var d=a.a.f(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};a.c.hidden={update:function(b,c){a.c.visible.update(b,function(){return!a.a.f(c())})}};(function(b){a.c[b]={init:function(c,d,e,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");
a.ca=function(){};a.ca.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.ca.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||w;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.C.F(d)}if(1==b.nodeType||8==b.nodeType)return new a.C.ia(b);throw Error("Unknown template type: "+b);};a.ca.prototype.renderTemplate=
function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.ca.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.ca.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.ca);a.kc=function(){function b(b,c,d,h){b=a.m.ac(b);for(var m=a.m.Ra,k=0;k<b.length;k++){var l=b[k].key;if(Object.prototype.hasOwnProperty.call(m,
l)){var p=m[l];if("function"===typeof p){if(l=p(b[k].value))throw Error(l);}else if(!p)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.m.vb(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,
d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{xd:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.kc.Ld(b,c)},d)},Ld:function(a,f){return a.replace(c,function(a,c,d,e,l){return b(l,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},md:function(b,c){return a.aa.Xb(function(d,h){var m=d.nextSibling;m&&m.nodeName.toLowerCase()===c&&a.ib(m,b,h)})}}}();a.b("__tr_ambtns",a.kc.md);(function(){a.C={};a.C.F=function(b){if(this.F=b){var c=
a.a.R(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4}};a.C.F.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.F[b];var c=arguments[0];"innerHTML"===b?a.a.fc(this.F,c):this.F[b]=c};var b=a.a.g.Z()+"_";a.C.F.prototype.data=function(c){if(1===arguments.length)return a.a.g.get(this.F,b+c);a.a.g.set(this.F,b+c,arguments[1])};var c=a.a.g.Z();a.C.F.prototype.nodes=function(){var b=this.F;
if(0==arguments.length){var e=a.a.g.get(b,c)||{},f=e.lb||(3===this.ab?b.content:4===this.ab?b:n);if(!f||e.jd){var g=this.text();g&&g!==e.bb&&(f=a.a.Md(g,b.ownerDocument),a.a.g.set(b,c,{lb:f,bb:g,jd:!0}))}return f}e=arguments[0];this.ab!==n&&this.text("");a.a.g.set(b,c,{lb:e})};a.C.ia=function(a){this.F=a};a.C.ia.prototype=new a.C.F;a.C.ia.prototype.constructor=a.C.ia;a.C.ia.prototype.text=function(){if(0==arguments.length){var b=a.a.g.get(this.F,c)||{};b.bb===n&&b.lb&&(b.bb=b.lb.innerHTML);return b.bb}a.a.g.set(this.F,
c,{bb:arguments[0]})};a.b("templateSources",a.C);a.b("templateSources.domElement",a.C.F);a.b("templateSources.anonymousTemplate",a.C.ia)})();(function(){function b(b,c,d){var e;for(c=a.h.nextSibling(c);b&&(e=b)!==c;)b=a.h.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=a.ga.instance,m=h.preprocessNode;if(m){b(e,f,function(a,b){var c=a.previousSibling,d=m.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):
(c.push(e,f),a.a.Ua(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.vc(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.aa.cd(b,[d])});a.a.Ua(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,m){m=m||{};var n=(b&&d(b)||f||{}).ownerDocument,B=m.templateEngine||g;a.kc.xd(f,B,n);f=B.renderTemplate(f,h,m,n);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.h.va(b,
f);n=!0;break;case "replaceNode":a.a.Xc(b,f);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}n&&(c(f,h),m.afterRender&&a.u.G(m.afterRender,null,[f,h[m.as||"$data"]]),"replaceChildren"==e&&a.i.ma(b,a.i.H));return f}function f(b,c,d){return a.O(b)?b():"function"===typeof b?b(c,d):b}var g;a.gc=function(b){if(b!=n&&!(b instanceof a.ca))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.dc=function(b,c,h,m,t){h=h||{};if((h.templateEngine||g)==
n)throw Error("Set a template engine before calling renderTemplate");t=t||"replaceChildren";if(m){var x=d(m);return a.$(function(){var g=c&&c instanceof a.fa?c:new a.fa(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(m,t,n,g,h);"replaceNode"==t&&(m=g,x=d(m))},null,{Sa:function(){return!x||!a.a.Sb(x)},l:x&&"replaceNode"==t?x.parentNode:x})}return a.aa.Xb(function(d){a.dc(b,c,h,d,"replaceNode")})};a.Qd=function(b,d,g,h,m){function x(b,c){a.u.G(a.a.ec,null,[h,b,u,g,r,c]);a.i.ma(h,a.i.H)}
function r(a,b){c(b,v);g.afterRender&&g.afterRender(b,a);v=null}function u(a,c){v=m.createChildContext(a,{as:z,noChildContext:g.noChildContext,extend:function(a){a.$index=c;z&&(a[z+"Index"]=c)}});var d=f(b,a,v);return e(h,"ignoreTargetNode",d,v,g)}var v,z=g.as,w=!1===g.includeDestroyed||a.options.foreachHidesDestroyed&&!g.includeDestroyed;if(w||g.beforeRemove||!a.Pc(d))return a.$(function(){var b=a.a.f(d)||[];"undefined"==typeof b.length&&(b=[b]);w&&(b=a.a.jb(b,function(b){return b===n||null===b||
!a.a.f(b._destroy)}));x(b)},null,{l:h});x(d.v());var A=d.subscribe(function(a){x(d(),a)},null,"arrayChange");A.l(h);return A};var h=a.a.g.Z(),m=a.a.g.Z();a.c.template={init:function(b,c){var d=a.a.f(c());if("string"==typeof d||"name"in d)a.h.Ea(b);else if("nodes"in d){d=d.nodes||[];if(a.O(d))throw Error('The "nodes" option must be a plain, non-observable array.');var e=d[0]&&d[0].parentNode;e&&a.a.g.get(e,m)||(e=a.a.Yb(d),a.a.g.set(e,m,!0));(new a.C.ia(b)).nodes(e)}else if(d=a.h.childNodes(b),0<d.length)e=
a.a.Yb(d),(new a.C.ia(b)).nodes(e);else throw Error("Anonymous template defined, but no template content was provided");return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.f(g);d=!0;e=null;"string"==typeof c?c={}:(g="name"in c?c.name:b,"if"in c&&(d=a.a.f(c["if"])),d&&"ifnot"in c&&(d=!a.a.f(c.ifnot)),d&&!g&&(d=!1));"foreach"in c?e=a.Qd(g,d&&c.foreach||[],c,b,f):d?(d=f,"data"in c&&(d=f.createChildContext(c.data,{as:c.as,noChildContext:c.noChildContext,exportDependencies:!0})),
e=a.dc(g,d,c,b)):a.h.Ea(b);f=e;(c=a.a.g.get(b,h))&&"function"==typeof c.s&&c.s();a.a.g.set(b,h,!f||f.ja&&!f.ja()?n:f)}};a.m.Ra.template=function(b){b=a.m.ac(b);return 1==b.length&&b[0].unknown||a.m.Id(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.h.ea.template=!0})();a.b("setTemplateEngine",a.gc);a.b("renderTemplate",a.dc);a.a.Kc=function(a,c,d){if(a.length&&c.length){var e,f,g,h,m;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;m=c[g];++g)if(h.value===
m.value){h.moved=m.index;m.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.Pb=function(){function b(b,d,e,f,g){var h=Math.min,m=Math.max,k=[],l,p=b.length,q,n=d.length,r=n-p||1,v=p+n+1,u,w,z;for(l=0;l<=p;l++)for(w=u,k.push(u=[]),z=h(n,l+r),q=m(0,l-1);q<=z;q++)u[q]=q?l?b[l-1]===d[q-1]?w[q-1]:h(w[q]||v,u[q-1]||v)+1:q+1:l+1;h=[];m=[];r=[];l=p;for(q=n;l||q;)n=k[l][q]-1,q&&n===k[l][q-1]?m.push(h[h.length]={status:e,value:d[--q],index:q}):l&&n===k[l-1][q]?r.push(h[h.length]={status:f,value:b[--l],index:l}):
(--q,--l,g.sparse||h.push({status:"retained",value:d[q]}));a.a.Kc(r,m,!g.dontLimitMoves&&10*p);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Pb);(function(){function b(b,c,d,h,m){var k=[],l=a.$(function(){var l=c(d,m,a.a.Ua(k,b))||[];0<k.length&&(a.a.Xc(k,l),h&&a.u.G(h,null,[d,l,m]));k.length=0;a.a.Nb(k,l)},null,{l:b,Sa:function(){return!a.a.kd(k)}});
return{Y:k,$:l.ja()?l:n}}var c=a.a.g.Z(),d=a.a.g.Z();a.a.ec=function(e,f,g,h,m,k){function l(b){y={Aa:b,pb:a.ta(w++)};v.push(y);r||F.push(y)}function p(b){y=t[b];w!==y.pb.v()&&D.push(y);y.pb(w++);a.a.Ua(y.Y,e);v.push(y)}function q(b,c){if(b)for(var d=0,e=c.length;d<e;d++)a.a.D(c[d].Y,function(a){b(a,d,c[d].Aa)})}f=f||[];"undefined"==typeof f.length&&(f=[f]);h=h||{};var t=a.a.g.get(e,c),r=!t,v=[],u=0,w=0,z=[],A=[],C=[],D=[],F=[],y,I=0;if(r)a.a.D(f,l);else{if(!k||t&&t._countWaitingForRemove){var E=
a.a.Mb(t,function(a){return a.Aa});k=a.a.Pb(E,f,{dontLimitMoves:h.dontLimitMoves,sparse:!0})}for(var E=0,G,H,K;G=k[E];E++)switch(H=G.moved,K=G.index,G.status){case "deleted":for(;u<K;)p(u++);H===n&&(y=t[u],y.$&&(y.$.s(),y.$=n),a.a.Ua(y.Y,e).length&&(h.beforeRemove&&(v.push(y),I++,y.Aa===d?y=null:C.push(y)),y&&z.push.apply(z,y.Y)));u++;break;case "added":for(;w<K;)p(u++);H!==n?(A.push(v.length),p(H)):l(G.value)}for(;w<f.length;)p(u++);v._countWaitingForRemove=I}a.a.g.set(e,c,v);q(h.beforeMove,D);a.a.D(z,
h.beforeRemove?a.oa:a.removeNode);var M,O,P;try{P=e.ownerDocument.activeElement}catch(N){}if(A.length)for(;(E=A.shift())!=n;){y=v[E];for(M=n;E;)if((O=v[--E].Y)&&O.length){M=O[O.length-1];break}for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M)}for(E=0;y=v[E];E++){y.Y||a.a.extend(y,b(e,g,y.Aa,m,y.pb));for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);!y.Ed&&m&&(m(y.Aa,y.Y,y.pb),y.Ed=!0,M=y.Y[y.Y.length-1])}P&&e.ownerDocument.activeElement!=P&&P.focus();q(h.beforeRemove,C);for(E=0;E<C.length;++E)C[E].Aa=d;q(h.afterMove,D);
q(h.afterAdd,F)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.ec);a.ba=function(){this.allowTemplateRewriting=!1};a.ba.prototype=new a.ca;a.ba.prototype.constructor=a.ba;a.ba.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.W?0:b.nodes)?b.nodes():null)return a.a.la(c.cloneNode(!0).childNodes);b=b.text();return a.a.ua(b,e)};a.ba.Ma=new a.ba;a.gc(a.ba.Ma);a.b("nativeTemplateEngine",a.ba);(function(){a.$a=function(){var a=this.Hd=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();
this.renderTemplateSource=function(b,e,f,g){g=g||w;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=v.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(h,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+
a+" })()) }}"};this.addTemplate=function(a,b){w.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || '');"},v.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.$a.prototype=new a.ca;a.$a.prototype.constructor=a.$a;var b=new a.$a;0<b.Hd&&a.gc(b);a.b("jqueryTmplTemplateEngine",a.$a)})()})})();})();

;(function(factory) {
    //CommonJS
    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        factory(require("knockout"), exports);
    //AMD
    } else if (typeof define === "function" && define.amd) {
        define('vendor/knockout-postbox',["knockout", "exports"], factory);
    //normal script tag
    } else {
        factory(ko, ko.postbox = {});
    }
}(function(ko, exports, undefined) {
    var disposeTopicSubscription, existingSubscribe,
        subscriptions = {},
        subId = 1;

    exports.subscriptions = subscriptions;

    //create a global postbox that supports subscribing/publishing
    ko.subscribable.call(exports);

    //keep a cache of the latest value and subscribers
    exports.topicCache = {};

    //allow customization of the function used to serialize values for the topic cache
    exports.serializer = ko.toJSON;

    //wrap notifySubscribers passing topic first and caching latest value
    exports.publish = function(topic, value) {
        if (topic) {
            //keep the value and a serialized version for comparison
            exports.topicCache[topic] = {
                value: value,
                serialized: exports.serializer(value)
            };
            exports.notifySubscribers(value, topic);
        }
    };

    //provide a subscribe API for the postbox that takes in the topic as first arg
    existingSubscribe = exports.subscribe;
    exports.subscribe = function(topic, action, target, initializeWithLatestValue) {
        var subscription, current, existingDispose;

        if (topic) {
            if (typeof target === "boolean") {
                initializeWithLatestValue = target;
                target = undefined;
            }

            subscription = existingSubscribe.call(exports, action, target, topic);
            subscription.subId = ++subId;
            subscriptions[ subId ] = subscription;

            if (initializeWithLatestValue) {
                current = exports.topicCache[topic];

                if (current !== undefined) {
                    action.call(target, current.value);
                }
            }

            existingDispose = subscription.dispose;
            subscription.dispose = function() {
                delete subscriptions[subscription.subId];
                existingDispose.call(subscription);
            };

            return subscription;
        }
    };

    //clean up all subscriptions and references
    exports.reset = function() {
        var subscription;

        for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
                subscription = subscriptions[id];

                if (subscription && typeof subscription.dispose === "function") {
                    subscription.dispose();
                }
            }
        }

        exports.topicCache = {};
    };

    //by default publish when the previous cached value does not equal the new value
    exports.defaultComparer = function(newValue, cacheItem) {
        return cacheItem && exports.serializer(newValue) === cacheItem.serialized;
    };

    //augment observables/computeds with the ability to automatically publish updates on a topic
    ko.subscribable.fn.publishOn = function(topic, skipInitialOrEqualityComparer, equalityComparer) {
        var skipInitialPublish, subscription, existingDispose;

        if (topic) {
            //allow passing the equalityComparer as the second argument
            if (typeof skipInitialOrEqualityComparer === "function") {
                equalityComparer = skipInitialOrEqualityComparer;
            } else {
                skipInitialPublish = skipInitialOrEqualityComparer;
            }

            equalityComparer = equalityComparer || exports.defaultComparer;

            //remove any existing subs
            disposeTopicSubscription.call(this, topic, "publishOn");

            //keep a reference to the subscription, so we can stop publishing
            subscription = this.subscribe(function(newValue) {
                if (!equalityComparer.call(this, newValue, exports.topicCache[topic])) {
                    exports.publish(topic, newValue);
                }
            }, this);

            //track the subscription in case of a reset
            subscription.id = ++subId;
            subscriptions[subId] = subscription;

            //ensure that we cleanup pointers to subscription on dispose
            existingDispose = subscription.dispose;
            subscription.dispose = function() {
                delete this.postboxSubs[topic].publishOn;
                delete subscriptions[subscription.id];

                existingDispose.call(subscription);
            }.bind(this);

            this.postboxSubs[topic].publishOn = subscription;

            //do an initial publish
            if (!skipInitialPublish) {
                exports.publish(topic, this());
            }
        }

        return this;
    };

    //handle disposing a subscription used to publish or subscribe to a topic
    disposeTopicSubscription = function(topic, type) {
        var subs = this.postboxSubs = this.postboxSubs || {};
        subs[topic] = subs[topic] || {};

        if (subs[topic][type]) {
            subs[topic][type].dispose();
        }
    };

    //discontinue automatically publishing on a topic
    ko.subscribable.fn.stopPublishingOn = function(topic) {
        disposeTopicSubscription.call(this, topic, "publishOn");

        return this;
    };

    //augment observables/computeds to automatically be updated by notifications on a topic
    ko.subscribable.fn.subscribeTo = function(topic, initializeWithLatestValueOrTransform, transform) {
        var initializeWithLatestValue, current, callback, subscription, existingDispose,
            self = this;

        //allow passing the filter as the second argument
        if (typeof initializeWithLatestValueOrTransform === "function") {
            transform = initializeWithLatestValueOrTransform;
        } else {
            initializeWithLatestValue = initializeWithLatestValueOrTransform;
        }

        if (topic && ko.isWriteableObservable(this)) {
            //remove any existing subs
            disposeTopicSubscription.call(this, topic, "subscribeTo");

            //if specified, apply a filter function in the subscription
            callback = function(newValue) {
                self(transform ? transform.call(self, newValue) : newValue);
            };

            ////keep a reference to the subscription, so we can unsubscribe, if necessary
            subscription = exports.subscribe(topic, callback);
            this.postboxSubs[topic].subscribeTo = subscription;

            //ensure that we cleanup pointers to subscription on dispose
            existingDispose = subscription.dispose;
            subscription.dispose = function() {
                delete this.postboxSubs[topic].subscribeTo;
                existingDispose.call(subscription);
            }.bind(this);

            if (initializeWithLatestValue) {
                current = exports.topicCache[topic];

                if (current !== undefined) {
                    callback(current.value);
                }
            }
        }

        return this;
    };

    //discontinue receiving updates on a topic
    ko.subscribable.fn.unsubscribeFrom = function(topic) {
        disposeTopicSubscription.call(this, topic, "subscribeTo");

        return this;
    };

    // both subscribe and publish on the same topic
    //   -allows the ability to sync an observable/writeable computed/observableArray between view models
    //   -subscribeTo should really not use a filter function, as it would likely cause infinite recursion
    ko.subscribable.fn.syncWith = function(topic, initializeWithLatestValue, skipInitialOrEqualityComparer, equalityComparer) {
        this.subscribeTo(topic, initializeWithLatestValue).publishOn(topic, skipInitialOrEqualityComparer, equalityComparer);

        return this;
    };

    ko.postbox = exports;
}));

/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
(function (global, factory) {

    "use strict";

    if (typeof module === "object" && typeof module.exports === "object") {

        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory(global, true) :
            function (w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
    } else {
        factory(global);
    }

    // Pass this if window is not defined yet
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {

    // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
    // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
    // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
    // enough that all such attempts are guarded in a try block.
    "use strict";

    var arr = [];

    var getProto = Object.getPrototypeOf;

    var slice = arr.slice;

    var flat = arr.flat ? function (array) {
        return arr.flat.call(array);
    } : function (array) {
        return arr.concat.apply([], array);
    };


    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var fnToString = hasOwn.toString;

    var ObjectFunctionString = fnToString.call(Object);

    var support = {};

    var isFunction = function isFunction(obj) {

        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
    };


    var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
    };


    var document = window.document;



    var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
    };

    function DOMEval(code, node, doc) {
        doc = doc || document;

        var i, val,
            script = doc.createElement("script");

        script.text = code;
        if (node) {
            for (i in preservedScriptAttributes) {

                // Support: Firefox 64+, Edge 18+
                // Some browsers don't support the "nonce" property on scripts.
                // On the other hand, just using `getAttribute` is not enough as
                // the `nonce` attribute is reset to an empty string whenever it
                // becomes browsing-context connected.
                // See https://github.com/whatwg/html/issues/2369
                // See https://html.spec.whatwg.org/#nonce-attributes
                // The `node.getAttribute` check was added for the sake of
                // `jQuery.globalEval` so that it can fake a nonce-containing node
                // via an object.
                val = node[i] || node.getAttribute && node.getAttribute(i);
                if (val) {
                    script.setAttribute(i, val);
                }
            }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
    }


    function toType(obj) {
        if (obj == null) {
            return obj + "";
        }

        // Support: Android <=2.3 only (functionish RegExp)
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[toString.call(obj)] || "object" :
            typeof obj;
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module



    var
        version = "3.5.1",

        // Define a local copy of jQuery
        jQuery = function (selector, context) {

            // The jQuery object is actually just the init constructor 'enhanced'
            // Need init if jQuery is called (just allow error to be thrown if not included)
            return new jQuery.fn.init(selector, context);
        };

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function () {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function (num) {

            // Return all the elements in a clean array
            if (num == null) {
                return slice.call(this);
            }

            // Return just the one element from the set
            return num < 0 ? this[num + this.length] : this[num];
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function (elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function (callback) {
            return jQuery.each(this, callback);
        },

        map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function () {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function () {
            return this.eq(0);
        },

        last: function () {
            return this.eq(-1);
        },

        even: function () {
            return this.pushStack(jQuery.grep(this, function (_elem, i) {
                return (i + 1) % 2;
            }));
        },

        odd: function () {
            return this.pushStack(jQuery.grep(this, function (_elem, i) {
                return i % 2;
            }));
        },

        eq: function (i) {
            var len = this.length,
                j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function () {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {

            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {

                // Extend the base object
                for (name in options) {
                    copy = options[name];

                    // Prevent Object.prototype pollution
                    // Prevent never-ending loop
                    if (name === "__proto__" || target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) ||
                        (copyIsArray = Array.isArray(copy)))) {
                        src = target[name];

                        // Ensure proper type for the source value
                        if (copyIsArray && !Array.isArray(src)) {
                            clone = [];
                        } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                            clone = {};
                        } else {
                            clone = src;
                        }
                        copyIsArray = false;

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function (msg) {
            throw new Error(msg);
        },

        noop: function () { },

        isPlainObject: function (obj) {
            var proto, Ctor;

            // Detect obvious negatives
            // Use toString instead of jQuery.type to catch host objects
            if (!obj || toString.call(obj) !== "[object Object]") {
                return false;
            }

            proto = getProto(obj);

            // Objects with no prototype (e.g., `Object.create( null )`) are plain
            if (!proto) {
                return true;
            }

            // Objects with prototype are plain iff they were constructed by a global Object function
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },

        isEmptyObject: function (obj) {
            var name;

            for (name in obj) {
                return false;
            }
            return true;
        },

        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function (code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
        },

        each: function (obj, callback) {
            var length, i = 0;

            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }

            return obj;
        },

        // results is for internal usage only
        makeArray: function (arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret,
                        typeof arr === "string" ?
                            [arr] : arr
                    );
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function (first, second) {
            var len = +second.length,
                j = 0,
                i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function (elems, callback, invert) {
            var callbackInverse,
                matches = [],
                i = 0,
                length = elems.length,
                callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function (elems, callback, arg) {
            var length, value,
                i = 0,
                ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return flat(ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function (_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
        });

    function isArrayLike(obj) {

        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType(obj);

        if (isFunction(obj) || isWindow(obj)) {
            return false;
        }

        return type === "array" || length === 0 ||
            typeof length === "number" && length > 0 && (length - 1) in obj;
    }
    var Sizzle =
        /*!
         * Sizzle CSS Selector Engine v2.3.5
         * https://sizzlejs.com/
         *
         * Copyright JS Foundation and other contributors
         * Released under the MIT license
         * https://js.foundation/
         *
         * Date: 2020-03-14
         */
        (function (window) {
            var i,
                support,
                Expr,
                getText,
                isXML,
                tokenize,
                compile,
                select,
                outermostContext,
                sortInput,
                hasDuplicate,

                // Local document vars
                setDocument,
                document,
                docElem,
                documentIsHTML,
                rbuggyQSA,
                rbuggyMatches,
                matches,
                contains,

                // Instance-specific data
                expando = "sizzle" + 1 * new Date(),
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                nonnativeSelectorCache = createCache(),
                sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                },

                // Instance methods
                hasOwn = ({}).hasOwnProperty,
                arr = [],
                pop = arr.pop,
                pushNative = arr.push,
                push = arr.push,
                slice = arr.slice,

                // Use a stripped-down indexOf as it's faster than native
                // https://jsperf.com/thor-indexof-vs-for/5
                indexOf = function (list, elem) {
                    var i = 0,
                        len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                },

                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
                    "ismap|loop|multiple|open|readonly|required|scoped",

                // Regular expressions

                // http://www.w3.org/TR/css3-selectors/#whitespace
                whitespace = "[\\x20\\t\\r\\n\\f]",

                // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
                identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
                    "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

                // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

                    // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace +

                    // "Attribute values must be CSS identifiers [capture 5]
                    // or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
                    whitespace + "*\\]",

                pseudos = ":(" + identifier + ")(?:\\((" +

                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

                    // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

                    // 3. anything else (capture 2)
                    ".*" +
                    ")\\)|)",

                // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
                    whitespace + "+$", "g"),

                rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
                    "*"),
                rdescend = new RegExp(whitespace + "|>"),

                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),

                matchExpr = {
                    "ID": new RegExp("^#(" + identifier + ")"),
                    "CLASS": new RegExp("^\\.(" + identifier + ")"),
                    "TAG": new RegExp("^(" + identifier + "|[*])"),
                    "ATTR": new RegExp("^" + attributes),
                    "PSEUDO": new RegExp("^" + pseudos),
                    "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
                        whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
                        whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                    "bool": new RegExp("^(?:" + booleans + ")$", "i"),

                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    "needsContext": new RegExp("^" + whitespace +
                        "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
                        "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                },

                rhtml = /HTML$/i,
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,

                rnative = /^[^{]+\{\s*\[native \w/,

                // Easily-parseable/retrievable ID or TAG or CLASS selectors
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                rsibling = /[+~]/,

                // CSS escapes
                // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
                funescape = function (escape, nonHex) {
                    var high = "0x" + escape.slice(1) - 0x10000;

                    return nonHex ?

                        // Strip the backslash prefix from a non-hex escape sequence
                        nonHex :

                        // Replace a hexadecimal escape sequence with the encoded Unicode code point
                        // Support: IE <=11+
                        // For values outside the Basic Multilingual Plane (BMP), manually construct a
                        // surrogate pair
                        high < 0 ?
                            String.fromCharCode(high + 0x10000) :
                            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                },

                // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                fcssescape = function (ch, asCodePoint) {
                    if (asCodePoint) {

                        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                        if (ch === "\0") {
                            return "\uFFFD";
                        }

                        // Control characters and (dependent upon position) numbers get escaped as code points
                        return ch.slice(0, -1) + "\\" +
                            ch.charCodeAt(ch.length - 1).toString(16) + " ";
                    }

                    // Other potentially-special ASCII characters get backslash-escaped
                    return "\\" + ch;
                },

                // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                unloadHandler = function () {
                    setDocument();
                },

                inDisabledFieldset = addCombinator(
                    function (elem) {
                        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
                    },
                    { dir: "parentNode", next: "legend" }
                );

            // Optimize for push.apply( _, NodeList )
            try {
                push.apply(
                    (arr = slice.call(preferredDoc.childNodes)),
                    preferredDoc.childNodes
                );

                // Support: Android<4.0
                // Detect silently failing push.apply
                // eslint-disable-next-line no-unused-expressions
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ?

                        // Leverage slice if possible
                        function (target, els) {
                            pushNative.apply(target, slice.call(els));
                        } :

                        // Support: IE<9
                        // Otherwise append directly
                        function (target, els) {
                            var j = target.length,
                                i = 0;

                            // Can't trust NodeList.length
                            while ((target[j++] = els[i++])) { }
                            target.length = j - 1;
                        }
                };
            }

            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, match, groups, newSelector,
                    newContext = context && context.ownerDocument,

                    // nodeType defaults to 9, since context defaults to document
                    nodeType = context ? context.nodeType : 9;

                results = results || [];

                // Return early from calls with invalid selector or context
                if (typeof selector !== "string" || !selector ||
                    nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                    return results;
                }

                // Try to shortcut find operations (as opposed to filters) in HTML documents
                if (!seed) {
                    setDocument(context);
                    context = context || document;

                    if (documentIsHTML) {

                        // If the selector is sufficiently simple, try using a "get*By*" DOM method
                        // (excepting DocumentFragment context, where the methods don't exist)
                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                            // ID selector
                            if ((m = match[1])) {

                                // Document context
                                if (nodeType === 9) {
                                    if ((elem = context.getElementById(m))) {

                                        // Support: IE, Opera, Webkit
                                        // TODO: identify versions
                                        // getElementById can match elements by name instead of ID
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }

                                    // Element context
                                } else {

                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (newContext && (elem = newContext.getElementById(m)) &&
                                        contains(context, elem) &&
                                        elem.id === m) {

                                        results.push(elem);
                                        return results;
                                    }
                                }

                                // Type selector
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;

                                // Class selector
                            } else if ((m = match[3]) && support.getElementsByClassName &&
                                context.getElementsByClassName) {

                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }

                        // Take advantage of querySelectorAll
                        if (support.qsa &&
                            !nonnativeSelectorCache[selector + " "] &&
                            (!rbuggyQSA || !rbuggyQSA.test(selector)) &&

                            // Support: IE 8 only
                            // Exclude object elements
                            (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {

                            newSelector = selector;
                            newContext = context;

                            // qSA considers elements outside a scoping root when evaluating child or
                            // descendant combinators, which is not what we want.
                            // In such cases, we work around the behavior by prefixing every selector in the
                            // list with an ID selector referencing the scope context.
                            // The technique has to be used as well when a leading combinator is used
                            // as such selectors are not recognized by querySelectorAll.
                            // Thanks to Andrew Dupont for this technique.
                            if (nodeType === 1 &&
                                (rdescend.test(selector) || rcombinators.test(selector))) {

                                // Expand context for sibling selectors
                                newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                    context;

                                // We can use :scope instead of the ID hack if the browser
                                // supports it & if we're not changing the context.
                                if (newContext !== context || !support.scope) {

                                    // Capture the context ID, setting it first if necessary
                                    if ((nid = context.getAttribute("id"))) {
                                        nid = nid.replace(rcssescape, fcssescape);
                                    } else {
                                        context.setAttribute("id", (nid = expando));
                                    }
                                }

                                // Prefix every selector in the list
                                groups = tokenize(selector);
                                i = groups.length;
                                while (i--) {
                                    groups[i] = (nid ? "#" + nid : ":scope") + " " +
                                        toSelector(groups[i]);
                                }
                                newSelector = groups.join(",");
                            }

                            try {
                                push.apply(results,
                                    newContext.querySelectorAll(newSelector)
                                );
                                return results;
                            } catch (qsaError) {
                                nonnativeSelectorCache(selector, true);
                            } finally {
                                if (nid === expando) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }

                // All others
                return select(selector.replace(rtrim, "$1"), context, results, seed);
            }

            /**
             * Create key-value caches of limited size
             * @returns {function(string, object)} Returns the Object data after storing it on itself with
             *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
             *	deleting the oldest entry
             */
            function createCache() {
                var keys = [];

                function cache(key, value) {

                    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                    if (keys.push(key + " ") > Expr.cacheLength) {

                        // Only keep the most recent entries
                        delete cache[keys.shift()];
                    }
                    return (cache[key + " "] = value);
                }
                return cache;
            }

            /**
             * Mark a function for special use by Sizzle
             * @param {Function} fn The function to mark
             */
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }

            /**
             * Support testing using an element
             * @param {Function} fn Passed the created element and returns a boolean result
             */
            function assert(fn) {
                var el = document.createElement("fieldset");

                try {
                    return !!fn(el);
                } catch (e) {
                    return false;
                } finally {

                    // Remove from its parent by default
                    if (el.parentNode) {
                        el.parentNode.removeChild(el);
                    }

                    // release memory in IE
                    el = null;
                }
            }

            /**
             * Adds the same handler for all of the specified attrs
             * @param {String} attrs Pipe-separated list of attributes
             * @param {Function} handler The method that will be applied
             */
            function addHandle(attrs, handler) {
                var arr = attrs.split("|"),
                    i = arr.length;

                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }

            /**
             * Checks document order of two siblings
             * @param {Element} a
             * @param {Element} b
             * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
             */
            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        a.sourceIndex - b.sourceIndex;

                // Use IE sourceIndex if available on both nodes
                if (diff) {
                    return diff;
                }

                // Check if b follows a
                if (cur) {
                    while ((cur = cur.nextSibling)) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }

                return a ? 1 : -1;
            }

            /**
             * Returns a function to use in pseudos for input types
             * @param {String} type
             */
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for buttons
             * @param {String} type
             */
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && elem.type === type;
                };
            }

            /**
             * Returns a function to use in pseudos for :enabled/:disabled
             * @param {Boolean} disabled true for :disabled; false for :enabled
             */
            function createDisabledPseudo(disabled) {

                // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                return function (elem) {

                    // Only certain elements can match :enabled or :disabled
                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                    // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                    if ("form" in elem) {

                        // Check for inherited disabledness on relevant non-disabled elements:
                        // * listed form-associated elements in a disabled fieldset
                        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                        // * option elements in a disabled optgroup
                        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                        // All such elements have a "form" property.
                        if (elem.parentNode && elem.disabled === false) {

                            // Option elements defer to a parent optgroup if present
                            if ("label" in elem) {
                                if ("label" in elem.parentNode) {
                                    return elem.parentNode.disabled === disabled;
                                } else {
                                    return elem.disabled === disabled;
                                }
                            }

                            // Support: IE 6 - 11
                            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                            return elem.isDisabled === disabled ||

                                // Where there is no isDisabled, check manually
                                /* jshint -W018 */
                                elem.isDisabled !== !disabled &&
                                inDisabledFieldset(elem) === disabled;
                        }

                        return elem.disabled === disabled;

                        // Try to winnow out elements that can't be disabled before trusting the disabled property.
                        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                        // even exist on them, let alone have a boolean value.
                    } else if ("label" in elem) {
                        return elem.disabled === disabled;
                    }

                    // Remaining elements are neither :enabled nor :disabled
                    return false;
                };
            }

            /**
             * Returns a function to use in pseudos for positionals
             * @param {Function} fn
             */
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j,
                            matchIndexes = fn([], seed.length, argument),
                            i = matchIndexes.length;

                        // Match elements found at the specified indexes
                        while (i--) {
                            if (seed[(j = matchIndexes[i])]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }

            /**
             * Checks a node for validity as a Sizzle context
             * @param {Element|Object=} context
             * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
             */
            function testContext(context) {
                return context && typeof context.getElementsByTagName !== "undefined" && context;
            }

            // Expose support vars for convenience
            support = Sizzle.support = {};

            /**
             * Detects XML nodes
             * @param {Element|Object} elem An element or a document
             * @returns {Boolean} True iff elem is a non-HTML XML node
             */
            isXML = Sizzle.isXML = function (elem) {
                var namespace = elem.namespaceURI,
                    docElem = (elem.ownerDocument || elem).documentElement;

                // Support: IE <=8
                // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
                // https://bugs.jquery.com/ticket/4833
                return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
            };

            /**
             * Sets document-related variables once based on the current document
             * @param {Element|Object} [doc] An element or document object to use to set the document
             * @returns {Object} Returns the current document
             */
            setDocument = Sizzle.setDocument = function (node) {
                var hasCompare, subWindow,
                    doc = node ? node.ownerDocument || node : preferredDoc;

                // Return early if doc is invalid or already selected
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }

                // Update global variables
                document = doc;
                docElem = document.documentElement;
                documentIsHTML = !isXML(document);

                // Support: IE 9 - 11+, Edge 12 - 18+
                // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if (preferredDoc != document &&
                    (subWindow = document.defaultView) && subWindow.top !== subWindow) {

                    // Support: IE 11, Edge
                    if (subWindow.addEventListener) {
                        subWindow.addEventListener("unload", unloadHandler, false);

                        // Support: IE 9 - 10 only
                    } else if (subWindow.attachEvent) {
                        subWindow.attachEvent("onunload", unloadHandler);
                    }
                }

                // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
                // Safari 4 - 5 only, Opera <=11.6 - 12.x only
                // IE/Edge & older browsers don't support the :scope pseudo-class.
                // Support: Safari 6.0 only
                // Safari 6.0 supports :scope but it's an alias of :root there.
                support.scope = assert(function (el) {
                    docElem.appendChild(el).appendChild(document.createElement("div"));
                    return typeof el.querySelectorAll !== "undefined" &&
                        !el.querySelectorAll(":scope fieldset div").length;
                });

                /* Attributes
                ---------------------------------------------------------------------- */

                // Support: IE<8
                // Verify that getAttribute really returns attributes and not properties
                // (excepting IE8 booleans)
                support.attributes = assert(function (el) {
                    el.className = "i";
                    return !el.getAttribute("className");
                });

                /* getElement(s)By*
                ---------------------------------------------------------------------- */

                // Check if getElementsByTagName("*") returns only elements
                support.getElementsByTagName = assert(function (el) {
                    el.appendChild(document.createComment(""));
                    return !el.getElementsByTagName("*").length;
                });

                // Support: IE<9
                support.getElementsByClassName = rnative.test(document.getElementsByClassName);

                // Support: IE<10
                // Check if getElementById returns elements by name
                // The broken getElementById methods don't pick up programmatically-set names,
                // so use a roundabout getElementsByName test
                support.getById = assert(function (el) {
                    docElem.appendChild(el).id = expando;
                    return !document.getElementsByName || !document.getElementsByName(expando).length;
                });

                // ID filter and find
                if (support.getById) {
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute("id") === attrId;
                        };
                    };
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var elem = context.getElementById(id);
                            return elem ? [elem] : [];
                        }
                    };
                } else {
                    Expr.filter["ID"] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== "undefined" &&
                                elem.getAttributeNode("id");
                            return node && node.value === attrId;
                        };
                    };

                    // Support: IE 6 - 7 only
                    // getElementById is not reliable as a find shortcut
                    Expr.find["ID"] = function (id, context) {
                        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                            var node, i, elems,
                                elem = context.getElementById(id);

                            if (elem) {

                                // Verify the id attribute
                                node = elem.getAttributeNode("id");
                                if (node && node.value === id) {
                                    return [elem];
                                }

                                // Fall back on getElementsByName
                                elems = context.getElementsByName(id);
                                i = 0;
                                while ((elem = elems[i++])) {
                                    node = elem.getAttributeNode("id");
                                    if (node && node.value === id) {
                                        return [elem];
                                    }
                                }
                            }

                            return [];
                        }
                    };
                }

                // Tag
                Expr.find["TAG"] = support.getElementsByTagName ?
                    function (tag, context) {
                        if (typeof context.getElementsByTagName !== "undefined") {
                            return context.getElementsByTagName(tag);

                            // DocumentFragment nodes don't have gEBTN
                        } else if (support.qsa) {
                            return context.querySelectorAll(tag);
                        }
                    } :

                    function (tag, context) {
                        var elem,
                            tmp = [],
                            i = 0,

                            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                            results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                            while ((elem = results[i++])) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }

                            return tmp;
                        }
                        return results;
                    };

                // Class
                Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                    if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };

                /* QSA/matchesSelector
                ---------------------------------------------------------------------- */

                // QSA and matchesSelector support

                // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                rbuggyMatches = [];

                // qSa(:focus) reports false when true (Chrome 21)
                // We allow this because of a bug in IE8/9 that throws an error
                // whenever `document.activeElement` is accessed on an iframe
                // So, we allow :focus to pass through QSA all the time to avoid the IE error
                // See https://bugs.jquery.com/ticket/13378
                rbuggyQSA = [];

                if ((support.qsa = rnative.test(document.querySelectorAll))) {

                    // Build QSA regex
                    // Regex strategy adopted from Diego Perini
                    assert(function (el) {

                        var input;

                        // Select is set to empty string on purpose
                        // This is to test IE's treatment of not explicitly
                        // setting a boolean content attribute,
                        // since its presence should be enough
                        // https://bugs.jquery.com/ticket/12359
                        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
                            "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                            "<option selected=''></option></select>";

                        // Support: IE8, Opera 11-12.16
                        // Nothing should be selected when empty strings follow ^= or $= or *=
                        // The test attribute must be unknown in Opera but "safe" for WinRT
                        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                        if (el.querySelectorAll("[msallowcapture^='']").length) {
                            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                        }

                        // Support: IE8
                        // Boolean attributes and "value" are not treated correctly
                        if (!el.querySelectorAll("[selected]").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                        }

                        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                            rbuggyQSA.push("~=");
                        }

                        // Support: IE 11+, Edge 15 - 18+
                        // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                        // Adding a temporary attribute to the document before the selection works
                        // around the issue.
                        // Interestingly, IE 10 & older don't seem to have the issue.
                        input = document.createElement("input");
                        input.setAttribute("name", "");
                        el.appendChild(input);
                        if (!el.querySelectorAll("[name='']").length) {
                            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" +
                                whitespace + "*(?:''|\"\")");
                        }

                        // Webkit/Opera - :checked should return selected option elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        // IE8 throws error here and will not see later tests
                        if (!el.querySelectorAll(":checked").length) {
                            rbuggyQSA.push(":checked");
                        }

                        // Support: Safari 8+, iOS 8+
                        // https://bugs.webkit.org/show_bug.cgi?id=136851
                        // In-page `selector#id sibling-combinator selector` fails
                        if (!el.querySelectorAll("a#" + expando + "+*").length) {
                            rbuggyQSA.push(".#.+[+~]");
                        }

                        // Support: Firefox <=3.6 - 5 only
                        // Old Firefox doesn't throw on a badly-escaped identifier.
                        el.querySelectorAll("\\\f");
                        rbuggyQSA.push("[\\r\\n\\f]");
                    });

                    assert(function (el) {
                        el.innerHTML = "<a href='' disabled='disabled'></a>" +
                            "<select disabled='disabled'><option/></select>";

                        // Support: Windows 8 Native Apps
                        // The type and name attributes are restricted during .innerHTML assignment
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden");
                        el.appendChild(input).setAttribute("name", "D");

                        // Support: IE8
                        // Enforce case-sensitivity of name attribute
                        if (el.querySelectorAll("[name=d]").length) {
                            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                        }

                        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                        // IE8 throws error here and will not see later tests
                        if (el.querySelectorAll(":enabled").length !== 2) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Support: IE9-11+
                        // IE's :disabled selector does not pick up the children of disabled fieldsets
                        docElem.appendChild(el).disabled = true;
                        if (el.querySelectorAll(":disabled").length !== 2) {
                            rbuggyQSA.push(":enabled", ":disabled");
                        }

                        // Support: Opera 10 - 11 only
                        // Opera 10-11 does not throw on post-comma invalid pseudos
                        el.querySelectorAll("*,:x");
                        rbuggyQSA.push(",.*:");
                    });
                }

                if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                    docElem.webkitMatchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector)))) {

                    assert(function (el) {

                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        support.disconnectedMatch = matches.call(el, "*");

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        matches.call(el, "[s!='']:x");
                        rbuggyMatches.push("!=", pseudos);
                    });
                }

                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                /* Contains
                ---------------------------------------------------------------------- */
                hasCompare = rnative.test(docElem.compareDocumentPosition);

                // Element contains another
                // Purposefully self-exclusive
                // As in, an element does not contain itself
                contains = hasCompare || rnative.test(docElem.contains) ?
                    function (a, b) {
                        var adown = a.nodeType === 9 ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !!(bup && bup.nodeType === 1 && (
                            adown.contains ?
                                adown.contains(bup) :
                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                        ));
                    } :
                    function (a, b) {
                        if (b) {
                            while ((b = b.parentNode)) {
                                if (b === a) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    };

                /* Sorting
                ---------------------------------------------------------------------- */

                // Document order sorting
                sortOrder = hasCompare ?
                    function (a, b) {

                        // Flag for duplicate removal
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        // Sort on method existence if only one input has compareDocumentPosition
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        if (compare) {
                            return compare;
                        }

                        // Calculate position if both inputs belong to the same document
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ?
                            a.compareDocumentPosition(b) :

                            // Otherwise we know they are disconnected
                            1;

                        // Disconnected nodes
                        if (compare & 1 ||
                            (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                            // Choose the first element that is related to our preferred document
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            if (a == document || a.ownerDocument == preferredDoc &&
                                contains(preferredDoc, a)) {
                                return -1;
                            }

                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            if (b == document || b.ownerDocument == preferredDoc &&
                                contains(preferredDoc, b)) {
                                return 1;
                            }

                            // Maintain original order
                            return sortInput ?
                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                0;
                        }

                        return compare & 4 ? -1 : 1;
                    } :
                    function (a, b) {

                        // Exit early if the nodes are identical
                        if (a === b) {
                            hasDuplicate = true;
                            return 0;
                        }

                        var cur,
                            i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];

                        // Parentless nodes are either documents or disconnected
                        if (!aup || !bup) {

                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            /* eslint-disable eqeqeq */
                            return a == document ? -1 :
                                b == document ? 1 :
                                    /* eslint-enable eqeqeq */
                                    aup ? -1 :
                                        bup ? 1 :
                                            sortInput ?
                                                (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                                0;

                            // If the nodes are siblings, we can do a quick check
                        } else if (aup === bup) {
                            return siblingCheck(a, b);
                        }

                        // Otherwise we need full lists of their ancestors for comparison
                        cur = a;
                        while ((cur = cur.parentNode)) {
                            ap.unshift(cur);
                        }
                        cur = b;
                        while ((cur = cur.parentNode)) {
                            bp.unshift(cur);
                        }

                        // Walk down the tree looking for a discrepancy
                        while (ap[i] === bp[i]) {
                            i++;
                        }

                        return i ?

                            // Do a sibling check if the nodes have a common ancestor
                            siblingCheck(ap[i], bp[i]) :

                            // Otherwise nodes in our document sort first
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            /* eslint-disable eqeqeq */
                            ap[i] == preferredDoc ? -1 :
                                bp[i] == preferredDoc ? 1 :
                                    /* eslint-enable eqeqeq */
                                    0;
                    };

                return document;
            };

            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };

            Sizzle.matchesSelector = function (elem, expr) {
                setDocument(elem);

                if (support.matchesSelector && documentIsHTML &&
                    !nonnativeSelectorCache[expr + " "] &&
                    (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                    (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                    try {
                        var ret = matches.call(elem, expr);

                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (ret || support.disconnectedMatch ||

                            // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                        nonnativeSelectorCache(expr, true);
                    }
                }

                return Sizzle(expr, document, null, [elem]).length > 0;
            };

            Sizzle.contains = function (context, elem) {

                // Set document vars if needed
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if ((context.ownerDocument || context) != document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };

            Sizzle.attr = function (elem, name) {

                // Set document vars if needed
                // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq
                if ((elem.ownerDocument || elem) != document) {
                    setDocument(elem);
                }

                var fn = Expr.attrHandle[name.toLowerCase()],

                    // Don't get fooled by Object.prototype properties (jQuery #13807)
                    val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                        fn(elem, name, !documentIsHTML) :
                        undefined;

                return val !== undefined ?
                    val :
                    support.attributes || !documentIsHTML ?
                        elem.getAttribute(name) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
            };

            Sizzle.escape = function (sel) {
                return (sel + "").replace(rcssescape, fcssescape);
            };

            Sizzle.error = function (msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg);
            };

            /**
             * Document sorting and removing duplicates
             * @param {ArrayLike} results
             */
            Sizzle.uniqueSort = function (results) {
                var elem,
                    duplicates = [],
                    j = 0,
                    i = 0;

                // Unless we *know* we can detect duplicates, assume their presence
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);

                if (hasDuplicate) {
                    while ((elem = results[i++])) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }

                // Clear input after sorting to release objects
                // See https://github.com/jquery/sizzle/pull/225
                sortInput = null;

                return results;
            };

            /**
             * Utility function for retrieving the text value of an array of DOM nodes
             * @param {Array|Element} elem
             */
            getText = Sizzle.getText = function (elem) {
                var node,
                    ret = "",
                    i = 0,
                    nodeType = elem.nodeType;

                if (!nodeType) {

                    // If no nodeType, this is expected to be an array
                    while ((node = elem[i++])) {

                        // Do not traverse comment nodes
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {

                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {

                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }

                // Do not include comment or processing instruction nodes

                return ret;
            };

            Expr = Sizzle.selectors = {

                // Can be adjusted by the user
                cacheLength: 50,

                createPseudo: markFunction,

                match: matchExpr,

                attrHandle: {},

                find: {},

                relative: {
                    ">": { dir: "parentNode", first: true },
                    " ": { dir: "parentNode" },
                    "+": { dir: "previousSibling", first: true },
                    "~": { dir: "previousSibling" }
                },

                preFilter: {
                    "ATTR": function (match) {
                        match[1] = match[1].replace(runescape, funescape);

                        // Move the given value to match[3] whether quoted or unquoted
                        match[3] = (match[3] || match[4] ||
                            match[5] || "").replace(runescape, funescape);

                        if (match[2] === "~=") {
                            match[3] = " " + match[3] + " ";
                        }

                        return match.slice(0, 4);
                    },

                    "CHILD": function (match) {

                        /* matches from matchExpr["CHILD"]
                            1 type (only|nth|...)
                            2 what (child|of-type)
                            3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                            4 xn-component of xn+y argument ([+-]?\d*n|)
                            5 sign of xn-component
                            6 x of xn-component
                            7 sign of y-component
                            8 y of y-component
                        */
                        match[1] = match[1].toLowerCase();

                        if (match[1].slice(0, 3) === "nth") {

                            // nth-* requires argument
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }

                            // numeric x and y parameters for Expr.filter.CHILD
                            // remember that false/true cast respectively to 0/1
                            match[4] = +(match[4] ?
                                match[5] + (match[6] || 1) :
                                2 * (match[3] === "even" || match[3] === "odd"));
                            match[5] = +((match[7] + match[8]) || match[3] === "odd");

                            // other types prohibit arguments
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }

                        return match;
                    },

                    "PSEUDO": function (match) {
                        var excess,
                            unquoted = !match[6] && match[2];

                        if (matchExpr["CHILD"].test(match[0])) {
                            return null;
                        }

                        // Accept quoted arguments as-is
                        if (match[3]) {
                            match[2] = match[4] || match[5] || "";

                            // Strip excess characters from unquoted arguments
                        } else if (unquoted && rpseudo.test(unquoted) &&

                            // Get excess from tokenize (recursively)
                            (excess = tokenize(unquoted, true)) &&

                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                            // excess is a negative index
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }

                        // Return only captures needed by the pseudo filter method (type and argument)
                        return match.slice(0, 3);
                    }
                },

                filter: {

                    "TAG": function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === "*" ?
                            function () {
                                return true;
                            } :
                            function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                            };
                    },

                    "CLASS": function (className) {
                        var pattern = classCache[className + " "];

                        return pattern ||
                            (pattern = new RegExp("(^|" + whitespace +
                                ")" + className + "(" + whitespace + "|$)")) && classCache(
                                    className, function (elem) {
                                        return pattern.test(
                                            typeof elem.className === "string" && elem.className ||
                                            typeof elem.getAttribute !== "undefined" &&
                                            elem.getAttribute("class") ||
                                            ""
                                        );
                                    });
                    },

                    "ATTR": function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);

                            if (result == null) {
                                return operator === "!=";
                            }
                            if (!operator) {
                                return true;
                            }

                            result += "";

                            /* eslint-disable max-len */

                            return operator === "=" ? result === check :
                                operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf(check) === 0 :
                                        operator === "*=" ? check && result.indexOf(check) > -1 :
                                            operator === "$=" ? check && result.slice(-check.length) === check :
                                                operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                                    operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                                        false;
                            /* eslint-enable max-len */

                        };
                    },

                    "CHILD": function (type, what, _argument, first, last) {
                        var simple = type.slice(0, 3) !== "nth",
                            forward = type.slice(-4) !== "last",
                            ofType = what === "of-type";

                        return first === 1 && last === 0 ?

                            // Shortcut for :nth-*(n)
                            function (elem) {
                                return !!elem.parentNode;
                            } :

                            function (elem, _context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType,
                                    diff = false;

                                if (parent) {

                                    // :(first|last|only)-(child|of-type)
                                    if (simple) {
                                        while (dir) {
                                            node = elem;
                                            while ((node = node[dir])) {
                                                if (ofType ?
                                                    node.nodeName.toLowerCase() === name :
                                                    node.nodeType === 1) {

                                                    return false;
                                                }
                                            }

                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            start = dir = type === "only" && !start && "nextSibling";
                                        }
                                        return true;
                                    }

                                    start = [forward ? parent.firstChild : parent.lastChild];

                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if (forward && useCache) {

                                        // Seek `elem` from a previously-cached index

                                        // ...in a gzip-friendly way
                                        node = parent;
                                        outerCache = node[expando] || (node[expando] = {});

                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache = outerCache[node.uniqueID] ||
                                            (outerCache[node.uniqueID] = {});

                                        cache = uniqueCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = nodeIndex && cache[2];
                                        node = nodeIndex && parent.childNodes[nodeIndex];

                                        while ((node = ++nodeIndex && node && node[dir] ||

                                            // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop())) {

                                            // When found, cache indexes on `parent` and break
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                break;
                                            }
                                        }

                                    } else {

                                        // Use previously-cached element index if available
                                        if (useCache) {

                                            // ...in a gzip-friendly way
                                            node = elem;
                                            outerCache = node[expando] || (node[expando] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[node.uniqueID] ||
                                                (outerCache[node.uniqueID] = {});

                                            cache = uniqueCache[type] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = nodeIndex;
                                        }

                                        // xml :nth-child(...)
                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        if (diff === false) {

                                            // Use the same loop as above to seek `elem` from the start
                                            while ((node = ++nodeIndex && node && node[dir] ||
                                                (diff = nodeIndex = 0) || start.pop())) {

                                                if ((ofType ?
                                                    node.nodeName.toLowerCase() === name :
                                                    node.nodeType === 1) &&
                                                    ++diff) {

                                                    // Cache the index of each encountered element
                                                    if (useCache) {
                                                        outerCache = node[expando] ||
                                                            (node[expando] = {});

                                                        // Support: IE <9 only
                                                        // Defend against cloned attroperties (jQuery gh-1709)
                                                        uniqueCache = outerCache[node.uniqueID] ||
                                                            (outerCache[node.uniqueID] = {});

                                                        uniqueCache[type] = [dirruns, diff];
                                                    }

                                                    if (node === elem) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    // Incorporate the offset, then check against cycle size
                                    diff -= last;
                                    return diff === first || (diff % first === 0 && diff / first >= 0);
                                }
                            };
                    },

                    "PSEUDO": function (pseudo, argument) {

                        // pseudo-class names are case-insensitive
                        // http://www.w3.org/TR/selectors/#pseudo-classes
                        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                        // Remember that setFilters inherits from pseudos
                        var args,
                            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                Sizzle.error("unsupported pseudo: " + pseudo);

                        // The user may use createPseudo to indicate that
                        // arguments are needed to create the filter function
                        // just as Sizzle does
                        if (fn[expando]) {
                            return fn(argument);
                        }

                        // But maintain support for old signatures
                        if (fn.length > 1) {
                            args = [pseudo, pseudo, "", argument];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                markFunction(function (seed, matches) {
                                    var idx,
                                        matched = fn(seed, argument),
                                        i = matched.length;
                                    while (i--) {
                                        idx = indexOf(seed, matched[i]);
                                        seed[idx] = !(matches[idx] = matched[i]);
                                    }
                                }) :
                                function (elem) {
                                    return fn(elem, 0, args);
                                };
                        }

                        return fn;
                    }
                },

                pseudos: {

                    // Potentially complex pseudos
                    "not": markFunction(function (selector) {

                        // Trim the selector passed to compile
                        // to avoid treating leading and trailing
                        // spaces as combinators
                        var input = [],
                            results = [],
                            matcher = compile(selector.replace(rtrim, "$1"));

                        return matcher[expando] ?
                            markFunction(function (seed, matches, _context, xml) {
                                var elem,
                                    unmatched = matcher(seed, null, xml, []),
                                    i = seed.length;

                                // Match elements unmatched by `matcher`
                                while (i--) {
                                    if ((elem = unmatched[i])) {
                                        seed[i] = !(matches[i] = elem);
                                    }
                                }
                            }) :
                            function (elem, _context, xml) {
                                input[0] = elem;
                                matcher(input, null, xml, results);

                                // Don't keep the element (issue #299)
                                input[0] = null;
                                return !results.pop();
                            };
                    }),

                    "has": markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),

                    "contains": markFunction(function (text) {
                        text = text.replace(runescape, funescape);
                        return function (elem) {
                            return (elem.textContent || getText(elem)).indexOf(text) > -1;
                        };
                    }),

                    // "Whether an element is represented by a :lang() selector
                    // is based solely on the element's language value
                    // being equal to the identifier C,
                    // or beginning with the identifier C immediately followed by "-".
                    // The matching of C against the element's language value is performed case-insensitively.
                    // The identifier C does not have to be a valid language name."
                    // http://www.w3.org/TR/selectors/#lang-pseudo
                    "lang": markFunction(function (lang) {

                        // lang value must be a valid identifier
                        if (!ridentifier.test(lang || "")) {
                            Sizzle.error("unsupported lang: " + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if ((elemLang = documentIsHTML ?
                                    elem.lang :
                                    elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),

                    // Miscellaneous
                    "target": function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },

                    "root": function (elem) {
                        return elem === docElem;
                    },

                    "focus": function (elem) {
                        return elem === document.activeElement &&
                            (!document.hasFocus || document.hasFocus()) &&
                            !!(elem.type || elem.href || ~elem.tabIndex);
                    },

                    // Boolean properties
                    "enabled": createDisabledPseudo(false),
                    "disabled": createDisabledPseudo(true),

                    "checked": function (elem) {

                        // In CSS3, :checked should return both checked and selected elements
                        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                        var nodeName = elem.nodeName.toLowerCase();
                        return (nodeName === "input" && !!elem.checked) ||
                            (nodeName === "option" && !!elem.selected);
                    },

                    "selected": function (elem) {

                        // Accessing this property makes selected-by-default
                        // options in Safari work properly
                        if (elem.parentNode) {
                            // eslint-disable-next-line no-unused-expressions
                            elem.parentNode.selectedIndex;
                        }

                        return elem.selected === true;
                    },

                    // Contents
                    "empty": function (elem) {

                        // http://www.w3.org/TR/selectors/#empty-pseudo
                        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                        //   but not by others (comment: 8; processing instruction: 7; etc.)
                        // nodeType < 6 works because attributes (2) do not appear as children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },

                    "parent": function (elem) {
                        return !Expr.pseudos["empty"](elem);
                    },

                    // Element/input types
                    "header": function (elem) {
                        return rheader.test(elem.nodeName);
                    },

                    "input": function (elem) {
                        return rinputs.test(elem.nodeName);
                    },

                    "button": function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === "button" || name === "button";
                    },

                    "text": function (elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === "input" &&
                            elem.type === "text" &&

                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            ((attr = elem.getAttribute("type")) == null ||
                                attr.toLowerCase() === "text");
                    },

                    // Position-in-collection
                    "first": createPositionalPseudo(function () {
                        return [0];
                    }),

                    "last": createPositionalPseudo(function (_matchIndexes, length) {
                        return [length - 1];
                    }),

                    "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),

                    "even": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "odd": createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ?
                            argument + length :
                            argument > length ?
                                length :
                                argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),

                    "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };

            Expr.pseudos["nth"] = Expr.pseudos["eq"];

            // Add button/input type pseudos
            for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in { submit: true, reset: true }) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }

            // Easy API for creating new setFilters
            function setFilters() { }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();

            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched, match, tokens, type,
                    soFar, groups, preFilters,
                    cached = tokenCache[selector + " "];

                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }

                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;

                while (soFar) {

                    // Comma and first run
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {

                            // Don't consume trailing commas as valid
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push((tokens = []));
                    }

                    matched = false;

                    // Combinators
                    if ((match = rcombinators.exec(soFar))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,

                            // Cast descendant combinators to space
                            type: match[0].replace(rtrim, " ")
                        });
                        soFar = soFar.slice(matched.length);
                    }

                    // Filters
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                            (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }

                    if (!matched) {
                        break;
                    }
                }

                // Return the length of the invalid excess
                // if we're just parsing
                // Otherwise, throw an error or return tokens
                return parseOnly ?
                    soFar.length :
                    soFar ?
                        Sizzle.error(selector) :

                        // Cache the tokens
                        tokenCache(selector, groups).slice(0);
            };

            function toSelector(tokens) {
                var i = 0,
                    len = tokens.length,
                    selector = "";
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    skip = combinator.next,
                    key = skip || dir,
                    checkNonElements = base && key === "parentNode",
                    doneName = done++;

                return combinator.first ?

                    // Check against closest ancestor/preceding element
                    function (elem, context, xml) {
                        while ((elem = elem[dir])) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                return matcher(elem, context, xml);
                            }
                        }
                        return false;
                    } :

                    // Check against all ancestor/preceding elements
                    function (elem, context, xml) {
                        var oldCache, uniqueCache, outerCache,
                            newCache = [dirruns, doneName];

                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if (xml) {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[elem.uniqueID] ||
                                        (outerCache[elem.uniqueID] = {});

                                    if (skip && skip === elem.nodeName.toLowerCase()) {
                                        elem = elem[dir] || elem;
                                    } else if ((oldCache = uniqueCache[key]) &&
                                        oldCache[0] === dirruns && oldCache[1] === doneName) {

                                        // Assign to newCache so results back-propagate to previous elements
                                        return (newCache[2] = oldCache[2]);
                                    } else {

                                        // Reuse newcache so results back-propagate to previous elements
                                        uniqueCache[key] = newCache;

                                        // A match means we're done; a fail means we have to keep checking
                                        if ((newCache[2] = matcher(elem, context, xml))) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                        return false;
                    };
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ?
                    function (elem, context, xml) {
                        var i = matchers.length;
                        while (i--) {
                            if (!matchers[i](elem, context, xml)) {
                                return false;
                            }
                        }
                        return true;
                    } :
                    matchers[0];
            }

            function multipleContexts(selector, contexts, results) {
                var i = 0,
                    len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }

            function condense(unmatched, map, filter, context, xml) {
                var elem,
                    newUnmatched = [],
                    i = 0,
                    len = unmatched.length,
                    mapped = map != null;

                for (; i < len; i++) {
                    if ((elem = unmatched[i])) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }

                return newUnmatched;
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem,
                        preMap = [],
                        postMap = [],
                        preexisting = results.length,

                        // Get initial elements from seed or context
                        elems = seed || multipleContexts(
                            selector || "*",
                            context.nodeType ? [context] : context,
                            []
                        ),

                        // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        matcherIn = preFilter && (seed || !selector) ?
                            condense(elems, preMap, preFilter, context, xml) :
                            elems,

                        matcherOut = matcher ?

                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                            matcherIn;

                    // Find primary matches
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }

                    // Apply postFilter
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);

                        // Un-match failing elements by moving them back to matcherIn
                        i = temp.length;
                        while (i--) {
                            if ((elem = temp[i])) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }

                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {

                                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i])) {

                                        // Restore matcherIn since elem is not yet a final match
                                        temp.push((matcherIn[i] = elem));
                                    }
                                }
                                postFinder(null, (matcherOut = []), temp, xml);
                            }

                            // Move matched elements from seed to results to keep them synchronized
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) &&
                                    (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }

                        // Add elements to results, through postFinder if defined
                    } else {
                        matcherOut = condense(
                            matcherOut === results ?
                                matcherOut.splice(preexisting, matcherOut.length) :
                                matcherOut
                        );
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }

            function matcherFromTokens(tokens) {
                var checkContext, matcher, j,
                    len = tokens.length,
                    leadingRelative = Expr.relative[tokens[0].type],
                    implicitRelative = leadingRelative || Expr.relative[" "],
                    i = leadingRelative ? 1 : 0,

                    // The foundational matcher ensures that elements are reachable from top-level context(s)
                    matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true),
                    matchAnyContext = addCombinator(function (elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true),
                    matchers = [function (elem, context, xml) {
                        var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                            (checkContext = context).nodeType ?
                                matchContext(elem, context, xml) :
                                matchAnyContext(elem, context, xml));

                        // Avoid hanging onto element (issue #299)
                        checkContext = null;
                        return ret;
                    }];

                for (; i < len; i++) {
                    if ((matcher = Expr.relative[tokens[i].type])) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                        // Return special upon seeing a positional matcher
                        if (matcher[expando]) {

                            // Find the next relative operator (if any) for proper handling
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(
                                i > 1 && elementMatcher(matchers),
                                i > 1 && toSelector(

                                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                    tokens
                                        .slice(0, i - 1)
                                        .concat({ value: tokens[i - 2].type === " " ? "*" : "" })
                                ).replace(rtrim, "$1"),
                                matcher,
                                i < j && matcherFromTokens(tokens.slice(i, j)),
                                j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                j < len && toSelector(tokens)
                            );
                        }
                        matchers.push(matcher);
                    }
                }

                return elementMatcher(matchers);
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0,
                    byElement = elementMatchers.length > 0,
                    superMatcher = function (seed, context, xml, results, outermost) {
                        var elem, j, matcher,
                            matchedCount = 0,
                            i = "0",
                            unmatched = seed && [],
                            setMatched = [],
                            contextBackup = outermostContext,

                            // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find["TAG"]("*", outermost),

                            // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                            len = elems.length;

                        if (outermost) {

                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            outermostContext = context == document || context || outermost;
                        }

                        // Add elements passing elementMatchers directly to results
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;

                                // Support: IE 11+, Edge 17 - 18+
                                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                // two documents; shallow comparisons work.
                                // eslint-disable-next-line eqeqeq
                                if (!context && elem.ownerDocument != document) {
                                    setDocument(elem);
                                    xml = !documentIsHTML;
                                }
                                while ((matcher = elementMatchers[j++])) {
                                    if (matcher(elem, context || document, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }

                            // Track unmatched elements for set filters
                            if (bySet) {

                                // They will have gone through all possible matchers
                                if ((elem = !matcher && elem)) {
                                    matchedCount--;
                                }

                                // Lengthen the array for every element, matched or not
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }

                        // `i` is now the count of elements visited above, and adding it to `matchedCount`
                        // makes the latter nonnegative.
                        matchedCount += i;

                        // Apply set filters to unmatched elements
                        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                        // no element matchers and no seed.
                        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                        // numerically zero.
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while ((matcher = setMatchers[j++])) {
                                matcher(unmatched, setMatched, context, xml);
                            }

                            if (seed) {

                                // Reintegrate element matches to eliminate the need for sorting
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }

                                // Discard index placeholder values to get only actual matches
                                setMatched = condense(setMatched);
                            }

                            // Add matches to results
                            push.apply(results, setMatched);

                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (outermost && !seed && setMatched.length > 0 &&
                                (matchedCount + setMatchers.length) > 1) {

                                Sizzle.uniqueSort(results);
                            }
                        }

                        // Override manipulation of globals by nested matchers
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }

                        return unmatched;
                    };

                return bySet ?
                    markFunction(superMatcher) :
                    superMatcher;
            }

            compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
                var i,
                    setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];

                if (!cached) {

                    // Generate a function of recursive functions that can be used to check each element
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }

                    // Cache the compiled function
                    cached = compilerCache(
                        selector,
                        matcherFromGroupMatchers(elementMatchers, setMatchers)
                    );

                    // Save selector and tokenization
                    cached.selector = selector;
                }
                return cached;
            };

            /**
             * A low-level selection function that works with Sizzle's compiled
             *  selector functions
             * @param {String|Function} selector A selector or a pre-compiled
             *  selector function built with Sizzle.compile
             * @param {Element} context
             * @param {Array} [results]
             * @param {Array} [seed] A set of elements to match against
             */
            select = Sizzle.select = function (selector, context, results, seed) {
                var i, tokens, token, type, find,
                    compiled = typeof selector === "function" && selector,
                    match = !seed && tokenize((selector = compiled.selector || selector));

                results = results || [];

                // Try to minimize operations if there is only one selector in the list and no seed
                // (the latter of which guarantees us context)
                if (match.length === 1) {

                    // Reduce context if the leading compound selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                        context = (Expr.find["ID"](token.matches[0]
                            .replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;

                            // Precompiled matchers will still verify ancestry, so step up a level
                        } else if (compiled) {
                            context = context.parentNode;
                        }

                        selector = selector.slice(tokens.shift().value.length);
                    }

                    // Fetch a seed set for right-to-left matching
                    i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {

                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(
                                token.matches[0].replace(runescape, funescape),
                                rsibling.test(tokens[0].type) && testContext(context.parentNode) ||
                                context
                            ))) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }

                // Compile and execute a filtering function if one is not provided
                // Provide `match` to avoid retokenization if we modified the selector above
                (compiled || compile(selector, match))(
                    seed,
                    context,
                    !documentIsHTML,
                    results,
                    !context || rsibling.test(selector) && testContext(context.parentNode) || context
                );
                return results;
            };

            // One-time assignments

            // Sort stability
            support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

            // Support: Chrome 14-35+
            // Always assume duplicates if they aren't passed to the comparison function
            support.detectDuplicates = !!hasDuplicate;

            // Initialize against the default document
            setDocument();

            // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
            // Detached nodes confoundingly follow *each other*
            support.sortDetached = assert(function (el) {

                // Should return 1, but returns 4 (following)
                return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
            });

            // Support: IE<8
            // Prevent attribute/property "interpolation"
            // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
            if (!assert(function (el) {
                el.innerHTML = "<a href='#'></a>";
                return el.firstChild.getAttribute("href") === "#";
            })) {
                addHandle("type|href|height|width", function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                    }
                });
            }

            // Support: IE<9
            // Use defaultValue in place of getAttribute("value")
            if (!support.attributes || !assert(function (el) {
                el.innerHTML = "<input/>";
                el.firstChild.setAttribute("value", "");
                return el.firstChild.getAttribute("value") === "";
            })) {
                addHandle("value", function (elem, _name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === "input") {
                        return elem.defaultValue;
                    }
                });
            }

            // Support: IE<9
            // Use getAttributeNode to fetch booleans when getAttribute lies
            if (!assert(function (el) {
                return el.getAttribute("disabled") == null;
            })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                    }
                });
            }

            return Sizzle;

        })(window);



    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;

    // Deprecated
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;




    var dir = function (elem, dir, until) {
        var matched = [],
            truncate = until !== undefined;

        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };


    var siblings = function (n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }

        return matched;
    };


    var rneedsContext = jQuery.expr.match.needsContext;



    function nodeName(elem, name) {

        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

    };
    var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);



    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }

        // Single element
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return (elem === qualifier) !== not;
            });
        }

        // Arraylike of elements (jQuery, arguments, Array)
        if (typeof qualifier !== "string") {
            return jQuery.grep(elements, function (elem) {
                return (indexOf.call(qualifier, elem) > -1) !== not;
            });
        }

        // Filtered directly for both simple and complex selectors
        return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }

        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1;
        }));
    };

    jQuery.fn.extend({
        find: function (selector) {
            var i, ret,
                len = this.length,
                self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            ret = this.pushStack([]);

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function (selector) {
            return !!winnow(
                this,

                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                typeof selector === "string" && rneedsContext.test(selector) ?
                    jQuery(selector) :
                    selector || [],
                false
            ).length;
        }
    });


    // Initialize a jQuery object


    // A central reference to the root jQuery(document)
    var rootjQuery,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        // Strict HTML recognition (#11290: must start with <)
        // Shortcut simple #id case for speed
        rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

        init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;

            // HANDLE: $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Method init() accepts an alternate rootjQuery
            // so migrate can support jQuery.sub (gh-2101)
            root = root || rootjQuery;

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector[0] === "<" &&
                    selector[selector.length - 1] === ">" &&
                    selector.length >= 3) {

                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;

                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        jQuery.merge(this, jQuery.parseHTML(
                            match[1],
                            context && context.nodeType ? context.ownerDocument || context : document,
                            true
                        ));

                        // HANDLE: $(html, props)
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {

                                // Properties of context are called as methods if possible
                                if (isFunction(this[match])) {
                                    this[match](context[match]);

                                    // ...and otherwise set as attributes
                                } else {
                                    this.attr(match, context[match]);
                                }
                            }
                        }

                        return this;

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        if (elem) {

                            // Inject the element directly into the jQuery object
                            this[0] = elem;
                            this.length = 1;
                        }
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || root).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(DOMElement)
            } else if (selector.nodeType) {
                this[0] = selector;
                this.length = 1;
                return this;

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (isFunction(selector)) {
                return root.ready !== undefined ?
                    root.ready(selector) :

                    // Execute immediately if ready is not present
                    selector(jQuery);
            }

            return jQuery.makeArray(selector, this);
        };

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);


    var rparentsprev = /^(?:parents|prev(?:Until|All))/,

        // Methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this),
                l = targets.length;

            return this.filter(function () {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function (selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                matched = [],
                targets = typeof selectors !== "string" && jQuery(selectors);

            // Positional selectors never match, since there's no _selection_ context
            if (!rneedsContext.test(selectors)) {
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                        // Always skip document fragments
                        if (cur.nodeType < 11 && (targets ?
                            targets.index(cur) > -1 :

                            // Don't pass non-elements to Sizzle
                            cur.nodeType === 1 &&
                            jQuery.find.matchesSelector(cur, selectors))) {

                            matched.push(cur);
                            break;
                        }
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },

        // Determine the position of an element within the set
        index: function (elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,

                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem
            );
        },

        add: function (selector, context) {
            return this.pushStack(
                jQuery.uniqueSort(
                    jQuery.merge(this.get(), jQuery(selector, context))
                )
            );
        },

        addBack: function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) { }
        return cur;
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function (elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function (elem, _i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function (elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function (elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function (elem, _i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function (elem, _i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function (elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function (elem) {
            return siblings(elem.firstChild);
        },
        contents: function (elem) {
            if (elem.contentDocument != null &&

                // Support: IE 11+
                // <object> elements with no `data` attribute has an object
                // `contentDocument` with a `null` prototype.
                getProto(elem.contentDocument)) {

                return elem.contentDocument;
            }

            // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
            // Treat the template element as a regular one in browsers that
            // don't support it.
            if (nodeName(elem, "template")) {
                elem = elem.content || elem;
            }

            return jQuery.merge([], elem.childNodes);
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {

                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        };
    });
    var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);



    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function (options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            createOptions(options) :
            jQuery.extend({}, options);

        var // Flag to know if list is currently firing
            firing,

            // Last fire value for non-forgettable lists
            memory,

            // Flag to know if list was already fired
            fired,

            // Flag to prevent firing
            locked,

            // Actual callback list
            list = [],

            // Queue of execution data for repeatable lists
            queue = [],

            // Index of currently firing callback (modified by add/remove as needed)
            firingIndex = -1,

            // Fire callbacks
            fire = function () {

                // Enforce single-firing
                locked = locked || options.once;

                // Execute callbacks for all pending executions,
                // respecting firingIndex overrides and runtime changes
                fired = firing = true;
                for (; queue.length; firingIndex = -1) {
                    memory = queue.shift();
                    while (++firingIndex < list.length) {

                        // Run callback and check for early termination
                        if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                            options.stopOnFalse) {

                            // Jump to end and forget the data so .add doesn't re-fire
                            firingIndex = list.length;
                            memory = false;
                        }
                    }
                }

                // Forget the data if we're done with it
                if (!options.memory) {
                    memory = false;
                }

                firing = false;

                // Clean up if we're done firing for good
                if (locked) {

                    // Keep an empty list if we have data for future add calls
                    if (memory) {
                        list = [];

                        // Otherwise, this object is spent
                    } else {
                        list = "";
                    }
                }
            },

            // Actual Callbacks object
            self = {

                // Add a callback or a collection of callbacks to the list
                add: function () {
                    if (list) {

                        // If we have memory from a past run, we should fire after adding
                        if (memory && !firing) {
                            firingIndex = list.length - 1;
                            queue.push(memory);
                        }

                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                if (isFunction(arg)) {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && toType(arg) !== "string") {

                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);

                        if (memory && !firing) {
                            fire();
                        }
                    }
                    return this;
                },

                // Remove a callback from the list
                remove: function () {
                    jQuery.each(arguments, function (_, arg) {
                        var index;
                        while ((index = jQuery.inArray(arg, list, index)) > -1) {
                            list.splice(index, 1);

                            // Handle firing indexes
                            if (index <= firingIndex) {
                                firingIndex--;
                            }
                        }
                    });
                    return this;
                },

                // Check if a given callback is in the list.
                // If no argument is given, return whether or not list has callbacks attached.
                has: function (fn) {
                    return fn ?
                        jQuery.inArray(fn, list) > -1 :
                        list.length > 0;
                },

                // Remove all callbacks from the list
                empty: function () {
                    if (list) {
                        list = [];
                    }
                    return this;
                },

                // Disable .fire and .add
                // Abort any current/pending executions
                // Clear all callbacks and values
                disable: function () {
                    locked = queue = [];
                    list = memory = "";
                    return this;
                },
                disabled: function () {
                    return !list;
                },

                // Disable .fire
                // Also disable .add unless we have memory (since it would have no effect)
                // Abort any pending executions
                lock: function () {
                    locked = queue = [];
                    if (!memory && !firing) {
                        list = memory = "";
                    }
                    return this;
                },
                locked: function () {
                    return !!locked;
                },

                // Call all callbacks with the given context and arguments
                fireWith: function (context, args) {
                    if (!locked) {
                        args = args || [];
                        args = [context, args.slice ? args.slice() : args];
                        queue.push(args);
                        if (!firing) {
                            fire();
                        }
                    }
                    return this;
                },

                // Call all the callbacks with the given arguments
                fire: function () {
                    self.fireWith(this, arguments);
                    return this;
                },

                // To know if the callbacks have already been called at least once
                fired: function () {
                    return !!fired;
                }
            };

        return self;
    };


    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
        var method;

        try {

            // Check for promise aspect first to privilege synchronous behavior
            if (value && isFunction((method = value.promise))) {
                method.call(value).done(resolve).fail(reject);

                // Other thenables
            } else if (value && isFunction((method = value.then))) {
                method.call(value, resolve, reject);

                // Other non-thenables
            } else {

                // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                // * false: [ value ].slice( 0 ) => resolve( value )
                // * true: [ value ].slice( 1 ) => resolve()
                resolve.apply(undefined, [value].slice(noValue));
            }

            // For Promises/A+, convert exceptions into rejections
            // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
            // Deferred#then to conditionally suppress rejection.
        } catch (value) {

            // Support: Android 4.0 only
            // Strict mode functions invoked without .call/.apply get global-object context
            reject.apply(undefined, [value]);
        }
    }

    jQuery.extend({

        Deferred: function (func) {
            var tuples = [

                // action, add listener, callbacks,
                // ... .then handlers, argument index, [final state]
                ["notify", "progress", jQuery.Callbacks("memory"),
                    jQuery.Callbacks("memory"), 2],
                ["resolve", "done", jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"), 0, "resolved"],
                ["reject", "fail", jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"), 1, "rejected"]
            ],
                state = "pending",
                promise = {
                    state: function () {
                        return state;
                    },
                    always: function () {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    "catch": function (fn) {
                        return promise.then(null, fn);
                    },

                    // Keep pipe for back-compat
                    pipe: function ( /* fnDone, fnFail, fnProgress */) {
                        var fns = arguments;

                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (_i, tuple) {

                                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

                                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    if (returned && isFunction(returned.promise)) {
                                        returned.promise()
                                            .progress(newDefer.notify)
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject);
                                    } else {
                                        newDefer[tuple[0] + "With"](
                                            this,
                                            fn ? [returned] : arguments
                                        );
                                    }
                                });
                            });
                            fns = null;
                        }).promise();
                    },
                    then: function (onFulfilled, onRejected, onProgress) {
                        var maxDepth = 0;
                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this,
                                    args = arguments,
                                    mightThrow = function () {
                                        var returned, then;

                                        // Support: Promises/A+ section 2.3.3.3.3
                                        // https://promisesaplus.com/#point-59
                                        // Ignore double-resolution attempts
                                        if (depth < maxDepth) {
                                            return;
                                        }

                                        returned = handler.apply(that, args);

                                        // Support: Promises/A+ section 2.3.1
                                        // https://promisesaplus.com/#point-48
                                        if (returned === deferred.promise()) {
                                            throw new TypeError("Thenable self-resolution");
                                        }

                                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                                        // https://promisesaplus.com/#point-54
                                        // https://promisesaplus.com/#point-75
                                        // Retrieve `then` only once
                                        then = returned &&

                                            // Support: Promises/A+ section 2.3.4
                                            // https://promisesaplus.com/#point-64
                                            // Only check objects and functions for thenability
                                            (typeof returned === "object" ||
                                                typeof returned === "function") &&
                                            returned.then;

                                        // Handle a returned thenable
                                        if (isFunction(then)) {

                                            // Special processors (notify) just wait for resolution
                                            if (special) {
                                                then.call(
                                                    returned,
                                                    resolve(maxDepth, deferred, Identity, special),
                                                    resolve(maxDepth, deferred, Thrower, special)
                                                );

                                                // Normal processors (resolve) also hook into progress
                                            } else {

                                                // ...and disregard older resolution values
                                                maxDepth++;

                                                then.call(
                                                    returned,
                                                    resolve(maxDepth, deferred, Identity, special),
                                                    resolve(maxDepth, deferred, Thrower, special),
                                                    resolve(maxDepth, deferred, Identity,
                                                        deferred.notifyWith)
                                                );
                                            }

                                            // Handle all other returned values
                                        } else {

                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if (handler !== Identity) {
                                                that = undefined;
                                                args = [returned];
                                            }

                                            // Process the value(s)
                                            // Default process is resolve
                                            (special || deferred.resolveWith)(that, args);
                                        }
                                    },

                                    // Only normal processors (resolve) catch and reject exceptions
                                    process = special ?
                                        mightThrow :
                                        function () {
                                            try {
                                                mightThrow();
                                            } catch (e) {

                                                if (jQuery.Deferred.exceptionHook) {
                                                    jQuery.Deferred.exceptionHook(e,
                                                        process.stackTrace);
                                                }

                                                // Support: Promises/A+ section 2.3.3.3.4.1
                                                // https://promisesaplus.com/#point-61
                                                // Ignore post-resolution exceptions
                                                if (depth + 1 >= maxDepth) {

                                                    // Only substitute handlers pass on context
                                                    // and multiple values (non-spec behavior)
                                                    if (handler !== Thrower) {
                                                        that = undefined;
                                                        args = [e];
                                                    }

                                                    deferred.rejectWith(that, args);
                                                }
                                            }
                                        };

                                // Support: Promises/A+ section 2.3.3.3.1
                                // https://promisesaplus.com/#point-57
                                // Re-resolve promises immediately to dodge false rejection from
                                // subsequent errors
                                if (depth) {
                                    process();
                                } else {

                                    // Call an optional hook to record the stack, in case of exception
                                    // since it's otherwise lost when execution goes async
                                    if (jQuery.Deferred.getStackHook) {
                                        process.stackTrace = jQuery.Deferred.getStackHook();
                                    }
                                    window.setTimeout(process);
                                }
                            };
                        }

                        return jQuery.Deferred(function (newDefer) {

                            // progress_handlers.add( ... )
                            tuples[0][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onProgress) ?
                                        onProgress :
                                        Identity,
                                    newDefer.notifyWith
                                )
                            );

                            // fulfilled_handlers.add( ... )
                            tuples[1][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onFulfilled) ?
                                        onFulfilled :
                                        Identity
                                )
                            );

                            // rejected_handlers.add( ... )
                            tuples[2][3].add(
                                resolve(
                                    0,
                                    newDefer,
                                    isFunction(onRejected) ?
                                        onRejected :
                                        Thrower
                                )
                            );
                        }).promise();
                    },

                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Add list-specific methods
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2],
                    stateString = tuple[5];

                // promise.progress = list.add
                // promise.done = list.add
                // promise.fail = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(
                        function () {

                            // state = "resolved" (i.e., fulfilled)
                            // state = "rejected"
                            state = stateString;
                        },

                        // rejected_callbacks.disable
                        // fulfilled_callbacks.disable
                        tuples[3 - i][2].disable,

                        // rejected_handlers.disable
                        // fulfilled_handlers.disable
                        tuples[3 - i][3].disable,

                        // progress_callbacks.lock
                        tuples[0][2].lock,

                        // progress_handlers.lock
                        tuples[0][3].lock
                    );
                }

                // progress_handlers.fire
                // fulfilled_handlers.fire
                // rejected_handlers.fire
                list.add(tuple[3].fire);

                // deferred.notify = function() { deferred.notifyWith(...) }
                // deferred.resolve = function() { deferred.resolveWith(...) }
                // deferred.reject = function() { deferred.rejectWith(...) }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                    return this;
                };

                // deferred.notifyWith = list.fireWith
                // deferred.resolveWith = list.fireWith
                // deferred.rejectWith = list.fireWith
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function (singleValue) {
            var

                // count of uncompleted subordinates
                remaining = arguments.length,

                // count of unprocessed arguments
                i = remaining,

                // subordinate fulfillment data
                resolveContexts = Array(i),
                resolveValues = slice.call(arguments),

                // the master Deferred
                master = jQuery.Deferred(),

                // subordinate callback factory
                updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this;
                        resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                        if (!(--remaining)) {
                            master.resolveWith(resolveContexts, resolveValues);
                        }
                    };
                };

            // Single- and empty arguments are adopted like Promise.resolve
            if (remaining <= 1) {
                adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject,
                    !remaining);

                // Use .then() to unwrap secondary thenables (cf. gh-3000)
                if (master.state() === "pending" ||
                    isFunction(resolveValues[i] && resolveValues[i].then)) {

                    return master.then();
                }
            }

            // Multiple arguments are aggregated like Promise.all array elements
            while (i--) {
                adoptValue(resolveValues[i], updateFunc(i), master.reject);
            }

            return master.promise();
        }
    });


    // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {

        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
            window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }
    };




    jQuery.readyException = function (error) {
        window.setTimeout(function () {
            throw error;
        });
    };




    // The deferred used on DOM ready
    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {

        readyList
            .then(fn)

            // Wrap jQuery.readyException in a function so that the lookup
            // happens at the time of error handling instead of callback
            // registration.
            .catch(function (error) {
                jQuery.readyException(error);
            });

        return this;
    };

    jQuery.extend({

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Handle when the DOM is ready
        ready: function (wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);
        }
    });

    jQuery.ready.then = readyList.then;

    // The ready event handler and self cleanup method
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }

    // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon
    if (document.readyState === "complete" ||
        (document.readyState !== "loading" && !document.documentElement.doScroll)) {

        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);

    } else {

        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed);

        // A fallback to window.onload, that will always work
        window.addEventListener("load", completed);
    }




    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;

        // Sets many values
        if (toType(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!isFunction(value)) {
                raw = true;
            }

            if (bulk) {

                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function (elem, _key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(
                        elems[i], key, raw ?
                        value :
                        value.call(elems[i], i, fn(elems[i], key))
                    );
                }
            }
        }

        if (chainable) {
            return elems;
        }

        // Gets
        if (bulk) {
            return fn.call(elems);
        }

        return len ? fn(elems[0], key) : emptyGet;
    };


    // Matches dashed string for camelizing
    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g;

    // Used by camelCase as callback to replace()
    function fcamelCase(_all, letter) {
        return letter.toUpperCase();
    }

    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function (owner) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };




    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        cache: function (owner) {

            // Check if the owner object already has a cache
            var value = owner[this.expando];

            // If not, create one
            if (!value) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                        owner[this.expando] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }

            return value;
        },
        set: function (owner, data, value) {
            var prop,
                cache = this.cache(owner);

            // Handle: [ owner, key, value ] args
            // Always use camelCase key (gh-2257)
            if (typeof data === "string") {
                cache[camelCase(data)] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                    cache[camelCase(prop)] = data[prop];
                }
            }
            return cache;
        },
        get: function (owner, key) {
            return key === undefined ?
                this.cache(owner) :

                // Always use camelCase key (gh-2257)
                owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function (owner, key, value) {

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined ||
                ((key && typeof key === "string") && value === undefined)) {

                return this.get(owner, key);
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function (owner, key) {
            var i,
                cache = owner[this.expando];

            if (cache === undefined) {
                return;
            }

            if (key !== undefined) {

                // Support array or space separated string of keys
                if (Array.isArray(key)) {

                    // If key is an array of keys...
                    // We always set camelCase keys, so remove that.
                    key = key.map(camelCase);
                } else {
                    key = camelCase(key);

                    // If a key with the spaces exists, use it.
                    // Otherwise, create an array by matching non-whitespace
                    key = key in cache ?
                        [key] :
                        (key.match(rnothtmlwhite) || []);
                }

                i = key.length;

                while (i--) {
                    delete cache[key[i]];
                }
            }

            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {

                // Support: Chrome <=35 - 45
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function (owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();



    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
        if (data === "true") {
            return true;
        }

        if (data === "false") {
            return false;
        }

        if (data === "null") {
            return null;
        }

        // Only convert to a number if it doesn't change the string
        if (data === +data + "") {
            return +data;
        }

        if (rbrace.test(data)) {
            return JSON.parse(data);
        }

        return data;
    }

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = getData(data);
                } catch (e) { }

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function (elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },

        data: function (elem, name, data) {
            return dataUser.access(elem, name, data);
        },

        removeData: function (elem, name) {
            dataUser.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function (elem, name, data) {
            return dataPriv.access(elem, name, data);
        },

        _removeData: function (elem, name) {
            dataPriv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data,
                elem = this[0],
                attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);

                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE 11 only
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function () {
                    dataUser.set(this, key);
                });
            }

            return access(this, function (value) {
                var data;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {

                    // Attempt to get data from the cache
                    // The key will always be camelCased in Data
                    data = dataUser.get(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, key);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                this.each(function () {

                    // We always store the camelCased key
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function (key) {
            return this.each(function () {
                dataUser.remove(this, key);
            });
        }
    });


    jQuery.extend({
        queue: function (elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || Array.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function () {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function (elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function () {
                    dataPriv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ?
                this :
                this.each(function () {
                    var queue = jQuery.queue(this, type, data);

                    // Ensure a hooks for this queue
                    jQuery._queueHooks(this, type);

                    if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                    }
                });
        },
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function (type) {
            return this.queue(type || "fx", []);
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function () {
                    if (!(--count)) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var documentElement = document.documentElement;



    var isAttached = function (elem) {
        return jQuery.contains(elem.ownerDocument, elem);
    },
        composed = { composed: true };

    // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.
    if (documentElement.getRootNode) {
        isAttached = function (elem) {
            return jQuery.contains(elem.ownerDocument, elem) ||
                elem.getRootNode(composed) === elem.ownerDocument;
        };
    }
    var isHiddenWithinTree = function (elem, el) {

        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;

        // Inline style trumps all
        return elem.style.display === "none" ||
            elem.style.display === "" &&

            // Otherwise, check computed style
            // Support: Firefox <=43 - 45
            // Disconnected elements can have computed display: none, so first confirm that elem is
            // in the document.
            isAttached(elem) &&

            jQuery.css(elem, "display") === "none";
    };



    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale,
            maxIterations = 20,
            currentValue = tween ?
                function () {
                    return tween.cur();
                } :
                function () {
                    return jQuery.css(elem, prop, "");
                },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

            // Starting value computation is required for potential unit mismatches
            initialInUnit = elem.nodeType &&
                (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
                rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {

            // Support: Firefox <=54
            // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
            initial = initial / 2;

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            while (maxIterations--) {

                // Evaluate and update our best guess (doubling guesses that zero out).
                // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                jQuery.style(elem, prop, initialInUnit + unit);
                if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                    maxIterations = 0;
                }
                initialInUnit = initialInUnit / scale;

            }

            initialInUnit = initialInUnit * 2;
            jQuery.style(elem, prop, initialInUnit + unit);

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];
        }

        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ?
                initialInUnit + (valueParts[1] + 1) * valueParts[2] :
                +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }


    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[nodeName];

        if (display) {
            return display;
        }

        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");

        temp.parentNode.removeChild(temp);

        if (display === "none") {
            display = "block";
        }
        defaultDisplayMap[nodeName] = display;

        return display;
    }

    function showHide(elements, show) {
        var display, elem,
            values = [],
            index = 0,
            length = elements.length;

        // Determine new display value for elements that need to change
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            display = elem.style.display;
            if (show) {

                // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                // check is required in this first loop unless we have a nonempty display value (either
                // inline or about-to-be-restored)
                if (display === "none") {
                    values[index] = dataPriv.get(elem, "display") || null;
                    if (!values[index]) {
                        elem.style.display = "";
                    }
                }
                if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                    values[index] = getDefaultDisplay(elem);
                }
            } else {
                if (display !== "none") {
                    values[index] = "none";

                    // Remember what we're overwriting
                    dataPriv.set(elem, "display", display);
                }
            }
        }

        // Set the display of the elements in a second loop to avoid constant reflow
        for (index = 0; index < length; index++) {
            if (values[index] != null) {
                elements[index].style.display = values[index];
            }
        }

        return elements;
    }

    jQuery.fn.extend({
        show: function () {
            return showHide(this, true);
        },
        hide: function () {
            return showHide(this);
        },
        toggle: function (state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function () {
                if (isHiddenWithinTree(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    var rcheckableType = (/^(?:checkbox|radio)$/i);

    var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]*)/i);

    var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);



    (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");

        // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;

        // Support: IE <=9 only
        // IE <=9 replaces <option> tags with their contents when inserted outside of
        // the select element.
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
    })();


    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

        _default: [0, "", ""]
    };

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // Support: IE <=9 only
    if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }


    function getAll(context, tag) {

        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");

        } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");

        } else {
            ret = [];
        }

        if (tag === undefined || tag && nodeName(context, tag)) {
            return jQuery.merge([context], ret);
        }

        return ret;
    }


    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
            dataPriv.set(
                elems[i],
                "globalEval",
                !refElements || dataPriv.get(refElements[i], "globalEval")
            );
        }
    }


    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for (; i < l; i++) {
            elem = elems[i];

            if (elem || elem === 0) {

                // Add nodes directly
                if (toType(elem) === "object") {

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                    // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));

                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ((elem = nodes[i++])) {

            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }

            attached = isAttached(elem);

            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");

            // Preserve script evaluation history
            if (attached) {
                setGlobalEval(tmp);
            }

            // Capture executables
            if (scripts) {
                j = 0;
                while ((elem = tmp[j++])) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }

        return fragment;
    }


    var
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).
    function expectSync(elem, type) {
        return (elem === safeActiveElement()) === (type === "focus");
    }

    // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) { }
    }

    function on(elem, types, selector, data, fn, one) {
        var origFn, type;

        // Types can be a map of types/handlers
        if (typeof types === "object") {

            // ( types-Object, selector, data )
            if (typeof selector !== "string") {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }

        if (data == null && fn == null) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }

        if (one === 1) {
            origFn = fn;
            fn = function (event) {

                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function () {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

        global: {},

        add: function (elem, types, handler, data, selector) {

            var handleObjIn, eventHandle, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.get(elem);

            // Only attach events to objects that accept data
            if (!acceptData(elem)) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Ensure that invalid selectors throw exceptions at attach time
            // Evaluate against documentElement in case elem is a non-element node (e.g., document)
            if (selector) {
                jQuery.find.matchesSelector(documentElement, selector);
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                        jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }

            // Handle multiple events separated by a space
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup ||
                        special.setup.call(elem, data, namespaces, eventHandle) === false) {

                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, selector, mappedTypes) {

            var j, origCount, tmp,
                events, t, handleObj,
                special, handlers, type, namespaces, origType,
                elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnothtmlwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] &&
                    new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if ((mappedTypes || origType === handleObj.origType) &&
                        (!handler || handler.guid === handleObj.guid) &&
                        (!tmp || tmp.test(handleObj.namespace)) &&
                        (!selector || selector === handleObj.selector ||
                            selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown ||
                        special.teardown.call(elem, namespaces, elemData.handle) === false) {

                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },

        dispatch: function (nativeEvent) {

            var i, j, ret, matched, handleObj, handlerQueue,
                args = new Array(arguments.length),

                // Make a writable jQuery.Event from the native event object
                event = jQuery.event.fix(nativeEvent),

                handlers = (
                    dataPriv.get(this, "events") || Object.create(null)
                )[event.type] || [],
                special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;

            for (i = 1; i < arguments.length; i++) {
                args[i] = arguments[i];
            }

            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) &&
                    !event.isImmediatePropagationStopped()) {

                    // If the event is namespaced, then each handler is only invoked if it is
                    // specially universal or its namespaces are a superset of the event's.
                    if (!event.rnamespace || handleObj.namespace === false ||
                        event.rnamespace.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                            handleObj.handler).apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function (event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors,
                handlerQueue = [],
                delegateCount = handlers.delegateCount,
                cur = event.target;

            // Find delegate handlers
            if (delegateCount &&

                // Support: IE <=9
                // Black-hole SVG <use> instance trees (trac-13180)
                cur.nodeType &&

                // Support: Firefox <=42
                // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                // Support: IE 11 only
                // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                !(event.type === "click" && event.button >= 1)) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                        matchedHandlers = [];
                        matchedSelectors = {};
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matchedSelectors[sel] === undefined) {
                                matchedSelectors[sel] = handleObj.needsContext ?
                                    jQuery(sel, this).index(cur) > -1 :
                                    jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matchedSelectors[sel]) {
                                matchedHandlers.push(handleObj);
                            }
                        }
                        if (matchedHandlers.length) {
                            handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            cur = this;
            if (delegateCount < handlers.length) {
                handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }

            return handlerQueue;
        },

        addProp: function (name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: true,
                configurable: true,

                get: isFunction(hook) ?
                    function () {
                        if (this.originalEvent) {
                            return hook(this.originalEvent);
                        }
                    } :
                    function () {
                        if (this.originalEvent) {
                            return this.originalEvent[name];
                        }
                    },

                set: function (value) {
                    Object.defineProperty(this, name, {
                        enumerable: true,
                        configurable: true,
                        writable: true,
                        value: value
                    });
                }
            });
        },

        fix: function (originalEvent) {
            return originalEvent[jQuery.expando] ?
                originalEvent :
                new jQuery.Event(originalEvent);
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            click: {

                // Utilize native event to ensure correct state for checkable inputs
                setup: function (data) {

                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;

                    // Claim the first handler
                    if (rcheckableType.test(el.type) &&
                        el.click && nodeName(el, "input")) {

                        // dataPriv.set( el, "click", ... )
                        leverageNative(el, "click", returnTrue);
                    }

                    // Return false to allow normal processing in the caller
                    return false;
                },
                trigger: function (data) {

                    // For mutual compressibility with _default, replace `this` access with a local var.
                    // `|| data` is dead code meant only to preserve the variable through minification.
                    var el = this || data;

                    // Force setup before triggering a click
                    if (rcheckableType.test(el.type) &&
                        el.click && nodeName(el, "input")) {

                        leverageNative(el, "click");
                    }

                    // Return non-false to allow normal event-path propagation
                    return true;
                },

                // For cross-browser consistency, suppress native .click() on links
                // Also prevent it if we're currently inside a leveraged native-event stack
                _default: function (event) {
                    var target = event.target;
                    return rcheckableType.test(target.type) &&
                        target.click && nodeName(target, "input") &&
                        dataPriv.get(target, "click") ||
                        nodeName(target, "a");
                }
            },

            beforeunload: {
                postDispatch: function (event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.
    function leverageNative(el, type, expectSync) {

        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if (!expectSync) {
            if (dataPriv.get(el, type) === undefined) {
                jQuery.event.add(el, type, returnTrue);
            }
            return;
        }

        // Register the controller as a special universal handler for all event namespaces
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
            namespace: false,
            handler: function (event) {
                var notAsync, result,
                    saved = dataPriv.get(this, type);

                if ((event.isTrigger & 1) && this[type]) {

                    // Interrupt processing of the outer synthetic .trigger()ed event
                    // Saved data should be false in such cases, but might be a leftover capture object
                    // from an async native handler (gh-4350)
                    if (!saved.length) {

                        // Store arguments for use when handling the inner native event
                        // There will always be at least one argument (an event object), so this array
                        // will not be confused with a leftover capture object.
                        saved = slice.call(arguments);
                        dataPriv.set(this, type, saved);

                        // Trigger the native event and capture its result
                        // Support: IE <=9 - 11+
                        // focus() and blur() are asynchronous
                        notAsync = expectSync(this, type);
                        this[type]();
                        result = dataPriv.get(this, type);
                        if (saved !== result || notAsync) {
                            dataPriv.set(this, type, false);
                        } else {
                            result = {};
                        }
                        if (saved !== result) {

                            // Cancel the outer synthetic event
                            event.stopImmediatePropagation();
                            event.preventDefault();
                            return result.value;
                        }

                        // If this is an inner synthetic event for an event with a bubbling surrogate
                        // (focus or blur), assume that the surrogate already propagated from triggering the
                        // native event and prevent that from happening again here.
                        // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                        // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                        // less bad than duplication.
                    } else if ((jQuery.event.special[type] || {}).delegateType) {
                        event.stopPropagation();
                    }

                    // If this is a native event triggered above, everything is now in order
                    // Fire an inner synthetic event with the original arguments
                } else if (saved.length) {

                    // ...and capture the result
                    dataPriv.set(this, type, {
                        value: jQuery.event.trigger(

                            // Support: IE <=9 - 11+
                            // Extend with the prototype to reset the above stopImmediatePropagation()
                            jQuery.extend(saved[0], jQuery.Event.prototype),
                            saved.slice(1),
                            this
                        )
                    });

                    // Abort handling of the native event
                    event.stopImmediatePropagation();
                }
            }
        });
    }

    jQuery.removeEvent = function (elem, type, handle) {

        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };

    jQuery.Event = function (src, props) {

        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented ||
                src.defaultPrevented === undefined &&

                // Support: Android <=2.3 only
                src.returnValue === false ?
                returnTrue :
                returnFalse;

            // Create target properties
            // Support: Safari <=6 - 7 only
            // Target should not be a text node (#504, #13143)
            this.target = (src.target && src.target.nodeType === 3) ?
                src.target.parentNode :
                src.target;

            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || Date.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function () {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

    // Includes all common event props including KeyEvent and MouseEvent specific props
    jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,

        which: function (event) {
            var button = event.button;

            // Add which for key events
            if (event.which == null && rkeyEvent.test(event.type)) {
                return event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                if (button & 1) {
                    return 1;
                }

                if (button & 2) {
                    return 3;
                }

                if (button & 4) {
                    return 2;
                }

                return 0;
            }

            return event.which;
        }
    }, jQuery.event.addProp);

    jQuery.each({ focus: "focusin", blur: "focusout" }, function (type, delegateType) {
        jQuery.event.special[type] = {

            // Utilize native event if possible so blur/focus sequence is correct
            setup: function () {

                // Claim the first handler
                // dataPriv.set( this, "focus", ... )
                // dataPriv.set( this, "blur", ... )
                leverageNative(this, type, expectSync);

                // Return false to allow normal processing in the caller
                return false;
            },
            trigger: function () {

                // Force setup before trigger
                leverageNative(this, type);

                // Return non-false to allow normal event-path propagation
                return true;
            },

            delegateType: delegateType
        };
    });

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function (event) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    jQuery.fn.extend({

        on: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function (types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function (types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                    handleObj.namespace ?
                        handleObj.origType + "." + handleObj.namespace :
                        handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if (typeof types === "object") {

                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });


    var

        // Support: IE <=10 - 11, Edge 12 - 13 only
        // In IE/Edge using regex groups here causes severe slowdowns.
        // See https://connect.microsoft.com/IE/feedback/details/1736512/
        rnoInnerhtml = /<script|<style|<link/i,

        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    // Prefer a tbody over its parent table for containing new rows
    function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") &&
            nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

            return jQuery(elem).children("tbody")[0] || elem;
        }

        return elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;

            if (events) {
                dataPriv.remove(dest, "handle events");

                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);

            dataUser.set(dest, udataCur);
        }
    }

    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip(collection, args, callback, ignored) {

        // Flatten any nested arrays
        args = flat(args);

        var fragment, first, scripts, hasScripts, node, doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            valueIsFunction = isFunction(value);

        // We can't cloneNode fragments that contain checked, in WebKit
        if (valueIsFunction ||
            (l > 1 && typeof value === "string" &&
                !support.checkClone && rchecked.test(value))) {
            return collection.each(function (index) {
                var self = collection.eq(index);
                if (valueIsFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }

        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;

            if (fragment.childNodes.length === 1) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (; i < l; i++) {
                    node = fragment;

                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);

                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) {

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }

                    callback.call(collection[i], node, i);
                }

                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;

                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);

                    // Evaluate executable scripts on first document insertion
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") &&
                            !dataPriv.access(node, "globalEval") &&
                            jQuery.contains(doc, node)) {

                            if (node.src && (node.type || "").toLowerCase() !== "module") {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if (jQuery._evalUrl && !node.noModule) {
                                    jQuery._evalUrl(node.src, {
                                        nonce: node.nonce || node.getAttribute("nonce")
                                    }, doc);
                                }
                            } else {
                                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;

        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }

            if (node.parentNode) {
                if (keepData && isAttached(node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }

        return elem;
    }

    jQuery.extend({
        htmlPrefilter: function (html) {
            return html;
        },

        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements,
                clone = elem.cloneNode(true),
                inPage = isAttached(elem);

            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function (elems) {
            var data, elem, type,
                special = jQuery.event.special,
                i = 0;

            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if ((data = elem[dataPriv.expando])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {

                        // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });

    jQuery.fn.extend({
        detach: function (selector) {
            return remove(this, selector, true);
        },

        remove: function (selector) {
            return remove(this, selector);
        },

        text: function (value) {
            return access(this, function (value) {
                return value === undefined ?
                    jQuery.text(this) :
                    this.empty().each(function () {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            this.textContent = value;
                        }
                    });
            }, null, value, arguments.length);
        },

        append: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function () {
            return domManip(this, arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function () {
            return domManip(this, arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        empty: function () {
            var elem,
                i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                    !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = jQuery.htmlPrefilter(value);

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) { }
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function () {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function (elem) {
                var parent = this.parentNode;

                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }

                // Force callback invocation
            }, ignored);
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems,
                ret = [],
                insert = jQuery(selector),
                last = insert.length - 1,
                i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: Android <=4.0 only, PhantomJS 1 only
                // .get() because push.apply(_, arraylike) throws on ancient WebKit
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {

        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
            view = window;
        }

        return view.getComputedStyle(elem);
    };

    var swap = function (elem, options, callback) {
        var ret, name,
            old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.call(elem);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };


    var rboxStyle = new RegExp(cssExpand.join("|"), "i");



    (function () {

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {

            // This is a singleton, we need to execute it only once
            if (!div) {
                return;
            }

            container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
                "margin-top:1px;padding:0;border:0";
            div.style.cssText =
                "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
                "margin:auto;border:1px;padding:1px;" +
                "width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);

            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";

            // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

            // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
            // Some styles come back with percentage values, even though they shouldn't
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

            // Support: IE 9 - 11 only
            // Detect misreporting of content dimensions for box-sizing:border-box elements
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

            // Support: IE 9 only
            // Detect overflow:scroll screwiness (gh-3699)
            // Support: Chrome <=64
            // Don't get tricked when zoom affects offsetWidth (gh-4029)
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;

            documentElement.removeChild(container);

            // Nullify the div so it wouldn't be stored in the memory and
            // it will also be a sign that checks already performed
            div = null;
        }

        function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
        }

        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
            reliableTrDimensionsVal, reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div");

        // Finish early in limited (non-browser) environments
        if (!div.style) {
            return;
        }

        // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        jQuery.extend(support, {
            boxSizingReliable: function () {
                computeStyleTests();
                return boxSizingReliableVal;
            },
            pixelBoxStyles: function () {
                computeStyleTests();
                return pixelBoxStylesVal;
            },
            pixelPosition: function () {
                computeStyleTests();
                return pixelPositionVal;
            },
            reliableMarginLeft: function () {
                computeStyleTests();
                return reliableMarginLeftVal;
            },
            scrollboxSize: function () {
                computeStyleTests();
                return scrollboxSizeVal;
            },

            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            reliableTrDimensions: function () {
                var table, tr, trChild, trStyle;
                if (reliableTrDimensionsVal == null) {
                    table = document.createElement("table");
                    tr = document.createElement("tr");
                    trChild = document.createElement("div");

                    table.style.cssText = "position:absolute;left:-11111px";
                    tr.style.height = "1px";
                    trChild.style.height = "9px";

                    documentElement
                        .appendChild(table)
                        .appendChild(tr)
                        .appendChild(trChild);

                    trStyle = window.getComputedStyle(tr);
                    reliableTrDimensionsVal = parseInt(trStyle.height) > 3;

                    documentElement.removeChild(table);
                }
                return reliableTrDimensionsVal;
            }
        });
    })();


    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret,

            // Support: Firefox 51+
            // Retrieving style before computed somehow
            // fixes an issue with getting wrong values
            // on detached elements
            style = elem.style;

        computed = computed || getStyles(elem);

        // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];

            if (ret === "" && !isAttached(elem)) {
                ret = jQuery.style(elem, name);
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // https://drafts.csswg.org/cssom/#resolved-values
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?

            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + "" :
            ret;
    }


    function addGetHookIf(conditionFn, hookFn) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function () {
                if (conditionFn()) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }


    var cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style,
        vendorProps = {};

    // Return a vendor-prefixed property or undefined
    function vendorPropName(name) {

        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }

    // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
    function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];

        if (final) {
            return final;
        }
        if (name in emptyStyle) {
            return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
    }


    var

        // Swappable if display is none or starts with table
        // except "table", "table-cell", or "table-caption"
        // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        };

    function setPositiveNumber(_elem, value, subtract) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ?

            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
            value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0;

        // Adjustment may not be necessary
        if (box === (isBorderBox ? "border" : "content")) {
            return 0;
        }

        for (; i < 4; i += 2) {

            // Both box models exclude margin
            if (box === "margin") {
                delta += jQuery.css(elem, box + cssExpand[i], true, styles);
            }

            // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
            if (!isBorderBox) {

                // Add padding
                delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // For "border" or "margin", add border
                if (box !== "padding") {
                    delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

                    // But still keep track of it otherwise
                } else {
                    extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }

                // If we get here with a border-box (content + padding + border), we're seeking "content" or
                // "padding" or "margin"
            } else {

                // For "content", subtract padding
                if (box === "content") {
                    delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // For "content" or "padding", subtract border
                if (box !== "margin") {
                    delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        // Account for positive content-box scroll gutter when requested by providing computedVal
        if (!isBorderBox && computedVal >= 0) {

            // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
            // Assuming integer scroll gutter, subtract the rest and round down
            delta += Math.max(0, Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                computedVal -
                delta -
                extra -
                0.5

                // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
                // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
        }

        return delta;
    }

    function getWidthOrHeight(elem, dimension, extra) {

        // Start with computed style
        var styles = getStyles(elem),

            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
            // Fake content-box until we know it's needed to know the true value.
            boxSizingNeeded = !support.boxSizingReliable() || extra,
            isBorderBox = boxSizingNeeded &&
                jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            valueIsBorderBox = isBorderBox,

            val = curCSS(elem, dimension, styles),
            offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);

        // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.
        if (rnumnonpx.test(val)) {
            if (!extra) {
                return val;
            }
            val = "auto";
        }


        // Support: IE 9 - 11 only
        // Use offsetWidth/offsetHeight for when box sizing is unreliable.
        // In those cases, the computed value can be trusted to be border-box.
        if ((!support.boxSizingReliable() && isBorderBox ||

            // Support: IE 10 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Interestingly, in some cases IE 9 doesn't suffer from this issue.
            !support.reliableTrDimensions() && nodeName(elem, "tr") ||

            // Fall back to offsetWidth/offsetHeight when value is "auto"
            // This happens for inline elements with no explicit setting (gh-3571)
            val === "auto" ||

            // Support: Android <=4.1 - 4.3 only
            // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
            !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") &&

            // Make sure the element is visible & connected
            elem.getClientRects().length) {

            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

            // Where available, offsetWidth/offsetHeight approximate border box dimensions.
            // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
            // retrieved value as a content box dimension.
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
                val = elem[offsetProp];
            }
        }

        // Normalize "" and auto
        val = parseFloat(val) || 0;

        // Adjust for the element's box model
        return (val +
            boxModelAdjustment(
                elem,
                dimension,
                extra || (isBorderBox ? "border" : "content"),
                valueIsBorderBox,
                styles,

                // Provide the current computed size to request scroll gutter calculation (gh-3589)
                val
            )
        ) + "px";
    }

    jQuery.extend({

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {

                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "gridArea": true,
            "gridColumn": true,
            "gridColumnEnd": true,
            "gridColumnStart": true,
            "gridRow": true,
            "gridRowEnd": true,
            "gridRowStart": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},

        // Get and set the style property on a DOM Node
        style: function (elem, name, value, extra) {

            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name),
                style = elem.style;

            // Make sure that we're working with the right name. We don't
            // want to query the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                // "px" to a few hardcoded values.
                if (type === "number" && !isCustomProp) {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }

                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) ||
                    (value = hooks.set(elem, value, extra)) !== undefined) {

                    if (isCustomProp) {
                        style.setProperty(name, value);
                    } else {
                        style[name] = value;
                    }
                }

            } else {

                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks &&
                    (ret = hooks.get(elem, false, extra)) !== undefined) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function (elem, name, extra, styles) {
            var val, num, hooks,
                origName = camelCase(name),
                isCustomProp = rcustomProp.test(name);

            // Make sure that we're working with the right name. We don't
            // want to modify the value if it is a CSS custom property
            // since they are user-defined.
            if (!isCustomProp) {
                name = finalPropName(origName);
            }

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }

            return val;
        }
    });

    jQuery.each(["height", "width"], function (_i, dimension) {
        jQuery.cssHooks[dimension] = {
            get: function (elem, computed, extra) {
                if (computed) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) &&

                        // Support: Safari 8+
                        // Table columns in Safari have non-zero offsetWidth & zero
                        // getBoundingClientRect().width unless display is changed.
                        // Support: IE <=11 only
                        // Running getBoundingClientRect on a disconnected node
                        // in IE throws an error.
                        (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
                        swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, dimension, extra);
                        }) :
                        getWidthOrHeight(elem, dimension, extra);
                }
            },

            set: function (elem, value, extra) {
                var matches,
                    styles = getStyles(elem),

                    // Only read styles.position if the test has a chance to fail
                    // to avoid forcing a reflow.
                    scrollboxSizeBuggy = !support.scrollboxSize() &&
                        styles.position === "absolute",

                    // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                    boxSizingNeeded = scrollboxSizeBuggy || extra,
                    isBorderBox = boxSizingNeeded &&
                        jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                    subtract = extra ?
                        boxModelAdjustment(
                            elem,
                            dimension,
                            extra,
                            isBorderBox,
                            styles
                        ) :
                        0;

                // Account for unreliable border-box dimensions by comparing offset* to computed and
                // faking a content-box to get border and padding (gh-3699)
                if (isBorderBox && scrollboxSizeBuggy) {
                    subtract -= Math.ceil(
                        elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] -
                        parseFloat(styles[dimension]) -
                        boxModelAdjustment(elem, dimension, "border", false, styles) -
                        0.5
                    );
                }

                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) &&
                    (matches[3] || "px") !== "px") {

                    elem.style[dimension] = value;
                    value = jQuery.css(elem, dimension);
                }

                return setPositiveNumber(elem, value, subtract);
            }
        };
    });

    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
        function (elem, computed) {
            if (computed) {
                return (parseFloat(curCSS(elem, "marginLeft")) ||
                    elem.getBoundingClientRect().left -
                    swap(elem, { marginLeft: 0 }, function () {
                        return elem.getBoundingClientRect().left;
                    })
                ) + "px";
            }
        }
    );

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0,
                    expanded = {},

                    // Assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                        parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (prefix !== "margin") {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len,
                    map = {},
                    i = 0;

                if (Array.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ?
                    jQuery.style(elem, name, value) :
                    jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    });


    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function () {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ?
                hooks.get(this) :
                Tween.propHooks._default.get(this);
        },
        run: function (percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 ||
                    tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function (tween) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (
                    jQuery.cssHooks[tween.prop] ||
                    tween.elem.style[finalPropName(tween.prop)] != null)) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function (p) {
            return p;
        },
        swing: function (p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back compat <1.8 extension point
    jQuery.fx.step = {};




    var
        fxNow, inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function schedule() {
        if (inProgress) {
            if (document.hidden === false && window.requestAnimationFrame) {
                window.requestAnimationFrame(schedule);
            } else {
                window.setTimeout(schedule, jQuery.fx.interval);
            }

            jQuery.fx.tick();
        }
    }

    // Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout(function () {
            fxNow = undefined;
        });
        return (fxNow = Date.now());
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = { height: type };

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree(elem),
            dataShow = dataPriv.get(elem, "fxshow");

        // Queue-skipping animations hijack the fx hooks
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function () {

                // Ensure the complete handler is called before this completes
                anim.always(function () {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // Detect show/hide animations
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {

                    // Pretend to be hidden if this is a "show" and
                    // there is still data from a stopped show/hide
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;

                        // Ignore all other no-op show/hide data
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            }
        }

        // Bail out if this is a no-op like .hide().hide()
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
            return;
        }

        // Restrict "overflow" and "display" styles during box animations
        if (isBox && elem.nodeType === 1) {

            // Support: IE <=9 - 11, Edge 12 - 15
            // Record all 3 overflow attributes because IE does not infer the shorthand
            // from identically-valued overflowX and overflowY and Edge just mirrors
            // the overflowX value there.
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Identify a display type, preferring old show/hide data over the CSS cascade
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
                restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery.css(elem, "display");
            if (display === "none") {
                if (restoreDisplay) {
                    display = restoreDisplay;
                } else {

                    // Get nonempty value(s) by temporarily forcing visibility
                    showHide([elem], true);
                    restoreDisplay = elem.style.display || restoreDisplay;
                    display = jQuery.css(elem, "display");
                    showHide([elem]);
                }
            }

            // Animate inline elements as inline-block
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                if (jQuery.css(elem, "float") === "none") {

                    // Restore the original display value at the end of pure show/hide animations
                    if (!propTween) {
                        anim.done(function () {
                            style.display = restoreDisplay;
                        });
                        if (restoreDisplay == null) {
                            display = style.display;
                            restoreDisplay = display === "none" ? "" : display;
                        }
                    }
                    style.display = "inline-block";
                }
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function () {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // Implement show/hide animations
        propTween = false;
        for (prop in orig) {

            // General show/hide setup for this element animation
            if (!propTween) {
                if (dataShow) {
                    if ("hidden" in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
                }

                // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                if (toggle) {
                    dataShow.hidden = !hidden;
                }

                // Show elements before animating them
                if (hidden) {
                    showHide([elem], true);
                }

                /* eslint-disable no-loop-func */

                anim.done(function () {

                    /* eslint-enable no-loop-func */

                    // The final step of a "hide" animation is actually hiding the element
                    if (!hidden) {
                        showHide([elem]);
                    }
                    dataPriv.remove(elem, "fxshow");
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
            }

            // Per-property setup
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
                dataShow[prop] = propTween.start;
                if (hidden) {
                    propTween.end = propTween.start;
                    propTween.start = 0;
                }
            }
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function () {

                // Don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function () {
                if (stopped) {
                    return false;
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

                    // Support: Android 2.3 only
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                // If there's more to do, yield
                if (percent < 1 && length) {
                    return remaining;
                }

                // If this was an empty animation, synthesize a final progress notification
                if (!length) {
                    deferred.notifyWith(elem, [animation, 1, 0]);
                }

                // Resolve the animation and report its conclusion
                deferred.resolveWith(elem, [animation]);
                return false;
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {
                    specialEasing: {},
                    easing: jQuery.easing._default
                }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                        animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function (gotoEnd) {
                    var index = 0,

                        // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped) {
                        return this;
                    }
                    stopped = true;
                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // Resolve when we played the last frame; otherwise, reject
                    if (gotoEnd) {
                        deferred.notifyWith(elem, [animation, 1, 0]);
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
                        result.stop.bind(result);
                }
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        // Attach callbacks from options
        animation
            .progress(animation.opts.progress)
            .done(animation.opts.done, animation.opts.complete)
            .fail(animation.opts.fail)
            .always(animation.opts.always);

        jQuery.fx.timer(
            jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })
        );

        return animation;
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweeners: {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            }]
        },

        tweener: function (props, callback) {
            if (isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.match(rnothtmlwhite);
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },

        prefilters: [defaultPrefilter],

        prefilter: function (callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });

    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing ||
                isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !isFunction(easing) && easing
        };

        // Go to the end state if fx are off
        if (jQuery.fx.off) {
            opt.duration = 0;

        } else {
            if (typeof opt.duration !== "number") {
                if (opt.duration in jQuery.fx.speeds) {
                    opt.duration = jQuery.fx.speeds[opt.duration];

                } else {
                    opt.duration = jQuery.fx.speeds._default;
                }
            }
        }

        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function () {
            if (isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {

            // Show any hidden elements after setting opacity to 0
            return this.filter(isHiddenWithinTree).css("opacity", 0).show()

                // Animate to the value specified
                .end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {

                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations, or finishing resolves immediately
                    if (empty || dataPriv.get(this, "finish")) {
                        anim.stop(true);
                    }
                };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ?
                this.each(doAnimation) :
                this.queue(optall.queue, doAnimation);
        },
        stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue) {
                this.queue(type || "fx", []);
            }

            return this.each(function () {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = dataPriv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this &&
                        (type == null || timers[index].queue === type)) {

                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function (type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function () {
                var index,
                    data = dataPriv.get(this),
                    queue = data[type + "queue"],
                    hooks = data[type + "queueHooks"],
                    timers = jQuery.timers,
                    length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function (_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ?
                cssFn.apply(this, arguments) :
                this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.timers = [];
    jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;

        fxNow = Date.now();

        for (; i < timers.length; i++) {
            timer = timers[i];

            // Run the timer and safely remove it when done (allowing for external removal)
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
    };

    jQuery.fx.interval = 13;
    jQuery.fx.start = function () {
        if (inProgress) {
            return;
        }

        inProgress = true;
        schedule();
    };

    jQuery.fx.stop = function () {
        inProgress = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };


    // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function (next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function () {
                window.clearTimeout(timeout);
            };
        });
    };


    (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE <=11 only
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: IE <=11 only
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();


    var boolHook,
        attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function (elem, name, value) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                hooks = jQuery.attrHooks[name.toLowerCase()] ||
                    (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }

            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }

                if (hooks && "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                elem.setAttribute(name, value + "");
                return value;
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            ret = jQuery.find.attr(elem, name);

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === "radio" &&
                        nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function (elem, value) {
            var name,
                i = 0,

                // Attribute names can contain non-HTML whitespace characters
                // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                attrNames = value && value.match(rnothtmlwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    elem.removeAttribute(name);
                }
            }
        }
    });

    // Hooks for boolean attributes
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };

    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle,
                lowercaseName = name.toLowerCase();

            if (!isXML) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[lowercaseName];
                attrHandle[lowercaseName] = ret;
                ret = getter(elem, name, isXML) != null ?
                    lowercaseName :
                    null;
                attrHandle[lowercaseName] = handle;
            }
            return ret;
        };
    });




    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        prop: function (elem, name, value) {
            var ret, hooks,
                nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks &&
                    (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                return (elem[name] = value);
            }

            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            return elem[name];
        },

        propHooks: {
            tabIndex: {
                get: function (elem) {

                    // Support: IE <=9 - 11 only
                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");

                    if (tabindex) {
                        return parseInt(tabindex, 10);
                    }

                    if (
                        rfocusable.test(elem.nodeName) ||
                        rclickable.test(elem.nodeName) &&
                        elem.href
                    ) {
                        return 0;
                    }

                    return -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function (elem) {

                /* eslint no-unused-expressions: "off" */

                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;

                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
    ], function () {
        jQuery.propFix[this.toLowerCase()] = this;
    });




    // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }


    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
        }
        return [];
    }

    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }

            classes = classesToArray(value);

            if (classes.length) {
                while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function (value) {
            var classes, elem, cur, curValue, clazz, j, finalValue,
                i = 0;

            if (isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }

            if (!arguments.length) {
                return this.attr("class", "");
            }

            classes = classesToArray(value);

            if (classes.length) {
                while ((elem = this[i++])) {
                    curValue = getClass(elem);

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {

                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = stripAndCollapse(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function (value, stateVal) {
            var type = typeof value,
                isValidValue = type === "string" || Array.isArray(value);

            if (typeof stateVal === "boolean" && isValidValue) {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(
                        value.call(this, i, getClass(this), stateVal),
                        stateVal
                    );
                });
            }

            return this.each(function () {
                var className, i, self, classNames;

                if (isValidValue) {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = classesToArray(value);

                    while ((className = classNames[i++])) {

                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {

                        // Store className if set
                        dataPriv.set(this, "__className__", className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) {
                        this.setAttribute("class",
                            className || value === false ?
                                "" :
                                dataPriv.get(this, "__className__") || ""
                        );
                    }
                }
            });
        },

        hasClass: function (selector) {
            var className, elem,
                i = 0;

            className = " " + selector + " ";
            while ((elem = this[i++])) {
                if (elem.nodeType === 1 &&
                    (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        }
    });




    var rreturn = /\r/g;

    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, valueIsFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] ||
                        jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks &&
                        "get" in hooks &&
                        (ret = hooks.get(elem, "value")) !== undefined
                    ) {
                        return ret;
                    }

                    ret = elem.value;

                    // Handle most common string cases
                    if (typeof ret === "string") {
                        return ret.replace(rreturn, "");
                    }

                    // Handle cases where value is null/undef or number
                    return ret == null ? "" : ret;
                }

                return;
            }

            valueIsFunction = isFunction(value);

            return this.each(function (i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (valueIsFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";

                } else if (typeof val === "number") {
                    val += "";

                } else if (Array.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {

                    var val = jQuery.find.attr(elem, "value");
                    return val != null ?
                        val :

                        // Support: IE <=10 - 11 only
                        // option.text throws exceptions (#14686, #14858)
                        // Strip and collapse whitespace
                        // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                        stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function (elem) {
                    var value, option, i,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one",
                        values = one ? null : [],
                        max = one ? index + 1 : options.length;

                    if (index < 0) {
                        i = max;

                    } else {
                        i = one ? index : 0;
                    }

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // Support: IE <=9 only
                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&

                            // Don't return options that are disabled or in a disabled optgroup
                            !option.disabled &&
                            (!option.parentNode.disabled ||
                                !nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function (elem, value) {
                    var optionSet, option,
                        options = elem.options,
                        values = jQuery.makeArray(value),
                        i = options.length;

                    while (i--) {
                        option = options[i];

                        /* eslint-disable no-cond-assign */

                        if (option.selected =
                            jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
                        ) {
                            optionSet = true;
                        }

                        /* eslint-enable no-cond-assign */
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

    // Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (Array.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });




    // Return jQuery for attributes-only inclusion


    support.focusin = "onfocusin" in window;


    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function (e) {
            e.stopPropagation();
        };

    jQuery.extend(jQuery.event, {

        trigger: function (event, data, elem, onlyHandlers) {

            var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
                eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = lastElement = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") > -1) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ?
                event :
                new jQuery.Event(type, typeof event === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ?
                new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ?
                [event] :
                jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                lastElement = cur;
                event.type = i > 1 ?
                    bubbleType :
                    special.bindType || type;

                // jQuery handler
                handle = (
                    dataPriv.get(cur, "events") || Object.create(null)
                )[event.type] &&
                    dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default ||
                    special._default.apply(eventPath.pop(), data) === false) &&
                    acceptData(elem)) {

                    // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && isFunction(elem[type]) && !isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;

                        if (event.isPropagationStopped()) {
                            lastElement.addEventListener(type, stopPropagationCallback);
                        }

                        elem[type]();

                        if (event.isPropagationStopped()) {
                            lastElement.removeEventListener(type, stopPropagationCallback);
                        }

                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function (type, elem, event) {
            var e = jQuery.extend(
                new jQuery.Event(),
                event,
                {
                    type: type,
                    isSimulated: true
                }
            );

            jQuery.event.trigger(e, null, elem);
        }

    });

    jQuery.fn.extend({

        trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function (type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });


    // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
    if (!support.focusin) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function (orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };

            jQuery.event.special[fix] = {
                setup: function () {

                    // Handle: regular nodes (via `this.ownerDocument`), window
                    // (via `this.document`) & document (via `this`).
                    var doc = this.ownerDocument || this.document || this,
                        attaches = dataPriv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function () {
                    var doc = this.ownerDocument || this.document || this,
                        attaches = dataPriv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);

                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;

    var nonce = { guid: Date.now() };

    var rquery = (/\?/);



    // Cross-browser xml parsing
    jQuery.parseXML = function (data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.
        try {
            xml = (new window.DOMParser()).parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };


    var
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (Array.isArray(obj)) {

            // Serialize array item.
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {

                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(
                        prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                        v,
                        traditional,
                        add
                    );
                }
            });

        } else if (!traditional && toType(obj) === "object") {

            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {

            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function (key, valueOrFunction) {

                // If value is a function, invoke it and use its return value
                var value = isFunction(valueOrFunction) ?
                    valueOrFunction() :
                    valueOrFunction;

                s[s.length] = encodeURIComponent(key) + "=" +
                    encodeURIComponent(value == null ? "" : value);
            };

        if (a == null) {
            return "";
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

            // Serialize the form elements
            jQuery.each(a, function () {
                add(this.name, this.value);
            });

        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&");
    };

    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function () {
            return this.map(function () {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            })
                .filter(function () {
                    var type = this.type;

                    // Use .is( ":disabled" ) so that fieldset[disabled] works
                    return this.name && !jQuery(this).is(":disabled") &&
                        rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                        (this.checked || !rcheckableType.test(type));
                })
                .map(function (_i, elem) {
                    var val = jQuery(this).val();

                    if (val == null) {
                        return null;
                    }

                    if (Array.isArray(val)) {
                        return jQuery.map(val, function (val) {
                            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                        });
                    }

                    return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                }).get();
        }
    });


    var
        r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = "*/".concat("*"),

        // Anchor tag for parsing the document origin
        originAnchor = document.createElement("a");
    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType,
                i = 0,
                dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

            if (isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {},
            seekingTransport = (structure === transports);

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" &&
                    !seekingTransport && !inspected[dataTypeOrTransport]) {

                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {

            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev,
            converters = {},

            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] ||
                                    converters["* " + tmp[0]];
                                if (conv) {

                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return { state: "success", data: response };
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",

            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": JSON.parse,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            return settings ?

                // Building a settings object
                ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                // Extending ajaxSettings
                ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,

                // URL without anti-cache param
                cacheURL,

                // Response headers
                responseHeadersString,
                responseHeaders,

                // timeout handle
                timeoutTimer,

                // Url cleanup var
                urlAnchor,

                // Request state (becomes false upon send and true upon completion)
                completed,

                // To know if global events are to be dispatched
                fireGlobals,

                // Loop variable
                i,

                // uncached part of the url
                uncached,

                // Create the final options object
                s = jQuery.ajaxSetup({}, options),

                // Callbacks context
                callbackContext = s.context || s,

                // Context for global events is callbackContext if it is a DOM node or jQuery collection
                globalEventContext = s.context &&
                    (callbackContext.nodeType || callbackContext.jquery) ?
                    jQuery(callbackContext) :
                    jQuery.event,

                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),

                // Status-dependent callbacks
                statusCode = s.statusCode || {},

                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},

                // Default abort message
                strAbort = "canceled",

                // Fake xhr
                jqXHR = {
                    readyState: 0,

                    // Builds headers hashtable if needed
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase() + " "] =
                                        (responseHeaders[match[1].toLowerCase() + " "] || [])
                                            .concat(match[2]);
                                }
                            }
                            match = responseHeaders[key.toLowerCase() + " "];
                        }
                        return match == null ? null : match.join(", ");
                    },

                    // Raw string
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null;
                    },

                    // Caches the header
                    setRequestHeader: function (name, value) {
                        if (completed == null) {
                            name = requestHeadersNames[name.toLowerCase()] =
                                requestHeadersNames[name.toLowerCase()] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function (type) {
                        if (completed == null) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Status-dependent callbacks
                    statusCode: function (map) {
                        var code;
                        if (map) {
                            if (completed) {

                                // Execute the appropriate callbacks
                                jqXHR.always(map[jqXHR.status]);
                            } else {

                                // Lazy-add the new callbacks in a way that preserves old ones
                                for (code in map) {
                                    statusCode[code] = [statusCode[code], map[code]];
                                }
                            }
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        if (transport) {
                            transport.abort(finalText);
                        }
                        done(0, finalText);
                        return this;
                    }
                };

            // Attach deferreds
            deferred.promise(jqXHR);

            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "")
                .replace(rprotocol, location.protocol + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");

                // Support: IE <=8 - 11, Edge 12 - 15
                // IE throws exception on accessing the href property if url is malformed,
                // e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE <=8 - 11 only
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                        urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (completed) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            // Remove hash to simplify url manipulation
            cacheURL = s.url.replace(rhash, "");

            // More options handling for requests with no content
            if (!s.hasContent) {

                // Remember the hash so we can put it back
                uncached = s.url.slice(cacheURL.length);

                // If data is available and should be processed, append data to url
                if (s.data && (s.processData || typeof s.data === "string")) {
                    cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add or update anti-cache param if needed
                if (s.cache === false) {
                    cacheURL = cacheURL.replace(rantiCache, "$1");
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce.guid++) +
                        uncached;
                }

                // Put hash and anti-cache on the URL that will be requested (gh-1732)
                s.url = cacheURL + uncached;

                // Change '%20' to '+' if this is encoded form body content (gh-2658)
            } else if (s.data && s.processData &&
                (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                s.data = s.data.replace(r20, "+");
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                    s.accepts[s.dataTypes[0]] +
                    (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                    s.accepts["*"]
            );

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend &&
                (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            completeDeferred.add(s.complete);
            jqXHR.done(s.success);
            jqXHR.fail(s.error);

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }

                // If request was aborted inside ajaxSend, stop there
                if (completed) {
                    return jqXHR;
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    completed = false;
                    transport.send(requestHeaders, done);
                } catch (e) {

                    // Rethrow post-completion exceptions
                    if (completed) {
                        throw e;
                    }

                    // Propagate others as results
                    done(-1, e);
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Ignore repeat invocations
                if (completed) {
                    return;
                }

                completed = true;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Use a noop converter for missing script
                if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1) {
                    s.converters["text script"] = function () { };
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError",
                        [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function (_i, method) {
        jQuery[method] = function (url, data, callback, type) {

            // Shift arguments if data argument was omitted
            if (isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });

    jQuery.ajaxPrefilter(function (s) {
        var i;
        for (i in s.headers) {
            if (i.toLowerCase() === "content-type") {
                s.contentType = s.headers[i] || "";
            }
        }
    });


    jQuery._evalUrl = function (url, options, doc) {
        return jQuery.ajax({
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,

            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
                "text script": function () { }
            },
            dataFilter: function (response) {
                jQuery.globalEval(response, options, doc);
            }
        });
    };


    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap;

            if (this[0]) {
                if (isFunction(html)) {
                    html = html.call(this[0]);
                }

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function () {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function (html) {
            if (isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function () {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function (html) {
            var htmlIsFunction = isFunction(html);

            return this.each(function (i) {
                jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function (selector) {
            this.parent(selector).not("body").each(function () {
                jQuery(this).replaceWith(this.childNodes);
            });
            return this;
        }
    });


    jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };




    jQuery.ajaxSettings.xhr = function () {
        try {
            return new window.XMLHttpRequest();
        } catch (e) { }
    };

    var xhrSuccessStatus = {

        // File protocol always yields status code 0, assume 200
        0: 200,

        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    },
        xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function (options) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i,
                        xhr = options.xhr();

                    xhr.open(
                        options.type,
                        options.url,
                        options.async,
                        options.username,
                        options.password
                    );

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                callback = errorCallback = xhr.onload =
                                    xhr.onerror = xhr.onabort = xhr.ontimeout =
                                    xhr.onreadystatechange = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {

                                    // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(

                                            // File: protocol always yields status 0; see #8605, #14207
                                            xhr.status,
                                            xhr.statusText
                                        );
                                    }
                                } else {
                                    complete(
                                        xhrSuccessStatus[xhr.status] || xhr.status,
                                        xhr.statusText,

                                        // Support: IE <=9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        (xhr.responseType || "text") !== "text" ||
                                            typeof xhr.responseText !== "string" ?
                                            { binary: xhr.response } :
                                            { text: xhr.responseText },
                                        xhr.getAllResponseHeaders()
                                    );
                                }
                            }
                        };
                    };

                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = xhr.ontimeout = callback("error");

                    // Support: IE 9 only
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function () {

                            // Check readyState before timeout as it changes
                            if (xhr.readyState === 4) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout(function () {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }

                    // Create the abort callback
                    callback = callback("abort");

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },

                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });




    // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
    jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
            s.contents.script = false;
        }
    });

    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " +
                "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function (s) {

        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
            var script, callback;
            return {
                send: function (_, complete) {
                    script = jQuery("<script>")
                        .attr(s.scriptAttrs || {})
                        .prop({ charset: s.scriptCharset, src: s.url })
                        .on("load error", callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === "error" ? 404 : 200, evt.type);
                            }
                        });

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function () {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });




    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce.guid++));
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                "url" :
                typeof s.data === "string" &&
                (s.contentType || "")
                    .indexOf("application/x-www-form-urlencoded") === 0 &&
                rjsonp.test(s.data) && "data"
            );

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ?
                s.jsonpCallback() :
                s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // Force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function () {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function () {

                // If previous value didn't exist - remove it
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);

                    // Otherwise restore preexisting value
                } else {
                    window[callbackName] = overwritten;
                }

                // Save back as free
                if (s[callbackName]) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });




    // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = (function () {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
    })();


    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== "string") {
            return [];
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }

        var base, parsed, scripts;

        if (!context) {

            // Stop scripts or inline event handlers from being executed immediately
            // by using document.implementation
            if (support.createHTMLDocument) {
                context = document.implementation.createHTMLDocument("");

                // Set the base href for the created document
                // so any parsed elements with URLs
                // are based on the document's URL (gh-2965)
                base = context.createElement("base");
                base.href = document.location.href;
                context.head.appendChild(base);
            } else {
                context = document;
            }
        }

        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    };


    /**
     * Load a url into a page
     */
    jQuery.fn.load = function (url, params, callback) {
        var selector, type, response,
            self = this,
            off = url.indexOf(" ");

        if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function (responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?

                    // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                    // Otherwise use the full result
                    responseText);

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            }).always(callback && function (jqXHR, status) {
                self.each(function () {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
            });
        }

        return this;
    };




    jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem;
        }).length;
    };




    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css(elem, "position"),
                curElem = jQuery(elem),
                props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") &&
                (curCSSTop + curCSSLeft).indexOf("auto") > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (isFunction(options)) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);

            } else {
                if (typeof props.top === "number") {
                    props.top += "px";
                }
                if (typeof props.left === "number") {
                    props.left += "px";
                }
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({

        // offset() relates an element's border box to the document origin
        offset: function (options) {

            // Preserve chaining for setter
            if (arguments.length) {
                return options === undefined ?
                    this :
                    this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i);
                    });
            }

            var rect, win,
                elem = this[0];

            if (!elem) {
                return;
            }

            // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
            // Support: IE <=11 only
            // Running getBoundingClientRect on a
            // disconnected node in IE throws an error
            if (!elem.getClientRects().length) {
                return { top: 0, left: 0 };
            }

            // Get document-relative position by adding viewport scroll to viewport-relative gBCR
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
                top: rect.top + win.pageYOffset,
                left: rect.left + win.pageXOffset
            };
        },

        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function () {
            if (!this[0]) {
                return;
            }

            var offsetParent, offset, doc,
                elem = this[0],
                parentOffset = { top: 0, left: 0 };

            // position:fixed elements are offset from the viewport, which itself always has zero offset
            if (jQuery.css(elem, "position") === "fixed") {

                // Assume position:fixed implies availability of getBoundingClientRect
                offset = elem.getBoundingClientRect();

            } else {
                offset = this.offset();

                // Account for the *real* offset parent, which can be the document or its root element
                // when a statically positioned element is identified
                doc = elem.ownerDocument;
                offsetParent = elem.offsetParent || doc.documentElement;
                while (offsetParent &&
                    (offsetParent === doc.body || offsetParent === doc.documentElement) &&
                    jQuery.css(offsetParent, "position") === "static") {

                    offsetParent = offsetParent.parentNode;
                }
                if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {

                    // Incorporate borders into its offset, since they are outside its content origin
                    parentOffset = jQuery(offsetParent).offset();
                    parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
                    parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
                }
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent;

                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            });
        }
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {

                // Coalesce documents and windows
                var win;
                if (isWindow(elem)) {
                    win = elem;
                } else if (elem.nodeType === 9) {
                    win = elem.defaultView;
                }

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(
                        !top ? val : win.pageXOffset,
                        top ? val : win.pageYOffset
                    );

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });

    // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function (_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
            function (elem, computed) {
                if (computed) {
                    computed = curCSS(elem, prop);

                    // If curCSS returns percentage, fallback to offset
                    return rnumnonpx.test(computed) ?
                        jQuery(elem).position()[prop] + "px" :
                        computed;
                }
            }
        );
    });


    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({ Height: "height", Width: "width" }, function (name, type) {
        jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name },
            function (defaultExtra, funcName) {

                // Margin is only for outerHeight, outerWidth
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                        extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                    return access(this, function (elem, type, value) {
                        var doc;

                        if (isWindow(elem)) {

                            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            return funcName.indexOf("outer") === 0 ?
                                elem["inner" + name] :
                                elem.document.documentElement["client" + name];
                        }

                        // Get document width or height
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;

                            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                            // whichever is greatest
                            return Math.max(
                                elem.body["scroll" + name], doc["scroll" + name],
                                elem.body["offset" + name], doc["offset" + name],
                                doc["client" + name]
                            );
                        }

                        return value === undefined ?

                            // Get width or height on the element, requesting but not forcing parseFloat
                            jQuery.css(elem, type, extra) :

                            // Set width or height on the element
                            jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable);
                };
            });
    });


    jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
    ], function (_i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn);
        };
    });




    jQuery.fn.extend({

        bind: function (types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ?
                this.off(selector, "**") :
                this.off(types, selector || "**", fn);
        },

        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup contextmenu").split(" "),
        function (_i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ?
                    this.on(name, null, data, fn) :
                    this.trigger(name);
            };
        });




    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon
    jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if (!isFunction(fn)) {
            return undefined;
        }

        // Simulated bind
        args = slice.call(arguments, 2);
        proxy = function () {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    };

    jQuery.holdReady = function (hold) {
        if (hold) {
            jQuery.readyWait++;
        } else {
            jQuery.ready(true);
        }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;

    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {

        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") &&

            // parseFloat NaNs numeric-cast false positives ("")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            !isNaN(obj - parseFloat(obj));
    };

    jQuery.trim = function (text) {
        return text == null ?
            "" :
            (text + "").replace(rtrim, "");
    };



    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
        define("jquery", [], function () {
            return jQuery;
        });
    }




    var

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$;

    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    };

    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (typeof noGlobal === "undefined") {
        window.jQuery = window.$ = jQuery;
    }




    return jQuery;
});

if (typeof define === "function" && define.amd && define.amd.jQuery) {
    define("vendor/jquery-3.5.1", [], function () { return jQuery; });
};
/*!
 * jQuery Validation Plugin v1.19.2
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2020 Jrn Zaefferer
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === "function" && define.amd) {
        define('vendor/jquery.validate',["jquery"], factory);
    } else if (typeof module === "object" && module.exports) {
        module.exports = factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(function ($) {

    $.extend($.fn, {

        // https://jqueryvalidation.org/validate/
        validate: function (options) {

            // If nothing is selected, return nothing; can't chain anyway
            if (!this.length) {
                if (options && options.debug && window.console) {
                    console.warn("Nothing selected, can't validate, returning nothing.");
                }
                return;
            }

            // Check if a validator for this form was already created
            var validator = $.data(this[0], "validator");
            if (validator) {
                return validator;
            }

            // Add novalidate tag if HTML5.
            this.attr("novalidate", "novalidate");

            validator = new $.validator(options, this[0]);
            $.data(this[0], "validator", validator);

            if (validator.settings.onsubmit) {

                this.on("click.validate", ":submit", function (event) {

                    // Track the used submit button to properly handle scripted
                    // submits later.
                    validator.submitButton = event.currentTarget;

                    // Allow suppressing validation by adding a cancel class to the submit button
                    if ($(this).hasClass("cancel")) {
                        validator.cancelSubmit = true;
                    }

                    // Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
                    if ($(this).attr("formnovalidate") !== undefined) {
                        validator.cancelSubmit = true;
                    }
                });

                // Validate the form on submit
                this.on("submit.validate", function (event) {
                    if (validator.settings.debug) {

                        // Prevent form submit to be able to see console output
                        event.preventDefault();
                    }

                    function handle() {
                        var hidden, result;

                        // Insert a hidden input as a replacement for the missing submit button
                        // The hidden input is inserted in two cases:
                        //   - A user defined a `submitHandler`
                        //   - There was a pending request due to `remote` method and `stopRequest()`
                        //     was called to submit the form in case it's valid
                        if (validator.submitButton && (validator.settings.submitHandler || validator.formSubmitted)) {
                            hidden = $("<input type='hidden'/>")
                                .attr("name", validator.submitButton.name)
                                .val($(validator.submitButton).val())
                                .appendTo(validator.currentForm);
                        }

                        if (validator.settings.submitHandler && !validator.settings.debug) {
                            result = validator.settings.submitHandler.call(validator, validator.currentForm, event);
                            if (hidden) {

                                // And clean up afterwards; thanks to no-block-scope, hidden can be referenced
                                hidden.remove();
                            }
                            if (result !== undefined) {
                                return result;
                            }
                            return false;
                        }
                        return true;
                    }

                    // Prevent submit for invalid forms or custom submit handlers
                    if (validator.cancelSubmit) {
                        validator.cancelSubmit = false;
                        return handle();
                    }
                    if (validator.form()) {
                        if (validator.pendingRequest) {
                            validator.formSubmitted = true;
                            return false;
                        }
                        return handle();
                    } else {
                        validator.focusInvalid();
                        return false;
                    }
                });
            }

            return validator;
        },

        // https://jqueryvalidation.org/valid/
        valid: function () {
            var valid, validator, errorList;

            if ($(this[0]).is("form")) {
                valid = this.validate().form();
            } else {
                errorList = [];
                valid = true;
                validator = $(this[0].form).validate();
                this.each(function () {
                    valid = validator.element(this) && valid;
                    if (!valid) {
                        errorList = errorList.concat(validator.errorList);
                    }
                });
                validator.errorList = errorList;
            }
            return valid;
        },

        // https://jqueryvalidation.org/rules/
        rules: function (command, argument) {
            var element = this[0],
                isContentEditable = typeof this.attr("contenteditable") !== "undefined" && this.attr("contenteditable") !== "false",
                settings, staticRules, existingRules, data, param, filtered;

            // If nothing is selected, return empty object; can't chain anyway
            if (element == null) {
                return;
            }

            if (!element.form && isContentEditable) {
                element.form = this.closest("form")[0];
                element.name = this.attr("name");
            }

            if (element.form == null) {
                return;
            }

            if (command) {
                settings = $.data(element.form, "validator").settings;
                staticRules = settings.rules;
                existingRules = $.validator.staticRules(element);
                switch (command) {
                    case "add":
                        $.extend(existingRules, $.validator.normalizeRule(argument));

                        // Remove messages from rules, but allow them to be set separately
                        delete existingRules.messages;
                        staticRules[element.name] = existingRules;
                        if (argument.messages) {
                            settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages);
                        }
                        break;
                    case "remove":
                        if (!argument) {
                            delete staticRules[element.name];
                            return existingRules;
                        }
                        filtered = {};
                        $.each(argument.split(/\s/), function (index, method) {
                            filtered[method] = existingRules[method];
                            delete existingRules[method];
                        });
                        return filtered;
                }
            }

            data = $.validator.normalizeRules(
                $.extend(
                    {},
                    $.validator.classRules(element),
                    $.validator.attributeRules(element),
                    $.validator.dataRules(element),
                    $.validator.staticRules(element)
                ), element);

            // Make sure required is at front
            if (data.required) {
                param = data.required;
                delete data.required;
                data = $.extend({ required: param }, data);
            }

            // Make sure remote is at back
            if (data.remote) {
                param = data.remote;
                delete data.remote;
                data = $.extend(data, { remote: param });
            }

            return data;
        }
    });

    // JQuery trim is deprecated, provide a trim method based on String.prototype.trim
    var trim = function (str) {

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim#Polyfill
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    };

    // Custom selectors
    $.extend($.expr.pseudos || $.expr[":"], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

        // https://jqueryvalidation.org/blank-selector/
        blank: function (a) {
            return !trim("" + $(a).val());
        },

        // https://jqueryvalidation.org/filled-selector/
        filled: function (a) {
            var val = $(a).val();
            return val !== null && !!trim("" + val);
        },

        // https://jqueryvalidation.org/unchecked-selector/
        unchecked: function (a) {
            return !$(a).prop("checked");
        }
    });

    // Constructor for validator
    $.validator = function (options, form) {
        this.settings = $.extend(true, {}, $.validator.defaults, options);
        this.currentForm = form;
        this.init();
    };

    // https://jqueryvalidation.org/jQuery.validator.format/
    $.validator.format = function (source, params) {
        if (arguments.length === 1) {
            return function () {
                var args = $.makeArray(arguments);
                args.unshift(source);
                return $.validator.format.apply(this, args);
            };
        }
        if (params === undefined) {
            return source;
        }
        if (arguments.length > 2 && params.constructor !== Array) {
            params = $.makeArray(arguments).slice(1);
        }
        if (params.constructor !== Array) {
            params = [params];
        }
        $.each(params, function (i, n) {
            source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function () {
                return n;
            });
        });
        return source;
    };

    $.extend($.validator, {

        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            pendingClass: "pending",
            validClass: "valid",
            errorElement: "label",
            focusCleanup: false,
            focusInvalid: true,
            errorContainer: $([]),
            errorLabelContainer: $([]),
            onsubmit: true,
            ignore: ":hidden",
            ignoreTitle: false,
            onfocusin: function (element) {
                this.lastActive = element;

                // Hide error label and remove error class on focus if enabled
                if (this.settings.focusCleanup) {
                    if (this.settings.unhighlight) {
                        this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass);
                    }
                    this.hideThese(this.errorsFor(element));
                }
            },
            onfocusout: function (element) {
                if (!this.checkable(element) && (element.name in this.submitted || !this.optional(element))) {
                    this.element(element);
                }
            },
            onkeyup: function (element, event) {

                // Avoid revalidate the field when pressing one of the following keys
                // Shift       => 16
                // Ctrl        => 17
                // Alt         => 18
                // Caps lock   => 20
                // End         => 35
                // Home        => 36
                // Left arrow  => 37
                // Up arrow    => 38
                // Right arrow => 39
                // Down arrow  => 40
                // Insert      => 45
                // Num lock    => 144
                // AltGr key   => 225
                var excludedKeys = [
                    16, 17, 18, 20, 35, 36, 37,
                    38, 39, 40, 45, 144, 225
                ];

                if (event.which === 9 && this.elementValue(element) === "" || $.inArray(event.keyCode, excludedKeys) !== -1) {
                    return;
                } else if (element.name in this.submitted || element.name in this.invalid) {
                    this.element(element);
                }
            },
            onclick: function (element) {

                // Click on selects, radiobuttons and checkboxes
                if (element.name in this.submitted) {
                    this.element(element);

                    // Or option elements, check parent select in that case
                } else if (element.parentNode.name in this.submitted) {
                    this.element(element.parentNode);
                }
            },
            highlight: function (element, errorClass, validClass) {
                if (element.type === "radio") {
                    this.findByName(element.name).addClass(errorClass).removeClass(validClass);
                } else {
                    $(element).addClass(errorClass).removeClass(validClass);
                }
            },
            unhighlight: function (element, errorClass, validClass) {
                if (element.type === "radio") {
                    this.findByName(element.name).removeClass(errorClass).addClass(validClass);
                } else {
                    $(element).removeClass(errorClass).addClass(validClass);
                }
            }
        },

        // https://jqueryvalidation.org/jQuery.validator.setDefaults/
        setDefaults: function (settings) {
            $.extend($.validator.defaults, settings);
        },

        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date (ISO).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            equalTo: "Please enter the same value again.",
            maxlength: $.validator.format("Please enter no more than {0} characters."),
            minlength: $.validator.format("Please enter at least {0} characters."),
            rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
            range: $.validator.format("Please enter a value between {0} and {1}."),
            max: $.validator.format("Please enter a value less than or equal to {0}."),
            min: $.validator.format("Please enter a value greater than or equal to {0}."),
            step: $.validator.format("Please enter a multiple of {0}.")
        },

        autoCreateRanges: false,

        prototype: {

            init: function () {
                this.labelContainer = $(this.settings.errorLabelContainer);
                this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
                this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer);
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();

                var currentForm = this.currentForm,
                    groups = (this.groups = {}),
                    rules;
                $.each(this.settings.groups, function (key, value) {
                    if (typeof value === "string") {
                        value = value.split(/\s/);
                    }
                    $.each(value, function (index, name) {
                        groups[name] = key;
                    });
                });
                rules = this.settings.rules;
                $.each(rules, function (key, value) {
                    rules[key] = $.validator.normalizeRule(value);
                });

                function delegate(event) {
                    var isContentEditable = typeof $(this).attr("contenteditable") !== "undefined" && $(this).attr("contenteditable") !== "false";

                    // Set form expando on contenteditable
                    if (!this.form && isContentEditable) {
                        this.form = $(this).closest("form")[0];
                        this.name = $(this).attr("name");
                    }

                    // Ignore the element if it belongs to another form. This will happen mainly
                    // when setting the `form` attribute of an input to the id of another form.
                    if (currentForm !== this.form) {
                        return;
                    }

                    var validator = $.data(this.form, "validator"),
                        eventType = "on" + event.type.replace(/^validate/, ""),
                        settings = validator.settings;
                    if (settings[eventType] && !$(this).is(settings.ignore)) {
                        settings[eventType].call(validator, this, event);
                    }
                }

                $(this.currentForm)
                    .on("focusin.validate focusout.validate keyup.validate",
                        ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
                        "[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
                        "[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
                        "[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate)

                    // Support: Chrome, oldIE
                    // "select" is provided as event.target when clicking a option
                    .on("click.validate", "select, option, [type='radio'], [type='checkbox']", delegate);

                if (this.settings.invalidHandler) {
                    $(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler);
                }
            },

            // https://jqueryvalidation.org/Validator.form/
            form: function () {
                this.checkForm();
                $.extend(this.submitted, this.errorMap);
                this.invalid = $.extend({}, this.errorMap);
                if (!this.valid()) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                }
                this.showErrors();
                return this.valid();
            },

            checkForm: function () {
                this.prepareForm();
                for (var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++) {
                    this.check(elements[i]);
                }
                return this.valid();
            },

            // https://jqueryvalidation.org/Validator.element/
            element: function (element) {
                var cleanElement = this.clean(element),
                    checkElement = this.validationTargetFor(cleanElement),
                    v = this,
                    result = true,
                    rs, group;

                if (checkElement === undefined) {
                    delete this.invalid[cleanElement.name];
                } else {
                    this.prepareElement(checkElement);
                    this.currentElements = $(checkElement);

                    // If this element is grouped, then validate all group elements already
                    // containing a value
                    group = this.groups[checkElement.name];
                    if (group) {
                        $.each(this.groups, function (name, testgroup) {
                            if (testgroup === group && name !== checkElement.name) {
                                cleanElement = v.validationTargetFor(v.clean(v.findByName(name)));
                                if (cleanElement && cleanElement.name in v.invalid) {
                                    v.currentElements.push(cleanElement);
                                    result = v.check(cleanElement) && result;
                                }
                            }
                        });
                    }

                    rs = this.check(checkElement) !== false;
                    result = result && rs;
                    if (rs) {
                        this.invalid[checkElement.name] = false;
                    } else {
                        this.invalid[checkElement.name] = true;
                    }

                    if (!this.numberOfInvalids()) {

                        // Hide error containers on last error
                        this.toHide = this.toHide.add(this.containers);
                    }
                    this.showErrors();

                    // Add aria-invalid status for screen readers
                    $(element).attr("aria-invalid", !rs);
                }

                return result;
            },

            // https://jqueryvalidation.org/Validator.showErrors/
            showErrors: function (errors) {
                if (errors) {
                    var validator = this;

                    // Add items to error list and map
                    $.extend(this.errorMap, errors);
                    this.errorList = $.map(this.errorMap, function (message, name) {
                        return {
                            message: message,
                            element: validator.findByName(name)[0]
                        };
                    });

                    // Remove items from success list
                    this.successList = $.grep(this.successList, function (element) {
                        return !(element.name in errors);
                    });
                }
                if (this.settings.showErrors) {
                    this.settings.showErrors.call(this, this.errorMap, this.errorList);
                } else {
                    this.defaultShowErrors();
                }
            },

            // https://jqueryvalidation.org/Validator.resetForm/
            resetForm: function () {
                if ($.fn.resetForm) {
                    $(this.currentForm).resetForm();
                }
                this.invalid = {};
                this.submitted = {};
                this.prepareForm();
                this.hideErrors();
                var elements = this.elements()
                    .removeData("previousValue")
                    .removeAttr("aria-invalid");

                this.resetElements(elements);
            },

            resetElements: function (elements) {
                var i;

                if (this.settings.unhighlight) {
                    for (i = 0; elements[i]; i++) {
                        this.settings.unhighlight.call(this, elements[i],
                            this.settings.errorClass, "");
                        this.findByName(elements[i].name).removeClass(this.settings.validClass);
                    }
                } else {
                    elements
                        .removeClass(this.settings.errorClass)
                        .removeClass(this.settings.validClass);
                }
            },

            numberOfInvalids: function () {
                return this.objectLength(this.invalid);
            },

            objectLength: function (obj) {
                /* jshint unused: false */
                var count = 0,
                    i;
                for (i in obj) {

                    // This check allows counting elements with empty error
                    // message as invalid elements
                    if (obj[i] !== undefined && obj[i] !== null && obj[i] !== false) {
                        count++;
                    }
                }
                return count;
            },

            hideErrors: function () {
                this.hideThese(this.toHide);
            },

            hideThese: function (errors) {
                errors.not(this.containers).text("");
                this.addWrapper(errors).hide();
            },

            valid: function () {
                return this.size() === 0;
            },

            size: function () {
                return this.errorList.length;
            },

            focusInvalid: function () {
                if (this.settings.focusInvalid) {
                    try {
                        $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
                            .filter(":visible")
                            .trigger("focus")

                            // Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
                            .trigger("focusin");
                    } catch (e) {

                        // Ignore IE throwing errors when focusing hidden elements
                    }
                }
            },

            findLastActive: function () {
                var lastActive = this.lastActive;
                return lastActive && $.grep(this.errorList, function (n) {
                    return n.element.name === lastActive.name;
                }).length === 1 && lastActive;
            },

            elements: function () {
                var validator = this,
                    rulesCache = {};

                // Select all valid inputs inside the form (no submit or reset buttons)
                return $(this.currentForm)
                    .find("input, select, textarea, [contenteditable]")
                    .not(":submit, :reset, :image, :disabled")
                    .not(this.settings.ignore)
                    .filter(function () {
                        var name = this.name || $(this).attr("name"); // For contenteditable
                        var isContentEditable = typeof $(this).attr("contenteditable") !== "undefined" && $(this).attr("contenteditable") !== "false";

                        if (!name && validator.settings.debug && window.console) {
                            console.error("%o has no name assigned", this);
                        }

                        // Set form expando on contenteditable
                        if (isContentEditable) {
                            this.form = $(this).closest("form")[0];
                            this.name = name;
                        }

                        // Ignore elements that belong to other/nested forms
                        if (this.form !== validator.currentForm) {
                            return false;
                        }

                        // Select only the first element for each name, and only those with rules specified
                        if (name in rulesCache || !validator.objectLength($(this).rules())) {
                            return false;
                        }

                        rulesCache[name] = true;
                        return true;
                    });
            },

            clean: function (selector) {
                return $(selector)[0];
            },

            errors: function () {
                var errorClass = this.settings.errorClass.split(" ").join(".");
                return $(this.settings.errorElement + "." + errorClass, this.errorContext);
            },

            resetInternals: function () {
                this.successList = [];
                this.errorList = [];
                this.errorMap = {};
                this.toShow = $([]);
                this.toHide = $([]);
            },

            reset: function () {
                this.resetInternals();
                this.currentElements = $([]);
            },

            prepareForm: function () {
                this.reset();
                this.toHide = this.errors().add(this.containers);
            },

            prepareElement: function (element) {
                this.reset();
                this.toHide = this.errorsFor(element);
            },

            elementValue: function (element) {
                var $element = $(element),
                    type = element.type,
                    isContentEditable = typeof $element.attr("contenteditable") !== "undefined" && $element.attr("contenteditable") !== "false",
                    val, idx;

                if (type === "radio" || type === "checkbox") {
                    return this.findByName(element.name).filter(":checked").val();
                } else if (type === "number" && typeof element.validity !== "undefined") {
                    return element.validity.badInput ? "NaN" : $element.val();
                }

                if (isContentEditable) {
                    val = $element.text();
                } else {
                    val = $element.val();
                }

                if (type === "file") {

                    // Modern browser (chrome & safari)
                    if (val.substr(0, 12) === "C:\\fakepath\\") {
                        return val.substr(12);
                    }

                    // Legacy browsers
                    // Unix-based path
                    idx = val.lastIndexOf("/");
                    if (idx >= 0) {
                        return val.substr(idx + 1);
                    }

                    // Windows-based path
                    idx = val.lastIndexOf("\\");
                    if (idx >= 0) {
                        return val.substr(idx + 1);
                    }

                    // Just the file name
                    return val;
                }

                if (typeof val === "string") {
                    return val.replace(/\r/g, "");
                }
                return val;
            },

            check: function (element) {
                element = this.validationTargetFor(this.clean(element));

                var rules = $(element).rules(),
                    rulesCount = $.map(rules, function (n, i) {
                        return i;
                    }).length,
                    dependencyMismatch = false,
                    val = this.elementValue(element),
                    result, method, rule, normalizer;

                // Prioritize the local normalizer defined for this element over the global one
                // if the former exists, otherwise user the global one in case it exists.
                if (typeof rules.normalizer === "function") {
                    normalizer = rules.normalizer;
                } else if (typeof this.settings.normalizer === "function") {
                    normalizer = this.settings.normalizer;
                }

                // If normalizer is defined, then call it to retreive the changed value instead
                // of using the real one.
                // Note that `this` in the normalizer is `element`.
                if (normalizer) {
                    val = normalizer.call(element, val);

                    // Delete the normalizer from rules to avoid treating it as a pre-defined method.
                    delete rules.normalizer;
                }

                for (method in rules) {
                    rule = { method: method, parameters: rules[method] };
                    try {
                        result = $.validator.methods[method].call(this, val, element, rule.parameters);

                        // If a method indicates that the field is optional and therefore valid,
                        // don't mark it as valid when there are no other rules
                        if (result === "dependency-mismatch" && rulesCount === 1) {
                            dependencyMismatch = true;
                            continue;
                        }
                        dependencyMismatch = false;

                        if (result === "pending") {
                            this.toHide = this.toHide.not(this.errorsFor(element));
                            return;
                        }

                        if (!result) {
                            this.formatAndAdd(element, rule);
                            return false;
                        }
                    } catch (e) {
                        if (this.settings.debug && window.console) {
                            console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e);
                        }
                        if (e instanceof TypeError) {
                            e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
                        }

                        throw e;
                    }
                }
                if (dependencyMismatch) {
                    return;
                }
                if (this.objectLength(rules)) {
                    this.successList.push(element);
                }
                return true;
            },

            // Return the custom message for the given element and validation method
            // specified in the element's HTML5 data attribute
            // return the generic message if present and no method specific message is present
            customDataMessage: function (element, method) {
                return $(element).data("msg" + method.charAt(0).toUpperCase() +
                    method.substring(1).toLowerCase()) || $(element).data("msg");
            },

            // Return the custom message for the given element name and validation method
            customMessage: function (name, method) {
                var m = this.settings.messages[name];
                return m && (m.constructor === String ? m : m[method]);
            },

            // Return the first defined argument, allowing empty strings
            findDefined: function () {
                for (var i = 0; i < arguments.length; i++) {
                    if (arguments[i] !== undefined) {
                        return arguments[i];
                    }
                }
                return undefined;
            },

            // The second parameter 'rule' used to be a string, and extended to an object literal
            // of the following form:
            // rule = {
            //     method: "method name",
            //     parameters: "the given method parameters"
            // }
            //
            // The old behavior still supported, kept to maintain backward compatibility with
            // old code, and will be removed in the next major release.
            defaultMessage: function (element, rule) {
                if (typeof rule === "string") {
                    rule = { method: rule };
                }

                var message = this.findDefined(
                    this.customMessage(element.name, rule.method),
                    this.customDataMessage(element, rule.method),

                    // 'title' is never undefined, so handle empty string as undefined
                    !this.settings.ignoreTitle && element.title || undefined,
                    $.validator.messages[rule.method],
                    "<strong>Warning: No message defined for " + element.name + "</strong>"
                ),
                    theregex = /\$?\{(\d+)\}/g;
                if (typeof message === "function") {
                    message = message.call(this, rule.parameters, element);
                } else if (theregex.test(message)) {
                    message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);
                }

                return message;
            },

            formatAndAdd: function (element, rule) {
                var message = this.defaultMessage(element, rule);

                this.errorList.push({
                    message: message,
                    element: element,
                    method: rule.method
                });

                this.errorMap[element.name] = message;
                this.submitted[element.name] = message;
            },

            addWrapper: function (toToggle) {
                if (this.settings.wrapper) {
                    toToggle = toToggle.add(toToggle.parent(this.settings.wrapper));
                }
                return toToggle;
            },

            defaultShowErrors: function () {
                var i, elements, error;
                for (i = 0; this.errorList[i]; i++) {
                    error = this.errorList[i];
                    if (this.settings.highlight) {
                        this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass);
                    }
                    this.showLabel(error.element, error.message);
                }
                if (this.errorList.length) {
                    this.toShow = this.toShow.add(this.containers);
                }
                if (this.settings.success) {
                    for (i = 0; this.successList[i]; i++) {
                        this.showLabel(this.successList[i]);
                    }
                }
                if (this.settings.unhighlight) {
                    for (i = 0, elements = this.validElements(); elements[i]; i++) {
                        this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                    }
                }
                this.toHide = this.toHide.not(this.toShow);
                this.hideErrors();
                this.addWrapper(this.toShow).show();
            },

            validElements: function () {
                return this.currentElements.not(this.invalidElements());
            },

            invalidElements: function () {
                return $(this.errorList).map(function () {
                    return this.element;
                });
            },

            showLabel: function (element, message) {
                var place, group, errorID, v,
                    error = this.errorsFor(element),
                    elementID = this.idOrName(element),
                    describedBy = $(element).attr("aria-describedby");

                if (error.length) {

                    // Refresh error/success class
                    error.removeClass(this.settings.validClass).addClass(this.settings.errorClass);

                    // Replace message on existing label
                    error.html(message);
                } else {

                    // Create error element
                    error = $("<" + this.settings.errorElement + ">")
                        .attr("id", elementID + "-error")
                        .addClass(this.settings.errorClass)
                        .html(message || "");

                    // Maintain reference to the element to be placed into the DOM
                    place = error;
                    if (this.settings.wrapper) {

                        // Make sure the element is visible, even in IE
                        // actually showing the wrapped element is handled elsewhere
                        place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
                    }
                    if (this.labelContainer.length) {
                        this.labelContainer.append(place);
                    } else if (this.settings.errorPlacement) {
                        this.settings.errorPlacement.call(this, place, $(element));
                    } else {
                        place.insertAfter(element);
                    }

                    // Link error back to the element
                    if (error.is("label")) {

                        // If the error is a label, then associate using 'for'
                        error.attr("for", elementID);

                        // If the element is not a child of an associated label, then it's necessary
                        // to explicitly apply aria-describedby
                    } else if (error.parents("label[for='" + this.escapeCssMeta(elementID) + "']").length === 0) {
                        errorID = error.attr("id");

                        // Respect existing non-error aria-describedby
                        if (!describedBy) {
                            describedBy = errorID;
                        } else if (!describedBy.match(new RegExp("\\b" + this.escapeCssMeta(errorID) + "\\b"))) {

                            // Add to end of list if not already present
                            describedBy += " " + errorID;
                        }
                        $(element).attr("aria-describedby", describedBy);

                        // If this element is grouped, then assign to all elements in the same group
                        group = this.groups[element.name];
                        if (group) {
                            v = this;
                            $.each(v.groups, function (name, testgroup) {
                                if (testgroup === group) {
                                    $("[name='" + v.escapeCssMeta(name) + "']", v.currentForm)
                                        .attr("aria-describedby", error.attr("id"));
                                }
                            });
                        }
                    }
                }
                if (!message && this.settings.success) {
                    error.text("");
                    if (typeof this.settings.success === "string") {
                        error.addClass(this.settings.success);
                    } else {
                        this.settings.success(error, element);
                    }
                }
                this.toShow = this.toShow.add(error);
            },

            errorsFor: function (element) {
                var name = this.escapeCssMeta(this.idOrName(element)),
                    describer = $(element).attr("aria-describedby"),
                    selector = "label[for='" + name + "'], label[for='" + name + "'] *";

                // 'aria-describedby' should directly reference the error element
                if (describer) {
                    selector = selector + ", #" + this.escapeCssMeta(describer)
                        .replace(/\s+/g, ", #");
                }

                return this
                    .errors()
                    .filter(selector);
            },

            // See https://api.jquery.com/category/selectors/, for CSS
            // meta-characters that should be escaped in order to be used with JQuery
            // as a literal part of a name/id or any selector.
            escapeCssMeta: function (string) {
                return string.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1");
            },

            idOrName: function (element) {
                return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
            },

            validationTargetFor: function (element) {

                // If radio/checkbox, validate first element in group instead
                if (this.checkable(element)) {
                    element = this.findByName(element.name);
                }

                // Always apply ignore filter
                return $(element).not(this.settings.ignore)[0];
            },

            checkable: function (element) {
                return (/radio|checkbox/i).test(element.type);
            },

            findByName: function (name) {
                return $(this.currentForm).find("[name='" + this.escapeCssMeta(name) + "']");
            },

            getLength: function (value, element) {
                switch (element.nodeName.toLowerCase()) {
                    case "select":
                        return $("option:selected", element).length;
                    case "input":
                        if (this.checkable(element)) {
                            return this.findByName(element.name).filter(":checked").length;
                        }
                }
                return value.length;
            },

            depend: function (param, element) {
                return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;
            },

            dependTypes: {
                "boolean": function (param) {
                    return param;
                },
                "string": function (param, element) {
                    return !!$(param, element.form).length;
                },
                "function": function (param, element) {
                    return param(element);
                }
            },

            optional: function (element) {
                var val = this.elementValue(element);
                return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
            },

            startRequest: function (element) {
                if (!this.pending[element.name]) {
                    this.pendingRequest++;
                    $(element).addClass(this.settings.pendingClass);
                    this.pending[element.name] = true;
                }
            },

            stopRequest: function (element, valid) {
                this.pendingRequest--;

                // Sometimes synchronization fails, make sure pendingRequest is never < 0
                if (this.pendingRequest < 0) {
                    this.pendingRequest = 0;
                }
                delete this.pending[element.name];
                $(element).removeClass(this.settings.pendingClass);
                if (valid && this.pendingRequest === 0 && this.formSubmitted && this.form()) {
                    $(this.currentForm).submit();

                    // Remove the hidden input that was used as a replacement for the
                    // missing submit button. The hidden input is added by `handle()`
                    // to ensure that the value of the used submit button is passed on
                    // for scripted submits triggered by this method
                    if (this.submitButton) {
                        $("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove();
                    }

                    this.formSubmitted = false;
                } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {
                    $(this.currentForm).triggerHandler("invalid-form", [this]);
                    this.formSubmitted = false;
                }
            },

            previousValue: function (element, method) {
                method = typeof method === "string" && method || "remote";

                return $.data(element, "previousValue") || $.data(element, "previousValue", {
                    old: null,
                    valid: true,
                    message: this.defaultMessage(element, { method: method })
                });
            },

            // Cleans up all forms and elements, removes validator-specific events
            destroy: function () {
                this.resetForm();

                $(this.currentForm)
                    .off(".validate")
                    .removeData("validator")
                    .find(".validate-equalTo-blur")
                    .off(".validate-equalTo")
                    .removeClass("validate-equalTo-blur")
                    .find(".validate-lessThan-blur")
                    .off(".validate-lessThan")
                    .removeClass("validate-lessThan-blur")
                    .find(".validate-lessThanEqual-blur")
                    .off(".validate-lessThanEqual")
                    .removeClass("validate-lessThanEqual-blur")
                    .find(".validate-greaterThanEqual-blur")
                    .off(".validate-greaterThanEqual")
                    .removeClass("validate-greaterThanEqual-blur")
                    .find(".validate-greaterThan-blur")
                    .off(".validate-greaterThan")
                    .removeClass("validate-greaterThan-blur");
            }

        },

        classRuleSettings: {
            required: { required: true },
            email: { email: true },
            url: { url: true },
            date: { date: true },
            dateISO: { dateISO: true },
            number: { number: true },
            digits: { digits: true },
            creditcard: { creditcard: true }
        },

        addClassRules: function (className, rules) {
            if (className.constructor === String) {
                this.classRuleSettings[className] = rules;
            } else {
                $.extend(this.classRuleSettings, className);
            }
        },

        classRules: function (element) {
            var rules = {},
                classes = $(element).attr("class");

            if (classes) {
                $.each(classes.split(" "), function () {
                    if (this in $.validator.classRuleSettings) {
                        $.extend(rules, $.validator.classRuleSettings[this]);
                    }
                });
            }
            return rules;
        },

        normalizeAttributeRule: function (rules, type, method, value) {

            // Convert the value to a number for number inputs, and for text for backwards compability
            // allows type="date" and others to be compared as strings
            if (/min|max|step/.test(method) && (type === null || /number|range|text/.test(type))) {
                value = Number(value);

                // Support Opera Mini, which returns NaN for undefined minlength
                if (isNaN(value)) {
                    value = undefined;
                }
            }

            if (value || value === 0) {
                rules[method] = value;
            } else if (type === method && type !== "range") {

                // Exception: the jquery validate 'range' method
                // does not test for the html5 'range' type
                rules[method] = true;
            }
        },

        attributeRules: function (element) {
            var rules = {},
                $element = $(element),
                type = element.getAttribute("type"),
                method, value;

            for (method in $.validator.methods) {

                // Support for <input required> in both html5 and older browsers
                if (method === "required") {
                    value = element.getAttribute(method);

                    // Some browsers return an empty string for the required attribute
                    // and non-HTML5 browsers might have required="" markup
                    if (value === "") {
                        value = true;
                    }

                    // Force non-HTML5 browsers to return bool
                    value = !!value;
                } else {
                    value = $element.attr(method);
                }

                this.normalizeAttributeRule(rules, type, method, value);
            }

            // 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
            if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
                delete rules.maxlength;
            }

            return rules;
        },

        dataRules: function (element) {
            var rules = {},
                $element = $(element),
                type = element.getAttribute("type"),
                method, value;

            for (method in $.validator.methods) {
                value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase());

                // Cast empty attributes like `data-rule-required` to `true`
                if (value === "") {
                    value = true;
                }

                this.normalizeAttributeRule(rules, type, method, value);
            }
            return rules;
        },

        staticRules: function (element) {
            var rules = {},
                validator = $.data(element.form, "validator");

            if (validator.settings.rules) {
                rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
            }
            return rules;
        },

        normalizeRules: function (rules, element) {

            // Handle dependency check
            $.each(rules, function (prop, val) {

                // Ignore rule when param is explicitly false, eg. required:false
                if (val === false) {
                    delete rules[prop];
                    return;
                }
                if (val.param || val.depends) {
                    var keepRule = true;
                    switch (typeof val.depends) {
                        case "string":
                            keepRule = !!$(val.depends, element.form).length;
                            break;
                        case "function":
                            keepRule = val.depends.call(element, element);
                            break;
                    }
                    if (keepRule) {
                        rules[prop] = val.param !== undefined ? val.param : true;
                    } else {
                        $.data(element.form, "validator").resetElements($(element));
                        delete rules[prop];
                    }
                }
            });

            // Evaluate parameters
            $.each(rules, function (rule, parameter) {
                rules[rule] = $.isFunction(parameter) && rule !== "normalizer" ? parameter(element) : parameter;
            });

            // Clean number parameters
            $.each(["minlength", "maxlength"], function () {
                if (rules[this]) {
                    rules[this] = Number(rules[this]);
                }
            });
            $.each(["rangelength", "range"], function () {
                var parts;
                if (rules[this]) {
                    if (Array.isArray(rules[this])) {
                        rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
                    } else if (typeof rules[this] === "string") {
                        parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/);
                        rules[this] = [Number(parts[0]), Number(parts[1])];
                    }
                }
            });

            if ($.validator.autoCreateRanges) {

                // Auto-create ranges
                if (rules.min != null && rules.max != null) {
                    rules.range = [rules.min, rules.max];
                    delete rules.min;
                    delete rules.max;
                }
                if (rules.minlength != null && rules.maxlength != null) {
                    rules.rangelength = [rules.minlength, rules.maxlength];
                    delete rules.minlength;
                    delete rules.maxlength;
                }
            }

            return rules;
        },

        // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
        normalizeRule: function (data) {
            if (typeof data === "string") {
                var transformed = {};
                $.each(data.split(/\s/), function () {
                    transformed[this] = true;
                });
                data = transformed;
            }
            return data;
        },

        // https://jqueryvalidation.org/jQuery.validator.addMethod/
        addMethod: function (name, method, message) {
            $.validator.methods[name] = method;
            $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];
            if (method.length < 3) {
                $.validator.addClassRules(name, $.validator.normalizeRule(name));
            }
        },

        // https://jqueryvalidation.org/jQuery.validator.methods/
        methods: {

            // https://jqueryvalidation.org/required-method/
            required: function (value, element, param) {

                // Check if dependency is met
                if (!this.depend(param, element)) {
                    return "dependency-mismatch";
                }
                if (element.nodeName.toLowerCase() === "select") {

                    // Could be an array for select-multiple or a string, both are fine this way
                    var val = $(element).val();
                    return val && val.length > 0;
                }
                if (this.checkable(element)) {
                    return this.getLength(value, element) > 0;
                }
                return value !== undefined && value !== null && value.length > 0;
            },

            // https://jqueryvalidation.org/email-method/
            email: function (value, element) {

                // From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
                // Retrieved 2014-01-14
                // If you have a problem with this implementation, report a bug against the above spec
                // Or use custom methods to implement your own email validation
                return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
            },

            // https://jqueryvalidation.org/url-method/
            url: function (value, element) {

                // Copyright (c) 2010-2013 Diego Perini, MIT licensed
                // https://gist.github.com/dperini/729294
                // see also https://mathiasbynens.be/demo/url-regex
                // modified to allow protocol-relative URLs
                return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(value);
            },

            // https://jqueryvalidation.org/date-method/
            date: (function () {
                var called = false;

                return function (value, element) {
                    if (!called) {
                        called = true;
                        if (this.settings.debug && window.console) {
                            console.warn(
                                "The `date` method is deprecated and will be removed in version '2.0.0'.\n" +
                                "Please don't use it, since it relies on the Date constructor, which\n" +
                                "behaves very differently across browsers and locales. Use `dateISO`\n" +
                                "instead or one of the locale specific methods in `localizations/`\n" +
                                "and `additional-methods.js`."
                            );
                        }
                    }

                    return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
                };
            }()),

            // https://jqueryvalidation.org/dateISO-method/
            dateISO: function (value, element) {
                return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
            },

            // https://jqueryvalidation.org/number-method/
            number: function (value, element) {
                return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
            },

            // https://jqueryvalidation.org/digits-method/
            digits: function (value, element) {
                return this.optional(element) || /^\d+$/.test(value);
            },

            // https://jqueryvalidation.org/minlength-method/
            minlength: function (value, element, param) {
                var length = Array.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length >= param;
            },

            // https://jqueryvalidation.org/maxlength-method/
            maxlength: function (value, element, param) {
                var length = Array.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length <= param;
            },

            // https://jqueryvalidation.org/rangelength-method/
            rangelength: function (value, element, param) {
                var length = Array.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || (length >= param[0] && length <= param[1]);
            },

            // https://jqueryvalidation.org/min-method/
            min: function (value, element, param) {
                return this.optional(element) || value >= param;
            },

            // https://jqueryvalidation.org/max-method/
            max: function (value, element, param) {
                return this.optional(element) || value <= param;
            },

            // https://jqueryvalidation.org/range-method/
            range: function (value, element, param) {
                return this.optional(element) || (value >= param[0] && value <= param[1]);
            },

            // https://jqueryvalidation.org/step-method/
            step: function (value, element, param) {
                var type = $(element).attr("type"),
                    errorMessage = "Step attribute on input type " + type + " is not supported.",
                    supportedTypes = ["text", "number", "range"],
                    re = new RegExp("\\b" + type + "\\b"),
                    notSupported = type && !re.test(supportedTypes.join()),
                    decimalPlaces = function (num) {
                        var match = ("" + num).match(/(?:\.(\d+))?$/);
                        if (!match) {
                            return 0;
                        }

                        // Number of digits right of decimal point.
                        return match[1] ? match[1].length : 0;
                    },
                    toInt = function (num) {
                        return Math.round(num * Math.pow(10, decimals));
                    },
                    valid = true,
                    decimals;

                // Works only for text, number and range input types
                // TODO find a way to support input types date, datetime, datetime-local, month, time and week
                if (notSupported) {
                    throw new Error(errorMessage);
                }

                decimals = decimalPlaces(param);

                // Value can't have too many decimals
                if (decimalPlaces(value) > decimals || toInt(value) % toInt(param) !== 0) {
                    valid = false;
                }

                return this.optional(element) || valid;
            },

            // https://jqueryvalidation.org/equalTo-method/
            equalTo: function (value, element, param) {

                // Bind to the blur event of the target in order to revalidate whenever the target field is updated
                var target = $(param);
                if (this.settings.onfocusout && target.not(".validate-equalTo-blur").length) {
                    target.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function () {
                        $(element).valid();
                    });
                }
                return value === target.val();
            },

            // https://jqueryvalidation.org/remote-method/
            remote: function (value, element, param, method) {
                if (this.optional(element)) {
                    return "dependency-mismatch";
                }

                method = typeof method === "string" && method || "remote";

                var previous = this.previousValue(element, method),
                    validator, data, optionDataString;

                if (!this.settings.messages[element.name]) {
                    this.settings.messages[element.name] = {};
                }
                previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method];
                this.settings.messages[element.name][method] = previous.message;

                param = typeof param === "string" && { url: param } || param;
                optionDataString = $.param($.extend({ data: value }, param.data));
                if (previous.old === optionDataString) {
                    return previous.valid;
                }

                previous.old = optionDataString;
                validator = this;
                this.startRequest(element);
                data = {};
                data[element.name] = value;
                $.ajax($.extend(true, {
                    mode: "abort",
                    port: "validate" + element.name,
                    dataType: "json",
                    data: data,
                    context: validator.currentForm,
                    success: function (response) {
                        var valid = response === true || response === "true",
                            errors, message, submitted;

                        validator.settings.messages[element.name][method] = previous.originalMessage;
                        if (valid) {
                            submitted = validator.formSubmitted;
                            validator.resetInternals();
                            validator.toHide = validator.errorsFor(element);
                            validator.formSubmitted = submitted;
                            validator.successList.push(element);
                            validator.invalid[element.name] = false;
                            validator.showErrors();
                        } else {
                            errors = {};
                            message = response || validator.defaultMessage(element, { method: method, parameters: value });
                            errors[element.name] = previous.message = message;
                            validator.invalid[element.name] = true;
                            validator.showErrors(errors);
                        }
                        previous.valid = valid;
                        validator.stopRequest(element, valid);
                    }
                }, param));
                return "pending";
            }
        }

    });

    // Ajax mode: abort
    // usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
    // if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

    var pendingRequests = {},
        ajax;

    // Use a prefilter if available (1.5+)
    if ($.ajaxPrefilter) {
        $.ajaxPrefilter(function (settings, _, xhr) {
            var port = settings.port;
            if (settings.mode === "abort") {
                if (pendingRequests[port]) {
                    pendingRequests[port].abort();
                }
                pendingRequests[port] = xhr;
            }
        });
    } else {

        // Proxy ajax
        ajax = $.ajax;
        $.ajax = function (settings) {
            var mode = ("mode" in settings ? settings : $.ajaxSettings).mode,
                port = ("port" in settings ? settings : $.ajaxSettings).port;
            if (mode === "abort") {
                if (pendingRequests[port]) {
                    pendingRequests[port].abort();
                }
                pendingRequests[port] = ajax.apply(this, arguments);
                return pendingRequests[port];
            }
            return ajax.apply(this, arguments);
        };
    }
    return $;
}));
// Unobtrusive validation support library for jQuery and jQuery Validate
// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
// @version <placeholder>

/*jslint white: true, browser: true, onevar: true, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: false */
/*global document: false, jQuery: false */

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('vendor/jquery.validate.unobtrusive',['vendor/jquery.validate'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS-like environments that support module.exports     
        module.exports = factory(require('vendor/jquery.validate'));
    } else {
        // Browser global
        jQuery.validator.unobtrusive = factory(jQuery);
    }
}(function ($) {
    var $jQval = $.validator,
        adapters,
        data_validation = "unobtrusiveValidation";

    function setValidationValues(options, ruleName, value) {
        options.rules[ruleName] = value;
        if (options.message) {
            options.messages[ruleName] = options.message;
        }
    }

    function splitAndTrim(value) {
        return value.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
    }

    function escapeAttributeValue(value) {
        // As mentioned on http://api.jquery.com/category/selectors/
        return value.replace(/([!"#$%&'()*+,./:;<=>?@\[\\\]^`{|}~])/g, "\\$1");
    }

    function getModelPrefix(fieldName) {
        return fieldName.substr(0, fieldName.lastIndexOf(".") + 1);
    }

    function appendModelPrefix(value, prefix) {
        if (value.indexOf("*.") === 0) {
            value = value.replace("*.", prefix);
        }
        return value;
    }

    function onError(error, inputElement) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-for='" + escapeAttributeValue(inputElement[0].name) + "']"),
            replaceAttrValue = container.attr("data-valmsg-replace"),
            replace = replaceAttrValue ? JSON.parse(replaceAttrValue) !== false : null;

        container.removeClass("field-validation-valid").addClass("field-validation-error");
        error.data("unobtrusiveContainer", container);

        if (replace) {
            container.empty();
            error.removeClass("input-validation-error").appendTo(container);
        }
        else {
            error.hide();
        }
    }

    function onErrors(event, validator) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-summary=true]"),
            list = container.find("ul");

        if (list && list.length && validator.errorList.length) {
            list.empty();
            container.addClass("validation-summary-errors").removeClass("validation-summary-valid");

            $.each(validator.errorList, function () {
                $("<li />").html(this.message).appendTo(list);
            });
        }
    }

    function onSuccess(error) {  // 'this' is the form element
        var container = error.data("unobtrusiveContainer");

        if (container) {
            var replaceAttrValue = container.attr("data-valmsg-replace"),
                replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) : null;

            container.addClass("field-validation-valid").removeClass("field-validation-error");
            error.removeData("unobtrusiveContainer");

            if (replace) {
                container.empty();
            }
        }
    }

    function onReset(event) {  // 'this' is the form element
        var $form = $(this),
            key = '__jquery_unobtrusive_validation_form_reset';
        if ($form.data(key)) {
            return;
        }
        // Set a flag that indicates we're currently resetting the form.
        $form.data(key, true);
        try {
            $form.data("validator").resetForm();
        } finally {
            $form.removeData(key);
        }

        $form.find(".validation-summary-errors")
            .addClass("validation-summary-valid")
            .removeClass("validation-summary-errors");
        $form.find(".field-validation-error")
            .addClass("field-validation-valid")
            .removeClass("field-validation-error")
            .removeData("unobtrusiveContainer")
            .find(">*")  // If we were using valmsg-replace, get the underlying error
            .removeData("unobtrusiveContainer");
    }

    function validationInfo(form) {
        var $form = $(form),
            result = $form.data(data_validation),
            onResetProxy = $.proxy(onReset, form),
            defaultOptions = $jQval.unobtrusive.options || {},
            execInContext = function (name, args) {
                var func = defaultOptions[name];
                func && $.isFunction(func) && func.apply(form, args);
            };

        if (!result) {
            result = {
                options: {  // options structure passed to jQuery Validate's validate() method
                    errorClass: defaultOptions.errorClass || "input-validation-error",
                    errorElement: defaultOptions.errorElement || "span",
                    errorPlacement: function () {
                        onError.apply(form, arguments);
                        execInContext("errorPlacement", arguments);
                    },
                    invalidHandler: function () {
                        onErrors.apply(form, arguments);
                        execInContext("invalidHandler", arguments);
                    },
                    messages: {},
                    rules: {},
                    success: function () {
                        onSuccess.apply(form, arguments);
                        execInContext("success", arguments);
                    }
                },
                attachValidation: function () {
                    $form
                        .off("reset." + data_validation, onResetProxy)
                        .on("reset." + data_validation, onResetProxy)
                        .validate(this.options);
                },
                validate: function () {  // a validation function that is called by unobtrusive Ajax
                    $form.validate();
                    return $form.valid();
                }
            };
            $form.data(data_validation, result);
        }

        return result;
    }

    $jQval.unobtrusive = {
        adapters: [],

        parseElement: function (element, skipAttach) {
            /// <summary>
            /// Parses a single HTML element for unobtrusive validation attributes.
            /// </summary>
            /// <param name="element" domElement="true">The HTML element to be parsed.</param>
            /// <param name="skipAttach" type="Boolean">[Optional] true to skip attaching the
            /// validation to the form. If parsing just this single element, you should specify true.
            /// If parsing several elements, you should specify false, and manually attach the validation
            /// to the form when you are finished. The default is false.</param>
            var $element = $(element),
                form = $element.parents("form")[0],
                valInfo, rules, messages;

            if (!form) {  // Cannot do client-side validation without a form
                return;
            }

            valInfo = validationInfo(form);
            valInfo.options.rules[element.name] = rules = {};
            valInfo.options.messages[element.name] = messages = {};

            $.each(this.adapters, function () {
                var prefix = "data-val-" + this.name,
                    message = $element.attr(prefix),
                    paramValues = {};

                if (message !== undefined) {  // Compare against undefined, because an empty message is legal (and falsy)
                    prefix += "-";

                    $.each(this.params, function () {
                        paramValues[this] = $element.attr(prefix + this);
                    });

                    this.adapt({
                        element: element,
                        form: form,
                        message: message,
                        params: paramValues,
                        rules: rules,
                        messages: messages
                    });
                }
            });

            $.extend(rules, { "__dummy__": true });

            if (!skipAttach) {
                valInfo.attachValidation();
            }
        },

        parse: function (selector) {
            /// <summary>
            /// Parses all the HTML elements in the specified selector. It looks for input elements decorated
            /// with the [data-val=true] attribute value and enables validation according to the data-val-*
            /// attribute values.
            /// </summary>
            /// <param name="selector" type="String">Any valid jQuery selector.</param>

            // $forms includes all forms in selector's DOM hierarchy (parent, children and self) that have at least one
            // element with data-val=true
            var $selector = $(selector),
                $forms = $selector.parents()
                    .addBack()
                    .filter("form")
                    .add($selector.find("form"))
                    .has("[data-val=true]");

            $selector.find("[data-val=true]").each(function () {
                $jQval.unobtrusive.parseElement(this, true);
            });

            $forms.each(function () {
                var info = validationInfo(this);
                if (info) {
                    info.attachValidation();
                }
            });
        }
    };

    adapters = $jQval.unobtrusive.adapters;

    adapters.add = function (adapterName, params, fn) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="params" type="Array" optional="true">[Optional] An array of parameter names (strings) that will
        /// be extracted from the data-val-nnnn-mmmm HTML attributes (where nnnn is the adapter name, and
        /// mmmm is the parameter name).</param>
        /// <param name="fn" type="Function">The function to call, which adapts the values from the HTML
        /// attributes into jQuery Validate rules and/or messages.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        if (!fn) {  // Called with no params, just a function
            fn = params;
            params = [];
        }
        this.push({ name: adapterName, params: params, adapt: fn });
        return this;
    };

    adapters.addBool = function (adapterName, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has no parameter values.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, function (options) {
            setValidationValues(options, ruleName || adapterName, true);
        });
    };

    adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation has three potential rules (one for min-only, one for max-only, and
        /// one for min-and-max). The HTML parameters are expected to be named -min and -max.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="minRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a minimum value.</param>
        /// <param name="maxRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a maximum value.</param>
        /// <param name="minMaxRuleName" type="String">The name of the jQuery Validate rule to be used when you
        /// have both a minimum and maximum value.</param>
        /// <param name="minAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the minimum value. The default is "min".</param>
        /// <param name="maxAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the maximum value. The default is "max".</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [minAttribute || "min", maxAttribute || "max"], function (options) {
            var min = options.params.min,
                max = options.params.max;

            if (min && max) {
                setValidationValues(options, minMaxRuleName, [min, max]);
            }
            else if (min) {
                setValidationValues(options, minRuleName, min);
            }
            else if (max) {
                setValidationValues(options, maxRuleName, max);
            }
        });
    };

    adapters.addSingleVal = function (adapterName, attribute, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has a single value.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute(where nnnn is the adapter name).</param>
        /// <param name="attribute" type="String">[Optional] The name of the HTML attribute that contains the value.
        /// The default is "val".</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [attribute || "val"], function (options) {
            setValidationValues(options, ruleName || adapterName, options.params[attribute]);
        });
    };

    $jQval.addMethod("__dummy__", function (value, element, params) {
        return true;
    });

    $jQval.addMethod("regex", function (value, element, params) {
        var match;
        if (this.optional(element)) {
            return true;
        }

        match = new RegExp(params).exec(value);
        return (match && (match.index === 0) && (match[0].length === value.length));
    });

    $jQval.addMethod("nonalphamin", function (value, element, nonalphamin) {
        var match;
        if (nonalphamin) {
            match = value.match(/\W/g);
            match = match && match.length >= nonalphamin;
        }
        return match;
    });

    if ($jQval.methods.extension) {
        adapters.addSingleVal("accept", "mimtype");
        adapters.addSingleVal("extension", "extension");
    } else {
        // for backward compatibility, when the 'extension' validation method does not exist, such as with versions
        // of JQuery Validation plugin prior to 1.10, we should use the 'accept' method for
        // validating the extension, and ignore mime-type validations as they are not supported.
        adapters.addSingleVal("extension", "extension", "accept");
    }

    adapters.addSingleVal("regex", "pattern");
    adapters.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");
    adapters.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range");
    adapters.addMinMax("minlength", "minlength").addMinMax("maxlength", "minlength", "maxlength");
    adapters.add("equalto", ["other"], function (options) {
        var prefix = getModelPrefix(options.element.name),
            other = options.params.other,
            fullOtherName = appendModelPrefix(other, prefix),
            element = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(fullOtherName) + "']")[0];

        setValidationValues(options, "equalTo", element);
    });
    adapters.add("required", function (options) {
        // jQuery Validate equates "required" with "mandatory" for checkbox elements
        if (options.element.tagName.toUpperCase() !== "INPUT" || options.element.type.toUpperCase() !== "CHECKBOX") {
            setValidationValues(options, "required", true);
        }
    });
    adapters.add("remote", ["url", "type", "additionalfields"], function (options) {
        var value = {
            url: options.params.url,
            type: options.params.type || "GET",
            data: {}
        },
            prefix = getModelPrefix(options.element.name);

        $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {
            var paramName = appendModelPrefix(fieldName, prefix);
            value.data[paramName] = function () {
                var field = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(paramName) + "']");
                // For checkboxes and radio buttons, only pick up values from checked fields.
                if (field.is(":checkbox")) {
                    return field.filter(":checked").val() || field.filter(":hidden").val() || '';
                }
                else if (field.is(":radio")) {
                    return field.filter(":checked").val() || '';
                }
                return field.val();
            };
        });

        setValidationValues(options, "remote", value);
    });
    adapters.add("password", ["min", "nonalphamin", "regex"], function (options) {
        if (options.params.min) {
            setValidationValues(options, "minlength", options.params.min);
        }
        if (options.params.nonalphamin) {
            setValidationValues(options, "nonalphamin", options.params.nonalphamin);
        }
        if (options.params.regex) {
            setValidationValues(options, "regex", options.params.regex);
        }
    });
    adapters.add("fileextensions", ["extensions"], function (options) {
        setValidationValues(options, "extension", options.params.extensions);
    });

    $(function () {
        $jQval.unobtrusive.parse(document);
    });

    return $jQval.unobtrusive;
}));
/*
 *
 * Copyright (c) 2006-2011 Sam Collett (http://www.texotela.co.uk)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * 
 * Version 1.3
 * Demo: http://www.texotela.co.uk/code/jquery/numeric/
 *
 */
(function($) {
/*
 * Allows only valid characters to be entered into input boxes.
 * Note: fixes value when pasting via Ctrl+V, but not when using the mouse to paste
  *      side-effect: Ctrl+A does not work, though you can still use the mouse to select (or double-click to select all)
 *
 * @name     numeric
 * @param    config      { decimal : "." , negative : true }
 * @param    callback     A function that runs if the number is not valid (fires onblur)
 * @author   Sam Collett (http://www.texotela.co.uk)
 * @example  $(".numeric").numeric();
 * @example  $(".numeric").numeric(","); // use , as separater
 * @example  $(".numeric").numeric({ decimal : "," }); // use , as separator
 * @example  $(".numeric").numeric({ negative : false }); // do not allow negative values
 * @example  $(".numeric").numeric(null, callback); // use default values, pass on the 'callback' function
 *
 */
$.fn.numeric = function(config, callback)
{
	if(typeof config === 'boolean')
	{
		config = { decimal: config };
	}
	config = config || {};
	// if config.negative undefined, set to true (default is to allow negative numbers)
	if(typeof config.negative == "undefined") config.negative = true;
	// set decimal point
	var decimal = (config.decimal === false) ? "" : config.decimal || ".";
	// allow negatives
	var negative = (config.negative === true) ? true : false;
	// callback function
	var callback = typeof callback == "function" ? callback : function(){};
	// set data and methods
	return this.data("numeric.decimal", decimal).data("numeric.negative", negative).data("numeric.callback", callback).keypress($.fn.numeric.keypress).keyup($.fn.numeric.keyup).blur($.fn.numeric.blur);
}

$.fn.numeric.keypress = function(e)
{
	// get decimal character and determine if negatives are allowed
	var decimal = $.data(this, "numeric.decimal");
	var negative = $.data(this, "numeric.negative");
	// get the key that was pressed
	var key = e.charCode ? e.charCode : e.keyCode ? e.keyCode : 0;
	// allow enter/return key (only when in an input box)
	if(key == 13 && this.nodeName.toLowerCase() == "input")
	{
		return true;
	}
	else if(key == 13)
	{
		return false;
	}
	var allow = false;
	// allow Ctrl+A
	if((e.ctrlKey && key == 97 /* firefox */) || (e.ctrlKey && key == 65) /* opera */) return true;
	// allow Ctrl+X (cut)
	if((e.ctrlKey && key == 120 /* firefox */) || (e.ctrlKey && key == 88) /* opera */) return true;
	// allow Ctrl+C (copy)
	if((e.ctrlKey && key == 99 /* firefox */) || (e.ctrlKey && key == 67) /* opera */) return true;
	// allow Ctrl+Z (undo)
	if((e.ctrlKey && key == 122 /* firefox */) || (e.ctrlKey && key == 90) /* opera */) return true;
	// allow or deny Ctrl+V (paste), Shift+Ins
	if((e.ctrlKey && key == 118 /* firefox */) || (e.ctrlKey && key == 86) /* opera */
	|| (e.shiftKey && key == 45)) return true;
	// if a number was not pressed
	if(key < 48 || key > 57)
	{
		/* '-' only allowed at start and if negative numbers allowed */
		if(this.value.indexOf("-") != 0 && negative && key == 45 && (this.value.length == 0 || ($.fn.getSelectionStart(this)) == 0)) return true;
		/* only one decimal separator allowed */
		if(decimal && key == decimal.charCodeAt(0) && this.value.indexOf(decimal) != -1)
		{
			allow = false;
		}
		// check for other keys that have special purposes
		if(
			key != 8 /* backspace */ &&
			key != 9 /* tab */ &&
			key != 13 /* enter */ &&
			key != 35 /* end */ &&
			key != 36 /* home */ &&
			key != 37 /* left */ &&
			key != 39 /* right */ &&
			key != 46 /* del */
		)
		{
			allow = false;
		}
		else
		{
			// for detecting special keys (listed above)
			// IE does not support 'charCode' and ignores them in keypress anyway
			if(typeof e.charCode != "undefined")
			{
				// special keys have 'keyCode' and 'which' the same (e.g. backspace)
				if(e.keyCode == e.which && e.which != 0)
				{
					allow = true;
					// . and delete share the same code, don't allow . (will be set to true later if it is the decimal point)
					if(e.which == 46) allow = false;
				}
				// or keyCode != 0 and 'charCode'/'which' = 0
				else if(e.keyCode != 0 && e.charCode == 0 && e.which == 0)
				{
					allow = true;
				}
			}
		}
		// if key pressed is the decimal and it is not already in the field
		if(decimal && key == decimal.charCodeAt(0))
		{
			if(this.value.indexOf(decimal) == -1)
			{
				allow = true;
			}
			else
			{
				allow = false;
			}
		}
	}
	else
	{
		allow = true;
	}
	return allow;
}

$.fn.numeric.keyup = function(e)
{
	var val = this.value;
	if(val.length > 0)
	{
		// get carat (cursor) position
		var carat = $.fn.getSelectionStart(this);
		// get decimal character and determine if negatives are allowed
		var decimal = $.data(this, "numeric.decimal");
		var negative = $.data(this, "numeric.negative");
		
		// prepend a 0 if necessary
		if(decimal != "")
		{
			// find decimal point
			var dot = val.indexOf(decimal);
			// if dot at start, add 0 before
			if(dot == 0)
			{
				this.value = "0" + val;
			}
			// if dot at position 1, check if there is a - symbol before it
			if(dot == 1 && val.charAt(0) == "-")
			{
				this.value = "-0" + val.substring(1);
			}
			val = this.value;
		}
		
		// if pasted in, only allow the following characters
		var validChars = [0,1,2,3,4,5,6,7,8,9,'-',decimal];
		// get length of the value (to loop through)
		var length = val.length;
		// loop backwards (to prevent going out of bounds)
		for(var i = length - 1; i >= 0; i--)
		{
			var ch = val.charAt(i);
			// remove '-' if it is in the wrong place
			if(i != 0 && ch == "-")
			{
				val = val.substring(0, i) + val.substring(i + 1);
			}
			// remove character if it is at the start, a '-' and negatives aren't allowed
			else if(i == 0 && !negative && ch == "-")
			{
				val = val.substring(1);
			}
			var validChar = false;
			// loop through validChars
			for(var j = 0; j < validChars.length; j++)
			{
				// if it is valid, break out the loop
				if(ch == validChars[j])
				{
					validChar = true;
					break;
				}
			}
			// if not a valid character, or a space, remove
			if(!validChar || ch == " ")
			{
				val = val.substring(0, i) + val.substring(i + 1);
			}
		}
		// remove extra decimal characters
		var firstDecimal = val.indexOf(decimal);
		if(firstDecimal > 0)
		{
			for(var i = length - 1; i > firstDecimal; i--)
			{
				var ch = val.charAt(i);
				// remove decimal character
				if(ch == decimal)
				{
					val = val.substring(0, i) + val.substring(i + 1);
				}
			}
		}
		// set the value and prevent the cursor moving to the end
		this.value = val;
		$.fn.setSelection(this, carat);
	}
}

$.fn.numeric.blur = function()
{
	var decimal = $.data(this, "numeric.decimal");
	var callback = $.data(this, "numeric.callback");
	var val = this.value;
	if(val != "")
	{
		var re = new RegExp("^\\d+$|\\d*" + decimal + "\\d+");
		if(!re.exec(val))
		{
			callback.apply(this);
		}
	}
}

$.fn.removeNumeric = function()
{
    return this.data("numeric.decimal", null).data("numeric.negative", null).data("numeric.callback", null).unbind("keypress", $.fn.numeric.keypress).unbind("keyup", $.fn.numeric.keyup).unbind("blur", $.fn.numeric.blur);
}

// Based on code from http://javascript.nwbox.com/cursor_position/ (Diego Perini <dperini@nwbox.com>)
$.fn.getSelectionStart = function(o)
{
    if (o.createTextRange && document.selection) {
        var r = document.selection.createRange().duplicate();
        r.moveEnd('character', o.value.length);
        if (r.text == '')
            return o.value.length;
        return o.value.lastIndexOf(r.text);
    } else {
        try { return o.selectionStart; }
        catch (e) { return 0; }
    }
}

// set the selection, o is the object (input), p is the position ([start, end] or just start)
$.fn.setSelection = function(o, p)
{
	// if p is number, start and end are the same
	if(typeof p == "number") p = [p, p];
	// only set if p is an array of length 2
	if(p && p.constructor == Array && p.length == 2)
	{
		if (o.createTextRange)
		{
			var r = o.createTextRange();
			r.collapse(true);
			r.moveStart('character', p[0]);
			r.moveEnd('character', p[1]);
			r.select();
		}
		else {
			o.focus();
			try{
				if(o.setSelectionRange) {
					o.setSelectionRange(p[0], p[1]);
				}
			} catch(e) {
			}
		}
	}
}

})(jQuery);
define("vendor/jquery.numeric", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.jquery;
    };
}(this)));

/*!
 * jQuery Migrate - v3.3.1 - 2020-06-25T01:07Z
 * Copyright OpenJS Foundation and other contributors
 */

(function (factory) {
    "use strict";

    if (typeof (isJsUnitTest) !== "undefined" && isJsUnitTest) {
        return true;
    }

    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/jquery-migrate-3.3.1',["jquery"], function (jQuery) {
            return factory(jQuery, window);
        });
    } else if (typeof module === "object" && module.exports) {

        // Node/CommonJS
        // eslint-disable-next-line no-undef
        module.exports = factory(require("jquery"), window);
    } else {

        // Browser globals
        factory(jQuery, window);
    }
})(function (jQuery, window) {
    "use strict";

    jQuery.migrateVersion = "3.3.1";

    // Returns 0 if v1 == v2, -1 if v1 < v2, 1 if v1 > v2
    function compareVersions(v1, v2) {
        var i,
            rVersionParts = /^(\d+)\.(\d+)\.(\d+)/,
            v1p = rVersionParts.exec(v1) || [],
            v2p = rVersionParts.exec(v2) || [];

        for (i = 1; i <= 3; i++) {
            if (+v1p[i] > +v2p[i]) {
                return 1;
            }
            if (+v1p[i] < +v2p[i]) {
                return -1;
            }
        }
        return 0;
    }

    function jQueryVersionSince(version) {
        return compareVersions(jQuery.fn.jquery, version) >= 0;
    }

    (function () {

        // Support: IE9 only
        // IE9 only creates console object when dev tools are first opened
        // IE9 console is a host object, callable but doesn't have .apply()
        if (!window.console || !window.console.log) {
            return;
        }

        // Need jQuery 3.0.0+ and no older Migrate loaded
        if (!jQuery || !jQueryVersionSince("3.0.0")) {
            window.console.log("JQMIGRATE: jQuery 3.0.0+ REQUIRED");
        }
        if (jQuery.migrateWarnings) {
            window.console.log("JQMIGRATE: Migrate plugin loaded multiple times");
        }

        // Show a message on the console so devs know we're active
        window.console.log("JQMIGRATE: Migrate is installed" +
            (jQuery.migrateMute ? "" : " with logging active") +
            ", version " + jQuery.migrateVersion);

    })();

    var warnedAbout = {};

    // By default each warning is only reported once.
    jQuery.migrateDeduplicateWarnings = true;

    // List of warnings already given; public read only
    jQuery.migrateWarnings = [];

    // Set to false to disable traces that appear with warnings
    if (jQuery.migrateTrace === undefined) {
        jQuery.migrateTrace = true;
    }

    // Forget any warnings we've already given; public
    jQuery.migrateReset = function () {
        warnedAbout = {};
        jQuery.migrateWarnings.length = 0;
    };

    function migrateWarn(msg) {
        var console = window.console,
            warningsToIgnore = ["HTML tags must be properly nested and closed:", "jQuery.isFunction() is deprecated"];

        if (!jQuery.migrateDeduplicateWarnings || !warnedAbout[msg]) {
            if (console && console.warn && !jQuery.migrateMute) {
                if (warningsToIgnore.indexOf(msg) == -1 && msg.indexOf(warningsToIgnore[0]) == -1) {
                    warnedAbout[msg] = true;
                    jQuery.migrateWarnings.push(msg);

                    // console.warn("JQMIGRATE: " + msg);
                    // if (jQuery.migrateTrace && console.trace) {
                    //     console.trace();
                    // }
                }
            }
        }
    }

    function migrateWarnProp(obj, prop, value, msg) {
        Object.defineProperty(obj, prop, {
            configurable: true,
            enumerable: true,
            get: function () {
                migrateWarn(msg);
                return value;
            },
            set: function (newValue) {
                migrateWarn(msg);
                value = newValue;
            }
        });
    }

    function migrateWarnFunc(obj, prop, newFunc, msg) {
        obj[prop] = function () {
            migrateWarn(msg);
            return newFunc.apply(this, arguments);
        };
    }

    if (window.document.compatMode === "BackCompat") {

        // JQuery has never supported or tested Quirks Mode
        migrateWarn("jQuery is not compatible with Quirks Mode");
    }

    var findProp,
        class2type = {},
        oldInit = jQuery.fn.init,
        oldFind = jQuery.find,

        rattrHashTest = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/,
        rattrHashGlob = /\[(\s*[-\w]+\s*)([~|^$*]?=)\s*([-\w#]*?#[-\w#]*)\s*\]/g,

        // Support: Android <=4.0 only
        // Make sure we trim BOM and NBSP
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

    jQuery.fn.init = function (arg1) {
        var args = Array.prototype.slice.call(arguments);

        if (typeof arg1 === "string" && arg1 === "#") {

            // JQuery( "#" ) is a bogus ID selector, but it returned an empty set before jQuery 3.0
            migrateWarn("jQuery( '#' ) is not a valid selector");
            args[0] = [];
        }

        return oldInit.apply(this, args);
    };
    jQuery.fn.init.prototype = jQuery.fn;

    jQuery.find = function (selector) {
        var args = Array.prototype.slice.call(arguments);

        // Support: PhantomJS 1.x
        // String#match fails to match when used with a //g RegExp, only on some strings
        if (typeof selector === "string" && rattrHashTest.test(selector)) {

            // The nonstandard and undocumented unquoted-hash was removed in jQuery 1.12.0
            // First see if qS thinks it's a valid selector, if so avoid a false positive
            try {
                window.document.querySelector(selector);
            } catch (err1) {

                // Didn't *look* valid to qSA, warn and try quoting what we think is the value
                selector = selector.replace(rattrHashGlob, function (_, attr, op, value) {
                    return "[" + attr + op + "\"" + value + "\"]";
                });

                // If the regexp *may* have created an invalid selector, don't update it
                // Note that there may be false alarms if selector uses jQuery extensions
                try {
                    window.document.querySelector(selector);
                    migrateWarn("Attribute selector with '#' must be quoted: " + args[0]);
                    args[0] = selector;
                } catch (err2) {
                    migrateWarn("Attribute selector with '#' was not fixed: " + args[0]);
                }
            }
        }

        return oldFind.apply(this, args);
    };

    // Copy properties attached to original jQuery.find method (e.g. .attr, .isXML)
    for (findProp in oldFind) {
        if (Object.prototype.hasOwnProperty.call(oldFind, findProp)) {
            jQuery.find[findProp] = oldFind[findProp];
        }
    }

    // The number of elements contained in the matched element set
    migrateWarnFunc(jQuery.fn, "size", function () {
        return this.length;
    },
        "jQuery.fn.size() is deprecated and removed; use the .length property");

    migrateWarnFunc(jQuery, "parseJSON", function () {
        return JSON.parse.apply(null, arguments);
    },
        "jQuery.parseJSON is deprecated; use JSON.parse");

    migrateWarnFunc(jQuery, "holdReady", jQuery.holdReady,
        "jQuery.holdReady is deprecated");

    migrateWarnFunc(jQuery, "unique", jQuery.uniqueSort,
        "jQuery.unique is deprecated; use jQuery.uniqueSort");

    // Now jQuery.expr.pseudos is the standard incantation
    migrateWarnProp(jQuery.expr, "filters", jQuery.expr.pseudos,
        "jQuery.expr.filters is deprecated; use jQuery.expr.pseudos");
    migrateWarnProp(jQuery.expr, ":", jQuery.expr.pseudos,
        "jQuery.expr[':'] is deprecated; use jQuery.expr.pseudos");

    // Prior to jQuery 3.1.1 there were internal refs so we don't warn there
    if (jQueryVersionSince("3.1.1")) {
        migrateWarnFunc(jQuery, "trim", function (text) {
            return text == null ?
                "" :
                (text + "").replace(rtrim, "");
        },
            "jQuery.trim is deprecated; use String.prototype.trim");
    }

    // Prior to jQuery 3.2 there were internal refs so we don't warn there
    if (jQueryVersionSince("3.2.0")) {
        migrateWarnFunc(jQuery, "nodeName", function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
            "jQuery.nodeName is deprecated");
    }

    if (jQueryVersionSince("3.3.0")) {

        migrateWarnFunc(jQuery, "isNumeric", function (obj) {

            // As of jQuery 3.0, isNumeric is limited to
            // strings and numbers (primitives or objects)
            // that can be coerced to finite numbers (gh-2662)
            var type = typeof obj;
            return (type === "number" || type === "string") &&

                // parseFloat NaNs numeric-cast false positives ("")
                // ...but misinterprets leading-number strings, e.g. hex literals ("0x...")
                // subtraction forces infinities to NaN
                !isNaN(obj - parseFloat(obj));
        },
            "jQuery.isNumeric() is deprecated"
        );

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".
            split(" "),
            function (_, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
            });

        migrateWarnFunc(jQuery, "type", function (obj) {
            if (obj == null) {
                return obj + "";
            }

            // Support: Android <=2.3 only (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[Object.prototype.toString.call(obj)] || "object" :
                typeof obj;
        },
            "jQuery.type is deprecated");

        migrateWarnFunc(jQuery, "isFunction",
            function (obj) {
                return typeof obj === "function";
            },
            "jQuery.isFunction() is deprecated");

        migrateWarnFunc(jQuery, "isWindow",
            function (obj) {
                return obj != null && obj === obj.window;
            },
            "jQuery.isWindow() is deprecated"
        );

        migrateWarnFunc(jQuery, "isArray", Array.isArray,
            "jQuery.isArray is deprecated; use Array.isArray"
        );
    }

    // Support jQuery slim which excludes the ajax module
    if (jQuery.ajax) {

        var oldAjax = jQuery.ajax;

        jQuery.ajax = function () {
            var jQXHR = oldAjax.apply(this, arguments);

            // Be sure we got a jQXHR (e.g., not sync)
            if (jQXHR.promise) {
                migrateWarnFunc(jQXHR, "success", jQXHR.done,
                    "jQXHR.success is deprecated and removed");
                migrateWarnFunc(jQXHR, "error", jQXHR.fail,
                    "jQXHR.error is deprecated and removed");
                migrateWarnFunc(jQXHR, "complete", jQXHR.always,
                    "jQXHR.complete is deprecated and removed");
            }

            return jQXHR;
        };

    }

    var oldRemoveAttr = jQuery.fn.removeAttr,
        oldToggleClass = jQuery.fn.toggleClass,
        rmatchNonSpace = /\S+/g;

    jQuery.fn.removeAttr = function (name) {
        var self = this;

        jQuery.each(name.match(rmatchNonSpace), function (_i, attr) {
            if (jQuery.expr.match.bool.test(attr)) {
                migrateWarn("jQuery.fn.removeAttr no longer sets boolean properties: " + attr);
                self.prop(attr, false);
            }
        });

        return oldRemoveAttr.apply(this, arguments);
    };

    jQuery.fn.toggleClass = function (state) {

        // Only deprecating no-args or single boolean arg
        if (state !== undefined && typeof state !== "boolean") {
            return oldToggleClass.apply(this, arguments);
        }

        migrateWarn("jQuery.fn.toggleClass( boolean ) is deprecated");

        // Toggle entire class name of each element
        return this.each(function () {
            var className = this.getAttribute && this.getAttribute("class") || "";

            if (className) {
                jQuery.data(this, "__className__", className);
            }

            // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.
            if (this.setAttribute) {
                this.setAttribute("class",
                    className || state === false ?
                        "" :
                        jQuery.data(this, "__className__") || ""
                );
            }
        });
    };

    function camelCase(string) {
        return string.replace(/-([a-z])/g, function (_, letter) {
            return letter.toUpperCase();
        });
    }

    var oldFnCss,
        internalSwapCall = false,
        ralphaStart = /^[a-z]/,

        // The regex visualized:
        //
        //                         /----------\
        //                        |            |    /-------\
        //                        |  / Top  \  |   |         |
        //         /--- Border ---+-| Right  |-+---+- Width -+---\
        //        |                 | Bottom |                    |
        //        |                  \ Left /                     |
        //        |                                               |
        //        |                              /----------\     |
        //        |          /-------------\    |            |    |- END
        //        |         |               |   |  / Top  \  |    |
        //        |         |  / Margin  \  |   | | Right  | |    |
        //        |---------+-|           |-+---+-| Bottom |-+----|
        //        |            \ Padding /         \ Left /       |
        // BEGIN -|                                               |
        //        |                /---------\                    |
        //        |               |           |                   |
        //        |               |  / Min \  |    / Width  \     |
        //         \--------------+-|       |-+---|          |---/
        //                           \ Max /       \ Height /
        rautoPx = /^(?:Border(?:Top|Right|Bottom|Left)?(?:Width|)|(?:Margin|Padding)?(?:Top|Right|Bottom|Left)?|(?:Min|Max)?(?:Width|Height))$/;

    // If this version of jQuery has .swap(), don't false-alarm on internal uses
    if (jQuery.swap) {
        jQuery.each(["height", "width", "reliableMarginRight"], function (_, name) {
            var oldHook = jQuery.cssHooks[name] && jQuery.cssHooks[name].get;

            if (oldHook) {
                jQuery.cssHooks[name].get = function () {
                    var ret;

                    internalSwapCall = true;
                    ret = oldHook.apply(this, arguments);
                    internalSwapCall = false;
                    return ret;
                };
            }
        });
    }

    jQuery.swap = function (elem, options, callback, args) {
        var ret, name,
            old = {};

        if (!internalSwapCall) {
            migrateWarn("jQuery.swap() is undocumented and deprecated");
        }

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };

    if (jQueryVersionSince("3.4.0") && typeof Proxy !== "undefined") {

        jQuery.cssProps = new Proxy(jQuery.cssProps || {}, {
            set: function () {
                migrateWarn("JQMIGRATE: jQuery.cssProps is deprecated");
                return Reflect.set.apply(this, arguments);
            }
        });
    }

    // Create a dummy jQuery.cssNumber if missing. It won't be used by jQuery but
    // it will prevent code adding new keys to it unconditionally from crashing.
    if (!jQuery.cssNumber) {
        jQuery.cssNumber = {};
    }

    function isAutoPx(prop) {

        // The first test is used to ensure that:
        // 1. The prop starts with a lowercase letter (as we uppercase it for the second regex).
        // 2. The prop is not empty.
        return ralphaStart.test(prop) &&
            rautoPx.test(prop[0].toUpperCase() + prop.slice(1));
    }

    oldFnCss = jQuery.fn.css;

    jQuery.fn.css = function (name, value) {
        var camelName,
            origThis = this;
        if (name && typeof name === "object" && !Array.isArray(name)) {
            jQuery.each(name, function (n, v) {
                jQuery.fn.css.call(origThis, n, v);
            });
        }
        if (typeof value === "number") {
            camelName = camelCase(name);
            if (!isAutoPx(camelName) && !jQuery.cssNumber[camelName]) {
                migrateWarn("Number-typed values are deprecated for jQuery.fn.css( \"" +
                    name + "\", value )");
            }
        }

        return oldFnCss.apply(this, arguments);
    };

    var oldData = jQuery.data;

    jQuery.data = function (elem, name, value) {
        var curData, sameKeys, key;

        // Name can be an object, and each entry in the object is meant to be set as data
        if (name && typeof name === "object" && arguments.length === 2) {
            curData = jQuery.hasData(elem) && oldData.call(this, elem);
            sameKeys = {};
            for (key in name) {
                if (key !== camelCase(key)) {
                    migrateWarn("jQuery.data() always sets/gets camelCased names: " + key);
                    curData[key] = name[key];
                } else {
                    sameKeys[key] = name[key];
                }
            }

            oldData.call(this, elem, sameKeys);

            return name;
        }

        // If the name is transformed, look for the un-transformed name in the data object
        if (name && typeof name === "string" && name !== camelCase(name)) {
            curData = jQuery.hasData(elem) && oldData.call(this, elem);
            if (curData && name in curData) {
                migrateWarn("jQuery.data() always sets/gets camelCased names: " + name);
                if (arguments.length > 2) {
                    curData[name] = value;
                }
                return curData[name];
            }
        }

        return oldData.apply(this, arguments);
    };

    // Support jQuery slim which excludes the effects module
    if (jQuery.fx) {

        var intervalValue, intervalMsg,
            oldTweenRun = jQuery.Tween.prototype.run,
            linearEasing = function (pct) {
                return pct;
            };

        jQuery.Tween.prototype.run = function () {
            if (jQuery.easing[this.easing].length > 1) {
                migrateWarn(
                    "'jQuery.easing." + this.easing.toString() + "' should use only one argument"
                );

                jQuery.easing[this.easing] = linearEasing;
            }

            oldTweenRun.apply(this, arguments);
        };

        intervalValue = jQuery.fx.interval || 13;
        intervalMsg = "jQuery.fx.interval is deprecated";

        // Support: IE9, Android <=4.4
        // Avoid false positives on browsers that lack rAF
        // Don't warn if document is hidden, jQuery uses setTimeout (#292)
        if (window.requestAnimationFrame) {
            Object.defineProperty(jQuery.fx, "interval", {
                configurable: true,
                enumerable: true,
                get: function () {
                    if (!window.document.hidden) {
                        migrateWarn(intervalMsg);
                    }
                    return intervalValue;
                },
                set: function (newValue) {
                    migrateWarn(intervalMsg);
                    intervalValue = newValue;
                }
            });
        }

    }

    var oldLoad = jQuery.fn.load,
        oldEventAdd = jQuery.event.add,
        originalFix = jQuery.event.fix;

    jQuery.event.props = [];
    jQuery.event.fixHooks = {};

    migrateWarnProp(jQuery.event.props, "concat", jQuery.event.props.concat,
        "jQuery.event.props.concat() is deprecated and removed");

    jQuery.event.fix = function (originalEvent) {
        var event,
            type = originalEvent.type,
            fixHook = this.fixHooks[type],
            props = jQuery.event.props;

        if (props.length) {
            migrateWarn("jQuery.event.props are deprecated and removed: " + props.join());
            while (props.length) {
                jQuery.event.addProp(props.pop());
            }
        }

        if (fixHook && !fixHook._migrated_) {
            fixHook._migrated_ = true;
            migrateWarn("jQuery.event.fixHooks are deprecated and removed: " + type);
            if ((props = fixHook.props) && props.length) {
                while (props.length) {
                    jQuery.event.addProp(props.pop());
                }
            }
        }

        event = originalFix.call(this, originalEvent);

        return fixHook && fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    };

    jQuery.event.add = function (elem, types) {

        // This misses the multiple-types case but that seems awfully rare
        if (elem === window && types === "load" && window.document.readyState === "complete") {
            migrateWarn("jQuery(window).on('load'...) called after load event occurred");
        }
        return oldEventAdd.apply(this, arguments);
    };

    jQuery.each(["load", "unload", "error"], function (_, name) {

        jQuery.fn[name] = function () {
            var args = Array.prototype.slice.call(arguments, 0);

            // If this is an ajax load() the first arg should be the string URL;
            // technically this could also be the "Anything" arg of the event .load()
            // which just goes to show why this dumb signature has been deprecated!
            // jQuery custom builds that exclude the Ajax module justifiably die here.
            if (name === "load" && typeof args[0] === "string") {
                return oldLoad.apply(this, args);
            }

            migrateWarn("jQuery.fn." + name + "() is deprecated");

            args.splice(0, 0, name);
            if (arguments.length) {
                return this.on.apply(this, args);
            }

            // Use .triggerHandler here because:
            // - load and unload events don't need to bubble, only applied to window or image
            // - error event should not bubble to window, although it does pre-1.7
            // See http://bugs.jquery.com/ticket/11820
            this.triggerHandler.apply(this, args);
            return this;
        };

    });

    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup contextmenu").split(" "),
        function (_i, name) {

            // Handle event binding
            jQuery.fn[name] = function (data, fn) {
                migrateWarn("jQuery.fn." + name + "() event shorthand is deprecated");
                return arguments.length > 0 ?
                    this.on(name, null, data, fn) :
                    this.trigger(name);
            };
        });

    // Trigger "ready" event only once, on document ready
    jQuery(function () {
        jQuery(window.document).triggerHandler("ready");
    });

    jQuery.event.special.ready = {
        setup: function () {
            if (this === window.document) {
                migrateWarn("'ready' event is deprecated");
            }
        }
    };

    jQuery.fn.extend({

        bind: function (types, data, fn) {
            migrateWarn("jQuery.fn.bind() is deprecated");
            return this.on(types, null, data, fn);
        },
        unbind: function (types, fn) {
            migrateWarn("jQuery.fn.unbind() is deprecated");
            return this.off(types, null, fn);
        },
        delegate: function (selector, types, data, fn) {
            migrateWarn("jQuery.fn.delegate() is deprecated");
            return this.on(types, selector, data, fn);
        },
        undelegate: function (selector, types, fn) {
            migrateWarn("jQuery.fn.undelegate() is deprecated");
            return arguments.length === 1 ?
                this.off(selector, "**") :
                this.off(types, selector || "**", fn);
        },
        hover: function (fnOver, fnOut) {
            migrateWarn("jQuery.fn.hover() is deprecated");
            return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
    });

    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        origHtmlPrefilter = jQuery.htmlPrefilter,
        makeMarkup = function (html) {
            var doc = window.document.implementation.createHTMLDocument("");
            doc.body.innerHTML = html;
            return doc.body && doc.body.innerHTML;
        },
        warnIfChanged = function (html) {
            var changed = html.replace(rxhtmlTag, "<$1></$2>");
            if (changed !== html && makeMarkup(html) !== makeMarkup(changed)) {
                migrateWarn("HTML tags must be properly nested and closed: " + html);
            }
        };

    jQuery.UNSAFE_restoreLegacyHtmlPrefilter = function () {
        jQuery.htmlPrefilter = function (html) {
            warnIfChanged(html);
            return html.replace(rxhtmlTag, "<$1></$2>");
        };
    };

    jQuery.htmlPrefilter = function (html) {
        warnIfChanged(html);
        return origHtmlPrefilter(html);
    };

    var oldOffset = jQuery.fn.offset;

    jQuery.fn.offset = function () {
        var elem = this[0];

        if (elem && (!elem.nodeType || !elem.getBoundingClientRect)) {
            migrateWarn("jQuery.fn.offset() requires a valid DOM element");
            return arguments.length ? this : undefined;
        }

        return oldOffset.apply(this, arguments);
    };

    // Support jQuery slim which excludes the ajax module
    // The jQuery.param patch is about respecting `jQuery.ajaxSettings.traditional`
    // so it doesn't make sense for the slim build.
    if (jQuery.ajax) {

        var oldParam = jQuery.param;

        jQuery.param = function (data, traditional) {
            var ajaxTraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;

            if (traditional === undefined && ajaxTraditional) {

                migrateWarn("jQuery.param() no longer uses jQuery.ajaxSettings.traditional");
                traditional = ajaxTraditional;
            }

            return oldParam.call(this, data, traditional);
        };

    }

    var oldSelf = jQuery.fn.andSelf || jQuery.fn.addBack;

    jQuery.fn.andSelf = function () {
        migrateWarn("jQuery.fn.andSelf() is deprecated and removed, use jQuery.fn.addBack()");
        return oldSelf.apply(this, arguments);
    };

    // Support jQuery slim which excludes the deferred module in jQuery 4.0+
    if (jQuery.Deferred) {

        var oldDeferred = jQuery.Deferred,
            tuples = [

                // Action, add listener, callbacks, .then handlers, final state
                ["resolve", "done", jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"), "resolved"],
                ["reject", "fail", jQuery.Callbacks("once memory"),
                    jQuery.Callbacks("once memory"), "rejected"],
                ["notify", "progress", jQuery.Callbacks("memory"),
                    jQuery.Callbacks("memory")]
            ];

        jQuery.Deferred = function (func) {
            var deferred = oldDeferred(),
                promise = deferred.promise();

            deferred.pipe = promise.pipe = function ( /* fnDone, fnFail, fnProgress */) {
                var fns = arguments;

                migrateWarn("deferred.pipe() is deprecated");

                return jQuery.Deferred(function (newDefer) {
                    jQuery.each(tuples, function (i, tuple) {
                        var fn = typeof fns[i] === "function" && fns[i];

                        // Deferred.done(function() { bind to newDefer or newDefer.resolve })
                        // deferred.fail(function() { bind to newDefer or newDefer.reject })
                        // deferred.progress(function() { bind to newDefer or newDefer.notify })
                        deferred[tuple[1]](function () {
                            var returned = fn && fn.apply(this, arguments);
                            if (returned && typeof returned.promise === "function") {
                                returned.promise()
                                    .done(newDefer.resolve)
                                    .fail(newDefer.reject)
                                    .progress(newDefer.notify);
                            } else {
                                newDefer[tuple[0] + "With"](
                                    this === promise ? newDefer.promise() : this,
                                    fn ? [returned] : arguments
                                );
                            }
                        });
                    });
                    fns = null;
                }).promise();

            };

            if (func) {
                func.call(deferred, deferred);
            }

            return deferred;
        };

        // Preserve handler of uncaught exceptions in promise chains
        jQuery.Deferred.exceptionHook = oldDeferred.exceptionHook;

    }

    return jQuery;
});
var General = (function General() {
    var self = {};

    //-------------------------------------------------------------
    // functionName
    //-------------------------------------------------------------
    self.functionName = function (CallerObject) {
        var fn = CallerObject.toString();
        var fname = fn.substring(fn.indexOf("function") + 9, fn.indexOf("(")) || "anonymous";

        return fname;
    };

    //-------------------------------------------------------------
    // ref
    //-------------------------------------------------------------
    self.ref = function (id) {
        return document.getElementById(id);
    };

    //-------------------------------------------------------------
    // refByName
    //-------------------------------------------------------------
    self.refByName = function (name) {
        return document.getElementsByName(name);
    };

    //-------------------------------------------------------------
    // ArithmeticRound
    //-------------------------------------------------------------
    self.pow10cache = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];

    self.RateRound = function (_rate, _precision) {
        if (!self.isNumber(_rate))
            return "NA";

        var rateStr = _rate.toString();
        var isNegative = rateStr[0] === '-';
        var ratePos = isNegative ? rateStr.substring(1, rateStr.length) : rateStr;
        var precision = _precision || 7;

        if (self.lenAfterDelimeter(ratePos) == 0)
            return isNegative ? 0 - parseInt(ratePos, 10) : parseInt(ratePos, 10);

        var fractionLength = precision - self.lenBeforeDelimiter(ratePos) - 1;
        var base = Math.pow(10, fractionLength);
        var rounded = Math.round(self.toNumeric(ratePos) * base) / base;

        return isNegative ? 0 - rounded : rounded;
    };

    //-------------------------------------------------------------
    // Trailing zeros
    //-------------------------------------------------------------
    self.trailingZeros = function (number, precision) {
        if (!self.isNumber(number)) {
            return "NA";
        }

        if (number.toString().length < precision) {
            var numFormated = number.toString().split('');

            // add point/trailing zeroes
            for (var i = numFormated.length; i < precision; i++) {
                numFormated[i] = numFormated.join('').indexOf('.') < 0 ? '.' : '0';
            }

            // trim right point (.)
            var numFrmStr = numFormated.join('');
            number = numFrmStr.split('.')[1].length == 0 ? numFrmStr.replace('.', '') : numFrmStr;
        }

        return number.toString();
    };

    //-------------------------------------------------------------
    // InRange
    //-------------------------------------------------------------
    self.InRange = function (rate, range) {
        return (rate > range.far() && rate < range.near()) || (rate > range.near() && rate < range.far());
    };

    //-------------------------------------------------------------
    // RateAndPipsAndLastClosePip
    //-------------------------------------------------------------
    self.RateAndPipsAndLastClosePip = function (rate, pips, lastPip) {
        return { rate: rate, pips: pips, lastPip: lastPip };
    };

    //-------------------------------------------------------------
    // Get length of the integer part number. Support negotive numbers.
    //-------------------------------------------------------------
    self.lenBeforeDelimiter = function (number) {
        if (!self.isNumber(number)) {
            return "NA";
        }

        return Math.floor(Math.abs(number)).toString().length;
    };

    //-------------------------------------------------------------
    // Get length of the fractional part number
    //-------------------------------------------------------------
    self.lenAfterDelimeter = function (number) {

        if (!self.isNumber(number)) {
            return "NA";
        }
        var sNum = number.toString(),
            x = sNum.split('.');

        if (x.length == 1) // whole number
            return 0;

        return x[1].length;
    };

    //-------------------------------------------------------------
    // isInt
    //-------------------------------------------------------------
    self.isInt = function (x) {
        var y = parseInt(x, 10);

        if (isNaN(y))
            return false;

        return x == y;
    };

    //-------------------------------------------------------------
    // isEmpty
    //-------------------------------------------------------------
    self.isEmpty = function (x) {

        if (x.length == 0 || x == '')
            return true;

        return false;
    };

    //-------------------------------------------------------------
    // isNumber
    //-------------------------------------------------------------
    self.isNumber = function (x) {
        var y = parseFloat(x);

        if (isNaN(y))
            return false;

        return x == y;
    };

    //-------------------------------------------------------------
    // isPos
    //-------------------------------------------------------------
    self.isPos = function (x) {
        var y = 0;

        if (self.isNumber(x))
            y = parseFloat(x);

        return y > 0;
    };

    //-------------------------------------------------------------
    // toInt
    //-------------------------------------------------------------
    self.toInt = function (str) {
        var y = parseInt(str.replace(/,/g, ""), 10);

        if (isNaN(y))
            return "NA";

        return y;
    };

    //-------------------------------------------------------------
    //toNumeric
    //-------------------------------------------------------------
    self.toNumeric = function (str) {
        if (!self.isDefinedType(str)) {
            return;
        }

        if (self.isNullType(str)) {
            return;
        }

        if (self.isNumberType(str)) {
            return str;
        }

        var newstr = [];
        for (var i = 0; i < str.length; i++) {
            var s = str.substr(i, 1);

            if (s !== ",") {
                newstr.push(s);
            }
        }

        var strParse = parseFloat(newstr.join(""));

        if (isNaN(strParse)) {
            return "NA";
        }

        return strParse;
    };

    //-------------------------------------------------------------
    // toBoolean
    //-------------------------------------------------------------
    self.toBoolean = function (value) {
        if (self.isStringType(value)) {
            if (value.toLowerCase() == "false") {
                return false;
            }
        }

        return Boolean(value);
    };

    //-------------------------------------------------------------
    // getPageScroll ***********************
    //-------------------------------------------------------------
    self.PageYScroll = function () {
        if (self.pageYOffset) {
            return self.pageYOffset;
        }

        if (document.documentElement && document.documentElement.scrollTop) {
            return document.documentElement.scrollTop;
        }

        return document.body.scrollTop;
    };

    //-------------------------------------------------------------
    // WinInfo
    //-------------------------------------------------------------
    self.WindowInfo = function () {
        var win = { height: 0, width: 0, innerHeight: 0, yScroll: 0 };

        win.height = Math.max($(document).height(),
            $(window).height(), /* For opera: */
            document.documentElement.clientHeight);

        win.width = Math.max($(document).width(),
            $(window).width(),  /* For opera: */
            document.documentElement.clientWidth);

        win.innerHeight = window.innerHeight || document.documentElement.offsetHeight;

        win.yScroll = self.PageYScroll();

        return win;
    };

    //-------------------------------------------------------------
    // BlockNonInteger
    //-------------------------------------------------------------
    self.BlockNonInteger = function (e) {
        var key = "", reg = /\d/;

        e = e || window.event;

        if (e.keyCode) {
            key = e.keyCode;
        }
        else if (e.which) {
            key = e.which;
        }

        //--------------------------------------

        if (isNaN(key))
            return true;

        if (key == 8) // check for backspace
            return true;

        //--------------------------------------

        var keychar = String.fromCharCode(key);
        return reg.test(keychar);
    };

    //-------------------------------------------------------------
    // pad
    //-------------------------------------------------------------
    self.pad = function (number, length) {
        var str = String(number);

        while (str.length < length) {
            str = '0' + str;
        }

        return str;
    };

    //-------------------------------------------------------------
    // SplitDateTime  dd/mm/yy hh:mm:ss
    //-------------------------------------------------------------
    self.SplitDateTime = function (sDate) {
        var fullDateStr,
            fullTimeStr,
            ddStr = "01",
            mmStr = "01",
            yyStr = "1900",
            hhStr = "00",
            minStr = "00",
            ssStr = "00",
            msStr = "000",
            dateTimeParts = sDate.split(" "),
            chunk = dateTimeParts.shift();

        if (chunk) {
            if (chunk.indexOf("/") != -1) {
                var dateParts = chunk.split("/");

                ddStr = dateParts[0] ? (dateParts[0].length == 2 ? dateParts[0] : "0" + dateParts[0]) : "01";
                mmStr = dateParts[1] ? (dateParts[1].length == 2 ? dateParts[1] : "0" + dateParts[1]) : "01";
                yyStr = dateParts[2] ? (dateParts[2].length == 4 ? dateParts[2] : "20" + dateParts[2]) : "1900";

                // get next chunk
                dateTimeParts.push(chunk);
                chunk = dateTimeParts.shift();
            }
        }

        //fullDateStr = ddStr + "/" + mmStr + "/" + ((yyStr.length > 2) ? yyStr : "20" + yyStr);
        fullDateStr = ddStr + "/" + mmStr + "/" + yyStr;

        if (chunk) {
            if (chunk.indexOf(":") != -1) {
                var timeParts = chunk.split(":");

                hhStr = timeParts[0] ? (timeParts[0].length == 2 ? timeParts[0] : "0" + timeParts[0]) : "00";
                minStr = timeParts[1] ? (timeParts[1].length == 2 ? timeParts[1] : "0" + timeParts[1]) : "00";
                ssStr = timeParts[2] ? (timeParts[2].length == 2 ? timeParts[2] : "0" + timeParts[2]) : "00";
                msStr = timeParts[3] ? timeParts[3] : "000";

                dateTimeParts.push(chunk);
            }
        }

        fullTimeStr = hhStr + ":" + minStr + ":" + ssStr;

        return {
            day: ddStr,
            month: mmStr,
            year: yyStr,
            date: fullDateStr,
            time: fullTimeStr,
            hour: hhStr,
            min: minStr,
            sec: ssStr,
            ms: msStr
        };
    };

    //-------------------------------------------------------------
    //  fillHoursList - create an array of hours, from minimum to maximum
    //-------------------------------------------------------------
    self.fillHoursList = function (ddlHours, maxHour, maxMin, minHour) {
        if (ddlHours) {
            ddlHours.length = 0;

            minHour = minHour || 0;

            for (var i = minHour; i <= maxHour; i++) {
                var item = ((i < 10) ? "0" + i : i) + ":00";
                ddlHours.push({ "value": item, "text": item });
            }
        }

        if (maxMin != 0) {
            var lastItem = ((maxHour < 10) ? "0" + maxHour : maxHour) + ":" + ((maxMin < 10) ? "0" + maxMin : maxMin);
            ddlHours.push({ "value": lastItem, "text": lastItem });
        }
    };

    //-------------------------------------------------------------
    //  str2Date
    //-------------------------------------------------------------
    self.str2Date = function (date, format) {
        if (!date) {
            return null;
        }

        format = format || 'd/m/Y';

        var parts = date.split(/\W+/);

        var against = format.split(/\W+/), d, m, y, h, min, now = new Date();

        for (var i = 0; i < parts.length; i++) {
            switch (against[i]) {
                case 'd': case 'e':
                    d = parseInt(parts[i], 10);
                    break;

                case 'm':
                    m = parseInt(parts[i], 10) - 1;
                    break;

                case 'Y': case 'y':
                    y = parseInt(parts[i], 10);
                    y += y > 100 ? 0 : (y < 29 ? 2000 : 1900);
                    break;

                case 'H': case 'I': case 'k': case 'l':
                    h = parseInt(parts[i], 10);
                    break;

                case 'P': case 'p':
                    if (/pm/i.test(parts[i]) && h < 12) {
                        h += 12;
                    } else if (/am/i.test(parts[i]) && h >= 12) {
                        h -= 12;
                    }
                    break;

                case 'M':
                    min = parseInt(parts[i], 10);
                    break;
            }
        }

        return new Date(
            typeof y === "undefined" ? now.getFullYear() : y,
            typeof m === "undefined" ? now.getMonth() : m,
            typeof d === "undefined" ? now.getDate() : d,
            typeof h === "undefined" ? now.getHours() : h,
            typeof min === "undefined" ? now.getMinutes() : min,
            0
        );
    };

    //-------------------------------------------------------------
    //  addSign < or > according to limit type and deal direction
    //-------------------------------------------------------------
    self.addSign = function (orderDir, limitType) {
        if (orderDir !== eOrderDir.Sell && orderDir !== eOrderDir.Buy && orderDir !== eOrderDir.None) {
            return "NA";
        }

        if (limitType === eLimitType.StopLoss)
            return (orderDir == eOrderDir.Sell) ? ">" : "<";

        return (orderDir === eOrderDir.Sell) ? "<" : ">";
    };

    //-------------------------------------------------------------
    //Compare two values with numeric or alphabetic order
    //-------------------------------------------------------------
    self.CompareValues = function (left, right, asc) {
        if (self.isNumber(left) && self.isNumber(right))
            return left == right ? 0 : (Number(left) < Number(right) ? -1 : 1) * (asc ? 1 : -1);
        else
            return left.toString().localeCompare(right);
    };

    //-------------------------------------------------------------
    //  return string according to limit type SL: or TP:
    //-------------------------------------------------------------
    self.setrDirectionMessageText = function (limitType) {

        if (limitType == eLimitType.StopLoss)
            return Dictionary.GetItem("limtype1_short") + ": ";
        else if (limitType == eLimitType.TakeProfit)
            return Dictionary.GetItem("limtype2_short") + ": ";

        return "";

    };

    //---------------------------------------------------------------
    // divide the number given according to its size, return it with 2 decimal digits
    // (in K case 1 decimal digit) and add B\M\K 
    //---------------------------------------------------------------
    self.formatNumber = function (str, format) {
        var noComma = str.replace(/,/g, '');

        var r = Math.round(noComma * 10) / 10;
        var abs = Math.abs(r);

        if (abs > 999999999)
            r = (r / 1000000000).toFixed(2) + Dictionary.GetItem("roundB");
        else if (abs > 999999)
            r = (r / 1000000).toFixed(2) + Dictionary.GetItem("roundM");
        else if (format == "K" && abs > 9999) {
            if (r % 1000 == 0)
                r = (r / 1000);
            else
                r = (r / 1000).toFixed(1);
            r += Dictionary.GetItem("roundK");
        }

        return self.formatNumberWithThousandsSeparator(r);
    };

    //---------------------------------------------------------------
    // return the number given according to its size, return it with 2 decimal digits and add B\M\K 
    //---------------------------------------------------------------
    self.formatRoundM = function (str) {
        return self.formatNumber(str, "M");
    };

    //---------------------------------------------------------------
    // return the number given according to its size, return it with 2 decimal digits and add B\M\K 
    //---------------------------------------------------------------
    self.formatWithThresholdAndDecimals = function (str, format) {
        var noComma = str.replace(/,/g, '');
        var r = Number(noComma).toFixed(2);
        var abs = Math.abs(r);

        if (abs > 999999999)
            r = (r / 1000000000).toFixed(2) + Dictionary.GetItem("roundB");
        else if (abs > 999999)
            r = (r / 1000000).toFixed(2) + Dictionary.GetItem("roundM");
        else if (format == "K" && abs > 9999) {
            if (r % 1000 == 0)
                r = (r / 1000);
            else
                r = (r / 1000).toFixed(1);
            r += Dictionary.GetItem("roundK");
        }

        return self.formatNumberWithThousandsSeparator(r);
    };

    //---------------------------------------------------------------
    // if the passed number is above the threshold, the old rounding self.
    // is applied. If not, we round to the second digit.
    //---------------------------------------------------------------
    self.formatRoundBasedOnThreshold = function (str, format) {
        if (Math.abs(Number(str)) > cConfig.AmountRoundingThreshold) {
            return self.formatWithThresholdAndDecimals(str, format);
        }

        var noComma = str.replace(/,/g, '');
        var r = Number(noComma).toFixed(2);
        return self.formatNumberWithThousandsSeparator(r);
    };

    //---------------------------------------------------------------
    // if the passed number is above the threshold, the old rounding self.
    // is applied. If not, we round to the second digit.
    //---------------------------------------------------------------
    self.formatRoundMBasedOnThreshold = function (str) {
        return self.formatRoundBasedOnThreshold(str, "M");
    };

    //---------------------------------------------------------------
    // add Thousands Separator 
    //---------------------------------------------------------------
    self.formatNumberWithThousandsSeparator = function (value) {
        return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };

    //---------------------------------------------------------------
    // 
    //---------------------------------------------------------------
    self.roundedNumberFromAmount = function (number) {
        var noComma = number.toString().replace(/,/g, '');
        var noDecimals = Math.round(noComma);
        return noDecimals;
    };

    /////////////////////////////////////////////////////
    // for old browsers

    self.isNullType = function (value) {
        return value === null;
    };

    self.isDefinedType = function (value) {
        return typeof value !== 'undefined';
    };

    // TO DO: refactor the name, the method returns object not a true or false value
    self.isDefinedNotNullTypeReturnType = function (value) {
        if (value !== null && typeof value !== 'undefined')
            return value;
        else
            return {};
    };

    self.isArrayType = function (value) {
        // return typeof (value) == 'object' && (value instanceof Array);
        return Object.prototype.toString.apply(value) == '[object Array]';
    };

    self.isStringType = function (value) {
        return typeof (value) === 'string';
    };

    self.isBooleanType = function (value) {
        return typeof (value) === 'boolean';
    };

    self.isNumberType = function (value) {
        return typeof (value) === 'number' && isFinite(value);
    };

    self.isIntType = function (value) {
        return self.isNumberType(value) && parseInt(value, 10) == value;
    };

    self.isNullOrUndefined = function (value) {
        if (!self.isDefinedType(value)) {
            return true;
        }

        if (self.isNullType(value)) {
            return true;
        }

        return false;
    };

    self.isEmptyType = function (value) {
        return self.isEmptyValue(value);
    };

    self.isEmptyValue = function (value) {
        if (!self.isDefinedType(value)) {
            return true;
        }

        if (self.isNullType(value)) {
            return true;
        }

        if (self.isArrayType(value) && value.length < 1) {
            return true;
        }

        if (self.isStringType(value) && value.length < 1) {
            return true;
        }

        return false;
    };

    self.isPrimitiveType = function (value) {
        return self.isStringType(value) || self.isNumberType(value) || self.isBooleanType(value);
    };

    self.isObjectType = function (value) {
        return !!value && Object.prototype.toString.apply(value) === '[object Object]';
    };

    self.isDateType = function (value) {
        return Object.prototype.toString.apply(value) === '[object Date]';
    };

    self.isRegExpType = function (value) {
        return Object.prototype.toString.apply(value) == '[object RegExp]';
    };

    self.isFunctionType = function (value) {
        // return Object.prototype.toString.apply(value) === '[object Function]';
        return typeof value === "function"; // faster (http://jsperf.com/comparing-underscore-js-isfunction-with-typeof-function/2)
    };

    self.isIterableType = function (value) {
        if (self.isArrayType(value) || value.callee) {
            return true;
        }

        if (/NodeList|HTMLCollection/.test(Object.prototype.toString.call(value))) {
            return true;
        }

        return ((typeof value.nextNode != 'undefined' || value.item) && self.isNumberType(value.length)) || false;
    };

    self.eachType = function (array, fn, scope) {
        if (self.isEmptyValue(array)) {
            return;
        }

        if (!self.isIterableType(array) || self.isPrimitiveType(array)) {
            array = [array];
        }

        for (var i = 0, len = array.length; i < len; i++) {
            if (fn.apply(scope || array[i], [array[i], i, array]) === false) {
                return;
            }
        }
    };

    self.iterateType = function (obj, fn, scope) {
        if (self.isEmptyValue(obj)) {
            return;
        }

        if (self.isIterableType(obj)) {
            self.eachType(obj, fn, scope);
            return;
        }
        else if (self.isObjectType(obj)) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (fn.apply(scope || obj, [prop, obj[prop], obj]) === false) {
                        return;
                    }
                }
            }
        }
    };

    ///////////////////////////////////////////////
    // Extend an object
    /**
     * Copies all the properties of config to obj.
     * @param {Object} target The receiver of the properties
     * @param {Object} source The source of the properties
     * @param {Object} defaults A different object that will also be applied for default values
     * @return {Object} returns obj
     */
    self.extendType = function (target, source, defaults) {
        if (defaults) {
            self.extendType(target, defaults);
        }

        if (target && source && typeof source == 'object') {
            for (var propName in source) {
                if (source.hasOwnProperty(propName)) {
                    target[propName] = source[propName];
                }
            }
        }

        return target;
    };

    /**
     * Copies all the properties of config to obj if they don't already exist.
     * @param {Object} target The receiver of the properties
     * @param {Object} source The source of the properties
     * @return {Object} returns obj
     */
    self.extendIfType = function (target, source) {
        if (target) {
            for (var propName in source) {
                if (source.hasOwnProperty(propName)) {
                    if (!self.isDefinedType(target[propName])) {
                        target[propName] = source[propName];
                    }
                }
            }
        }

        return target;
    };

    /**
     * from JQGeneral.js
     */
    self.cloneHardCopy = function (object) {
        return $.extend(true, {}, object);
    };

    ///////////////////////////////////////////////
    //
    // URL functions
    //
    /**
     * Takes an object and converts it to an encoded URL. e.g. Ext.urlEncode({foo: 1, bar: 2}); would return "foo=1&bar=2".  Optionally, property values can be arrays, instead of keys and the resulting string that's returned will contain a name/value pair for each array value.
     * @param {Object} obj
     * @param {String} prefix (optional) A prefix to add to the url encoded string
     * @return {String}
     */
    self.urlEncode = function (obj, prefix) {
        var empty,
            buffer = [],
            encode = encodeURIComponent;

        self.iterateType(obj, function (key, item) {
            empty = self.isEmptyValue(item);
            self.eachType(empty ? key : item, function (value) {
                buffer.push('&', encode(key), '=', (!self.isEmptyValue(value) && (value != key || !empty)) ? (self.isDateType(value) ? encode(value).replace(/"/g, '') : encode(value)) : '');
            });
        });

        if (!prefix) {
            buffer.shift();
            prefix = '';
        }
        else if (prefix.lastIndexOf('?') == -1) {
            buffer.shift();
            prefix += '?';
        }

        return prefix + buffer.join('');
    };

    /**
     * Takes an encoded URL and and converts it to an object. 
     * @param {String} urlString
     * @param {Boolean} overwrite (optional) Items of the same name will overwrite previous values instead of creating an an array (Defaults to false).
     * @return {Object} A literal with members
     */
    self.urlDecode = function (urlString, overwrite) {
        if (urlString.length < 1) {
            return {};
        }

        urlString = urlString.split("#")[0];

        var obj = {},
            pairs = urlString.slice(urlString.indexOf('?') + 1).split('&'),
            decode = decodeURIComponent,
            name,
            value;

        for (var i = 0, len = pairs.length; i < len; i++) {
            var pair = pairs[i].split('=');
            name = pair[0];
            value = decode(pair[1]);
            obj[name] = overwrite || !obj[name] ? value : [].concat(obj[name]).concat(value);
        }

        return obj;
    };

    ///////////////////////////////////////////////
    /**
     * @param {String} str The string to escape
     * @return (String) The escaped string
     */
    self.escapeRe = function (str) {
        return str.replace(/([-.*+?^${}()|[\]\/\\])/g, "\\$1");
    };

    self.emptyFn = function () { };

    /* eslint no-extend-native: 0 */
    Function.prototype.override = function (func) {
        if (!self.isFunctionType(func)) {
            throw new SyntaxError("self.is required");
        }

        var superFunction = self;

        return function () {
            self.superFunction = superFunction;

            return func.apply(self, arguments);
        };
    };

    Boolean.parse = function (str) {
        if (self.isStringType(str)) {
            str = String(str).toLowerCase();

            var boolmap = {
                "no": false,
                "false": false,
                "yes": true,
                "true": true
            };

            if (str in boolmap) {
                return boolmap[str];
            }
        }

        return !!str;
    };

    self.simulatedContentStringLegth = function (text, font) {
        var f = font || '23px arial',
            o = $('<div>' + text + '</div>')
                .css({ 'position': 'absolute', 'float': 'left', 'white-space': 'nowrap', 'visibility': 'hidden', 'font': f })
                .appendTo($('body')),
            w = o.width();

        o.remove();

        return w;
    };

    /**
     * Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and
     * objects.
     *
     * Two objects or values are considered equivalent if at least one of the following is true:
     *
     * * Both objects or values pass `===` comparison.
     * * Both objects or values are of the same type and all of their properties pass `===` comparison.
     * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)
     * * Both values represent the same regular expression (In JavasScript,
     *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
     *   representation matches).
     *
     * During a property comparison, properties of `function` type are ignored.
     *
     * @param {*} o1 Object or value to compare.
     * @param {*} o2 Object or value to compare.
     * @returns {boolean} True if arguments are equal.
     */
    self.equals = function (o1, o2) {
        if (o1 === o2) {
            return true;
        }

        if (o1 === null || o2 === null) {
            return false;
        }

        /* eslint no-self-compare: 0 */
        if (o1 !== o1 && o2 !== o2) {
            return true; // NaN === NaN
        }

        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;

        if (t1 == t2) {
            if (t1 == 'object') {
                if (self.isArrayType(o1)) {
                    if (!self.isArrayType(o2)) {
                        return false;
                    }

                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!self.equals(o1[key], o2[key])) {
                                return false;
                            }
                        }

                        return true;
                    }
                } else if (self.isDateType(o1)) {
                    return self.isDateType(o2) && o1.getTime() == o2.getTime();
                } else if (self.isRegExpType(o1) && self.isRegExpType(o2)) {
                    return o1.toString() == o2.toString();
                } else if (self.isArrayType(o2)) {
                    return false;
                } else {
                    keySet = {};

                    for (key in o1) {
                        if (self.isFunctionType(o1[key])) {
                            continue;
                        }

                        if (!self.equals(o1[key], o2[key])) {
                            return false;
                        }

                        keySet[key] = true;
                    }

                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && typeof o2[key] !== "undefined" && !self.isFunctionType(o2[key])) {
                            return false;
                        }
                    }

                    return true;
                }
            }
        }

        return false;
    };

    self.argsToArray = function (input) {
        var args = [];

        for (var i = 0, length = input.length; i < length; i++) {
            args[i] = input[i];
        }

        return args;
    };

    self.getKeyByValue = function (object, value) {
        for (var key in object) {
            if (object.hasOwnProperty(key) && object[key] === value) {
                return key;
            }
        }

        return null;
    };

    self.padNumber = function (number) {
        return ('0' + number).slice(-2);
    };

    self.extractNumberFromString = function (str) {
        if (self.isEmptyValue(str)) {
            return "NA";
        }

        var arrayOfStrings = str.match(/[+-]?\d+(\.\d+)?/g);

        if (typeof arrayOfStrings === "undefined" || arrayOfStrings === null) {
            return "NA";
        }

        return parseFloat(arrayOfStrings.join(''));
    };

    self.createGuid = function () {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }

        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    };

    self.extractGuid = function (url) {
        var hashPos = url.indexOf('#');
        var guid = "";

        if (hashPos !== -1) {
            var hashStrArray = url.substring(hashPos, url.length).split('&');

            for (var i = 0; i < hashStrArray.length; i++) {
                if (hashStrArray[i].indexOf('guid') !== -1) {
                    guid = hashStrArray[i].split('=')[1];
                    break;
                }
            }
        }

        return guid;
    };

    self.objectFirst = function (container, filterCallback) {
        if (!container || !filterCallback || !self.isFunctionType(filterCallback)) {
            return null;
        }

        if (self.isArrayType(container)) {
            for (var i = 0, j = container.length; i < j; i++)
                if (filterCallback(container[i], i)) {
                    return container[i];
                }

            return null;
        }

        for (var item in container) {
            if (!container.hasOwnProperty(item)) {
                continue;
            }

            if (filterCallback(container[item])) {
                return container[item];
            }
        }

        return null;
    };

    self.objectFilter = function (container, filterCallback) {
        if (!container || !filterCallback || !self.isFunctionType(filterCallback)) {
            return null;
        }

        if (self.isArrayType(container)) {
            return container.filter(filterCallback);
        }

        var result = [];

        for (var item in container) {
            if (!container.hasOwnProperty(item)) {
                continue;
            }

            if (filterCallback(container[item])) {
                result.push(container[item]);
            }
        }

        return result;
    };

    self.objectContainsKey = function (container, key) {
        if (!container) {
            return null;
        }

        for (var item in container) {
            if (!container.hasOwnProperty(item)) {
                continue;
            }

            if (item == key) {
                return true;
            }
        }

        return false;
    };

    self.objectContainsValue = function (container, value) {
        if (!container) {
            return null;
        }

        for (var item in container) {
            if (!container.hasOwnProperty(item)) {
                continue;
            }

            if (container[item] == value) {
                return true;
            }
        }

        return false;
    };

    self.objectMap = function (container, mapCallback) {
        if (!container || !mapCallback || !self.isFunctionType(mapCallback)) {
            return null;
        }

        if (self.isArrayType(container)) {
            return container.map(mapCallback);
        }

        var result = [];

        for (var item in container) {
            if (!container.hasOwnProperty(item)) {
                continue;
            }

            result.push(mapCallback(container[item]));
        }

        return result;
    };

    self.objectToArray = function (container) {
        if (!container) {
            return null;
        }

        if (self.isArrayType(container)) {
            return container;
        }

        var result = [];

        for (var item in container) {
            if (!container.hasOwnProperty(item)) {
                continue;
            }

            result.push(container[item]);
        }

        return result;
    };

    self.disposeArray = function (disposablesArray) {
        if (!self.isArrayType(disposablesArray)) {
            throw new Error('Input parameter is not an array');
        }

        var disposableObject;

        for (var i = 0, j = disposablesArray.length; i < j; i++) {
            disposableObject = disposablesArray[i];

            if (disposableObject && self.isFunctionType(disposableObject.dispose)) {
                disposableObject.dispose();
            }
        }

        disposablesArray.length = 0;
    };

    self.containsHtmlTags = function (inputString) {
        return /<[a-z][\s\S]*>/i.test(inputString);
    };

    self.isPromiseFulfilled = function (promise) {
        return promise.inspect().state === "fulfilled";
    };

    self.addGMTSuffix = function (inputString) {
        return inputString + ' GMT';
    };

    self.clone = function (object) {
        function F() { }
        F.prototype = object;
        return new F();
    };

    self.extendClass = function (parentClass, inheritedClass) {
        /* eslint no-proto: 0 */
        if (typeof parentClass !== "function") {
            throw new Error("Argument exception: parentClass is not a function.");
        }

        if (typeof inheritedClass !== "function") {
            throw new Error("Argument exception: inheritedClass is not a function.");
        }

        var Class = function () {
            var args = self.argsToArray(arguments);
            var obj = {};
            var parent = new (Function.prototype.bind.apply(parentClass, [null].concat(args)))();

            obj.parent = parent;
            obj.__proto__ = parent;

            var child = inheritedClass.apply(obj, args);

            Object.assign(obj, child);

            return obj;
        };

        return Class;
    };

    return self;
}());

define("handlers/general", (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
				return this.General;
			};
        ret = fn.apply(global, arguments);
        return ret || global.General;
    };
}(this)));

var UrlResolver = (function () {
	var brokerID = null;

	var module = {
		memoizedValues: {},
		getVersion: function () {
			if (this.memoizedValues["version"]) {
				return this.memoizedValues["version"];
			} else {
				return (this.memoizedValues["version"] =
					(document.cookie.match(/(^|; )Version=([^;]+)/i) || "")[2] || "");
			}
		},
		getLanguage: function () {
			if (this.memoizedValues["language"]) {
				return this.memoizedValues["language"];
			} else {
				return (this.memoizedValues["language"] =
					(document.cookie.match(/(^|; )Language=([^;]+)/i) || "")[2] || "");
			}
		},
		getLanguageId: function () {
			if (this.memoizedValues["languageId"]) {
				return this.memoizedValues["languageId"];
			} else {
				return (this.memoizedValues["languageId"] =
					(document.cookie.match(/(^|; )LID=([^;]*)/i) || "")[2] || "");
			}
		},
		getCdnPath: function () {
			if (this.memoizedValues["cdnPath"]) {
				return this.memoizedValues["cdnPath"];
			} else {
				return (this.memoizedValues["cdnPath"] = (document.cookie.match(/(^|; )CDN=([^;]*)/i) || "")[2] || "");
			}
		},
		getApplicationType: function () {
			if (this.memoizedValues["applicationType"]) {
				return this.memoizedValues["applicationType"];
			} else {
				var viewMode = (document.cookie.match(/(^|; )ViewMode=([^;]*)/i) || 0)[2] || "";

				if (viewMode.toLowerCase() === "mobile") {
					return (this.memoizedValues["applicationType"] = "mobile");
				}

				return (this.memoizedValues["applicationType"] = "web");
			}
		},
		getDefaultBroker: function () {
			return (document.cookie.match(/(^|; )DB=([\d]+)B/i) || "")[2] || "0";
		},
		getBroker: function () {
			if (brokerID === null) {
				brokerID = (document.cookie.match(/(^|; )B=([\d]+)B\|/i) || "")[2] || "";
			}
			return brokerID;
		},
		getFolderForInstruments: function () {
			var isDemo = (document.cookie.match(/(^|; )B=.*\|(DM)\|/i) || "")[2] === "DM";

			if (isDemo) {
				return (document.cookie.match(/(^|; )B=.*\|([\d]+)RF\|/i) || "")[2] || "0";
			}

			return this.getFolder();
		},
		getFolder: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\d]+)F\|/i) || "")[2] || "";
		},
		getFuturesPermission: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\w]+)FP\|/i) || "")[2] || "";
		},
		getSharesPermission: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\w]+)SP\|/i) || "")[2] || "";
		},
		getShowTestInstruments: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\w]+)TST\|/i) || "")[2] || "";
		},
		getInstrumentsVersion: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\d]+)\-VER\|/i) || "")[2] || "";
		},
		getVersionHash: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\w]+)\-H\|/i) || "")[2] || "";
		},
		getDealAmountsVersion: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\d]+)\-DVER\|/i) || "")[2] || "";
		},
		getDealAmountsHash: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\w]+)\-DH\|/i) || "")[2] || "";
		},
		getMinDealsVersion: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\d]+)\-MVER\|/i) || "")[2] || "";
		},
		getMinDealGroupId: function () {
			return (document.cookie.match(/(^|; )MinDealGroupId=([^;]*)/i) || "")[2] || "";
		},
		getMinDealsHash: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\w]+)\-MH/i) || "")[2] || "";
		},
		getIsAutoLogin: function () {
			return (document.cookie.match(/(^|; )B=.*\|([\d]+)\-AL/i) || "")[2] || "";
		},
		getApplicationRelativePath: function () {
			return '/webpl3';
			if (this.memoizedValues["getApplicationRelativePath"]) {
				return this.memoizedValues["getApplicationRelativePath"];
			} else {
				return (this.memoizedValues["getApplicationRelativePath"] = window.location.pathname
					.substring(0, window.location.pathname.indexOf("/", 1))
					.toLowerCase());
			}
		},
		getStaticPath: function () {
			return this.combine(this.getCdnPath(), this.getApplicationRelativePath());
		},
		getAssetsPath: function () {
			return this.combine(this.getStaticPath(), "assets", this.getVersion());
		},
		getOriginJSPath: function (filename) {
			return this.combine("assets", this.getVersion(), "js", filename || "");
		},
		getStaticJSPath: function (filename) {
			return this.combine(this.getAssetsPath(), "js", filename || "");
		},
		getStaticJSActionPath: function (controller, action) {
			return this.combine(this.getAssetsPath(), controller, action + ".js");
		},
		getImagePath: function (filename, hasLanguage, hasBroker) {
			filename = filename || "";

			var lang = hasLanguage === true ? this.getLanguage() : "Default";
			var broker = hasBroker === true ? "Broker" + this.getDefaultBroker() : "AllBrokers";

			return this.combine(
				this.getAssetsPath(),
				"skins",
				this.getApplicationType(),
				broker,
				lang,
				"img",
				filename
			);
		},
		getImageSharedPath: function (filename) {
			filename = filename || "";

			return this.combine(this.getAssetsPath(), "skins", "Shared", "svg", filename);
		},
		getStaticParams: function () {
			var domain = window.location.host.replace(':9005',''),
				applicationType = this.getApplicationType(),
				brokerId = this.getBroker(),
				languageId = this.getLanguageId();

			return this.combine(domain, applicationType, brokerId, languageId);
		},
		getStaticFilePath: function () {
			return this.combine(this.getStaticPath(), this.getStaticParams());
		},
		getStaticResourcePath: function (resource) {
			return this.combine(this.getStaticPath(), this.getStaticParams(), this.getVersion(), resource + ".js");
		},
		getContentPath: function (resource) {
			return this.combine(
				this.getStaticPath(),
				this.getStaticParams(),
				this.getVersion(),
				this.getDefaultBroker(),
				resource + ".js"
			);
		},
		getHostName: function (url) {
			var match = url.match(/:\/\/([^\/]*)/i);

			if (
				typeof match !== "undefined" &&
				match !== null &&
				match.length > 1 &&
				typeof match[1] === "string" &&
				match[1].length > 0
			) {
				return match[1];
			} else {
				return null;
			}
		},
		getRedirectPath: function () {
			return "Account/Redirect";
		},
		getRedirectUrl: function (action, queryString) {
			return this.combine(
				this.getApplicationRelativePath(),
				this.getRedirectPath(),
				action,
				queryString ? "?" + queryString : String.empty
			);
		},
		getInstrumentsUrl: function (version, hash) {
			var action = "Instruments/";

			action += "fu" + this.getFuturesPermission();
			action += "-s" + this.getSharesPermission();
			action += "-fo" + this.getFolderForInstruments();
			action += "-br" + this.getBroker();
			action += "-tst" + this.getShowTestInstruments();
			action += "-v" + (version || this.getInstrumentsVersion());
			action += "-h" + (hash || this.getVersionHash());

			return action;
		},
		getInstrumentsFromOriginUrl: function () {
			var action = "InitialData/InstrumentsFromOrigin";

			action += "?futuresPermission=" + this.getFuturesPermission();
			action += "&stocksPermission=" + this.getSharesPermission();
			action += "&folderId=" + this.getFolderForInstruments();
			action += "&brokerId=" + this.getBroker();
			action += "&includeTestInstruments=" + this.getShowTestInstruments();

			return action;
		},
		getMinDealAmountsUrl: function (groupId, version, hash) {
			var action = "MinDealAmounts/";

			action += "g" + groupId;
			action += "-v" + (version || this.getMinDealsVersion());
			action += "-h" + (hash || this.getMinDealsHash());

			return action;
		},
		getDealAmountsUrl: function (version, hash) {
			var action = "DealAmounts/";
			action += "v" + (version || this.getDealAmountsVersion());
			action += "-h" + (hash || this.getDealAmountsHash());

			return action;
		},
		getStaticInitialDataInstrumentsUrl: function (version, hash) {
			return this.combine(this.getAssetsPath(), "InitialData", this.getInstrumentsUrl(version, hash) + ".js");
		},
		getStaticInitialDataDealAmountsUrl: function (version, hash) {
			return this.combine(this.getAssetsPath(), "InitialData", this.getDealAmountsUrl(version, hash) + ".js");
		},
		getStaticInitialDataMinDealAmountsUrl: function (groupId, version, hash) {
			return this.combine(
				this.getAssetsPath(),
				"InitialData",
				this.getMinDealAmountsUrl(groupId, version, hash) + ".js"
			);
		},
		isCors: function (requestUrl) {
			var currDomain = ""; //window.location.host;
			var requestDomain = this.getHostName(requestUrl);

			return requestDomain !== null && currDomain !== requestDomain;
		},
		combine: function () {
			var input = [].slice.call(arguments, 0),
				output = input
					.filter(function (item) {
						return typeof item !== "undefined" && item !== null && item !== "";
					})
					.join("/");

			output = output.replace(/:\/(?=[^\/])/g, "://"); // make sure that protocol is followed by 2 slashes
			output = output.replace(/([^:\s\%\3\A])\/+/g, "$1/"); // remove consecutive slashes
			output = output.replace(/\/(\?|&|#[^!]|$)/g, "$1"); // remove trailing slash before parameters or hash
			output = output.replace(/(\?.+)\?/g, "$1&"); // replace ? in parameters with &

			return output;
		},
		getHashParameters: function () {
			var hashData = {
				connectionToken: "",
				jwtToken: "",
				dealerCurrency: null,
				dealerAdvancedWalletView: null,
				CSMPushEnabled: "",
			};

			if (window.location.hash && window.location.hash.indexOf("$") > -1) {
				var hashParams = window.location.hash.slice(1).split("$");

				for (var i = 0; i < hashParams.length; i++) {
					if (hashParams[i].indexOf("ct=") !== -1) {
						hashData.connectionToken = hashParams[i].substring(3, hashParams[i].length);
					}

					if (hashParams[i].indexOf("jt=") !== -1) {
						hashData.jwtToken = hashParams[i].substring(3, hashParams[i].length);
					}

					if (hashParams[i].indexOf("dc=") !== -1) {
						hashData.dealerCurrency = parseInt(hashParams[i].substring(3, hashParams[i].length));
					}

					if (hashParams[i].indexOf("av=") !== -1) {
						hashData.dealerAdvancedWalletView = parseInt(hashParams[i].substring(3, hashParams[i].length));
					}

					if (hashParams[i].indexOf("en=") !== -1) {
						hashData.CSMPushEnabled = hashParams[i].substring(3, hashParams[i].length);
					}
				}

				window.location.hash = "";
			}

			return hashData;
		},
		getContentStyleBrokerId: function () {
			return (document.cookie.match(/(^|; )CS=([^;]*)/i) || "")[2] || "";
		},
		rndKey: "rnd",
		regexRndKey: /[?|&]rnd=0.\d+/g,
		rndMaxValue: 9007199254740991,
		getRndKeyValue: function () {
			if (window.location.host.indexOf("9005") > -1)
			{
				return "";
			}
			return module.rndKey + "=0." + Math.floor(Math.random() * module.rndMaxValue);
		},
		getUrlWithRndKeyValue: function (url) {
			url = url.replace(module.regexRndKey, "");
			var randomPrefix = url.indexOf("?") < 0 ? "?" : "&";

            url = url + randomPrefix + module.getRndKeyValue();
            return url;
        },
        getChatBotResourcesPath: function () {
            return UrlResolver.getStaticJSPath() + "/fx-chatbot/";
        },
        isNativeIos: function () {
            return new RegExp("(^|; )NativeIosApp=true", "i").test(document.cookie);
        },
        isNativeAndoid: function () {
            return new RegExp("(^|; )NativeAndroidApp=true", "i").test(document.cookie);
        },
        getMinDealGroupId: function () {
            return (document.cookie.match(/(^|; )MinDealGroupId=([^;]*)/i) || "")[2] || "";
        }
    };

	return module;
})();



(function (root, factory) {
	if (typeof define === "function" && define.amd) {
		// AMD. Register as an anonymous module.
		define('global/UrlResolver',[], factory);
	} else {
		// Browser globals
		root = factory();
	}
})(typeof self !== "undefined" ? self : this, function () {
	// Use b in some fashion.

	// Just return a value to define the module export.
	// This example returns an object, but the module
	// can return a function as the exported value.
	return UrlResolver;
});

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

        // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

        // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define('Q',definition);

        // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

        // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
    "use strict";

    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }

    // All code after this point will be filtered from stack traces reported
    // by Q.
    var qStartingLine = captureLine();
    var qFileName;

    // shims

    // used for fallback in "allResolved"
    var noop = function () { };

    // Use the fastest possible means to execute a task in a future turn
    // of the event loop.
    var nextTick = (function () {
        // linked list of tasks (single, with head node)
        var head = { task: void 0, next: null };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        // queue for late tasks, used by unhandled rejection tracking
        var laterQueue = [];

        function flush() {
            /* jshint loopfunc: true */
            var task, domain;

            while (head.next) {
                head = head.next;
                task = head.task;
                head.task = void 0;
                domain = head.domain;

                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }
                runSingle(task, domain);

            }
            while (laterQueue.length) {
                task = laterQueue.pop();
                runSingle(task);
            }
            flushing = false;
        }
        // runs a single function in the async queue
        function runSingle(task, domain) {
            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        nextTick = function (task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };

            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };

        if (typeof process === "object" &&
            process.toString() === "[object process]" && process.nextTick) {
            // Ensure Q is in a real Node environment, with a `process.nextTick`.
            // To see through fake Node environments:
            // * Mocha test runner - exposes a `process` global without a `nextTick`
            // * Browserify - exposes a `process.nexTick` function that uses
            //   `setTimeout`. In this case `setImmediate` is preferred because
            //    it is faster. Browserify's `process.toString()` yields
            //   "[object Object]", while in a real Node environment
            //   `process.nextTick()` yields "[object process]".
            isNodeJS = true;

            requestTick = function () {
                process.nextTick(flush);
            };

        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function () {
                    setImmediate(flush);
                };
            }

        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function () {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function () {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function () {
                setTimeout(flush, 0);
                requestPortTick();
            };

        } else {
            // old browsers
            requestTick = function () {
                setTimeout(flush, 0);
            };
        }
        // runs a task after all other tasks have been run
        // this is useful for unhandled rejection tracking that needs to happen
        // after all `then`d tasks have been run.
        nextTick.runAfter = function (task) {
            laterQueue.push(task);
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
        return nextTick;
    })();

    // Attempt to make generics safe in the face of downstream
    // modifications.
    // There is no situation where this is necessary.
    // If you need a security guarantee, these primordials need to be
    // deeply frozen anyway, and if you dont need a security guarantee,
    // this is just plain paranoid.
    // However, this **might** have the nice side-effect of reducing the size of
    // the minified code by reducing x.call() to merely x()
    // See Mark Millers explanation of what this does.
    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;
    function uncurryThis(f) {
        return function () {
            return call.apply(f, arguments);
        };
    }
    // This is equivalent, but slower:
    // uncurryThis = Function_bind.bind(Function_bind.call);
    // http://jsperf.com/uncurrythis

    var array_slice = uncurryThis(Array.prototype.slice);

    var array_reduce = uncurryThis(
        Array.prototype.reduce || function (callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );

    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function (value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );

    var array_map = uncurryThis(
        Array.prototype.map || function (callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function (undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );

    var object_create = Object.create || function (prototype) {
        function Type() { }
        Type.prototype = prototype;
        return new Type();
    };

    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

    var object_keys = Object.keys || function (object) {
        var keys = [];
        for (var key in object) {
            if (object_hasOwnProperty(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    var object_toString = uncurryThis(Object.prototype.toString);

    function isObject(value) {
        return value === Object(value);
    }

    // generator related shims

    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }

    // FIXME: Remove this helper and Q.return once ES6 generators are in
    // SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function (value) {
            this.value = value;
        };
    }

    // long stack traces

    var STACK_JUMP_SEPARATOR = "From previous event:";

    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);

            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }

    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }

    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
               stackLine.indexOf("(node.js:") !== -1;
    }

    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }

        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }

        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }

    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

        if (!fileNameAndLineNumber) {
            return false;
        }

        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];

        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }

    // discover own file name and line number range for filtering stack
    // traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }

        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }

            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }

    function deprecate(callback, name, alternative) {
        return function () {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                             " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }

    // end of shims
    // beginning of real work

    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promise, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (value instanceof Promise) {
            return value;
        }

        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }
    Q.resolve = Q;

    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;

    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;

    // enable long stacks if Q_DEBUG is set
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
    }

    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;

        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function (resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                Q.nextTick(function () {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };

        // XXX deprecated
        promise.valueOf = function () {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };

        promise.inspect = function () {
            if (!resolvedPromise) {
                return { state: "pending" };
            }
            return resolvedPromise.inspect();
        };

        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promise]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }

        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.

        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;

            array_reduce(messages, function (undefined, message) {
                Q.nextTick(function () {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);

            messages = void 0;
            progressListeners = void 0;
        }

        deferred.promise = promise;
        deferred.resolve = function (value) {
            if (resolvedPromise) {
                return;
            }

            become(Q(value));
        };

        deferred.fulfill = function (value) {
            if (resolvedPromise) {
                return;
            }

            become(fulfill(value));
        };
        deferred.reject = function (reason) {
            if (resolvedPromise) {
                return;
            }

            become(reject(reason));
        };
        deferred.notify = function (progress) {
            if (resolvedPromise) {
                return;
            }

            array_reduce(progressListeners, function (undefined, progressListener) {
                Q.nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        };

        return deferred;
    }

    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };

    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.Promise = promise; // ES6
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }

    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6

    // XXX experimental.  This method is a way to denote that a local value is
    // serializable and should be immediately dispatched to a remote upon request,
    // instead of passing a reference.
    Q.passByCopy = function (object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };

    Promise.prototype.passByCopy = function () {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };

    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function (x, y) {
        return Q(x).join(y);
    };

    Promise.prototype.join = function (that) {
        return Q([this, that]).spread(function (x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };

    /**
     * Returns a promise for the first of an array of promises to become settled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be settled
     */
    Q.race = race;
    function race(answerPs) {
        return promise(function (resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function (answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }

    Promise.prototype.race = function () {
        return this.then(Q.race);
    };

    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function (op) {
                return reject(new Error(
                    "Promise does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function () {
                return { state: "unknown" };
            };
        }

        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function (resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };

        promise.inspect = inspect;

        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }

            promise.valueOf = function () {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }

        return promise;
    }

    Promise.prototype.toString = function () {
        return "[object Promise]";
    };

    Promise.prototype.then = function (fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;   // ensure the untrusted promise makes at most a
        // single call to one of the callbacks

        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }

        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }

        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }

        Q.nextTick(function () {
            self.promiseDispatch(function (value) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_fulfilled(value));
            }, "when", [function (exception) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_rejected(exception));
            }]);
        });

        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function (value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }

            if (!threw) {
                deferred.notify(newValue);
            }
        }]);

        return deferred.promise;
    };

    Q.tap = function (promise, callback) {
        return Q(promise).tap(callback);
    };

    /**
     * Works almost like "finally", but not called for rejections.
     * Original resolution value is passed through callback unaffected.
     * Callback may return a promise that will be awaited for.
     * @param {Function} callback
     * @returns {Q.Promise}
     * @example
     * doSomething()
     *   .then(...)
     *   .tap(console.log)
     *   .then(...);
     */
    Promise.prototype.tap = function (callback) {
        callback = Q(callback);

        return this.then(function (value) {
            return callback.fcall(value).thenResolve(value);
        });
    };

    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }

    Promise.prototype.thenResolve = function (value) {
        return this.then(function () { return value; });
    };

    Q.thenResolve = function (promise, value) {
        return Q(promise).thenResolve(value);
    };

    Promise.prototype.thenReject = function (reason) {
        return this.then(function () { throw reason; });
    };

    Q.thenReject = function (promise, reason) {
        return Q(promise).thenReject(reason);
    };

    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If its a fulfilled promise, the fulfillment value is nearer.
     * If its a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */

    // XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }

    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;
    function isPromise(object) {
        return object instanceof Promise;
    }

    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }

    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }

    Promise.prototype.isPending = function () {
        return this.inspect().state === "pending";
    };

    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }

    Promise.prototype.isFulfilled = function () {
        return this.inspect().state === "fulfilled";
    };

    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }

    Promise.prototype.isRejected = function () {
        return this.inspect().state === "rejected";
    };

    //// BEGIN UNHANDLED REJECTION TRACKING

    // This promise library consumes exceptions thrown in handlers so they can be
    // handled by a subsequent promise.  The exceptions get added to this array when
    // they are created, and removed when they are handled.  Note that in ES6 or
    // shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;

    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;

        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }

    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                if (array_indexOf(unhandledRejections, promise) !== -1) {
                    process.emit("unhandledRejection", reason, promise);
                    reportedUnhandledRejections.push(promise);
                }
            });
        }

        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }

    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }

        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            if (typeof process === "object" && typeof process.emit === "function") {
                Q.nextTick.runAfter(function () {
                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
                    if (atReport !== -1) {
                        process.emit("rejectionHandled", unhandledReasons[at], promise);
                        reportedUnhandledRejections.splice(atReport, 1);
                    }
                });
            }
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }

    Q.resetUnhandledRejections = resetUnhandledRejections;

    Q.getUnhandledReasons = function () {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };

    Q.stopUnhandledRejectionTracking = function () {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };

    resetUnhandledRejections();

    //// END UNHANDLED REJECTION TRACKING

    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function (rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return { state: "rejected", reason: reason };
        });

        // Note that the reason has not been handled.
        trackRejection(rejection, reason);

        return rejection;
    }

    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function () {
                return value;
            },
            "get": function (name) {
                return value[name];
            },
            "set": function (name, rhs) {
                value[name] = rhs;
            },
            "delete": function (name) {
                delete value[name];
            },
            "post": function (name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function (thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function () {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return { state: "fulfilled", value: value };
        });
    }

    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function () {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }

    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function () { }
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function () {
            return Q(object).inspect();
        });
    }

    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }

    Promise.prototype.spread = function (fulfilled, rejected) {
        return this.all().then(function (array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };

    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;
    function async(makeGenerator) {
        return function () {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;

                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.

                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return Q(result.value);
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return Q(exception.value);
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }
            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }

    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }

    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      return foo + bar;
     * })
     * // Older SpiderMonkey style
     * Q.async(function () {
     *      var foo = yield getFooPromise();
     *      var bar = yield getBarPromise();
     *      Q.return(foo + bar);
     * })
     */
    Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }

    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
     *     return a + b;
     * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;
    function promised(callback) {
        return function () {
            return spread([this, all(arguments)], function (self, args) {
                return callback.apply(self, args);
            });
        };
    }

    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }

    Promise.prototype.dispatch = function (op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function () {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };

    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function (object, key) {
        return Q(object).dispatch("get", [key]);
    };

    Promise.prototype.get = function (key) {
        return this.dispatch("get", [key]);
    };

    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function (object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };

    Promise.prototype.set = function (key, value) {
        return this.dispatch("set", [key, value]);
    };

    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
    Q["delete"] = function (object, key) {
        return Q(object).dispatch("delete", [key]);
    };

    Promise.prototype.del = // XXX legacy
    Promise.prototype["delete"] = function (key) {
        return this.dispatch("delete", [key]);
    };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with URLs
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
    // bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
    Q.post = function (object, name, args) {
        return Q(object).dispatch("post", [name, args]);
    };

    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
    Promise.prototype.post = function (name, args) {
        return this.dispatch("post", [name, args]);
    };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
    Q.mcall = // XXX As proposed by "Redsandro"
    Q.invoke = function (object, name /*...args*/) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
    };

    Promise.prototype.send = // XXX Mark Miller's proposed parlance
    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
    Promise.prototype.invoke = function (name /*...args*/) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };

    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function (object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };

    Promise.prototype.fapply = function (args) {
        return this.dispatch("apply", [void 0, args]);
    };

    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
    Q.fcall = function (object /* ...args*/) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
    };

    Promise.prototype.fcall = function (/*...args*/) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };

    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function (object /*...args*/) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function (/*...args*/) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };

    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function (object) {
        return Q(object).dispatch("keys", []);
    };

    Promise.prototype.keys = function () {
        return this.dispatch("keys", []);
    };

    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
    // By Mark Miller
    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function (promises) {
            var pendingCount = 0;
            var deferred = defer();
            array_reduce(promises, function (undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++pendingCount;
                    when(
                        promise,
                        function (value) {
                            promises[index] = value;
                            if (--pendingCount === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function (progress) {
                            deferred.notify({ index: index, value: progress });
                        }
                    );
                }
            }, void 0);
            if (pendingCount === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }

    Promise.prototype.all = function () {
        return all(this);
    };

    /**
     * Returns the first resolved promise of an array. Prior rejected promises are
     * ignored.  Rejects only if all promises are rejected.
     * @param {Array*} an array containing values or promises for values
     * @returns a promise fulfilled with the value of the first resolved promise,
     * or a rejected promise if all promises are rejected.
     */
    Q.any = any;

    function any(promises) {
        if (promises.length === 0) {
            return Q.resolve();
        }

        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function (prev, current, index) {
            var promise = promises[index];

            pendingCount++;

            when(promise, onFulfilled, onRejected, onProgress);
            function onFulfilled(result) {
                deferred.resolve(result);
            }
            function onRejected() {
                pendingCount--;
                if (pendingCount === 0) {
                    deferred.reject(new Error(
                        "Can't get fulfillment value from any promise, all " +
                        "promises were rejected."
                    ));
                }
            }
            function onProgress(progress) {
                deferred.notify({
                    index: index,
                    value: progress
                });
            }
        }, undefined);

        return deferred.promise;
    }

    Promise.prototype.any = function () {
        return any(this);
    };

    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function (promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function (promise) {
                return when(promise, noop, noop);
            })), function () {
                return promises;
            });
        });
    }

    Promise.prototype.allResolved = function () {
        return allResolved(this);
    };

    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }

    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function () {
        return this.then(function (promises) {
            return all(array_map(promises, function (promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }
                return promise.then(regardless, regardless);
            }));
        });
    };

    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
    Q["catch"] = function (object, rejected) {
        return Q(object).then(void 0, rejected);
    };

    Promise.prototype.fail = // XXX legacy
    Promise.prototype["catch"] = function (rejected) {
        return this.then(void 0, rejected);
    };

    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }

    Promise.prototype.progress = function (progressed) {
        return this.then(void 0, void 0, progressed);
    };

    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
    Q["finally"] = function (object, callback) {
        return Q(object)["finally"](callback);
    };

    Promise.prototype.fin = // XXX legacy
    Promise.prototype["finally"] = function (callback) {
        if (!callback || typeof callback.apply !== "function") {
            throw new Error("Can't apply finally callback");
        }
        callback = Q(callback);
        return this.then(function (value) {
            return callback.fcall().then(function () {
                return value;
            });
        }, function (reason) {
            // TODO attempt to recycle the rejection with "this".
            return callback.fcall().then(function () {
                throw reason;
            });
        });
    };

    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function (object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };

    Promise.prototype.done = function (fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            Q.nextTick(function () {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };

        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;

        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }

        promise.then(void 0, onUnhandledError);
    };

    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {Any*} custom error message or Error object (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function (object, ms, error) {
        return Q(object).timeout(ms, error);
    };

    Promise.prototype.timeout = function (ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            if (!error || "string" === typeof error) {
                error = new Error(error || "Timed out after " + ms + " ms");
                error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
        }, ms);

        this.then(function (value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function (exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);

        return deferred.promise;
    };

    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function (object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };

    Promise.prototype.delay = function (timeout) {
        return this.then(function (value) {
            var deferred = defer();
            setTimeout(function () {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
     *      })
     *
     */
    Q.nfapply = function (callback, args) {
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfapply = function (args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
     * })
     *
     */
    Q.nfcall = function (callback /*...args*/) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfcall = function (/*...args*/) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
    Q.denodeify = function (callback /*...args*/) {
        var baseArgs = array_slice(arguments, 1);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            Q(callback).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };

    Promise.prototype.nfbind =
    Promise.prototype.denodeify = function (/*...args*/) {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
    };

    Q.nbind = function (callback, thisp /*...args*/) {
        var baseArgs = array_slice(arguments, 2);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }
            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };

    Promise.prototype.nbind = function (/*thisp, ...args*/) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
    Q.npost = function (object, name, args) {
        return Q(object).npost(name, args);
    };

    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
    Promise.prototype.npost = function (name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
    Q.nmcall = // XXX Based on "Redsandro's" proposal
    Q.ninvoke = function (object, name /*...args*/) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };

    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
    Promise.prototype.ninvoke = function (name /*...args*/) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }

    Promise.prototype.nodeify = function (nodeback) {
        if (nodeback) {
            this.then(function (value) {
                Q.nextTick(function () {
                    nodeback(null, value);
                });
            }, function (error) {
                Q.nextTick(function () {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };

    Q.noConflict = function () {
        throw new Error("Q.noConflict only works when Q is used as a global");
    };

    // All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();

    return Q;

});

function AjaxError(httpStatus, message, requestUrl, responseSnippet) {
	this.httpStatus = httpStatus;
	this.message = message;
	this.requestUrl = requestUrl;
	this.responseSnippet = encodeURI(responseSnippet);

	if (!Error.captureStackTrace) {
		this.stack = new Error().stack;
	} else {
		Error.captureStackTrace(this, this.constructor);
	}
}

AjaxError.prototype = Object.create(Error.prototype);
AjaxError.prototype.constructor = AjaxError;
AjaxError.prototype.toString = function () {
	return (
		this.httpStatus +
		" " +
		this.message +
		(this.requestUrl ? " " + this.requestUrl : "") +
		(this.responseSnippet ? " " + this.responseSnippet : "")
	);
};

AjaxError.fromXHR = function (xhr, message, requestUrl) {
	message +=
		"; xhr (statusText: " +
		xhr.statusText +
		", responseType: " +
		(xhr.responseType === "" ? "text" : xhr.responseType) +
		", status:" +
		xhr.status +
		")";
	return new AjaxError(xhr.status, message, requestUrl);
};

define('handlers/AjaxError',[], function () {
	return AjaxError;
});

/* global UrlResolver, AjaxError, General, Q*/
function TAjaxerStatus(state, data) {
    this.State = state || eAjaxerState.None;
    this.Data = data || null;
}

function TAjaxer(rti) {
    var self = this,
        httpRequest = createXhrObject(),
        defaultMaxRetries = 0,
        defaultMaxRetriesGet = 5,
        retryInterval = rti ? rti : 1000,
        isStopRetry = false,
        retryTimer = null,
        appRelativePath = UrlResolver.getApplicationRelativePath();

    function createXhrObject() {
        var xhr;

        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
        } else if (window.ActiveXObject) {
            var versions = [
                "MSXML2.XmlHttp.6.0",
                "MSXML2.XmlHttp.5.0",
                "MSXML2.XmlHttp.4.0",
                "MSXML2.XmlHttp.3.0",
                "MSXML2.XmlHttp.2.0",
                "Microsoft.XmlHttp",
                "Microsoft.XMLHTTP" // old
            ];

            for (var i = 0; i < versions.length; i++) {
                try {
                    xhr = new ActiveXObject(versions[i]);
                } catch (e) {
                    // empty
                }
            }
        }

        return xhr;
    }

    function prepareDeferred(onResolve, onReject, onNotify) {
        var deferred = Q.defer();

        // Normalize the handlers
        onResolve = General.isFunctionType(onResolve) ? onResolve : General.emptyFn;
        onReject = General.isFunctionType(onReject) ? onReject : General.emptyFn;
        onNotify = General.isFunctionType(onNotify) ? onNotify : General.emptyFn;

        // attach progress handler to original promise, bind it with the deferred
        deferred.promise.progress(onNotify.bind(self, deferred));

        // re-assign the promise to the deferred object, the onResolve might throw errors as well
        deferred.promise = deferred.promise.then(function (originalResponse) {
            var onResolveValue = onResolve.call(self, originalResponse);
            return onResolveValue || originalResponse;
        });

        // attach fail handler
        deferred.promise.fail(function (error) {
            onReject.call(self, error);
            throw error;
        });

        return deferred;
    }

    function onRetry(methodToRetry, defer, status) {
        status.State = status.State || eAjaxerState.None;

        if (status.State === eAjaxerState.Retry) {
            stopRetry();

            if (!General.isFunctionType(methodToRetry)) {
                return;
            }

            // Call the methodToRetry with extra parameter - the deferred object
            retryTimer = setTimeout(methodToRetry.bind(self, defer), retryInterval);
        }
    }

    function getMethod(callerInfo, url, params, onComplete, onError, tryCounter, customMaxRetries, sla, noCache, deferred) {
        noCache = General.isBooleanType(noCache) ? noCache : true;
        tryCounter = tryCounter || 1;

        var maxRetries = General.isNumber(customMaxRetries) ? Number(customMaxRetries) : defaultMaxRetriesGet,
            requestTime = Date.now(),
            onNotify;

        // If the deferred is defined, then the method is invoked from a RETRY attempt
        if (!deferred) {
            onNotify = function (defer, state) {
                tryCounter += 1;

                var methodToRetry = getMethod.bind(self,
                    state.Data.callerInfo,
                    state.Data.url,
                    null, // params already on the url query string //state.Data.params,
                    state.Data.onComplete,
                    state.Data.onError,
                    tryCounter,
                    state.Data.maxRetries,
                    state.Data.SLA,
                    null,
                    defer);

                onRetry(methodToRetry, defer, state);
            };

            deferred = prepareDeferred(onComplete, onError, onNotify);
        }

        if (!httpRequest) {
            deferred.reject(new Error("AJAXER (" +
                "description: XMLHttpRequest could not be created, " +
                "callerInfo: " + callerInfo + ", " +
                "url: " + url + ", " +
                "params: " + params + ", " +
                "request time: " + requestTime + ", " +
                "tryCounter: " + tryCounter + ", " +
                "maxRetries: " + maxRetries + ", " +
                "SLA: " + sla + "," +
                "noCahe: " + noCache + ")"
            ));
        } else {
            if (params) {
                url += (url.indexOf("?") === -1 ? "?" : "&") + params;
            }

            httpRequest.open("GET", getUrl(url, noCache), true);

            if (!UrlResolver.isCors(url)) {
                httpRequest.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                httpRequest.setRequestHeader("Accept", "application/json");
            }

            httpRequest.onreadystatechange = onReadyStateChanged.bind(httpRequest, callerInfo, url, params, tryCounter, maxRetries, deferred, sla, requestTime);
            httpRequest.send();
        }

        return deferred.promise;
    }

    function postMethod(callerInfo, url, params, onComplete, onError, tryCounter, customMaxRetries, sla, deferred) {
        tryCounter = tryCounter || 1;

        var maxRetries = General.isNumber(customMaxRetries) ? Number(customMaxRetries) : defaultMaxRetries,
            requestTime = Date.now(),
            onNotify;

        // If the deferred is defined, then the method is invoked from a RETRY attempt
        if (!deferred) {
            onNotify = function (defer, state) {
                tryCounter += 1;

                var methodToRetry = postMethod.bind(self,
                    state.Data.callerInfo,
                    state.Data.url,
                    state.Data.params,
                    state.Data.onComplete,
                    state.Data.onError,
                    tryCounter,
                    state.Data.maxRetries,
                    state.Data.SLA,
                    defer);

                onRetry(methodToRetry, defer, state);
            };

            deferred = prepareDeferred(onComplete, onError, onNotify);
        }

        if (!httpRequest) {
            deferred.reject(new Error("AJAXER (" +
                "description: XMLHttpRequest could not be created, " +
                "callerInfo: " + callerInfo + ", " +
                "url: " + url + ", " +
                "params: " + params + ", " +
                "request time: " + requestTime + ", " +
                "tryCounter: " + tryCounter + ", " +
                "maxRetries: " + maxRetries + ", " +
                "SLA: " + sla + ")"
            ));
        } else if (params) {
            // here we check if the user request a security token when not authenticated(initialized)
            // to prevent a call for security token that which will return an error
            var pattern = /SecurityToken/i;
            var result = params.match(pattern);

            if (result && !$customer.isAuthenticated()) {
                deferred.reject(new Error("AJAXER (" +
                    "description: Request is not authenticated, " +
                    "callerInfo: " + callerInfo + ", " +
                    "url: " + url + ", " +
                    "params: " + params + ", " +
                    "request time: " + requestTime + ", " +
                    "tryCounter: " + tryCounter + ", " +
                    "maxRetries: " + maxRetries + ", " +
                    "SLA: " + sla + ")"
                ));
            }
        }

        if (deferred.promise.isPending()) {
            var noCache = true;

            httpRequest.open("POST", getUrl(url, noCache), true);
            httpRequest.onreadystatechange = onReadyStateChanged.bind(httpRequest, callerInfo, url, params, tryCounter, maxRetries, deferred, sla, requestTime);
            if (!UrlResolver.isCors(url)) {
                httpRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                httpRequest.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            }
            httpRequest.send(params);
        }

        return deferred.promise;
    }

    function jsonPostMethod(callerInfo, url, params, onComplete, onError, tryCounter, customMaxRetries, sla, deferred) {
        tryCounter = tryCounter || 1;

        var maxRetries = General.isNumber(customMaxRetries) ? Number(customMaxRetries) : defaultMaxRetries,
            requestTime = Date.now(),
            onNotify;

        // If the deferred is defined, then the method is invoked from a RETRY attempt
        if (!deferred) {
            onNotify = function (defer, state) {
                tryCounter += 1;

                var methodToRetry = jsonPostMethod.bind(self,
                    state.Data.callerInfo,
                    state.Data.url,
                    state.Data.params,
                    state.Data.onComplete,
                    state.Data.onError,
                    tryCounter,
                    state.Data.maxRetries,
                    state.Data.SLA,
                    defer);

                onRetry(methodToRetry, defer, state);
            };

            deferred = prepareDeferred(onComplete, onError, onNotify);
        }

        if (!httpRequest) {
            deferred.reject(new Error("AJAXER (" +
                "description: XMLHttpRequest could not be created, " +
                "callerInfo: " + callerInfo + ", " +
                "url: " + url + ", " +
                "params: " + params + ", " +
                "request time: " + requestTime + ", " +
                "tryCounter: " + tryCounter + ", " +
                "maxRetries: " + maxRetries + ", " +
                "SLA: " + sla + ")"
            ));
        } else {
            var noCache = true;
            httpRequest.open("POST", getUrl(url, noCache), true);
            httpRequest.onreadystatechange = onReadyStateChanged.bind(httpRequest, callerInfo, url, params, tryCounter, maxRetries, deferred, sla, requestTime, noCache);

            if (!UrlResolver.isCors(url)) {
                httpRequest.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                httpRequest.setRequestHeader("Content-Type", "application/json; charset=utf-8");
            }

            httpRequest.send(params);
        }

        return deferred.promise;
    }

    function onReadyStateChanged(callerInfo, url, params, tryCounter, maxRetries, deferred, sla, requestTime) {
        var xhr = this,
            virtualUrl = getUrl(url),
            responseTime,
            duration;

        if (xhr.readyState == 4) {
            responseTime = Date.now();
            duration = responseTime - requestTime;
            var headers = (xhr.getAllResponseHeaders) ? xhr.getAllResponseHeaders() : '';
            switch (xhr.status) {
                case 200:
                    if (sla && requestTime && duration > sla) {
                        // SLA has been compromised
                        deferred.notify(new TAjaxerStatus(eAjaxerState.SlaCompromised, {
                            url: virtualUrl,
                            params: params,
                            "request time": requestTime,
                            "response time": responseTime,
                            duration: duration,
                            callerInfo: callerInfo,
                            tryCounter: tryCounter,
                            maxRetries: maxRetries,
                            SLA: sla
                        }));
                    }

                    if (xhr.responseText) {
                        if (xhr.responseText.indexOf("\"result\":\"ServerError\"") != -1) {
                            ErrorManager.onError(virtualUrl, "Server Error", eErrorSeverity.high);
                        } else if (xhr.responseText.indexOf("\"result\":\"SecurityError\"") != -1) {
                            ErrorManager.onError(virtualUrl, "Security Error", eErrorSeverity.high);
                        } else if (xhr.responseText.indexOf("\"result\":\"ServiceError\"") != -1) {
                            ErrorManager.onError(virtualUrl, "Service Unavailable", eErrorSeverity.low);
                        } else if (xhr.responseText.indexOf("\"status\":\"ServerError\"") != -1) {
                            deferred.reject(new AjaxError("Http500", headers, url));
                        }

                        deferred.resolve(xhr.responseText);
                    }
                    break;
                case 401: // Unauthorized
                case 403: // Forbidden
                case 420: // Version outdated
                    deferred.reject(new AjaxError(xhr.status, "http" + xhr.status, url));
                    break;
                case 417: // Double request
                    deferred.reject(new AjaxError(xhr.status, "AJAXER (" +
                        "description: Double request for resource \"" + url + "\", " +
                        "callerInfo: " + callerInfo + ", " +
                        "url: " + url + ", " +
                        "params: " + params + ", " +
                        "request time: " + requestTime + ", " +
                        "response time: " + responseTime + ", " +
                        "duration: " + duration + ", " +
                        "tryCounter: " + tryCounter + ", " +
                        "maxRetries: " + maxRetries + ", " +
                        "SLA: " + sla + ")"
                    ));
                    break;
                case 424: // Version mismatch 
                    if (!isStopRetry && tryCounter < maxRetries) {
                        // RETRY
                        deferred.notify(new TAjaxerStatus(eAjaxerState.Retry, {
                            url: virtualUrl,
                            params: params,
                            "request time": requestTime,
                            "response time": responseTime,
                            duration: duration,
                            callerInfo: callerInfo,
                            tryCounter: tryCounter,
                            maxRetries: maxRetries,
                            SLA: sla
                        }));
                    } else {
                        deferred.reject(AjaxError.fromXHR(xhr, "AJAXER (" +
                            "description: Version mismatch for resource \"" + url + "\", " +
                            "callerInfo: " + callerInfo + ", " +
                            "url: " + url + ", " +
                            "params: " + params + ", " +
                            "request time: " + requestTime + ", " +
                            "response time: " + responseTime + ", " +
                            "duration: " + duration + ", " +
                            "tryCounter: " + tryCounter + ", " +
                            "maxRetries: " + maxRetries + ", " +
                            "SLA: " + sla + ")"
                        ));
                    }
                    break;
                case 0: // Aborted request before getting the response
                    if (!isStopRetry && tryCounter < maxRetries) {
                        // RETRY
                        deferred.notify(new TAjaxerStatus(eAjaxerState.Retry, {
                            url: virtualUrl,
                            params: params,
                            "request time": requestTime,
                            "response time": responseTime,
                            duration: duration,
                            callerInfo: callerInfo,
                            tryCounter: tryCounter,
                            maxRetries: maxRetries,
                            SLA: sla
                        }));
                    } else {
                        deferred.reject(AjaxError.fromXHR(xhr, "AJAXER (" +
                            "description: Request was aborted for resource \"" + url + "\", " +
                            "callerInfo: " + callerInfo + ", " +
                            "url: " + url + ", " +
                            "params: " + params + ", " +
                            "request time: " + requestTime + ", " +
                            "response time: " + responseTime + ", " +
                            "duration: " + duration + ", " +
                            "tryCounter: " + tryCounter + ", " +
                            "maxRetries: " + maxRetries + ", " +
                            "SLA: " + sla + ")" + "response headers: " + headers
                        ));
                    }
                    break;
                default:
                    if (!isStopRetry && tryCounter < maxRetries) {
                        // RETRY
                        deferred.notify(new TAjaxerStatus(eAjaxerState.Retry, {
                            url: virtualUrl,
                            params: params,
                            "request time": requestTime,
                            "response time": responseTime,
                            duration: duration,
                            callerInfo: callerInfo,
                            tryCounter: tryCounter,
                            maxRetries: maxRetries,
                            SLA: sla
                        }));
                    } else {
                        deferred.reject(new AjaxError(xhr.status, "AJAXER (" +
                            "description: Request failed for resource \"" + url + "\", status code was " + xhr.status + ", " +
                            "callerInfo: " + callerInfo + ", " +
                            "url: " + url + ", " +
                            "params: " + params + ", " +
                            "request time: " + requestTime + ", " +
                            "response time: " + responseTime + ", " +
                            "duration: " + duration + ", " +
                            "tryCounter: " + tryCounter + ", " +
                            "maxRetries: " + maxRetries + ", " +
                            "SLA: " + sla + ")" + "response headers: " + headers
                        ));
                    }
                    break;
            }
        }
    }

    function getUrl(url, noCache) {
        var random = String.empty,
            prefix;

        
        var isdevelopermode = url.indexOf('.js') === -1 && url.indexOf('.html') === -1 && url.indexOf(port) === -1;   

        if (noCache && !isdevelopermode) {
            url = UrlResolver.getUrlWithRndKeyValue(url);
        }

        prefix = (url.startsWith(appRelativePath) || url.startsWith('http'))
            ? String.empty
            : appRelativePath;

        var port = 9005;  
        
/*         if (isdevelopermode && url.indexOf(port) === -1){
            prefix = "http://traderlocal.iforex.com:" + port + "/webpl3"
        } */
        

        return UrlResolver.combine(prefix, url, random);
    }

    function stopRetry(force) {
        isStopRetry = !!force;

        if (retryTimer) {
            clearTimeout(retryTimer);
            retryTimer = null;
        }
    }

    function abort() {
        if (httpRequest) {
            stopRetry();
            httpRequest.abort();
        }
    }

    //----------------------------------------------------------------
    // When you don't need to chain, you should use these methods
    function getMethodDone() {
        var promise = getMethod.apply(self, arguments);
        promise.done();
    }

    function postMethodDone() {
        var promise = postMethod.apply(self, arguments);
        promise.done();
    }

    function jsonPostMethodDone() {
        var promise = jsonPostMethod.apply(self, arguments);
        promise.done();
    }

    //----------------------------------------------------------------

    return {
        abort: abort,
        get: getMethodDone,
        post: postMethodDone,
        jsonPost: jsonPostMethodDone,
        promises: {
            abort: abort,
            get: getMethod,
            post: postMethod,
            jsonPost: jsonPostMethod
        }
    };
}
;
define("handlers/Ajaxer", ["Q","handlers/AjaxError","global/UrlResolver"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (q) {
				Q = q;
				return this.TAjaxer;
			};
        ret = fn.apply(global, arguments);
        return ret || global.TAjaxer;
    };
}(this)));

/* global General */
function THashTable() {
    var length = 0;
    var container = {};

    function removeItem(key) {
        if (container.hasOwnProperty(key) && General.isDefinedType(container[key])) {
            length -= 1;

            delete container[key];
        }
    }

    function getItem(key) {
        if (container.hasOwnProperty(key) && General.isDefinedType(container[key])) {
            return container[key];
        }

        return null;
    }

    function foreach(delegate) {
        for (var key in container) {
            if (container.hasOwnProperty(key)) {
                if (delegate(key, container[key]) === false) {
                    break;
                }
            }
        }
    }

    function filter(callback) {
        var result = new THashTable();

        for (var key in container) {
            if (container.hasOwnProperty(key)) {
                if (callback(key, container[key])) {
                    result.SetItem(key, container[key]);
                }
            }
        }

        return result;
    }

    function find(callback) {
        var result = new THashTable();

        for (var key in container) {
            if (container.hasOwnProperty(key)) {
                if (callback(key, container[key])) {
                    result.SetItem(key, container[key]);

                    return result;
                }
            }
        }
        return result;
    }

    function setItem(key, value) {
        if (General.isDefinedType(value)) {
            if (!General.isDefinedType(container[key])) {
                length += 1;
                container[key] = value;
            }
        }
    }

    function overrideItem(key, value) {
        if (hasItem(key)) {
            if (General.isDefinedType(value)) {
                container[key] = value;
            }
        }
        else {
            setItem(key, value);
        }
    }

    function firstItem() {
        for (var key in container) {
            if (container.hasOwnProperty(key)) {
                return container[key];
            }
        }

        return null;
    }

    function hasItem(key) {
        return container.hasOwnProperty(key) && General.isDefinedType(container[key]);
    }

    function hasItems() {
        return length > 0;
    }

    function clear() {
        for (var key in container) {
            if (container.hasOwnProperty(key)) {
                if (!General.isNullOrUndefined(container[key]) && General.isFunctionType(container[key].dispose)) {
                    container[key].dispose();
                }

                delete container[key];
            }
        }

        length = 0;
    }

    function count() {
        return length;
    }

    function sort(field, asc) {
        /* eslint no-array-constructor: 0 */
        var res = [],
            tmp = [],
            item,
            fieldValue;

        for (var key in container) {
            if (!container.hasOwnProperty(key)) {
                continue;
            }

            item = container[key];

            if (item !== null && typeof item === 'object') {
                fieldValue = item[field];

                if (General.isNumber(fieldValue) || General.isStringType(fieldValue)) {
                    tmp.push(new Array(fieldValue, key));
                }
            }
        }

        //---------------------------------------

        for (var i = 1, n = tmp.length; i < n; i++) {
            for (var j = 0; j < n - i; j++) {
                if (tmp[j][0] > tmp[j + 1][0]) {
                    var tempVal = tmp[j];
                    tmp[j] = tmp[j + 1];
                    tmp[j + 1] = tempVal;
                }
            }
        }

        //---------------------------------------

        for (var t = 0; t < tmp.length; t++) {
            res[t] = tmp[t][1];
        }

        return asc ? res : res.reverse();
    }

    return {
        count: count,
        Sort: sort,
        Clear: clear,
        GetItem: getItem,
        SetItem: setItem,
        HasItem: hasItem,
        OverrideItem: overrideItem,
        RemoveItem: removeItem,
        Container: container,
        firstItem: firstItem,
        hasItems: hasItems,
        ForEach: foreach,
        Filter: filter,
        Find: find
    };
}

define(
    'handlers/HashTable',
    [
        'handlers/general'
    ],
    function () {
        return THashTable
    }
);

define(
    'StateObject',
    [
        'handlers/HashTable',
        'handlers/general'
    ],
    function (hashTable, general) {
        function StateObject(name) {
            this._data = [];
            this._keys = [];
            this._name = name;
            this._currentListeners = {};
            this._nextListeners = {};
        }

        StateObject.prototype.containsKey = function (name) {
            var index = this._keys.indexOf(name);

            return index >= 0;
        };

        StateObject.prototype.set = function (name, value) {
            var index = this._keys.indexOf(name);

            if (index !== -1 && index < this._data.length) {
                return this.get(name);
            }

            this._keys.push(name);

            index = this._data.push(value) - 1;

            this._nextListeners[name] = this._currentListeners[name] = [];

            return this._data[index];
        };

        StateObject.prototype.update = function (name, value) {
            var index = this._keys.indexOf(name);
            var listener;

            var listeners = this._currentListeners[name] = this._nextListeners[name];
            if (listeners) {
                for (var i = 0, ii = listeners.length; i < ii; i++) {
                    listener = listeners[i];
                    listener(value);
                }
            }

            if (index !== -1 && index < this._data.length) {
                this._data[index] = value;
                return this._data[index];
            }

            return this.set(name, value);
        };

        StateObject.prototype.get = function (name) {
            var index = this._keys.indexOf(name);

            if (index !== -1 && index < this._data.length) {
                return this._data[index];
            }

            return null;
        };

        StateObject.prototype.unset = function (name) {
            var index = this._keys.indexOf(name);

            if (index !== -1 && index < this._data.length) {
                this._keys.splice(index, 1);
                this._data.splice(index, 1);
            }
        };

        StateObject.prototype.getAll = function () {
            var obj = {};

            for (var index = 0; index < this._keys.length; index++) {
                obj[this._keys[index]] = this._data[index];
            }

            return obj;
        };

        StateObject.prototype.subscribe = function (name, listener) {
            var index = this._keys.indexOf(name);

            if (index === -1) {
                this.set(name, null);
            }

            if (typeof listener !== 'function') {
                throw new ReferenceError('Expected listener to be a function.');
            }

            if (this._nextListeners[name] === this._currentListeners[name]) {
                this._nextListeners[name] = this._currentListeners[name].slice();
            }

            this._nextListeners[name].push(listener);

            return unsubscribe.bind(this, name, listener);
        };

        function unsubscribe(name, listener) {
            if (this._nextListeners[name] === this._currentListeners[name] && general.isArrayType(this._currentListeners[name])) {
                this._nextListeners[name] = this._currentListeners[name].slice();
            }

            if (general.isArrayType(this._nextListeners[name])) {
                var listenerIndex = this._nextListeners[name].indexOf(listener);
                this._nextListeners[name].splice(listenerIndex, 1);
            }
        }

        StateObject.prototype.clear = function () {
            this._data = [];
            this._keys = [];
            this._currentListeners = {};
            this._nextListeners = {};
        }

        var store = new hashTable();

        return {
            load: function (stateObjectName, req, onload, config) {
                if (config && config.isBuild) {
                    onload(null);
                    return;
                }

                var key = stateObjectName.toLowerCase(),
                    stateObject;

                if (!store.HasItem(key)) {
                    stateObject = new StateObject(stateObjectName);
                    store.SetItem(key, stateObject);
                }

                onload(store.GetItem(key));
            }
        };
    }
);


define(
    'generalmanagers/ShutDownHandler',
    [
        'require',
        'StateObject!SystemNotificationEvents'
    ],
    function(require) {
        var stateObject = require('StateObject!SystemNotificationEvents');

        function ShutDownHandler() {
            var areServicesStarted = true;

            function stopRunningServices() {
                if (areServicesStarted) {
                    stateObject.update(eShutDownHandlerTopics.stopClientStateManagerCalls);
                    stateObject.update(eShutDownHandlerTopics.stopKeepAliveCalls);
                    stateObject.update(eShutDownHandlerTopics.stopGetRatesRecentWebCalls);
                    stateObject.update(eShutDownHandlerTopics.stopGetActiveIMCalls);
                }

                areServicesStarted = false;
            }

            function restartStoppedServices() {
                if (!areServicesStarted) {
                    stateObject.update(eShutDownHandlerTopics.restartClientStateManagerCalls);
                    stateObject.update(eShutDownHandlerTopics.restartGetActiveIMCalls);
                    stateObject.update(eShutDownHandlerTopics.restartGetRatesRecentWebCalls);
                    stateObject.update(eShutDownHandlerTopics.restartGetActiveIMCalls);
                }

                areServicesStarted = true;
            }

            return {
                StopRunningServices: stopRunningServices,
                RestartStoppedServices: restartStoppedServices
            };
        }

        return new ShutDownHandler();
    }
);
define("dataaccess/dalCommon", [
	"global/UrlResolver",
	"handlers/general",
	"handlers/Ajaxer",
	"generalmanagers/ShutDownHandler",
], function dalCommonClass(urlResolver, general, TAjaxer, ShutDownHandler) {
	function checkAjaxerStatus(status) {
		status.State = status.State || eAjaxerState.None;

		if (status.State === eAjaxerState.Retry) {
			// console.log('Retry the last request: ' + JSON.stringify(status.Data));
		}
	}

	function logout(reason) { 
		FxNet.SessionStorage.removeItem("TrackingSessionId");

		if (typeof $cacheManager !== "undefined" && $cacheManager) {
			$cacheManager.Unregister();
		}

		if (ShutDownHandler) {
			ShutDownHandler.StopRunningServices();
		}
 
		var reasonqs = reason ? "?" + reason : "";

		window.location = urlResolver.combine(
			urlResolver.getApplicationRelativePath(),
			"Account/Logout",
			($initialDataManager.prop.csmg || "") + reasonqs
		);
	}

	function login(reason) {
		debugger;
		FxNet.SessionStorage.removeItem("TrackingSessionId");

		var reasonqs = reason ? "?" + reason : "";

		window.location = urlResolver.combine(urlResolver.getApplicationRelativePath(), "Account/Login", reasonqs);
	}

	function exit(reason) {
		FxNet.SessionStorage.removeItem("TrackingSessionId");

		if (typeof $cacheManager !== "undefined" && $cacheManager) {
			$cacheManager.Unregister();
		}

		var reasonqs = reason ? "?" + reason : "";

		if (ShutDownHandler) {
			ShutDownHandler.StopRunningServices();
		}

		window.location = urlResolver.combine(
			urlResolver.getApplicationRelativePath(),
			"Account/Exit",
			($initialDataManager.prop.csmg || "") + reasonqs
		);
	}

	function getJWTLogin() {
		var ajaxer = new TAjaxer();
		var params = "";
		var promise = ajaxer.promises.get(
			"dalCommon/GetJWTLogin",
			"account/GetJWTLogin",
			params,
			null,
			function (error) {
				ErrorManager.onError("dalCommon/getGwtToken", "", eErrorSeverity.low);
				promise.reject(error);
			}
		);

		return promise;
	}

	function keepAlive(callback) {
		var ajaxer = new TAjaxer();
		var params = "";

		var promise = ajaxer.promises.get(
			"dalCommon/keepAlive",
			"api/clientstate/KeepAlive",
			params,
			callback,
			function () {
				ErrorManager.onError("dalCommon/keepAlive", "", eErrorSeverity.high);
			},
			0,
			1000
		);

		promise.progress(checkAjaxerStatus).done();
	}

	var switchClickedOnce = false;

	function switchAccount() {
		if (switchClickedOnce) {
			return;
		}

		switchClickedOnce = true;
		if (typeof $cacheManager !== "undefined" && $cacheManager) {
			$cacheManager.Unregister();
		}

		if (ShutDownHandler) {
			ShutDownHandler.StopRunningServices();
		}

		window.location.replace(
			urlResolver.combine(
				urlResolver.getApplicationRelativePath(),
				"Account/Switch?" + urlResolver.getRndKeyValue()
			)
		);
	}

	function addLog(source, message) {
		var ajaxer = new TAjaxer();
		var params = JSON.stringify({
			loggedErrorString: JSON.stringify({ Location: source, Info: message }),
		});

		return ajaxer.promises.jsonPost("Error/logError", "Error/Log", params).fail(function () {});
	}

	function addWarning(source, message) {
		var ajaxer = new TAjaxer();
		var params = JSON.stringify({
			loggedErrorString: JSON.stringify({ Location: source, Info: message }),
		});

		return ajaxer.promises.jsonPost("Warning/logWarning", "Error/Warn", params).fail(function () {});
	}

	function addInfo(source, message) {
		var ajaxer = new TAjaxer();
		var params = JSON.stringify({
			loggedErrorString: JSON.stringify({ Location: source, Info: message }),
		});

		return ajaxer.promises.jsonPost("logInfo", "Error/Info", params);
	}

	function logUploadActivityMessage(errorType, errorDetails, frameGuid) {
		var ajaxer = new TAjaxer();
		var params = JSON.stringify({ errorType: errorType, errorDetails: errorDetails, frameGuid: frameGuid });

		ajaxer.jsonPost(
			"Error/WriteUploadErrorActivityLog",
			"Error/WriteUploadErrorActivityLog",
			params,
			general.emptyFn,
			function () {
				ErrorManager.onError("Error/WriteUploadErrorActivityLog", "", eErrorSeverity.medium);
			}
		);
	}

	function logFrameNotLoadedMessage(errorType, errorDetails, frameGuid) {
		logUploadActivityMessage(errorType, errorDetails, frameGuid);
	}

	function logUploadCommunication(messageType, message, action) {
		var ajaxer = new TAjaxer(),
			params = JSON.stringify({ messageType: messageType, message: message, action: action });

		ajaxer.jsonPost(
			"Error/LogUploadCommunication",
			"Error/LogUploadCommunication",
			params,
			general.emptyFn,
			function () {
				ErrorManager.onError("Error/LogUploadCommunication", "", eErrorSeverity.medium);
			}
		);
	}

	function writeInfoLog(messageType, message, action) {
		var ajaxer = new TAjaxer(),
			params = JSON.stringify({ messageType: messageType, message: message, action: action });

		ajaxer.jsonPost("Error/WriteInfoLog", "Error/WriteInfoLog", params, general.emptyFn, function (error) {
			ErrorManager.onWarning("Error/WriteInfoLog", error, eErrorSeverity.medium);
		});
	}

	var module = (dalCommon = {
		GetJWTLogin: getJWTLogin,
		AddInfo: addInfo,
		AddLog: addLog,
		AddWarning: addWarning,
		Logout: logout,
		Login: login,
		SwitchAccount: switchAccount,
		Exit: exit,
		KeepAlive: keepAlive,
		LogUploadActivityMessage: logUploadActivityMessage,
		LogUploadCommunication: logUploadCommunication,
		LogFrameNotLoadedMessage: logFrameNotLoadedMessage,
		WriteInfoLog: writeInfoLog,
	});

	return module;
});

var Logger = function (dalCommon) {
    return {
        log: function log(source, message, callback, severity) {
            severity = severity || eErrorSeverity.medium;

            dalCommon
                .AddLog(source, message)
                .then(callback)
                .done();
        },
        info: function info(source, message, callback) {
            dalCommon.AddInfo(source, message)
                .then(callback)
                .done();
        },
        warn: function warn(source, message, callback, severity) {
            severity = severity || eErrorSeverity.warning;

            dalCommon
                .AddWarning(source, message)
                .then(callback)
                .done();
        },
        error: function error(source, message, callback, severity) {
            severity = severity || eErrorSeverity.low;

            dalCommon
                .AddLog(source, message)
                .then(callback)
                .done();
        }
    }
};

define("handlers/Logger", ["dataaccess/dalCommon"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (dc) {
				return this.Logger(dc);
			};
        ret = fn.apply(global, arguments);
        return ret || global.Logger;
    };
}(this)));

/*global eErrorSeverity */
define(
    "JSONHelper",
    [
        "handlers/Logger",
        "handlers/general"
    ],
    function (logger, general) {
        function JSONHelperClass() {
            function strToJson(callerName, jsonString, errorSeverity, onErrorCallback) {
                if (!general.isDefinedType(jsonString) ||
                    general.isNumberType(jsonString) ||
                    jsonString == '') {
                    return null;
                }

                if (general.isObjectType(jsonString)) {
                    return jsonString;
                }

                if (general.isNumber(jsonString)) {
                    return Number(jsonString);
                }

                // default severity is 'high'- if severity is not given the severity is high
                errorSeverity = errorSeverity || eErrorSeverity.medium;

                try {
                    return JSON.parse(jsonString);
                } catch (err) {
                    var msgJson = JSON.stringify({
                        error: "JSONHelper.STR2JSON threw an exception",
                        name: err.name,
                        message: err.message,
                        str: jsonString,
                        stack: err.stack
                    }, null, 4);

                    logger.log(callerName, msgJson, onErrorCallback, errorSeverity);

                    return null;
                }
            }

            function isValid(jsonString) {
                if (!jsonString ||
                    !general.isStringType(jsonString)) {
                    return false;
                }

                if (general.isNumber(jsonString)) {
                    return true;
                }

                if (jsonString.indexOf('[') < 0 &&
                    jsonString.indexOf('{') < 0) {
                    return false;
                }

                try {
                    return !!JSON.parse(jsonString);
                } catch (e) {
                    return false;
                }
            }

            return {
                STR2JSON: strToJson,
                IsValid: isValid
            };
        }

        JSONHelper = new JSONHelperClass();

        return JSONHelper;
    }
);


/*=============================================================================
	Author:			Eric M. Barnard - @ericmbarnard								
	License:		MIT (http://opensource.org/licenses/mit-license.php)		
																				
	Description:	Validation Library for KnockoutJS							
	Version:		2.0.4											
===============================================================================
*/
/*globals require: false, exports: false, define: false, ko: false */

(function (factory) {
	// Module systems magic dance.

	if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
		// CommonJS or Node: hard-coded dependency on "knockout"
		factory(require("knockout"), requre("JSONHelper"), exports);
	} else if (typeof define === "function" && define["amd"]) {
		// AMD anonymous module with hard-coded dependency on "knockout"
		define('vendor/knockout.validation',["knockout", "JSONHelper", "exports"], factory);
	} else {
		// <script> tag: use the global `ko` object, attaching a `validation` property
		factory(ko, JSONHelper, ko.validation = {});
	}
}(function ( ko, JSONHelper, exports ) {

	if (typeof (ko) === 'undefined') {
		throw new Error('Knockout is required, please ensure it is loaded before loading this validation plug-in');
	}

	// create our namespace object
	ko.validation = exports;

	var kv = ko.validation,
		koUtils = ko.utils,
		unwrap = koUtils.unwrapObservable,
		forEach = koUtils.arrayForEach,
		extend = koUtils.extend;
;/*global ko: false*/

var defaults = {
	registerExtenders: true,
	messagesOnModified: true,
	errorsAsTitle: true,            // enables/disables showing of errors as title attribute of the target element.
	errorsAsTitleOnModified: false, // shows the error when hovering the input field (decorateElement must be true)
	messageTemplate: null,
	insertMessages: true,           // automatically inserts validation messages as <span></span>
	parseInputAttributes: false,    // parses the HTML5 validation attribute from a form element and adds that to the object
	writeInputAttributes: false,    // adds HTML5 input validation attributes to form elements that ko observable's are bound to
	decorateInputElement: false,         // false to keep backward compatibility
	decorateElementOnModified: true,// true to keep backward compatibility
	errorClass: null,               // single class for error message and element
	errorElementClass: 'validationElement',  // class to decorate error element
	errorMessageClass: 'validationMessage',  // class to decorate error message
	allowHtmlMessages: false,		// allows HTML in validation messages
	grouping: {
		deep: false,        //by default grouping is shallow
		observable: true,   //and using observables
		live: false		    //react to changes to observableArrays if observable === true
	},
	validate: {
		// throttle: 10
	}
};

// make a copy  so we can use 'reset' later
var configuration = extend({}, defaults);

configuration.html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];
configuration.html5InputTypes = ['email', 'number', 'date'];

configuration.reset = function () {
	extend(configuration, defaults);
};

kv.configuration = configuration;
;kv.utils = (function () {
	var seedId = new Date().getTime();

	var domData = {}; //hash of data objects that we reference from dom elements
	var domDataKey = '__ko_validation__';

	return {
		isArray: function (o) {
			return o.isArray || Object.prototype.toString.call(o) === '[object Array]';
		},
		isObject: function (o) {
			return o !== null && typeof o === 'object';
		},
		isNumber: function(o) {
			return !isNaN(o);
		},
		isObservableArray: function(instance) {
			return !!instance &&
					typeof instance["remove"] === "function" &&
					typeof instance["removeAll"] === "function" &&
					typeof instance["destroy"] === "function" &&
					typeof instance["destroyAll"] === "function" &&
					typeof instance["indexOf"] === "function" &&
					typeof instance["replace"] === "function";
		},
		values: function (o) {
			var r = [];
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					r.push(o[i]);
				}
			}
			return r;
		},
		getValue: function (o) {
			return (typeof o === 'function' ? o() : o);
		},
		hasAttribute: function (node, attr) {
			return node.getAttribute(attr) !== null;
		},
		getAttribute: function (element, attr) {
			return element.getAttribute(attr);
		},
		setAttribute: function (element, attr, value) {
			return element.setAttribute(attr, value);
		},
		isValidatable: function (o) {
			return !!(o && o.rules && o.isValid && o.isModified);
		},
		insertAfter: function (node, newNode) {
			node.parentNode.insertBefore(newNode, node.nextSibling);
		},
		newId: function () {
			return seedId += 1;
		},
		getConfigOptions: function (element) {
			var options = kv.utils.contextFor(element);

			return options || kv.configuration;
		},
		setDomData: function (node, data) {
			var key = node[domDataKey];

			if (!key) {
				node[domDataKey] = key = kv.utils.newId();
			}

			domData[key] = data;
		},
		getDomData: function (node) {
			var key = node[domDataKey];

			if (!key) {
				return undefined;
			}

			return domData[key];
		},
		contextFor: function (node) {
			switch (node.nodeType) {
				case 1:
				case 8:
					var context = kv.utils.getDomData(node);
					if (context) { return context; }
					if (node.parentNode) { return kv.utils.contextFor(node.parentNode); }
					break;
			}
			return undefined;
		},
		isEmptyVal: function (val) {
			if (val === undefined) {
				return true;
			}
			if (val === null) {
				return true;
			}
			if (val === "") {
				return true;
			}
			return false;
		},
		getOriginalElementTitle: function (element) {
			var savedOriginalTitle = kv.utils.getAttribute(element, 'data-orig-title'),
				currentTitle = element.title,
				hasSavedOriginalTitle = kv.utils.hasAttribute(element, 'data-orig-title');

			return hasSavedOriginalTitle ?
				savedOriginalTitle : currentTitle;
		},
		async: function (expr) {
			if (window.setImmediate) { window.setImmediate(expr); }
			else { window.setTimeout(expr, 0); }
		},
		forEach: function (object, callback) {
			if (kv.utils.isArray(object)) {
				return forEach(object, callback);
			}
			for (var prop in object) {
				if (object.hasOwnProperty(prop)) {
					callback(object[prop], prop);
				}
			}
		}
	};
}());
;var api = (function () {

	var isInitialized = 0,
		configuration = kv.configuration,
		utils = kv.utils;

	function cleanUpSubscriptions(context) {
		forEach(context.subscriptions, function (subscription) {
			subscription.dispose();
		});
		context.subscriptions = [];
	}

	function dispose(context) {
		if (context.options.deep) {
			forEach(context.flagged, function (obj) {
				delete obj.__kv_traversed;
			});
			context.flagged.length = 0;
		}

		if (!context.options.live) {
			cleanUpSubscriptions(context);
		}
	}

	function traverseGraph(obj, context, level) {
		var objValues = [],
			val = obj.peek ? obj.peek() : obj;

		if (obj.__kv_traversed === true) {
			return;
		}

		if (context.options.deep) {
			obj.__kv_traversed = true;
			context.flagged.push(obj);
		}

		//default level value depends on deep option.
		level = (level !== undefined ? level : context.options.deep ? 1 : -1);

		// if object is observable then add it to the list
		if (ko.isObservable(obj)) {
			// ensure it's validatable but don't extend validatedObservable because it
			// would overwrite isValid property.
			if (!obj.errors && !utils.isValidatable(obj)) {
				obj.extend({ validatable: true });
			}
			context.validatables.push(obj);

			if (context.options.live && utils.isObservableArray(obj)) {
				context.subscriptions.push(obj.subscribe(function () {
					context.graphMonitor.valueHasMutated();
				}));
			}
		}

		//get list of values either from array or object but ignore non-objects
		// and destroyed objects
		if (val && !val._destroy) {
			if (utils.isArray(val)) {
				objValues = val;
			}
			else if (utils.isObject(val)) {
				objValues = utils.values(val);
			}
		}

		//process recursively if it is deep grouping
		if (level !== 0) {
			utils.forEach(objValues, function (observable) {
				//but not falsy things and not HTML Elements
				if (observable && !observable.nodeType && (!ko.isComputed(observable) || observable.rules)) {
					traverseGraph(observable, context, level + 1);
				}
			});
		}
	}

	function runTraversal(obj, context) {
		context.validatables = [];
		cleanUpSubscriptions(context);
		traverseGraph(obj, context);
		dispose(context);
	}

	function collectErrors(array) {
		var errors = [];
		forEach(array, function (observable) {
			// Do not collect validatedObservable errors
			if (utils.isValidatable(observable) && !observable.isValid()) {
				// Use peek because we don't want a dependency for 'error' property because it
				// changes before 'isValid' does. (Issue #99)
				errors.push(observable.error.peek());
			}
		});
		return errors;
	}

	return {
		//Call this on startup
		//any config can be overridden with the passed in options
		init: function (options, force) {
			//done run this multiple times if we don't really want to
			if (isInitialized > 0 && !force) {
				return;
			}

			//because we will be accessing options properties it has to be an object at least
			options = options || {};
			//if specific error classes are not provided then apply generic errorClass
			//it has to be done on option so that options.errorClass can override default
			//errorElementClass and errorMessage class but not those provided in options
			options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;
			options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;

			extend(configuration, options);

			if (configuration.registerExtenders) {
				kv.registerExtenders();
			}

			isInitialized = 1;
		},

		// resets the config back to its original state
		reset: kv.configuration.reset,

		// recursively walks a viewModel and creates an object that
		// provides validation information for the entire viewModel
		// obj -> the viewModel to walk
		// options -> {
		//	  deep: false, // if true, will walk past the first level of viewModel properties
		//	  observable: false // if true, returns a computed observable indicating if the viewModel is valid
		// }
		group: function group(obj, options) { // array of observables or viewModel
			options = extend(extend({}, configuration.grouping), options);

			var context = {
				options: options,
				graphMonitor: ko.observable(),
				flagged: [],
				subscriptions: [],
				validatables: []
			};

			var result = null;

			//if using observables then traverse structure once and add observables
			if (options.observable) {
				result = ko.computed(function () {
					context.graphMonitor(); //register dependency
					runTraversal(obj, context);
					return collectErrors(context.validatables);
				});
			}
			else { //if not using observables then every call to error() should traverse the structure
				result = function () {
					runTraversal(obj, context);
					return collectErrors(context.validatables);
				};
			}

			result.showAllMessages = function (show) { // thanks @heliosPortal
				if (show === undefined) {//default to true
					show = true;
				}

				result.forEach(function (observable) {
					if (utils.isValidatable(observable)) {
						observable.isModified(show);
					}
				});
			};

			result.isAnyMessageShown = function () {
				var invalidAndModifiedPresent;

				invalidAndModifiedPresent = !!result.find(function (observable) {
					return utils.isValidatable(observable) && !observable.isValid() && observable.isModified();
				});
				return invalidAndModifiedPresent;
			};

			result.filter = function(predicate) {
				predicate = predicate || function () { return true; };
				// ensure we have latest changes
				result();

				return koUtils.arrayFilter(context.validatables, predicate);
			};

			result.find = function(predicate) {
				predicate = predicate || function () { return true; };
				// ensure we have latest changes
				result();

				return koUtils.arrayFirst(context.validatables, predicate);
			};

			result.forEach = function(callback) {
				callback = callback || function () { };
				// ensure we have latest changes
				result();

				forEach(context.validatables, callback);
			};

			result.map = function(mapping) {
				mapping = mapping || function (item) { return item; };
				// ensure we have latest changes
				result();

				return koUtils.arrayMap(context.validatables, mapping);
			};

			/**
			 * @private You should not rely on this method being here.
			 * It's a private method and it may change in the future.
			 *
			 * @description Updates the validated object and collects errors from it.
			 */
			result._updateState = function(newValue) {
				if (!utils.isObject(newValue)) {
					throw new Error('An object is required.');
				}
				obj = newValue;
				if (options.observable) {
					context.graphMonitor.valueHasMutated();
				}
				else {
					runTraversal(newValue, context);
					return collectErrors(context.validatables);
				}
			};
			return result;
		},

		formatMessage: function (message, params, observable) {
			if (utils.isObject(params) && params.typeAttr) {
				params = params.value;
			}
			if (typeof message === 'function') {
				return message(params, observable);
			}
			var replacements = unwrap(params);
			if (replacements == null) {
				replacements = [];
			}
			if (!utils.isArray(replacements)) {
				replacements = [replacements];
			}
			return message.replace(/{(\d+)}/gi, function(match, index) {
				if (typeof replacements[index] !== 'undefined') {
					return replacements[index];
				}
				return match;
			});
		},

		// addRule:
		// This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator
		// ie: kv.addRule(myObservable, {
		//		  rule: 'required',
		//		  params: true
		//	  });
		//
		addRule: function (observable, rule) {
			observable.extend({ validatable: true });

			var hasRule = !!koUtils.arrayFirst(observable.rules(), function(item) {
				return item.rule && item.rule === rule.rule;
			});

			if (!hasRule) {
				//push a Rule Context to the observables local array of Rule Contexts
				observable.rules.push(rule);
			}
			return observable;
		},

		// addAnonymousRule:
		// Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property
		// and developers typically are wanting to add them on the fly or not register a rule with the 'kv.rules' object
		//
		// Example:
		// var test = ko.observable('something').extend{(
		//	  validation: {
		//		  validator: function(val, someOtherVal){
		//			  return true;
		//		  },
		//		  message: "Something must be really wrong!',
		//		  params: true
		//	  }
		//  )};
		addAnonymousRule: function (observable, ruleObj) {
			if (ruleObj['message'] === undefined) {
				ruleObj['message'] = 'Error';
			}

			//make sure onlyIf is honoured
			if (ruleObj.onlyIf) {
				ruleObj.condition = ruleObj.onlyIf;
			}

			//add the anonymous rule to the observable
			kv.addRule(observable, ruleObj);
		},

		addExtender: function (ruleName) {
			ko.extenders[ruleName] = function (observable, params) {
				//params can come in a few flavors
				// 1. Just the params to be passed to the validator
				// 2. An object containing the Message to be used and the Params to pass to the validator
				// 3. A condition when the validation rule to be applied
				//
				// Example:
				// var test = ko.observable(3).extend({
				//	  max: {
				//		  message: 'This special field has a Max of {0}',
				//		  params: 2,
				//		  onlyIf: function() {
				//			return specialField.IsVisible();
				//		  }
				//	  }
				//  )};
				//
				if (params && (params.message || params.onlyIf)) { //if it has a message or condition object, then its an object literal to use
					return kv.addRule(observable, {
						rule: ruleName,
						message: params.message,
						params: utils.isEmptyVal(params.params) ? true : params.params,
						condition: params.onlyIf
					});
				} else {
					return kv.addRule(observable, {
						rule: ruleName,
						params: params
					});
				}
			};
		},

		// loops through all kv.rules and adds them as extenders to
		// ko.extenders
		registerExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts
			if (configuration.registerExtenders) {
				for (var ruleName in kv.rules) {
					if (kv.rules.hasOwnProperty(ruleName)) {
						if (!ko.extenders[ruleName]) {
							kv.addExtender(ruleName);
						}
					}
				}
			}
		},

		//creates a span next to the @element with the specified error class
		insertValidationMessage: function (element) {
			var span = document.createElement('SPAN');
			span.className = utils.getConfigOptions(element).errorMessageClass;
			utils.insertAfter(element, span);
			return span;
		},

		// if html-5 validation attributes have been specified, this parses
		// the attributes on @element
		parseInputValidationAttributes: function (element, valueAccessor) {
			forEach(kv.configuration.html5Attributes, function (attr) {
				if (utils.hasAttribute(element, attr)) {

					var params = element.getAttribute(attr) || true;

					if (attr === 'min' || attr === 'max')
					{
						// If we're validating based on the min and max attributes, we'll
						// need to know what the 'type' attribute is set to
						var typeAttr = element.getAttribute('type');
						if (typeof typeAttr === "undefined" || !typeAttr)
						{
							// From http://www.w3.org/TR/html-markup/input:
							//   An input element with no type attribute specified represents the
							//   same thing as an input element with its type attribute set to "text".
							typeAttr = "text";
						}
						params = {typeAttr: typeAttr, value: params};
					}

					kv.addRule(valueAccessor(), {
						rule: attr,
						params: params
					});
				}
			});

			var currentType = element.getAttribute('type');
			forEach(kv.configuration.html5InputTypes, function (type) {
				if (type === currentType) {
					kv.addRule(valueAccessor(), {
						rule: (type === 'date') ? 'dateISO' : type,
						params: true
					});
				}
			});
		},

		// writes html5 validation attributes on the element passed in
		writeInputValidationAttributes: function (element, valueAccessor) {
			var observable = valueAccessor();

			if (!observable || !observable.rules) {
				return;
			}

			var contexts = observable.rules(); // observable array

			// loop through the attributes and add the information needed
			forEach(kv.configuration.html5Attributes, function (attr) {
				var ctx = koUtils.arrayFirst(contexts, function (ctx) {
					return ctx.rule && ctx.rule.toLowerCase() === attr.toLowerCase();
				});

				if (!ctx) {
					return;
				}

				// we have a rule matching a validation attribute at this point
				// so lets add it to the element along with the params
				ko.computed({
					read: function() {
						var params = ko.unwrap(ctx.params);

						// we have to do some special things for the pattern validation
						if (ctx.rule === "pattern" && params instanceof RegExp) {
							// we need the pure string representation of the RegExpr without the //gi stuff
							params = params.source;
						}

						element.setAttribute(attr, params);
					},
					disposeWhenNodeIsRemoved: element
				});
			});

			contexts = null;
		},

		//take an existing binding handler and make it cause automatic validations
		makeBindingHandlerValidatable: function (handlerName) {
			var init = ko.bindingHandlers[handlerName].init;

			ko.bindingHandlers[handlerName].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {

				init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);

				return ko.bindingHandlers['validationCore'].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
			};
		},

		// visit an objects properties and apply validation rules from a definition
		setRules: function (target, definition) {
			var setRules = function (target, definition) {
				if (!target || !definition) { return; }

				for (var prop in definition) {
					if (!definition.hasOwnProperty(prop)) { continue; }
					var ruleDefinitions = definition[prop];

					//check the target property exists and has a value
					if (!target[prop]) { continue; }
					var targetValue = target[prop],
						unwrappedTargetValue = unwrap(targetValue),
						rules = {},
						nonRules = {};

					for (var rule in ruleDefinitions) {
						if (!ruleDefinitions.hasOwnProperty(rule)) { continue; }
						if (kv.rules[rule]) {
							rules[rule] = ruleDefinitions[rule];
						} else {
							nonRules[rule] = ruleDefinitions[rule];
						}
					}

					//apply rules
					if (ko.isObservable(targetValue)) {
						targetValue.extend(rules);
					}

					//then apply child rules
					//if it's an array, apply rules to all children
					if (unwrappedTargetValue && utils.isArray(unwrappedTargetValue)) {
						for (var i = 0; i < unwrappedTargetValue.length; i++) {
							setRules(unwrappedTargetValue[i], nonRules);
						}
						//otherwise, just apply to this property
					} else {
						setRules(unwrappedTargetValue, nonRules);
					}
				}
			};
			setRules(target, definition);
		}
	};

}());

// expose api publicly
extend(ko.validation, api);
;//Validation Rules:
// You can view and override messages or rules via:
// kv.rules[ruleName]
//
// To implement a custom Rule, simply use this template:
// kv.rules['<custom rule name>'] = {
//      validator: function (val, param) {
//          <custom logic>
//          return <true or false>;
//      },
//      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'
// };
//
// Example:
// kv.rules['mustEqual'] = {
//      validator: function( val, mustEqualVal ){
//          return val === mustEqualVal;
//      },
//      message: 'This field must equal {0}'
// };
//
kv.rules = {};
kv.rules['required'] = {
	validator: function (val, required) {
		var testVal;

		if (val === undefined || val === null) {
			return !required;
		}

		testVal = val;
		if (typeof (val) === 'string') {
			if (String.prototype.trim) {
				testVal = val.trim();
			}
			else {
				testVal = val.replace(/^\s+|\s+$/g, '');
			}
		}

		if (!required) {// if they passed: { required: false }, then don't require this
			return true;
		}

		return ((testVal + '').length > 0);
	},
	message: 'This field is required.'
};

function minMaxValidatorFactory(validatorName) {
	var isMaxValidation = validatorName === "max";

	return function (val, options) {
		if (kv.utils.isEmptyVal(val)) {
			return true;
		}

		var comparisonValue, type;
		if (options.typeAttr === undefined) {
			// This validator is being called from javascript rather than
			// being bound from markup
			type = "text";
			comparisonValue = options;
		} else {
			type = options.typeAttr;
			comparisonValue = options.value;
		}

		// From http://www.w3.org/TR/2012/WD-html5-20121025/common-input-element-attributes.html#attr-input-min,
		// if the value is parseable to a number, then the minimum should be numeric
		if (!isNaN(comparisonValue) && !(comparisonValue instanceof Date)) {
			type = "number";
		}

		var regex, valMatches, comparisonValueMatches;
		switch (type.toLowerCase()) {
			case "week":
				regex = /^(\d{4})-W(\d{2})$/;
				valMatches = val.match(regex);
				if (valMatches === null) {
					throw new Error("Invalid value for " + validatorName + " attribute for week input.  Should look like " +
						"'2000-W33' http://www.w3.org/TR/html-markup/input.week.html#input.week.attrs.min");
				}
				comparisonValueMatches = comparisonValue.match(regex);
				// If no regex matches were found, validation fails
				if (!comparisonValueMatches) {
					return false;
				}

				if (isMaxValidation) {
					return (valMatches[1] < comparisonValueMatches[1]) || // older year
						// same year, older week
						((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2]));
				} else {
					return (valMatches[1] > comparisonValueMatches[1]) || // newer year
						// same year, newer week
						((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));
				}
				break;

			case "month":
				regex = /^(\d{4})-(\d{2})$/;
				valMatches = val.match(regex);
				if (valMatches === null) {
					throw new Error("Invalid value for " + validatorName + " attribute for month input.  Should look like " +
						"'2000-03' http://www.w3.org/TR/html-markup/input.month.html#input.month.attrs.min");
				}
				comparisonValueMatches = comparisonValue.match(regex);
				// If no regex matches were found, validation fails
				if (!comparisonValueMatches) {
					return false;
				}

				if (isMaxValidation) {
					return ((valMatches[1] < comparisonValueMatches[1]) || // older year
						// same year, older month
						((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2])));
				} else {
					return (valMatches[1] > comparisonValueMatches[1]) || // newer year
						// same year, newer month
						((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2]));
				}
				break;

			case "number":
			case "range":
				if (isMaxValidation) {
					return (!isNaN(val) && parseFloat(val) < parseFloat(comparisonValue));
				} else {
					return (!isNaN(val) && parseFloat(val) > parseFloat(comparisonValue));
				}
				break;

			default:
				if (isMaxValidation) {
					return val < comparisonValue;
				} else {
					return val > comparisonValue;
				}
		}
	};
}

kv.rules['min'] = {
	validator: minMaxValidatorFactory("min"),
	message: 'Please enter a value greater than or equal to {0}.'
};

kv.rules['max'] = {
	validator: minMaxValidatorFactory("max"),
	message: 'Please enter a value less than or equal to {0}.'
};

kv.rules['minLength'] = {
	validator: function (val, minLength) {
		if(kv.utils.isEmptyVal(val)) { return true; }
		var normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;
		return normalizedVal.length >= minLength;
	},
	message: 'Please enter at least {0} characters.'
};

kv.rules['maxLength'] = {
	validator: function (val, maxLength) {
		if(kv.utils.isEmptyVal(val)) { return true; }
		var normalizedVal = kv.utils.isNumber(val) ? ('' + val) : val;
		return normalizedVal.length <= maxLength;
	},
	message: 'Please enter no more than {0} characters.'
};

kv.rules['pattern'] = {
	validator: function (val, regex) {
		return kv.utils.isEmptyVal(val) || val.toString().match(regex) !== null;
	},
	message: 'Please check this value.'
};

kv.rules['step'] = {
	validator: function (val, step) {

		// in order to handle steps of .1 & .01 etc.. Modulus won't work
		// if the value is a decimal, so we have to correct for that
		if (kv.utils.isEmptyVal(val) || step === 'any') { return true; }
		var dif = (val * 100) % (step * 100);
		return Math.abs(dif) < 0.00001 || Math.abs(1 - dif) < 0.00001;
	},
	message: 'The value must increment by {0}.'
};

kv.rules['email'] = {
	validator: function (val, validate) {
		if (!validate) { return true; }

		//I think an empty email address is also a valid entry
		//if one want's to enforce entry it should be done with 'required: true'
		return kv.utils.isEmptyVal(val) || (
			// jquery validate regex - thanks Scott Gonzalez
			validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val)
		);
	},
	message: 'Please enter a proper email address.'
};

kv.rules['date'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));
	},
	message: 'Please enter a proper date.'
};

kv.rules['dateISO'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && /^\d{4}[-/](?:0?[1-9]|1[012])[-/](?:0?[1-9]|[12][0-9]|3[01])$/.test(value));
	},
	message: 'Please enter a proper date.'
};

kv.rules['number'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value));
	},
	message: 'Please enter a number.'
};

kv.rules['digit'] = {
	validator: function (value, validate) {
		if (!validate) { return true; }
		return kv.utils.isEmptyVal(value) || (validate && /^\d+$/.test(value));
	},
	message: 'Please enter a digit.'
};

kv.rules['phoneUS'] = {
	validator: function (phoneNumber, validate) {
		if (!validate) { return true; }
		if (kv.utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required
		if (typeof (phoneNumber) !== 'string') { return false; }
		phoneNumber = phoneNumber.replace(/\s+/g, "");
		return validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/);
	},
	message: 'Please specify a valid phone number.'
};

kv.rules['equal'] = {
	validator: function (val, params) {
		var otherValue = params;
		return val === kv.utils.getValue(otherValue);
	},
	message: 'Values must equal.'
};

kv.rules['notEqual'] = {
	validator: function (val, params) {
		var otherValue = params;
		return val !== kv.utils.getValue(otherValue);
	},
	message: 'Please choose another value.'
};

//unique in collection
// options are:
//    collection: array or function returning (observable) array
//              in which the value has to be unique
//    valueAccessor: function that returns value from an object stored in collection
//              if it is null the value is compared directly
//    external: set to true when object you are validating is automatically updating collection
kv.rules['unique'] = {
	validator: function (val, options) {
		var c = kv.utils.getValue(options.collection),
			external = kv.utils.getValue(options.externalValue),
			counter = 0;

		if (!val || !c) { return true; }

		koUtils.arrayFilter(c, function (item) {
			if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) { counter++; }
		});
		// if value is external even 1 same value in collection means the value is not unique
		return counter < (!!external ? 1 : 2);
	},
	message: 'Please make sure the value is unique.'
};

//custom rules:

kv.rules['rate'] = {
    validator: function (value, validate) {
        if (!validate) { return true; }
        return kv.utils.isEmptyVal(value) || (validate && /^\d*\,?\d*\.?\d*$/.test(value));
    },
    message: 'Invalid Rate'
};

kv.rules['amount'] = {
    validator: function (value, validate) {
        if (!validate) { return true; }
        return kv.utils.isEmptyVal(value) || (validate && /^\d*\,?\d*\.?\d*$/.test(value));
    },
    message: 'Invalid Amount'
};


   
//********************************************
//1. Number(str): Convert str to a number; the number may well have a fractional portion, or may be NaN.
//2. Math.floor: Truncate the number (chops off any fractional portion).
//3. String(...): Converts the result back into a normal decimal string.
//4. ... === str: Compares that to the original string.
//5. n > 0: Check that it's positive.    
//********************************************
kv.rules['positiveInteger'] = {
    validator: function (value, validate) {
         if (!validate) { return true; }
        var n = Math.floor(Number(value));
        return kv.utils.isEmptyVal(value) || (n == value && n > 0);
    },
    message: 'Invalid positiveInteger'
};

kv.rules['range'] = {
    validator: function (value, range) {
         if (!range) { return true; }
        var isB;
        if (range.isBetween == undefined)
            isB = true;
        else
            isB = range.isBetween;
        if (isB)
            return (kv.utils.isEmptyVal(value) || (value > range.min && value < range.max));
        else
            return (kv.utils.isEmptyVal(value) || (value > range.min || value < range.max));
    },
    message: 'Invalid Range'
};

kv.rules['rangeInterval'] = {
    validator: function (value, rangeinterval) {
        if (!rangeinterval) { return true; }
        
         

        var numericValue = typeof (value) === 'string' && value !== ""
       ? Globalize.parseFloat(value)
       : value;

        var r1 = (numericValue > rangeinterval.minfar && numericValue < rangeinterval.minnear);
        var r2 = (numericValue > rangeinterval.maxnear && numericValue < rangeinterval.maxfar);
        var res = kv.utils.isEmptyVal(numericValue) || r1 || r2;
        //window.console.log("value: " + value + "[ " + rangeinterval.minfar + " .. " + rangeinterval.minnear + " ] [" + rangeinterval.maxnear + ".." + rangeinterval.maxfar + " ] :" + res);
        return res;

    },
    message: 'Invalid rangeinterval'
    // invalid IF value is outer interval:  [minfar...  minnear] [maxnear.. maxfar] 
    // ex: 1.1,1.25,1.6 are INVALID 
    // ex: 1.1,1.4 are VALID
    // in the following range [1.0 .. 1.2] [1.3 .. 1.5]
};

kv.rules['in'] = {
	validator: function (val, params) {
		var possibleValues = params;
		return possibleValues.contains(val);
	},
	message: ""
};

kv.rules['asyncValidator'] = {
	async: true,
	validator: function (val, func, callback) {
		func(val, function (data) {
			var response = JSONHelper.STR2JSON(func.name, data);
			callback(Boolean.parse(response));
		}, function () {
			callback(false);
		});

	},
	message: ""
};

kv.rules['phoneNumber'] = {
	validator: function (phoneNumber, validate) {
		if (!validate) return true;
		if (typeof (phoneNumber) !== 'string') { return false; }
		if ((phoneNumber === "")) { return true; } // makes it optional, use 'required' rule if it should be required
		
		return validate && phoneNumber.match(/^(?=(?:\D*\d){5,})(\(?\+?\d{1,3}\)?\s*[-]?\s*)+\d*$/);
	},
	message: 'Please specify a valid phone number'
};

kv.rules['minAge18'] = {
	validator: function (val, validate) {
		if (validate && (val.indexOf("undefined") !== -1 || val.indexOf("...") !== -1)) { return false; }

		var formDateValues = val.split('/'),
			day = parseInt(formDateValues[0]),
			month = parseInt(formDateValues[1]),
			year = parseInt(formDateValues[2]),
			currdate = new Date(),
			age = 18,
			formDate = (year + '-' + month + '-' + day).toString();


		try {
			var myDate = $.datepicker.parseDate("yy-mm-dd", formDate);
			month = month - 1;
			myDate.setFullYear(year, month, day);
			currdate.setFullYear(currdate.getFullYear() - age);
			if ((currdate - myDate) < 0) {
				return false;
			}
			return true;

		} catch (e) {
			return false;
		}

	},
	message: 'You must be at least {0} years of age.'
};


//now register all of these!
(function () {
	kv.registerExtenders();
}());
;// The core binding handler
// this allows us to setup any value binding that internally always
// performs the same functionality
ko.bindingHandlers['validationCore'] = (function () {

	return {
		init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var config = kv.utils.getConfigOptions(element);
			var observable = valueAccessor();

			// parse html5 input validation attributes, optional feature
			if (config.parseInputAttributes) {
				kv.utils.async(function () { kv.parseInputValidationAttributes(element, valueAccessor); });
			}

			// if requested insert message element and apply bindings
			if (config.insertMessages && kv.utils.isValidatable(observable)) {

				// insert the <span></span>
				var validationMessageElement = kv.insertValidationMessage(element);

				// if we're told to use a template, make sure that gets rendered
				if (config.messageTemplate) {
					ko.renderTemplate(config.messageTemplate, { field: observable }, null, validationMessageElement, 'replaceNode');
				} else {
					ko.applyBindingsToNode(validationMessageElement, { validationMessage: observable });
				}
			}

			// write the html5 attributes if indicated by the config
			if (config.writeInputAttributes && kv.utils.isValidatable(observable)) {

				kv.writeInputValidationAttributes(element, valueAccessor);
			}

			// if requested, add binding to decorate element
			if (config.decorateInputElement && kv.utils.isValidatable(observable)) {
				ko.applyBindingsToNode(element, { validationElement: observable });
			}
		}
	};

}());

// override for KO's default 'value', 'checked', 'textInput' and selectedOptions bindings
kv.makeBindingHandlerValidatable("value");
kv.makeBindingHandlerValidatable("checked");
if (ko.bindingHandlers.textInput) {
	kv.makeBindingHandlerValidatable("textInput");
}
kv.makeBindingHandlerValidatable("selectedOptions");


ko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding
	update: function (element, valueAccessor) {
		var obsv = valueAccessor(),
			config = kv.utils.getConfigOptions(element),
			val = unwrap(obsv),
			msg = null,
			isModified = false,
			isValid = false;

		if (obsv === null || typeof obsv === 'undefined') {
			throw new Error('Cannot bind validationMessage to undefined value. data-bind expression: ' +
				element.getAttribute('data-bind'));
		}

		isModified = obsv.isModified && obsv.isModified();
		isValid = obsv.isValid && obsv.isValid();

		var error = null;
		if (!config.messagesOnModified || isModified) {
			error = isValid ? null : obsv.error;
		}

		var isVisible = !config.messagesOnModified || isModified ? !isValid : false;
		var isCurrentlyVisible = element.style.display !== "none";

		if (config.allowHtmlMessages) {
			koUtils.setHtml(element, error);
		} else {
			ko.bindingHandlers.text.update(element, function () { return error; });
		}

		if (isCurrentlyVisible && !isVisible) {
			element.style.display = 'none';
		} else if (!isCurrentlyVisible && isVisible) {
			element.style.display = '';
		}
	}
};

ko.bindingHandlers['validationElement'] = {
	update: function (element, valueAccessor, allBindingsAccessor) {
		var obsv = valueAccessor(),
			config = kv.utils.getConfigOptions(element),
			val = unwrap(obsv),
			msg = null,
			isModified = false,
			isValid = false;

		if (obsv === null || typeof obsv === 'undefined') {
			throw new Error('Cannot bind validationElement to undefined value. data-bind expression: ' +
				element.getAttribute('data-bind'));
		}

		isModified = obsv.isModified && obsv.isModified();
		isValid = obsv.isValid && obsv.isValid();

		// create an evaluator function that will return something like:
		// css: { validationElement: true }
		var cssSettingsAccessor = function () {
			var css = {};

			var shouldShow = ((!config.decorateElementOnModified || isModified) ? !isValid : false);

			// css: { validationElement: false }
			css[config.errorElementClass] = shouldShow;

			return css;
		};

		//add or remove class on the element;
		ko.bindingHandlers.css.update(element, cssSettingsAccessor, allBindingsAccessor);
		if (!config.errorsAsTitle) { return; }

		ko.bindingHandlers.attr.update(element, function () {
			var
				hasModification = !config.errorsAsTitleOnModified || isModified,
				title = kv.utils.getOriginalElementTitle(element);

			if (hasModification && !isValid) {
				return { title: obsv.error, 'data-orig-title': title };
			} else if (!hasModification || isValid) {
				return { title: title, 'data-orig-title': null };
			}
		});
	}
};

// ValidationOptions:
// This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements
//
// Example:
// <div data-bind="validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}">
//      <input type="text" data-bind="value: someValue"/>
//      <input type="text" data-bind="value: someValue2"/>
// </div>
ko.bindingHandlers['validationOptions'] = (function () {
	return {
		init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
			var options = unwrap(valueAccessor());
			if (options) {
				var newConfig = extend({}, kv.configuration);
				extend(newConfig, options);

				//store the validation options on the node so we can retrieve it later
				kv.utils.setDomData(element, newConfig);
			}
		}
	};
}());
;// Validation Extender:
// This is for creating custom validation logic on the fly
// Example:
// var test = ko.observable('something').extend{(
//      validation: {
//          validator: function(val, someOtherVal){
//              return true;
//          },
//          message: "Something must be really wrong!',
//          params: true
//      }
//  )};
ko.extenders['validation'] = function (observable, rules) { // allow single rule or array
	forEach(kv.utils.isArray(rules) ? rules : [rules], function (rule) {
		// the 'rule' being passed in here has no name to identify a core Rule,
		// so we add it as an anonymous rule
		// If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples
		kv.addAnonymousRule(observable, rule);
	});
	return observable;
};

//This is the extender that makes a Knockout Observable also 'Validatable'
//examples include:
// 1. var test = ko.observable('something').extend({validatable: true});
// this will ensure that the Observable object is setup properly to respond to rules
//
// 2. test.extend({validatable: false});
// this will remove the validation properties from the Observable object should you need to do that.
ko.extenders['validatable'] = function (observable, options) {
	if (!kv.utils.isObject(options)) {
		options = { enable: options };
	}

	if (!('enable' in options)) {
		options.enable = true;
	}

	if (options.enable && !kv.utils.isValidatable(observable)) {
		var config = kv.configuration.validate || {};
		var validationOptions = {
			throttleEvaluation : options.throttle || config.throttle
		};

		observable.error = ko.observable(null); // holds the error message, we only need one since we stop processing validators when one is invalid

		// observable.rules:
		// ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it
		//
		// Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }
		observable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation

		//in case async validation is occurring
		observable.isValidating = ko.observable(false);

		//the true holder of whether the observable is valid or not
		observable.__valid__ = ko.observable(true);

		observable.isModified = ko.observable(false);

		// a semi-protected observable
		observable.isValid = ko.computed(observable.__valid__);

		//manually set error state
		observable.setError = function (error) {
			var previousError = observable.error.peek();
			var previousIsValid = observable.__valid__.peek();

			observable.error(error);
			observable.__valid__(false);

			if (previousError !== error && !previousIsValid) {
				// if the observable was not valid before then isValid will not mutate,
				// hence causing any grouping to not display the latest error.
				observable.isValid.notifySubscribers();
			}
		};

		//manually clear error state
		observable.clearError = function () {
			observable.error(null);
			observable.__valid__(true);
			return observable;
		};

		//subscribe to changes in the observable
		var h_change = observable.subscribe(function () {
			observable.isModified(true);
		});

		// we use a computed here to ensure that anytime a dependency changes, the
		// validation logic evaluates
		var h_obsValidationTrigger = ko.computed(extend({
			read: function () {
				var obs = observable(),
					ruleContexts = observable.rules();

				kv.validateObservable(observable);

				return true;
			}
		}, validationOptions));

		extend(h_obsValidationTrigger, validationOptions);

		observable._disposeValidation = function () {
			//first dispose of the subscriptions
			observable.isValid.dispose();
			observable.rules.removeAll();
			h_change.dispose();
			h_obsValidationTrigger.dispose();

			delete observable['rules'];
			delete observable['error'];
			delete observable['isValid'];
			delete observable['isValidating'];
			delete observable['__valid__'];
			delete observable['isModified'];
            delete observable['setError'];
            delete observable['clearError'];
            delete observable['_disposeValidation'];
		};
	} else if (options.enable === false && observable._disposeValidation) {
		observable._disposeValidation();
	}
	return observable;
};

function validateSync(observable, rule, ctx) {
	//Execute the validator and see if its valid
	if (!rule.validator(observable(), (ctx.params === undefined ? true : unwrap(ctx.params)))) { // default param is true, eg. required = true

		//not valid, so format the error message and stick it in the 'error' variable
		observable.setError(kv.formatMessage(
					ctx.message || rule.message,
					unwrap(ctx.params),
					observable));
		return false;
	} else {
		return true;
	}
}

function validateAsync(observable, rule, ctx) {
	observable.isValidating(true);

	var callBack = function (valObj) {
		var isValid = false,
			msg = '';

		if (!observable.__valid__()) {

			// since we're returning early, make sure we turn this off
			observable.isValidating(false);

			return; //if its already NOT valid, don't add to that
		}

		//we were handed back a complex object
		if (valObj['message']) {
			isValid = valObj.isValid;
			msg = valObj.message;
		} else {
			isValid = valObj;
		}

		if (!isValid) {
			//not valid, so format the error message and stick it in the 'error' variable
			observable.error(kv.formatMessage(
				msg || ctx.message || rule.message,
				unwrap(ctx.params),
				observable));
			observable.__valid__(isValid);
		}

		// tell it that we're done
		observable.isValidating(false);
	};

	kv.utils.async(function() {
	    //fire the validator and hand it the callback
        rule.validator(observable(), ctx.params === undefined ? true : unwrap(ctx.params), callBack);
	});
}

kv.validateObservable = function (observable) {
	var i = 0,
		rule, // the rule validator to execute
		ctx, // the current Rule Context for the loop
		ruleContexts = observable.rules(), //cache for iterator
		len = ruleContexts.length; //cache for iterator

	for (; i < len; i++) {

		//get the Rule Context info to give to the core Rule
		ctx = ruleContexts[i];

		// checks an 'onlyIf' condition
		if (ctx.condition && !ctx.condition()) {
			continue;
		}

		//get the core Rule to use for validation
		rule = ctx.rule ? kv.rules[ctx.rule] : ctx;

		if (rule['async'] || ctx['async']) {
			//run async validation
			validateAsync(observable, rule, ctx);

		} else {
			//run normal sync validation
			if (!validateSync(observable, rule, ctx)) {
				return false; //break out of the loop
			}
		}
	}
	//finally if we got this far, make the observable valid again!
	observable.clearError();
	return true;
};
;
var _locales = {};
var _currentLocale;

kv.defineLocale = function(name, values) {
	if (name && values) {
		_locales[name.toLowerCase()] = values;
		return values;
	}
	return null;
};

kv.locale = function(name) {
	if (name) {
		name = name.toLowerCase();

		if (_locales.hasOwnProperty(name)) {
			kv.localize(_locales[name]);
			_currentLocale = name;
		}
		else {
			throw new Error('Localization ' + name + ' has not been loaded.');
		}
	}
	return _currentLocale;
};

//quick function to override rule messages
kv.localize = function (msgTranslations) {
	var rules = kv.rules;

	//loop the properties in the object and assign the msg to the rule
	for (var ruleName in msgTranslations) {
		if (rules.hasOwnProperty(ruleName)) {
			rules[ruleName].message = msgTranslations[ruleName];
		}
	}
};

// Populate default locale (this will make en-US.js somewhat redundant)
(function() {
	var localeData = {};
	var rules = kv.rules;

	for (var ruleName in rules) {
		if (rules.hasOwnProperty(ruleName)) {
			localeData[ruleName] = rules[ruleName].message;
		}
	}
	kv.defineLocale('en-us', localeData);
})();

// No need to invoke locale because the messages are already defined along with the rules for en-US
_currentLocale = 'en-us';
;/**
 * Possible invocations:
 * 		applyBindingsWithValidation(viewModel)
 * 		applyBindingsWithValidation(viewModel, options)
 * 		applyBindingsWithValidation(viewModel, rootNode)
 *		applyBindingsWithValidation(viewModel, rootNode, options)
 */
ko.applyBindingsWithValidation = function (viewModel, rootNode, options) {
	var node = document.body,
		config;

	if (rootNode && rootNode.nodeType) {
		node = rootNode;
		config = options;
	}
	else {
		config = rootNode;
	}

	kv.init();

	if (config) {
		config = extend(extend({}, kv.configuration), config);
		kv.utils.setDomData(node, config);
	}

	ko.applyBindings(viewModel, node);
};

//override the original applyBindings so that we can ensure all new rules and what not are correctly registered
var origApplyBindings = ko.applyBindings;
ko.applyBindings = function () {
	kv.init();
	origApplyBindings.apply(this, arguments);
};

ko.validatedObservable = function (initialValue, options) {
	if (!options && !kv.utils.isObject(initialValue)) {
		return ko.observable(initialValue).extend({ validatable: true });
	}

	var obsv = ko.observable(initialValue);
	obsv.errors = kv.group(kv.utils.isObject(initialValue) ? initialValue : {}, options);
	obsv.isValid = ko.observable(obsv.errors().length === 0);

	if (ko.isObservable(obsv.errors)) {
		obsv.errors.subscribe(function(errors) {
			obsv.isValid(errors.length === 0);
		});
	}
	else {
		ko.computed(obsv.errors).subscribe(function (errors) {
			obsv.isValid(errors.length === 0);
		});
	}

	obsv.subscribe(function(newValue) {
		if (!kv.utils.isObject(newValue)) {
			/*
			 * The validation group works on objects.
			 * Since the new value is a primitive (scalar, null or undefined) we need
			 * to create an empty object to pass along.
			 */
			newValue = {};
		}
		// Force the group to refresh
		obsv.errors._updateState(newValue);
		obsv.isValid(obsv.errors().length === 0);
	});

	return obsv;
};
;}));
define(
    'helpers/ObservableCustomExtender',
    [
        'knockout',
        'handlers/general',
        'vendor/knockout.validation'
    ],
    function (ko, general) {
        ko.extenders.dirty = function dirtyKoExtender(target, startDirty) {
            target.cleanValue = ko.observable(ko.toJS(target)); // the cleanValue is normalized
            target.originalValue = target.cleanValue;
            target.dirtyOverride = ko.observable(ko.utils.unwrapObservable(startDirty));

            target.isDirty = ko.computed(function isDirtyHandler() {
                // get normalized observable value
                var currentValue = ko.toJS(this),
                    cleanValue = this.cleanValue(),
                    dirtyOverride = this.dirtyOverride(),
                    result;

                if (typeof currentValue == 'object') {
                    result = dirtyOverride || !general.equals(currentValue, cleanValue);
                }
                else if (isNaN(currentValue) || isNaN(cleanValue)) {
                    result = dirtyOverride || currentValue !== cleanValue;
                }
                else {
                    result = dirtyOverride || Number(currentValue) != Number(cleanValue);
                }

                return result;
            }, target);

            target.markClean = function markClean() {
                this.cleanValue(ko.toJS(this));
                this.dirtyOverride(false);
            };

            target.markDirty = function markDirty() {
                this.dirtyOverride(true);
            };

            return target;
        };

        ko.extenders.toNumericLength = function toNumericLengthKoExtender(target, options) {
            if (options !== false && target) {
                if (target.toNumericLengthSubscriber &&
                    general.isFunctionType(target.toNumericLengthSubscriber.dispose)) {
                    target.toNumericLengthSubscriber.dispose();
                }

                target.toNumericLengthSubscriber = target.subscribe(function (value) {
                    var observable = this,
                        maxValue = Number.MAX_SAFE_INTEGER,
                        ranges = options.ranges,
                        isAllowNAValue = ko.utils.unwrapObservable(options.isAllowNAValue),
                        isForceCeil = ko.utils.unwrapObservable(options.isForceCeil),
                        valueAsNumber = general.toNumeric(value);

                    if (value === '') {
                        return;
                    }

                    if (isAllowNAValue && value === 'NA') {
                        return;
                    }

                    if (valueAsNumber != 'NA' && valueAsNumber <= maxValue) {
                        valueAsNumber = Math.abs(valueAsNumber);
                        var decimalDigits = getDecimalDigits(valueAsNumber, ranges),
                            currentNumberOfDecimalDigits = general.lenAfterDelimeter(valueAsNumber);

                        if (currentNumberOfDecimalDigits > decimalDigits) {
                            var multiplier = Math.pow(10, decimalDigits);

                            if (isForceCeil) {
                                valueAsNumber = Math.ceil(valueAsNumber * multiplier) / multiplier;
                            } else {
                                valueAsNumber = Math.floor(valueAsNumber * multiplier) / multiplier;
                            }
                        }

                        if (valueAsNumber != value) {
                            observable(valueAsNumber);
                        }
                    }
                    else {
                        observable('');
                    }
                }, target);

            }
            else if (target && target.toNumericLengthSubscriber) {
                target.toNumericLengthSubscriber.dispose();
                target.toNumericLengthSubscriber = null;
            }

            function getDecimalDigits(value, ranges) {
                var range = ranges.find(function (item) {
                    return (value >= item.from && value < item.to);
                });

                return range.decimalDigits;
            }

            return target;
        }

        ko.extenders.amountValidation = function amountValidationKoExtender(target, options) {
            if (options !== false && target) {
                var dealsAmounts = ko.utils.unwrapObservable(options);
                target.minAmount = ko.observable();
                target.maxAmount = ko.observable();

                target.minAmount(dealsAmounts.reduce(function (accumulator, value) {
                    return Math.min(accumulator, value);
                },
                    dealsAmounts[0] || 0));

                target.maxAmount(dealsAmounts.reduce(function (accumulator, value) {
                    return Math.max(accumulator, value);
                },
                    dealsAmounts[dealsAmounts.length - 1] || 10000000000));

                removeAmountValidation();

                target.validationRule = ko.validation.addAnonymousRule(target, {
                    validator: function (value) {
                        var valueToCheck = general.toNumeric(value);
                        if (isNaN(valueToCheck)) {
                            valueToCheck = -1; // Invalid value for all possible cases
                        }
                        return target.minAmount() <= valueToCheck && valueToCheck <= target.maxAmount();
                    },
                    params: true
                });
            }
            else if (options === false && target) {
                removeAmountValidation();
            }

            function removeAmountValidation() {
                if (general.isDefinedType(target.rules) && !general.isEmptyValue(target.validationRule)) {
                    var prevValidationRule = target.rules().find(function (item) {
                        return item.rule === target.validationRule;
                    });

                    if (prevValidationRule) {
                        target.rules.remove(prevValidationRule);
                    }
                }
            }
        };

        ko.extenders.empty = function emptyKoExtender(target, enable) {
            if (enable && !target.isEmpty) {
                target.isEmpty = ko.computed(function isEmptyHandler() {
                    var value = ko.utils.unwrapObservable(this);
                    return general.isEmptyValue(value);
                }, target);
            }
            else if (target.isEmpty) {
                target.isEmpty.dispose();
            }

            return target;
        };

        ko.extenders.triggerValidation = function triggerValidationKoExtender(target, enable) {
            if (enable && ko.validation.utils.isValidatable(target)) {
                target.triggerValidation = function triggerValidation() {
                    var value = ko.utils.unwrapObservable(this);
                    this.notifySubscribers(value);
                };
            }
            else if (!enable && target.triggerValidation) {
                target.triggerValidation = null;
            }

            return target;
        };

        // Tooltip validation can be added only for observable who extend ko validation 
        // The message for tooltip validation can be set in observable extend with a new value
        ko.extenders.tooltipValidation = function tooltipValidationKoExtender(target, options) {
            if (options !== false) {
                target.tooltipClosed = ko.observable(false);
                target.dummyObservable = ko.observable('');
                target.tooltipVisible = ko.pureComputed(function tooltipVisibleHandler() {
                    var showTooltip = this.showTooltip(),
                        isValid = this.isValid(),
                        isClosed = this.tooltipClosed();

                    this.dummyObservable.notifySubscribers();

                    return !isClosed && !isValid && showTooltip;
                }, target);

                target.showTooltip = ko.pureComputed(typeof options.showTooltip === 'function' ? options.showTooltip : function () { return true; });

                target.closeTooltip = function closeTooltip() {
                    this.tooltipClosed(true);
                };

                target.resetTooltip = function resetTooltip() {
                    this.tooltipClosed(false);
                };

                target._selfSubscriber = target.subscribe(function () {
                    this.tooltipClosed(false);
                }, target);

                target.tooltipMessage = ko.pureComputed(function tooltipMessageHandler() {
                    this.dummyObservable();

                    if (options.message) {
                        return options.message;
                    }

                    return this.error;
                }, target);

                if (ko.validation.utils.isValidatable(target)) {
                    if (options.notify === 'always') {
                        target.__valid__ = target.__valid__.extend({ notify: 'always' });
                        target.isValid = target.isValid.extend({ notify: 'always' });
                    }
                }
            }
            else {
                var disposableProps = ['tooltipMessage', '_selfSubscriber', 'showTooltip', 'tooltipVisible'],
                    nullableProps = ['resetTooltip', 'closeTooltip', 'dummyObservable', 'tooltipClosed'];
                disposableProps.forEach(function (prop) {
                    if (target[prop]) {
                        target[prop].dispose();
                        delete target[prop];
                    }
                });

                nullableProps.forEach(function (prop) {
                    if (target[prop]) {
                        target[prop] = null;
                        delete target[prop];
                    }
                });
            }

            return target;
        };

        /**
         * Extend an observable to support incremental value update, 
         * adding increment and decrement methods on target observable
         * 
         * For more details, see {@link ObservableExtenderTest.js}
         * 
         * If options === false, then the incremental logic is removed from observable 
         * @param {ko.observable} target observable to extend
         * @param {Object} options incremental values: units, tenths, hundreds, thousands
         * @returns {ko.observable}  target
         */
        ko.extenders.incremental = function incrementalKoExtender(target, options) {
            if (options !== false) {
                options = options || {};

                var defaults = {
                    precision: 4,
                    ranges: [
                        { from: 0, to: 10, step: 1 }, // units
                        { from: 10, to: 100, step: 5 }, // tens
                        { from: 100, to: 1000, step: 50 }, // hundreds
                        { from: 1000, to: Number.MAX_VALUE, step: 500 } // thousands
                    ]
                };

                options = ko.utils.extend(defaults, options);

                var getStepValue = function (currentValue) {
                    var foundRange = options.ranges.find(function (item) {
                        return currentValue >= item.from && currentValue < item.to;
                    });

                    if (!foundRange) {
                        return 1;
                    }

                    return foundRange.step;
                };

                var normalizeValue = function (direction, value, precision) {
                    value = Number(value);

                    var multiplier = Math.pow(10, precision),
                        currentStep = getStepValue(value),
                        multipliedCurrentStep = Math.floor(currentStep * multiplier),
                        multipliedValue = Math.floor(value * multiplier),
                        valueToReturn = multipliedValue,
                        newValue,
                        mod;

                    if (direction === 'up') {
                        newValue = multipliedValue + multipliedCurrentStep;
                        mod = newValue % multipliedCurrentStep;

                        valueToReturn = newValue - mod;

                    }
                    else if (direction === 'down') {
                        newValue = multipliedValue - multipliedCurrentStep;
                        mod = newValue % multipliedCurrentStep;

                        if (mod !== 0) {
                            valueToReturn = multipliedValue - mod;
                        }
                        else {
                            var nextStep = getStepValue(value - currentStep);
                            var multipliedNextStep = nextStep * multiplier;

                            valueToReturn = multipliedValue - multipliedNextStep;
                        }
                    }

                    return valueToReturn / multiplier;
                };

                target.increment = function increment(doNotUpdate) {
                    var newValue = normalizeValue('up', this(), options.precision);

                    if (!doNotUpdate) {
                        this(newValue);
                    }

                    return newValue;
                };

                target.decrement = function decrement(doNotUpdate) {
                    var newValue = normalizeValue('down', this(), options.precision);

                    if (!doNotUpdate) {
                        this(newValue);
                    }

                    return newValue;
                };

                target.step = ko.computed(function () {
                    return getStepValue(target());
                });

                // Extend ko.observable
                ko.subscribable.fn.isIncremental = function isIncremental() {
                    var observable = this;

                    return (typeof observable.increment === 'function') && (typeof observable.decrement === 'function');
                };
            }
            else {
                if (target.step) {
                    target.step.dispose();
                }

                target.step = null;
                target.increment = null;
                target.decrement = null;
            }

            return target;
        }

        return ko;
    }
);

Object.keys = Object.keys || (function () {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !{ toString: null}.propertyIsEnumerable("toString"),
        DontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
        ],
        DontEnumsLength = DontEnums.length;

    return function (o) {
        if (typeof o != "object" && typeof o != "function" || o === null)
            throw new TypeError("Object.keys called on a non-object");

        var result = [];
        for (var name in o) {
            if (hasOwnProperty.call(o, name))
                result.push(name);
        }

        if (hasDontEnumBug) {
            for (var i = 0; i < DontEnumsLength; i++) {
                if (hasOwnProperty.call(o, DontEnums[i]))
                    result.push(DontEnums[i]);
            }
        }

        return result;
    };
})();

if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
      value: function assign(target, varArgs) { // .length of function is 2
        'use strict';
        if (target == null) { // TypeError if undefined or null
          throw new TypeError('Cannot convert undefined or null to object');
        }
  
        var to = Object(target);
  
        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];
  
          if (nextSource != null) { // Skip over if undefined or null
            for (var nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      },
      writable: true,
      configurable: true
    });
}

/*
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
Object.create Polyfill
This polyfill covers the main use case which is creating a new object for which the prototype 
has been chosen but doesn't take the second argument into account.
*/
if (typeof Object.create != 'function') {
  Object.create = (function() {
      var F = function() { };
      return function(prototype) {
          if (arguments.length > 1) {
              throw Error('Second argument not supported');
          }
          if (typeof prototype != 'object') {
              throw TypeError('Argument must be an object');
          }
          F.prototype = prototype;
          var result = new F();
          F.prototype = null;
          return result;
      };
  })();
}

Object.isEmpty = Object.isEmpty || function(obj) {
    return Object.keys(obj).length === 0 && JSON.stringify(obj) === JSON.stringify({});
};
define("extensions/Object", function(){});

/* eslint no-extend-native: 0 */
function addMemberOnObject(memberName, memberDefinition, targetObject) {
    if (typeof (Browser) !== "undefined" && Browser.isDefinePropertySupported()) {
        Object.defineProperty(targetObject, memberName, {
            value: memberDefinition,
            writable: true,
            enumerable: false,
            configurable: true
        });
    } else {
        targetObject[memberName] = memberDefinition;
    }
}

function addMemberOnArrayPrototype(memberName, memberDefinition) {
    addMemberOnObject(memberName, memberDefinition, Array.prototype);
}

function addMemberOnArray(memberName, memberDefinition) {
    addMemberOnObject(memberName, memberDefinition, Array);
}

addMemberOnArrayPrototype("remove",
    function (group) {
        var tmp = [];

        for (var i = 0; i < this.length; i++) {
            if (group.indexAt(this[i]) === -1) {
                tmp.push(this[i]);
            }
        }

        return tmp;
    });

//-------------------------------------------------------

addMemberOnArrayPrototype("removeItem",
    function(key) {
        var index = this.indexAt(key);

        if (index > -1) {
            this.splice(index, 1);
        }
    });

//-------------------------------------------------------

addMemberOnArrayPrototype("clear",
    function () {
        while (this.length > 0) {
            this.pop();
        }
    });

//-------------------------------------------------------

addMemberOnArrayPrototype("compareTo",
    function (testArr) {

        if (this.length !== testArr.length)
            return false;

        for (var i = 0; i < testArr.length; i++) {
            if (this[i].compare)
                if(!this[i].compare(testArr[i]))
                    return false;

            if (this[i] !== testArr[i])
                return false;
        }

        return true;
    });

//--------------------------------------------------------

addMemberOnArrayPrototype("indexAt", 
    function(what) {
        var length = this.length,
            i = 0;

        while (i < length) {
            if (this[i] === what) {
                return i;
            }

            ++i;
        }
    
        return -1;
    });

//--------------------------------------------------------

addMemberOnArrayPrototype("addUnique",
    function (what) {
        if (this.indexAt(what) === -1) {
            this.push(what);
        }

        return this;
    });

//--------------------------------------------------------

addMemberOnArrayPrototype("contains", 
    function(obj) {
        var i = this.length;
    
        while (i--) {
            if (this[i] == obj) { // eslint-disable-line
                return true;
            }
        }
    
        return false;
    });

//--------------------------------------------------------

// Polyfill
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Compatibility

if (!Array.isArray) {
    addMemberOnArray("isArray", 
        function (arg) {
            return Object.prototype.toString.call(arg) === '[object Array]';
        });
}


//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill
if (!Array.prototype.find) {
    addMemberOnArrayPrototype("find", 
        function (predicate) {
            if (this == null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;

            for (var i = 0; i < length; i++) {
                if (i in list) {
                    value = list[i];
                    if (predicate.call(thisArg, value, i, list)) {
                        return value;
                    }
                }
            }
            return undefined;
        });


    //https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Compatibility
    if (!Array.prototype.filter) {
        addMemberOnArrayPrototype("filter", 
            function (fun /*, thisArg */) {
                "use strict";

                if (this === void 0 || this === null)
                    throw new TypeError();

                var t = Object(this);
                var len = t.length >>> 0;
                if (typeof fun !== "function")
                    throw new TypeError();

                var res = [];
                var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
                for (var i = 0; i < len; i++) {
                    if (i in t) {
                        var val = t[i];

                        // NOTE: Technically this should Object.defineProperty at
                        //       the next index, as push can be affected by
                        //       properties on Object.prototype and Array.prototype.
                        //       But that method's new, and collisions should be
                        //       rare, so use the more-compatible alternative.
                        if (fun.call(thisArg, val, i, t))
                            res.push(val);
                    }
                }

                return res;
            });
    }
}
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#Polyfill
if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
        value: function (predicate) {
            'use strict';
            if (this == null) {
                throw new TypeError('Array.prototype.findIndex called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(thisArg, value, i, list)) {
                    return i;
                }
            }
            return -1;
        },
        enumerable: false,
        configurable: true,
        writable: true
    });
}
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
if (!Array.prototype.indexOf) {
    addMemberOnArrayPrototype("indexOf", 
        function (searchElement, fromIndex) {

            var k;

            // 1. Let O be the result of calling ToObject passing
            //    the this value as the argument.
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }

            var O = Object(this);

            // 2. Let lenValue be the result of calling the Get
            //    internal method of O with the argument "length".
            // 3. Let len be ToUint32(lenValue).
            var len = O.length >>> 0;

            // 4. If len is 0, return -1.
            if (len === 0) {
                return -1;
            }

            // 5. If argument fromIndex was passed let n be
            //    ToInteger(fromIndex); else let n be 0.
            var n = +fromIndex || 0;

            if (Math.abs(n) === Infinity) {
                n = 0;
            }

            // 6. If n >= len, return -1.
            if (n >= len) {
                return -1;
            }

            // 7. If n >= 0, then Let k be n.
            // 8. Else, n<0, Let k be len - abs(n).
            //    If k is less than 0, then let k be 0.
            k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

            // 9. Repeat, while k < len
            while (k < len) {
                var kValue;
                // a. Let Pk be ToString(k).
                //   This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the
                //    HasProperty internal method of O with argument Pk.
                //   This step can be combined with c
                // c. If kPresent is true, then
                //    i.  Let elementK be the result of calling the Get
                //        internal method of O with the argument ToString(k).
                //   ii.  Let same be the result of applying the
                //        Strict Equality Comparison Algorithm to
                //        searchElement and elementK.
                //  iii.  If same is true, return k.
                if (k in O && O[k] === searchElement) {
                    return k;
                }
                k++;
            }
            return -1;
        });
}

//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Polyfill
if (!Array.prototype.map) {
    addMemberOnArrayPrototype("map", 
        function (callback, thisArg) {

            var T, A, k;

            if (this == null) {
                throw new TypeError(" this is null or not defined");
            }

            // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
            var O = Object(this);

            // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
            // 3. Let len be ToUint32(lenValue).
            var len = O.length >>> 0;

            // 4. If IsCallable(callback) is false, throw a TypeError exception.
            // See: http://es5.github.com/#x9.11
            if (typeof callback !== "function") {
                throw new TypeError(callback + " is not a function");
            }

            // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
            if (arguments.length > 1) {
                T = thisArg;
            }

            // 6. Let A be a new array created as if by the expression new Array( len) where Array is
            // the standard built-in constructor with that name and len is the value of len.
            A = new Array(len);

            // 7. Let k be 0
            k = 0;

            // 8. Repeat, while k < len
            while (k < len) {

                var kValue, mappedValue;

                // a. Let Pk be ToString(k).
                //   This is implicit for LHS operands of the in operator
                // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
                //   This step can be combined with c
                // c. If kPresent is true, then
                if (k in O) {

                    // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                    kValue = O[k];

                    // ii. Let mappedValue be the result of calling the Call internal method of callback
                    // with T as the this value and argument list containing kValue, k, and O.
                    mappedValue = callback.call(T, kValue, k, O);

                    // iii. Call the DefineOwnProperty internal method of A with arguments
                    // Pk, Property Descriptor {Value: mappedValue, Writable: true, Enumerable: true, Configurable: true},
                    // and false.

                    // In browsers that support Object.defineProperty, use the following:
                    // Object.defineProperty( A, k, { value: mappedValue, writable: true, enumerable: true, configurable: true });

                    // For best browser support, use the following:
                    A[k] = mappedValue;
                }
                // d. Increase k by 1.
                k++;
            }

            // 9. return A
            return A;
        });
}

if (!Array.prototype.reduce) {
    addMemberOnArrayPrototype("reduce", {
        value: function (callback /*, initialValue*/) {
            if (this === null) {
                throw new TypeError('Array.prototype.reduce ' +
                  'called on null or undefined');
            }
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }

            // 1. Let O be ? ToObject(this value).
            var o = Object(this);

            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;

            // Steps 3, 4, 5, 6, 7      
            var k = 0;
            var value;

            if (arguments.length >= 2) {
                value = arguments[1];
            } else {
                while (k < len && !(k in o)) {
                    k++;
                }

                // 3. If len is 0 and initialValue is not present,
                //    throw a TypeError exception.
                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }
                value = o[k++];
            }

            // 8. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kPresent be ? HasProperty(O, Pk).
                // c. If kPresent is true, then
                //    i.  Let kValue be ? Get(O, Pk).
                //    ii. Let accumulator be ? Call(
                //          callbackfn, undefined,
                //           accumulator, kValue, k, O ).
                if (k in o) {
                    value = callback(value, o[k], k, o);
                }

                // d. Increase k by 1.      
                k++;
            }

            // 9. Return accumulator.
            return value;
        }
    });
}

//--------------------------------------------------------

addMemberOnArrayPrototype("concatUnique",
    function (obj) {
        if (!obj || Object.prototype.toString.apply(obj) !== '[object Array]' || typeof obj === 'undefined' || typeof (value) === 'string' || obj === null || obj.length < 1)
        {
            return this;
        }
        
        var destinationArray = this;
        return this.concat(obj.filter(function isNotContainedInOtherArray(item) { return destinationArray.indexOf(item) < 0; }))
    });

addMemberOnArrayPrototype("concatUniqueObject",
    function (obj) {
        if (!obj || Object.prototype.toString.apply(obj) !== '[object Array]' || typeof obj === 'undefined' || typeof (value) === 'string' || obj === null || obj.length < 1)
        {
            return this;
        }

        var destinationArray = this;
        return this.concat(obj.filter(function isNotContainedInOtherArray(item, index) {
            return destinationArray.findIndex(
                function (destItem) { return JSON.stringify(destItem) === JSON.stringify(item); }) === -1;
        }));
    });

// find is needed for phantom js headless browser
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
// https://tc39.github.io/ecma262/#sec-array.prototype.find
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }

            var o = Object(this);

            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;

            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }

            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];

            // 5. Let k be 0.
            var k = 0;

            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T,  kValue, k, O )).
                // d. If testResult is true, return kValue.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                // e. Increase k by 1.
                k++;
            }

            // 7. Return undefined.
            return undefined;
        },
        configurable: true,
        writable: true
    });
};
define("extensions/Array", function(){});

var eDayOfWeek = {
    Sunday: 0,
    Monday: 1,
    Tuesday: 2,
    Wednesday: 3,
    Thursday: 4,
    Friday: 5,
    Saturday: 6
};

function timeStamp() {
    return (new Date).getTime();
}

Date.prototype.toDotNetString = function() {
    return "/Date(" + this.getTime() + ")/";
};

Date.prototype.AddSeconds = function(s) {
    var miliSeconds = s * 1000;

    this.setTime(this.getTime() + miliSeconds);

    return this;
};

Date.prototype.AddDays = function (d) {
    this.setDate(this.getDate() + d);

    return this;
};

Date.prototype.AddWeeks = function (w) {
    this.setDate(this.getDate() + w * 7);

    return this;
};

Date.prototype.AddMonths = function (m) {
    this.setMonth(this.getMonth() + m);

    return this;
};

Date.prototype.addHours = function(h) {
    this.setHours(this.getHours() + h);

    return this;
};

Date.prototype.Clone = function() {
    return new Date(this.getTime());
};

Date.prototype.ExtractDate = function () {
    return this.getDate() + "/" + (this.getMonth() + 1) + "/" + this.getFullYear();
};

Date.prototype.ExtractDateUTC = function () {
    return this.getUTCDate() + "/" + (this.getUTCMonth() + 1) + "/" + this.getUTCFullYear();
};

Date.prototype.ExtractDateShortYear = function () {
    return General.pad((this.getDate()), 2) + "/" + General.pad((this.getMonth() + 1), 2) + "/" + this.getFullYear().toString().substr(2,2);
};

Date.prototype.ExtractDateLongYear = function () {
    return General.pad((this.getDate()), 2) + "/" + General.pad((this.getMonth() + 1), 2) + "/" + this.getFullYear();
};

Date.prototype.ExtractUTCDateLongYear = function () {
    return General.pad((this.getUTCDate()), 2) + "/" + General.pad((this.getUTCMonth() + 1), 2) + "/" + this.getFullYear();
};

Date.prototype.ExtractDateShortYearUTC = function () {
    return  General.pad((this.getUTCDate()), 2) + "/" + General.pad((this.getUTCMonth() + 1), 2) + "/" + this.getUTCFullYear().toString().substr(2, 2);
};

Date.prototype.ExtractNextYearDate = function () {
    return this.getDate() + "/" + (this.getMonth() + 1) + "/" + (this.getFullYear() + 1);
};

Date.prototype.ExtractHour = function () {

    return this.getHours();
};

Date.prototype.ExtractTime = function () {
    return General.pad(this.getHours(), 2) + ":" + General.pad(this.getMinutes(), 2);
};

Date.prototype.ExtractTimeUTC = function () {
    return General.pad(this.getUTCHours(), 2) + ":" + General.pad(this.getUTCMinutes(), 2);
};

Date.prototype.ExtractFullTime = function () {
    return General.pad(this.getHours(), 2) + ":" + General.pad(this.getMinutes(), 2) + ":" + General.pad(this.getSeconds(), 2);
};

Date.prototype.ExtractFullTimeUTC = function () {
    return General.pad(this.getUTCHours(), 2) + ":" + General.pad(this.getUTCMinutes(), 2) + ":" + General.pad(this.getUTCSeconds(), 2);
};

Date.prototype.shortDateTime = function () {
    return this.getDate() + "/" + (this.getMonth() + 1) + "/" + this.getFullYear() + "  " + this.getHours() + ":" + this.getMinutes() + ":" + this.getSeconds();
};

Date.prototype.ExtractDateShortMonthYear = function () {
    return General.pad((this.getMonth() + 1), 2) + "/" + this.getFullYear().toString().substr(-2);
};

Date.prototype.AddYear = function (y) {
    this.setFullYear(this.getFullYear() + y);
    return this;
};

Date.prototype.compareTo = function (_date) {
    if (typeof (_date) === 'string') {
        _date = new Date(_date);
    }

    return this.valueOf() > _date.valueOf() ? 1 : 0;
};

Date.prototype.isWeekend = function () {
    var day = this.getDay();

    return day === eDayOfWeek.Sunday || day === eDayOfWeek.Saturday;
};

function datePad(number) {
    if (number < 10) {
        return '0' + number;
    }

    return number;
}

if (!Date.prototype.toISOString) {
    (function () {
        Date.prototype.toISOString = function () {
            return this.getUTCFullYear() +
                '-' + datePad(this.getUTCMonth() + 1) +
                '-' + datePad(this.getUTCDate()) +
                'T' + datePad(this.getUTCHours()) +
                ':' + datePad(this.getUTCMinutes()) +
                ':' + datePad(this.getUTCSeconds()) +
              '.' + (this.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) +
              'Z';
        };
    }());
}

(function () {
    Date.prototype.toShortISOString = function () {
        return this.getUTCFullYear() +
            '-' + datePad(this.getUTCMonth() + 1) +
            '-' + datePad(this.getUTCDate());
    };
}());

Date.prototype.skipWeekendDays = function () {
    if (this.getDay() === eDayOfWeek.Saturday) {
        this.AddDays(2);
        this.setHours(23);
        this.setMinutes(59);
    }

    if (this.getDay() === eDayOfWeek.Sunday) {
        this.AddDays(1);
        this.setHours(23);
        this.setMinutes(59);
    }

    return this;
}

Date.prototype.toLaterDate = function () {
    this.AddDays(14);
    this.setHours(23);
    this.setMinutes(59);
    this.setSeconds(0);

    return this;
}

Date.prototype.getPureUTCDate = function() {
    return new Date(this.getUTCDate(), this.getUTCMonth(), this.getUTCFullYear());
}

Date.prototype.isValid = function (y, m, d) {
    this.setYear(y);
    this.setDate(d);
    this.setMonth(m - 1);

    if (this.getDate() !== d || this.getMonth()+1 !== m || this.getFullYear() !== y) {
        return false;
    } else {
        return true;
    }
};
define("extensions/Date", function(){});

String.empty = '';

//---------------------------------------------------

String.format = function() {
    var i,
        exp1,
        exp2;

    if (typeof (arguments[1]) == 'object') {
        //-- String.Format("{0} x {1}", [12,13])
        for (i = 0; i < arguments[1].length; i++) {
            exp1 = new RegExp('\\{' + (i) + '\\}', 'gm');
            arguments[0] = arguments[0].replace(exp1, arguments[1][i]);
        }
    } else {
        //-- String.Format("{0} x {1}", 12, 13) 
        for (i = 1; i < arguments.length; i++) {
            exp2 = new RegExp('\\{' + (i - 1) + '\\}', 'gm');
            arguments[0] = arguments[0].replace(exp2, arguments[i]);
        }
    }

    return arguments[0];
};

String.prototype.round = function() {
    var str = this;
    if (str && str.length > 0) {
        var noComma = str.replace(/,/g, '');
        var rounded = Math.round(noComma);
        if (!isNaN(rounded)) {
            str = rounded.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
    }
    return str;
};

String.prototype.sign = function () {
    var noComma = this.replace(/,/g, ''),
        integer = Math.round(noComma);
    
    if (isNaN(integer)) {
        return 0;
    }

    return integer;
};

String.prototype.cleanComma = function () {
    var noComma = this.replace(/,/g, '');

    if (isNaN(noComma)) {
        return 0;
    }

    return noComma;
};


/**
* ReplaceAll by Fagner Brack (MIT Licensed)
* Replaces all occurrences of a substring in a string
*/
String.prototype.replaceAll = function (token, newToken, ignoreCase) {
    var str, i = -1, _token;
    if ((str = this.toString()) && typeof token === "string") {
        _token = ignoreCase === true ? token.toLowerCase() : undefined;
        while ((i = (
            _token !== undefined ?
                str.toLowerCase().indexOf(
                            _token,
                            i >= 0 ? i + newToken.length : 0
                ) : str.indexOf(
                            token,
                            i >= 0 ? i + newToken.length : 0
                )
        )) !== -1) {
            str = str.substring(0, i)
                    .concat(newToken)
                    .concat(str.substring(i + token.length));
        }
    }
    return str;
};

String.prototype.toNumeric = function () {
    var str = this;
    if (General.isNumberType(str))
        return str;

    var newstr = [];

    for (var i = 0; i < str.length; i++) {
        var s = str.substr(i, 1);

        if (s !== ",") {
            newstr.push(s);
        }
    }

    return parseFloat(newstr.join(""));
};

if (!String.prototype.containsNotEmpty) {
    String.prototype.containsNotEmpty = function () {
        if (arguments && arguments[0].length > 0)
            return String.prototype.indexOf.apply(this, arguments) !== -1;
        else
            return false;
    };
}

if (!String.prototype.trim) {
    String.prototype.trim = function () {
        return this.replace(/^\s+|\s+$/g, '');
    };
}

if (!String.prototype.capitalizeFirstLetter) {
    String.prototype.capitalizeFirstLetter = function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    }
}

if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(searchString, position) {
        return this.substr(position || 0, searchString.length) === searchString;
    };
}

String.prototype.isRtlText = function () {
    return cArabicChars.test(this);
};
define("extensions/String", function(){});

Number.toStr = function(number) {
	var sNum = number.toString(); 

	sNum += '';

	var x = sNum.split('.');
	var x1 = x[0];
	var x2 = x.length > 1 ? '.' + x[1] : '';

	var rgx = /(\d+)(\d{3})/;

    while (rgx.test(x1)) {
        x1 = x1.replace(rgx, '$1' + ',' + '$2');
    }

    return x1 + x2.substr(0,5);
};

Number.fromStr = function (numberStr) {
    var multiplier = 1;

    if (!numberStr) {
        return Number.NaN;
    }

    if (numberStr.indexOf(',') >= 0) {
        numberStr = numberStr.replace(/,/g, '');
    }
    
    if (numberStr.indexOf('M') >= 0) {
        multiplier = 1000000;
        numberStr = numberStr.replace(/M/g, '');
    }
    
    if (numberStr.indexOf('K') >= 0) {
        multiplier = 1000;
        numberStr = numberStr.replace(/K/g, '');
    }

    return Number(numberStr) * multiplier;
}

Number.prototype.sign = function () {
    return Math.round(this);
};

if (typeof Number.MIN_SAFE_INTEGER !== 'number') {
    Number.MIN_SAFE_INTEGER = -9007199254740991; //-(Math.pow(2, 53) - 1)  // 
}

if (typeof Number.MAX_SAFE_INTEGER !== 'number') {
    Number.MAX_SAFE_INTEGER = 9007199254740991; //Math.pow(2, 53) - 1 
}

if (typeof Number.MAX_INT32_SAFE_INTEGER !== 'number') {
    Number.MAX_INT32_SAFE_INTEGER = 2147483647;
};
define("extensions/Number", function(){});

/* global General */
var Format = {
    //--------------------------------------------------------------------
    // If digit param exists, return the number with 'digit' decimal digits, else floor it
    //--------------------------------------------------------------------
    toAmount: function (num, digit) {
        if (!General.isNumber(num)) {
            return "NA";
        }

        num = Math.abs(Number(num));

        if (digit) {
            return num.toFixed(digit);
        }
        else {
            return Math.floor(num);
        }
    },

    //--------------------------------------------------------------------
    // Return a whole number and round it if needed 
    //--------------------------------------------------------------------
    toFixedAmount: function (num) {
        var amount = General.roundedNumberFromAmount(num);

        if (!General.isNumber(amount)) {
            return "NA";
        }

        return General.formatNumberWithThousandsSeparator(amount);
    },

    //--------------------------------------------------------------------
    // Return number with Thousands Separator 
    //--------------------------------------------------------------------
    toNumberWithThousandsSeparator: function (num, decimals, displayToken) {
        var amount = General.toNumeric(num);

        displayToken = !General.isDefinedType(displayToken) ? "NA" : displayToken;

        if (!General.isNumber(amount)) {
            return displayToken;
        }

        if (decimals >= 0) {
            amount = amount.toFixed(decimals);
        }

        return General.formatNumberWithThousandsSeparator(amount);
    },

    //--------------------------------------------------------------------
    // Return sign for a symbol id
    //--------------------------------------------------------------------
    toSign: function (symbolId) {
        var formatCurrency = {
                "signNumber symbol": function (arr, symbol) { arr.push(' ' + symbol); return arr.join(''); },
                "sign number symbol": function (arr, symbol) { arr.splice(1, 0, ' '); arr.push(' ' + symbol); return arr.join(''); },
                "symbol signNumber": function (arr, symbol) { arr.splice(0, 0, symbol + ' '); return arr.join(''); },
                "signSymbol number": function (arr, symbol) { arr.splice(1, 0, symbol + ' '); return arr.join(''); },
                "symbolSignNumber": function (arr, symbol) { arr.splice(0, 0, symbol); return arr.join(''); },
            },
            otherSymbol = $symbolsManager.GetSymbol(symbolId),
            defaultSignObj = { sign: otherSymbol ? otherSymbol.name : "", isWithSpace: true, format: formatCurrency["symbol signNumber"] },
            currencySignsMap = {
                '4': { currency: 'CHF', sign: '&#70;&#114;&#46;', isWithSpace: true, format: formatCurrency["symbol signNumber"] },
                '9': { currency: 'CZK', sign: '&#75;&#269;', isWithSpace: true, format: formatCurrency["sign number symbol"] },
                '14': { currency: 'EUR', sign: '&#8364;', isWithSpace: false, format: formatCurrency["symbol signNumber"] },
                '16': { currency: 'GBP', sign: '&#163;', isWithSpace: false, format: formatCurrency["signSymbol number"] },
                '18': { currency: 'HKD', sign: '&#36;', isWithSpace: false, format: formatCurrency["signSymbol number"] },
                '19': { currency: 'HUF', sign: '&#70;&#116;', isWithSpace: false, format: formatCurrency["sign number symbol"] },
                '20': { currency: 'ILS', sign: '&#8362;', isWithSpace: false, format: formatCurrency["symbol signNumber"] },
                '23': { currency: 'JPY', sign: '&#165;', isWithSpace: false, format: formatCurrency["signSymbol number"] },
                '24': { currency: 'MXN', sign: '&#36;', isWithSpace: false, format: formatCurrency["signSymbol number"] },
                '33': { currency: 'PLN', sign: '&#122;&#322;', isWithSpace: true, format: formatCurrency["sign number symbol"] },
                '34': { currency: 'LEI', sign: '&#108;&#101;&#105;', isWithSpace: true, format: formatCurrency["sign number symbol"] },
                '40': { currency: 'SEK', sign: '&#107;&#114;', isWithSpace: true, format: formatCurrency["sign number symbol"] },
                '46': { currency: 'TRY', sign: '&#8378;', isWithSpace: true, format: formatCurrency["sign number symbol"] },
                '47': { currency: 'USD', sign: '&#36;', isWithSpace: false, format: formatCurrency["symbol signNumber"] },
                '69': { currency: 'KRW', sign: '&#8361;', isWithSpace: false, format: formatCurrency["symbol signNumber"] },
                '77': { currency: 'RUB', sign: '&#8381;', isWithSpace: false, format: formatCurrency["signNumber symbol"] },
                '78': { currency: 'SAR', sign: '&#65020;', isWithSpace: false, format: formatCurrency["signNumber symbol"] },
            };

        if (symbolId in currencySignsMap) {
            defaultSignObj = currencySignsMap[symbolId];
        }

        return defaultSignObj;
    },

    //--------------------------------------------------------------------
    // Returns an formated number with the currency Sign
    //--------------------------------------------------------------------
    toNumberWithCurrency: function (value, formatOptions) {
        formatOptions = formatOptions || {};
        var maximumFractionDigits = 2,
            minimumFractionDigits = 0;

        if (!(General.isNumber(General.toNumeric(value)) && General.isDefinedType(formatOptions.currencyId))) {
            return '';
        }

        if (General.isNumberType(formatOptions.decimals)) {
            maximumFractionDigits = minimumFractionDigits = formatOptions.decimals;
        }

        var options = {
                style: 'decimal',
                useGrouping: General.isBooleanType(formatOptions.useGrouping) ? formatOptions.useGrouping : true,
                maximumFractionDigits: General.isNumberType(formatOptions.maximumFractionDigits) ? formatOptions.maximumFractionDigits : maximumFractionDigits,
                minimumFractionDigits: General.isNumberType(formatOptions.minimumFractionDigits) ? formatOptions.minimumFractionDigits : minimumFractionDigits
            },
            strNum = General.toNumeric(value).toString();

        if (strNum.indexOf('.') < 0) {
            strNum += '.00000000';
        }

        var retNumWithCurrecy = Number(strNum.substring(0, strNum.indexOf('.') + options.maximumFractionDigits + 1)).toLocaleString("en-GB", options);

        return Format.addCurrencyToNumber(retNumWithCurrecy, formatOptions.currencyId, value);
    },

    //--------------------------------------------------------------------
    // Adds the currency to the specified number
    //--------------------------------------------------------------------
    addCurrencyToNumber: function (formatedNumber, currencyId, originalNumberValue) {
        var symbol = Format.toSign(currencyId);

        var arr = formatedNumber.split('-');

        var sign = '';
        if (General.isNumber(originalNumberValue)) {
            sign = (0 <= Number(originalNumberValue)) ? '' : '-';
        } else {
            sign = (0 <= formatedNumber.indexOf('-')) ? '-' : '';
        }
        arr.splice(0, 0, sign);
        formatedNumber = symbol.format(arr, symbol.sign);

        return formatedNumber.trim().replace(' ', '&nbsp;');
    },

    //--------------------------------------------------------------------
    // Returns an ammount formatted with the specified function (Format.toAmount for example)
    // followed by the specified currency (if any).
    //--------------------------------------------------------------------
    toAmountWithCurrency: function (formatter, value, currency, isCurrencyBeforeValue) {
        if (!formatter) {
            formatter = Format.toAmount;
        }

        var formattedAmount = formatter(value);

        if (currency && formattedAmount !== "NA") {
            formattedAmount = isCurrencyBeforeValue
                ? currency + ' ' + formattedAmount
                : formattedAmount + ' ' + currency;
        }

        return formattedAmount;
    },

    //--------------------------------------------------------------------
    // Returns a number as rate, add zero's at the end if needed according to precision.
    // If it gets instrumentId, it checks the decimal length of the specific rate, 
    // and according to that it calculates the total length of the rate,
    // else, rate precision default is 7.
    //--------------------------------------------------------------------
    toRate: function (rateValue, needRound, instrumentId, decimals) {
        if (!General.isNumber(rateValue)) {
            return "NA";
        }

        var ratePrecision = 7; // Default rate length
        var rateStr = rateValue.toString();
        var isNegative = rateStr[0] === '-';
        var ratePos = isNegative ? rateStr.substring(1, rateStr.length) : rateStr;

        if (!General.isDefinedType(decimals)) {
            var instrument = $instrumentsManager.GetInstrument(instrumentId);
            if (instrument) {
                ratePrecision = General.lenBeforeDelimiter(ratePos.toString()) + instrument.DecimalDigit + 1;
            }
        } else {
            ratePrecision = General.lenBeforeDelimiter(ratePos.toString()) + decimals + 1;
        }

        var rate = needRound ? General.RateRound(ratePos, ratePrecision).toString() : ratePos.toString();
        rate = General.trailingZeros(rate, ratePrecision);

        return isNegative ? '-' + rate : rate;
    },

    roundToPip: function (value, pipDigit, precision, dir) {
        pipDigit = pipDigit || 0;
        precision = precision || pipDigit > 0 ? pipDigit : 0;

        var floatValue = parseFloat(value),
            multiplier = Math.pow(10, pipDigit),
            coefficient = (dir == ">" ? 0.59 : -0.59),
            pipsValue,
            roundedToPip,
            formattedToDecimals;

        if (isNaN(floatValue)) {
            return false;
        }

        pipsValue = floatValue * multiplier;

        if (dir == ">" || dir == "<") {
            roundedToPip = Math.round(pipsValue + coefficient) / multiplier;
        } else {
            roundedToPip = Math.round(pipsValue) / multiplier;
        }

        formattedToDecimals = parseFloat(roundedToPip).toFixed(precision);

        return formattedToDecimals;
    },

    //--------------------------------------------------------------------
    // Returns the average rate between bid and ask parameters given
    //--------------------------------------------------------------------
    toMidRate: function (bid, ask) {
        if (!General.isNumber(bid) || !General.isNumber(ask)) {
            return "NA";
        }

        var midRate = (General.toNumeric(bid) + General.toNumeric(ask)) * 10 * 0.05; // Middle rate value calculation
        var midRtPrecision = General.lenBeforeDelimiter(midRate) + // Middle rate length calculation
            General.lenAfterDelimeter(bid) + parseInt(General.lenBeforeDelimiter(bid) < 0 ? 0 : 1);
        var midRtRounded = General.RateRound(midRate, midRtPrecision); // Round rate

        return General.trailingZeros(midRtRounded, midRtPrecision);
    },

    //--------------------------------------------------------------------
    // Returns time '01:00:00' from date '13/12/2015 01:00:00'
    //--------------------------------------------------------------------
    toTime: function (date) {
        if (General.isNullOrUndefined(date)) {
            return "";
        }

        var timeVector = date.split(" ");
        var time = timeVector[1];

        if (!General.isDefinedType(time)) {
            time = '00:00:00';
        }

        return time;
    },

    //--------------------------------------------------------------------
    // Shorten the year to 2 digits. Example: for 'August 2016' will 
    // return '(August 16) '
    //--------------------------------------------------------------------
    toShortYear: function (monthAndYear) {
        if (General.isNullOrUndefined(monthAndYear) || monthAndYear.trim().length === 0) {
            return "";
        }

        var monthAndYearVector = monthAndYear.split(/\s+/);
        var year = monthAndYearVector[1];
        var month = monthAndYearVector[0];

        if (General.isNullOrUndefined(year) || !General.isDefinedType(month)) {
            return "(" + monthAndYear + ") ";
        }

        return "(" + month + " " + year.substring(2) + ") ";
    },

    //--------------------------------------------------------------------
    // Returns the rounded number without any decimals
    //--------------------------------------------------------------------
    toRoundNumber: function (num) {
        if (!General.isNumber(num)) {
            return "NA";
        }

        return Math.round(num);
    },

    //--------------------------------------------------------------------
    // Returns the number with 2 decimal digits and % sign
    //--------------------------------------------------------------------
    toPercent: function (num, hideNA) {
        if (!General.isNumber(num)) {
            return (hideNA) ? num : "NA";
        }

        num = Math.round(num * 100) / 100;

        var sNum = String(num),
            t = sNum.split('.');

        if (t.length == 1) {
            t[0] = t[0] == '-0' ? '0' : t[0];
            return t[0] + '.00%';
        }
        if (t[1].length == 1) {
            return t[0] + '.' + t[1] + '0%';
        }

        return t[0] + '.' + t[1].substring(0, 2) + '%';
    },

    //--------------------------------------------------------------------
    // Returns the number with precision decimal digits and % sign
    //--------------------------------------------------------------------
    toPercentWithPrecision: function (num, precision) {
        if (!General.isNumber(num)) {
            return "NA";
        }

        precision = precision || 2;

        num = num.toFixed(precision);

        return String(num) + "%";
    },

    //--------------------------------------------------------------------
    // Returns the number the +/- sign and with 2 decimal digits and % sign
    //--------------------------------------------------------------------
    toSignedPercent: function (num, resultWhenValueIsInvalid) {
        if (!General.isNumber(num)) {
            return General.isNullOrUndefined(resultWhenValueIsInvalid) ? 'NA' : resultWhenValueIsInvalid;
        }

        var formattedNum = Format.toPercent(num);

        return ((formattedNum === "0.00%" || formattedNum.indexOf('-') >= 0) ? '' : '+') + Format.toPercent(num);
    },

    //--------------------------------------------------------------------
    // Returns the CC number in CC number format, as described(international or local)
    //--------------------------------------------------------------------
    toCCNumber: function (first6, last4) {
        //' International cards format:   <first 6 digits>-XXXX-<last 4 digits>
        //' Local cards format:           XXXX-<last 4 digits>

        if (last4.length !== 4) {
            return "NA";
        }
        if ((first6.length > 0) && (first6.length !== 6)) {
            return "NA";
        }

        return first6 + (first6.length > 0 ? '-' : '') + 'XXXX-' + last4;
    },

    //--------------------------------------------------------------------
    //  Add dot in case a value is in the right range
    //--------------------------------------------------------------------
    addDotInRange: function (value, rangeArray) {
        var newVal = value,
            inRange;

        for (var i = 0; i < rangeArray.length; i++) {
            var range = rangeArray[i];
            var nearIsSmall = range.near() < range.far();
            var low = nearIsSmall ? range.near() : range.far();
            var high = nearIsSmall ? range.far() : range.near();
            var lowFloor = Math.floor(low);
            var highFloor = Math.floor(high);
            inRange = newVal >= lowFloor && newVal <= highFloor;
            if (inRange) {
                return (newVal + '.');

            }
        }
        return newVal;
    },

    //--------------------------------------------------------------------
    // Return the value given with sign (+/-)
    //--------------------------------------------------------------------
    toSignedNumericWithDecimals: function (amount, formatOptions) {
        formatOptions = formatOptions || {};
        formatOptions.decimals = General.isDefinedType(formatOptions.decimals) ? formatOptions.decimals : 2;
        formatOptions.showThousandSeparator = !!formatOptions.showThousandSeparator;

        var numericValue = General.toNumeric(amount);

        if (!General.isNumber(numericValue)) {
            return 'NA';
        }

        var stringValue = numericValue.toFixed(formatOptions.decimals),
            signedValue = stringValue.indexOf("-") !== -1 ? stringValue : "+" + stringValue;

        if (formatOptions.showThousandSeparator) {
            return General.formatNumberWithThousandsSeparator(signedValue);
        }

        return signedValue;
    },

    //--------------------------------------------------------------------
    // Return the number divided by 10,000
    //--------------------------------------------------------------------
    toKAmount: function (amount) {
        if (!General.isNumber(amount)) {
            return "NA";
        }
        return (Math.round((amount / 1000) * 10000) / 10000).toString();
    },

    //--------------------------------------------------------------------
    // Returns milliseconds converted to second   
    //--------------------------------------------------------------------
    secToMil: function (sec) {
        if (!General.isNumber(sec)) {
            return "NA";
        }
        return (sec * 1000).toString();
    },

    //--------------------------------------------------------------------
    // Returns the rate as it should be displayed  as 10th of pips,
    // both for button display(first, middle, last) and for label display(first, last).
    //--------------------------------------------------------------------
    tenthOfPipSplitRate: function (sRate, instrumentId, specialFontStart, specialFontLength) {
        var retVal = {
            label: { first: '0', last: '0' },
            button: { first: '0', middle: '0', last: '0' }
        };

        if (!General.isDefinedType(specialFontStart) || !General.isDefinedType(specialFontLength)) {
            var instrument = $instrumentsManager.GetInstrument(instrumentId);

            if (General.isNullOrUndefined(instrument)) {
                return retVal;
            }

            specialFontStart = instrument.SpecialFontStart;
            specialFontLength = instrument.SpecialFontLength;
        }

        var sNum = sRate.toString(),
            SpecialFontStartPositionfromLeft = sNum.length - specialFontStart,
            first = sNum.substring(0, SpecialFontStartPositionfromLeft),
            second = sNum.substring(SpecialFontStartPositionfromLeft, SpecialFontStartPositionfromLeft + specialFontLength),
            third = sNum.substring(SpecialFontStartPositionfromLeft + specialFontLength);


        retVal.label.first = first + second;
        retVal.label.last = third;

        retVal.button.first = first;
        retVal.button.middle = second;
        retVal.button.last = third;

        return retVal;
    },

    //--------------------------------------------------------------------
    //   Returns the given value rounded with thousands separator. 
    //   if smaller then 10, returns with 1 decimal, if its zero returns .
    //--------------------------------------------------------------------
    formatDealAmount: function (value) {
        var valueAsNumber = General.toNumeric(value);

        if (!General.isNumber(valueAsNumber)) {
            return "NA";
        }

        if (valueAsNumber == 0) {
            return "";
        }

        if (valueAsNumber < 10) {
            return valueAsNumber.toFixed(1);
        }

        return General.formatNumberWithThousandsSeparator(Math.round(valueAsNumber));
    },

    toDateTimeUTC: function (eventTime) {
        var eventDate = new Date(eventTime);
        return eventDate.ExtractDateShortYearUTC() + ' ' + eventDate.ExtractTimeUTC();
    },

    toDateTime: function (eventTime) {
        if (!eventTime) {
            return "";
        }

        var eventDate = new Date(eventTime);
        return eventDate.ExtractDateShortYear() + ' ' + eventDate.ExtractTime();
    },

    toTimehhmm: function (eventTime) {
        var eventDate = new Date(eventTime);
        return eventDate.ExtractTimeUTC();
    },

    toLocaleDate: function (eventTime, lcid) {
        var options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        var eventDate = new Date(eventTime.split("T")[0]);
        return eventDate.toLocaleDateString(lcid, options);
    },

    rateWithPipTemplate: function (rate, instrumentId, smallFontClass) {
        smallFontClass = smallFontClass || 'tenths';
        if (General.isNullOrUndefined(rate) || General.isNullOrUndefined(instrumentId)) {
            return 'N/A';
        }
        return '<span>' + Format.tenthOfPipSplitRate(rate, instrumentId).label.first
            + '</span>'
            + '<span class="' + smallFontClass + '">'
            + Format.tenthOfPipSplitRate(rate, instrumentId).label.last + '</span>';
    },

    toFullDateTimeUTC: function (time) {
        var date = new Date(time);
        return date.ExtractUTCDateLongYear() + ' ' + date.ExtractFullTimeUTC();
    },

    numberAddThousandSeparator: function (num, decimals, displayToken) {
        var amount = General.toNumeric(num);

        displayToken = !General.isDefinedType(displayToken) ? "NA" : displayToken;
        decimals = General.isNumber(General.toNumeric(decimals)) ? General.toNumeric(decimals) : 0;

        if (!General.isNumber(amount)) {
            return displayToken;
        }

        amount = decimals > 0 ? amount.toFixed(decimals) : Math.floor(amount);

        return General.formatNumberWithThousandsSeparator(amount);
    }
};
define("handlers/format", function(){});

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/EventRaiser',
            [
                'jquery'
            ], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = factory();
    } else {
        // running in browser
        root.TrackingEventRaiser = factory;
    }
})(typeof self !== 'undefined' ? self : this,
    function TrackingEventRaiser() {
        // IE<9 Date.now() fix
        Date.now = Date.now || function () { return + new Date(); };

        /**
         * Adds a leading zero to a number
         * @param {Number} number 
         * @returns {String}
         */
        function padNumber(number) {
            return ('0' + number).slice(-2);
        }

        /**
         * Formats a Date object as a `dd/mm/yyyy hh:mm:ss` string
         * @param {Date} date 
         * @returns {String} 
         */
        function formatEventDate(date) {
            var formattedDateString = padNumber(date.getDate()) + '/' +
                padNumber(date.getMonth() + 1) + '/' +
                date.getFullYear() + ' ' +
                padNumber(date.getHours()) + ':' +
                padNumber(date.getMinutes()) + ':' +
                padNumber(date.getSeconds());

            return formattedDateString;
        }

        function getEventTime() {
            var eventTime;

            if (typeof $cacheManager !== 'undefined') {
                eventTime = formatEventDate($cacheManager.ServerTime());
            }
            else {
                eventTime = formatEventDate(new Date(Date.now() + (new Date().getTimezoneOffset() * 60 * 1000)));
            }

            return eventTime;
        }

        var eventData = {};

        function addEventTime() {
            eventData.EventTime = getEventTime();
        }

        function callGoogleApi() {
            try {
                window.dataLayer.push(getEventDataClone());
            }
            catch (ex) {
                ErrorManager.onError('callGoogleApi', 'Google Tag Manager has failed for event: ' + eventData.event, eErrorSeverity.high);
            }
        }

        function getEventDataClone() {
            return $.extend(true, {}, eventData);
        }

        function clean() {
            for (var prop in eventData) {
                if (eventData.hasOwnProperty(prop)) {
                    delete eventData[prop];
                }
            }
        }

        function raiseEvent() {
            addEventTime();
            callGoogleApi();
            clean();
        }

        return {
            eventData: eventData,
            raiseEvent: raiseEvent,
            formatEventDate: formatEventDate
        };
    }
);

var PerformanceDataCollector = function PerformanceDataCollector() {
    var timestamps = {},
        resourceList = (window.performance && window.performance.getEntriesByType) ? window.performance.getEntriesByType("resource") : [];

    function registerEventTimestamp(event) {
        timestamps[event] = Date.now();
    }

    function getResourceTiming(resourceNamePattern) {
        var resourceNameRegex = new RegExp(resourceNamePattern, "gi");
        var duration = 0;

        var resources = resourceList.filter(function(item) {
            // filter by resource name
            return resourceNameRegex.test(item.name);
        });

        if (resources && resources.length) {
            resources.forEach(function(item) {
                duration += (item.responseEnd - item.startTime);
            });
        }

        return duration;
    }

    function isNewVersion() {
        var isNew = false;

        if (StorageFactory.isSupported(StorageFactory.eStorageType.local)) {
            var cookieCurrentVersion = CookieHandler.ReadCookie('Version');
            var localStorage = StorageFactory(StorageFactory.eStorageType.local);
            var localStorageVersion = localStorage.getItem('fxnet_version');

            if (localStorageVersion !== cookieCurrentVersion) {
                isNew = true;
                localStorage.setItem('fxnet_version', cookieCurrentVersion);
            };
        }

        return isNew;
    }

    function loadEventEnd() {
        var loadEventEndValue = "";

        try {
            loadEventEndValue = window.performance.timing.loadEventEnd;
        } catch (e) {
            ErrorManager.onWarning("window.performance.timing.loadEventEnd",
                "window.performance.timing.loadEventEnd is not supported in this OS");
        }

        return loadEventEndValue;
    }

    function responseEnd() {
        var responseEndValue = "";

        try {
            responseEndValue = window.performance.timing.responseEnd;
        } catch (e) {
            ErrorManager.onWarning("window.performance.timing.responseEnd",
                "window.performance.timing.responseEnd is not supported in this OS");
        }

        return responseEndValue;
    }

    function fetchStart() {
        var fetchStartValue = "";

        try {
            fetchStartValue = window.performance.timing.fetchStart;
        } catch (e) {
            ErrorManager.onWarning("window.performance.timing.responseEnd",
                "window.performance.timing.fetchStart is not supported in this OS");
        }

        return fetchStartValue;
    }

    return {
        Timestamps: timestamps,
        getResourceTiming: getResourceTiming,
        isNewVersion: isNewVersion,
        registerEventTimestamp: registerEventTimestamp,
        loadEventEnd: loadEventEnd,
        responseEnd: responseEnd,
        fetchStart: fetchStart
    };
};

define("tracking/PerformanceDataCollector", [],function(){return PerformanceDataCollector() });

/* global General */
var Dictionary = (function Dictionary() {
    var _staticContent = {};

    function getResourceName(resourceName) {
        var _resourceName = resourceName || 'contentdata';
        return _resourceName.toLowerCase()
    }

    function getItem(key, resourceName, defaultValue) {
        resourceName = getResourceName(resourceName);

        var value = '';

        if (_staticContent.hasOwnProperty(resourceName)) {
            value = _staticContent[resourceName][key];
        }

        if (!value && !defaultValue) {
            value = String.format("***{0}", key);
            //  var warningMessage = 'Missing content for key: ' + key + ' and resource: ' + resourceName + ' on platform: ' + UrlResolver.getApplicationType();
            // Logger.warn("DictionaryContent", warningMessage, General.emptyFn, eErrorSeverity.warning);
        }

        if (!General.isNullOrUndefined(value)) {
            if (!General.isNullOrUndefined(value)) {
                return value;
            }
            else {
                if (!General.isNullOrUndefined(defaultValue)) {
                    return defaultValue;
                }
                else {
                    return value;
                }
            }
        }
        else {
            return defaultValue || "";
        }
    }

    function getAllItemsForResource(resourceName) {
        var value = null;

        if (_staticContent.hasOwnProperty(resourceName)) {
            value = _staticContent[resourceName];
        }

        return value;
    }

    function getAllKeys(resourceName) {
        var value = null;

        resourceName = getResourceName(resourceName);

        if (_staticContent.hasOwnProperty(resourceName)) {
            value = Object.keys(_staticContent[resourceName]);
        }

        return value;
    }

    function getGlobalItem(key, defaultValue) {
        return getItem(key, 'contentdata', defaultValue);
    }

    function addResource(resourceName, content) {
        resourceName = getResourceName(resourceName);
        _staticContent[resourceName] = content;
    }

    function getTemplate(key) {
        var templatesStore = getInitializedTemplatesStore();
        var value = templatesStore[key];

        if (!value) {
            value = String.format("***{0}", key);
        }

        templatesStore[key] = value;

        return value;
    }

    function getInitializedTemplatesStore() {
        if (!systemInfo.templates) {
            systemInfo.templates = {};
        }

        return systemInfo.templates;
    }

    function valueIsEmpty(key, resourceName) {
        var _resourceName = getResourceName(resourceName);

        if (!_staticContent.hasOwnProperty(_resourceName)) {
            return true;
        }

        var value = _staticContent[_resourceName][key];

        return General.isEmptyValue(value);
    }

    return {
        AddResource: addResource,
        GetItem: getItem,
        GetAllKeys: getAllKeys,
        GetAllItemsForResource: getAllItemsForResource,
        GetGlobalItem: getGlobalItem,
        GetTemplate: getTemplate,
        ValueIsEmpty: valueIsEmpty
    };
}());

define("Dictionary", [],function () { return Dictionary });
var TDelegate = function () {
    var _items = [];

    function add(func) {
        if (typeof func === "function") {
            _items.push(func);
        }
    }

    function invoke() {
        var tmpHandlers = _items.slice(0);
        var len = tmpHandlers.length;
        var args = [];

        for (var i = 0, length = arguments.length; i < length; i++) {
            args[i] = arguments[i];
        }

        for (var j = 0; j < len; j++) {
            if (typeof tmpHandlers[j] === "function") {
                tmpHandlers[j].apply(null, args);
            }
        }

        tmpHandlers.length = 0;
    }

    function remove(func) {
        var len = _items.length;

        for (var i = 0; i < len; i++) {
            if (_items[i] === func) {
                _items.splice(i, 1);
                break;
            }
        }
    }

    function flush() {
        _items.splice(0);
    }

    function count() {
        return _items.length;
    }

    return {
        Add: add,
        Invoke: invoke,
        Remove: remove,
        Flush: flush,
        Count: count,
    }
}

define("handlers/Delegate", [],function () { return TDelegate });

function Instrument(instrumentInfo, hasWeightedVolumeFactor, isOvernightOnForex) {
    this.id = instrumentInfo[eInstruments.id];
    this.ccyPair = instrumentInfo[eInstruments.ccyPair];
    this.amountGroupId = instrumentInfo[eInstruments.amountGroupId];
    this.factor = instrumentInfo[eInstruments.factor];
    this.isTradable = instrumentInfo[eInstruments.tradable] == 1;
    this.hasSignal = instrumentInfo[eInstruments.hasSignals] == 1;
    this.signalName = instrumentInfo[eInstruments.signalName];
    this.dealMinMaxAmounts = [];
    this.defaultDealSize = instrumentInfo[eInstruments.defaultDealSize];
    this.maxDeal = instrumentInfo[eInstruments.maxDeal];
    this.SLMinDistance = instrumentInfo[eInstruments.SLMinDistance];
    this.TPMinDistance = instrumentInfo[eInstruments.TPMinDistance];

    this.DecimalDigit = instrumentInfo[eInstruments.DecimalDigit];
    this.PipDigit = instrumentInfo[eInstruments.PipDigit];
    this.SpecialFontStart = instrumentInfo[eInstruments.SpecialFontStart];
    this.SpecialFontLength = instrumentInfo[eInstruments.SpecialFontLength];

    this.instrumentTypeId = instrumentInfo[eInstruments.instrumentTypeId];
    this.assetTypeId = instrumentInfo[eInstruments.assetTypeId];
    this.expirationDate = instrumentInfo[eInstruments.expirationDate] === '' ? null : instrumentInfo[eInstruments.expirationDate];
    //--------- future -----------------------------

    this.isFuture = this.assetTypeId === eAssetType.Future;
    this.isShare = this.assetTypeId === eAssetType.Share;
    this.isForex = this.assetTypeId === eAssetType.Forex;
    this.isStock = this.instrumentTypeId === eInstrumentType.Stocks;

    this.futureValueDate = null;

    //-------- symbols -----------------------------

    this.baseSymbol = instrumentInfo[eInstruments.baseSymbolId];
    this.otherSymbol = instrumentInfo[eInstruments.otherSymbolId];
    this.baseSymbolName = instrumentInfo[eInstruments.ccyPair].toString().split(/\//g)[0];
    this.otherSymbolName = instrumentInfo[eInstruments.ccyPair].toString().split(/\//g)[1];

    this.exchangeInstrumentName = instrumentInfo[eInstruments.exchangeInstrumentName];
    this.exchange = instrumentInfo[eInstruments.exchange];
    this.contractMonthAndYear = instrumentInfo[eInstruments.contractMonthAndYear];
    this.instrumentEnglishName = instrumentInfo[eInstruments.instrumentEnglishName];
    this.weightedVolumeFactor = hasWeightedVolumeFactor ? parseFloat(instrumentInfo[eInstruments.weightedVolumeFactor]) : 1;
    this.eventDate = instrumentInfo[eInstruments.eventDate];
    this.eventAmount = instrumentInfo[eInstruments.eventAmount];
    this.marketPriceTolerance = instrumentInfo[eInstruments.marketPriceTolerance];

    this.isOvernightOnForex = isOvernightOnForex;
}

define("handlers/Instrument", [],function(){ return Instrument });
function StringBuilder() {
    this._length = 0;
    this._buffer = [];
}

StringBuilder.prototype.append = function(text) {
    this._buffer[this._length] = text;
    this._length += 1;
};

StringBuilder.prototype.toString = function() {
    return this._buffer.join("");
};

StringBuilder.prototype.isEmpty = function() {
    return this._length === 0;
};
define("handlers/StringBuilder", function(){});

define('dataaccess/dalorder',[
	"handlers/Ajaxer",
	"JSONHelper",
	"knockout",
	"global/UrlResolver",
	"handlers/general",
	"handlers/StringBuilder",
	"extensions/Date",
], function (tAjaxer, jsonhelper, ko, UrlResolver, General) {
	var _lastTimeRequest = timeStamp();

	function openDeal(newDeal, callback) {
		var ajaxer = new tAjaxer();
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.NewDeal;
			var result = analyzeResponse(responseText, eOrderActionType.NewDeal);

			callback(result, callerId, newDeal.instrumentID, newDeal);
		};

		var sb = new StringBuilder();

		sb.append(String.format("DealType={0}&", newDeal.dealType));
		sb.append(String.format("InstrumentId={0}&", newDeal.instrumentID));
		sb.append(String.format("Amount={0}&", newDeal.amount));
		sb.append(String.format("MarketRate={0}&", newDeal.marketRate));
		sb.append(String.format("OtherRateSeen={0}&", newDeal.otherRateSeen));
		sb.append(String.format("OrderDirection={0}&", newDeal.orderDir));
		sb.append(String.format("TakeProfitRate={0}&", newDeal.tpRate));
		sb.append(String.format("StopLossRate={0}&", newDeal.slRate));
		sb.append(String.format("SecurityToken={0}", systemInfo.securityToken));

		ajaxer.post("dalOrder/openDeal", "Deals/OpenDeal", sb.toString(), OnLoadComplete, function (error) {
			ErrorManager.onError("dalOrder/openDeal", error.message, eErrorSeverity.medium);
		});
	}

	function closeDeals(items, callback, config) {
		var ajaxer = new tAjaxer(),
			failCallback =
				config && config.hasOwnProperty("failCallback") && typeof config.failCallback === "function"
					? config.failCallback
					: null;
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.CloseDeal;

			var result = analyzeResponse(responseText, eOrderActionType.CloseDeal);
			callback(result, callerId, unWrappedItems);
		};

		var sb = [],
			unWrappedItems = [];
		for (var i = 0, len = items.length; i < len; i++) {
			unWrappedItems[i] = ko.toJS(items[i]);
			sb.push(
				String.format(
					"{0}#{1}#{2}",
					unWrappedItems[i].positionNumber,
					unWrappedItems[i].spotRate,
					unWrappedItems[i].fwPips
				)
			);
		}

		var positions = sb.join("_");

		ajaxer.post(
			"dalOrder/closeDeals",
			"Deals/CloseDeals",
			String.format("positions={0}&SecurityToken={1}", positions, systemInfo.securityToken),
			OnLoadComplete,
			function (error) {
				ErrorManager.onError("dalOrder/closeDeals", error.message, eErrorSeverity.medium);
				if (failCallback) {
					failCallback();
				}
			}
		);
	}

	function addLimit(limit, callback, controller) {
		var ajaxer = new tAjaxer(),
			data = {
				limit: limit,
				SecurityToken: systemInfo.securityToken,
			};
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = limit.mode === eLimitMode.PriceAlert ? eOrderAction.NewPriceAlert : eOrderAction.NewLimit;
			var result = analyzeResponse(
				responseText,
				limit.mode === eLimitMode.PriceAlert ? eOrderActionType.NewPriceAlert : eOrderActionType.NewLimit
			);

			callback(result, callerId, limit.instrumentID, limit);
		};

		//--------------------------------
		if (controller) {
			ajaxer.jsonPost("dalOrder/addLimit", "Limits/AddLimit", JSON.stringify(data), OnLoadComplete, function (
				error
			) {
				ErrorManager.onError("dalOrder/addLimit", error.message, eErrorSeverity.medium);
			});
		} else {
			ajaxer.post(
				"dalOrder/addLimit",
				"api/limits/AddLimit",
				JSON.stringify(data),
				OnLoadComplete,
				function (error) {
					ErrorManager.onError("dalOrder/addLimit", error.message, eErrorSeverity.medium);
				}
			);
		}
	}

	function editLimit(limit, callback) {
		var ajaxer = new tAjaxer(),
			data = {
				limit: limit,
				SecurityToken: systemInfo.securityToken,
			};
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.EditLimit;
			var result = analyzeResponse(responseText, eOrderActionType.EditLimit);

			callback(result, callerId, limit);
		};

		ajaxer.post(
			"dalOrder/editLimit",
			"api/limits/EditLimit",
			JSON.stringify(data),
			OnLoadComplete,
			function (error) {
				ErrorManager.onError("dalOrder/editLimit", error.message, eErrorSeverity.medium);
			}
		);
	}

	function saveLimits(limits, callback) {
		var ajaxer = new tAjaxer(),
			data = {
				limits: limits,
				SecurityToken: systemInfo.securityToken,
			};
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.SaveLimits;
			var result = analyzeResponse(responseText);
			callback(result, callerId, null, limits);
		};

		ajaxer.post(
			"dalOrder/editLimit",
			"api/limits/SaveLimits",
			JSON.stringify(data),
			OnLoadComplete,
			function (error) {
				ErrorManager.onError("dalOrder/saveLimits", error.message, eErrorSeverity.medium);
			}
		);
	}

	function deleteLimit(limit, callback) {
		var ajaxer = new tAjaxer(),
			data = {
				limit: limit,
				SecurityToken: systemInfo.securityToken,
			};
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.DeleteLimit;

			var result = analyzeResponse(
				responseText,
				limit.mode === eLimitMode.PriceAlert ? eOrderActionType.DeletePriceAlert : eOrderActionType.DeleteLimit
			);
			callback(result, callerId, limit);
		};

		ajaxer.post(
			"dalOrder/deleteLimit",
			"api/limits/DeleteLimit",
			JSON.stringify(data),
			OnLoadComplete,
			function (error) {
				ErrorManager.onError("dalOrder/deleteLimit", error.message, eErrorSeverity.medium);
			}
		);
	}

	function deleteLimits(limits, callback) {
		var ajaxer = new tAjaxer(),
			data = {
				limits: limits,
				SecurityToken: systemInfo.securityToken,
			};
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.DeleteLimit;

			var result = analyzeResponse(
				responseText,
				limits[0].mode === eLimitMode.PriceAlert
					? eOrderActionType.DeletePriceAlert
					: eOrderActionType.DeleteLimit
			);
			callback(result, callerId, limits);
		};

		ajaxer.post(
			"dalOrder/deleteLimits",
			"api/limits/DeleteLimits",
			JSON.stringify(data),
			OnLoadComplete,
			function (error) {
				ErrorManager.onError("dalOrder/deleteLimits", error.message, eErrorSeverity.medium);
			}
		);
	}

	function deletePriceAlerts(priceAlerts, callback) {
		var ajaxer = new tAjaxer(),
			data = {
				limits: priceAlerts,
				SecurityToken: systemInfo.securityToken,
			};
		_lastTimeRequest = timeStamp();

		var OnLoadComplete = function (responseText) {
			var callerId = eOrderAction.DeleteLimit;

			var result = analyzeResponse(
				responseText,
				priceAlerts[0].mode === eLimitMode.PriceAlert
					? eOrderActionType.DeletePriceAlert
					: eOrderActionType.DeleteLimit
			);
			callback(result, callerId, priceAlerts);
		};

		ajaxer.post(
			"dalOrder/deleteLimits",
			"api/limits/DeleteLimits",
			JSON.stringify(data),
			OnLoadComplete,
			function (error) {
				ErrorManager.onError("dalOrder/deleteLimits", error.message, eErrorSeverity.medium);
			}
		);
	}

	function cashBackVolumes() {
		var ajaxer = new tAjaxer();
		_lastTimeRequest = timeStamp();

		var params = new StringBuilder();
		params.append(String.format("SecurityToken={0}", systemInfo.securityToken));

		var noCache = false;
		return ajaxer.promises
			.get(
				"dalOrder/cashBackVolumes",
				"Deals/CashBackGetVolumes",
				params.toString(),
				null,
				null,
				null,
				null,
				null,
				noCache
			)
			.then(function (responseText) {
				var result = analyzeResponse(responseText, eOrderActionType.CashBack);

				return result;
			})
			.fail(function (error) {
				ErrorManager.onError("dalOrder/cashBackVolumes", error.message, eErrorSeverity.medium);

				throw error;
			});
	}

	function getDealMarginDetails(instrumentId) {
		_lastTimeRequest = timeStamp();
		var ajaxer = tAjaxer();

		var params = new StringBuilder();
		params.append(String.format("instrumentId={0}", instrumentId));

		return ajaxer.promises
			.get(
				"dalOrder/getDealMarginDetails",
				"Deals/GetDealMarginDetails",
				params.toString(),
				null,
				null,
				1,
				null,
				null,
				false
			)
			.then(analyzeResponse)
			.fail(function (error) {
				ErrorManager.onError("dalOrder/getDealMarginDetails", error.message, eErrorSeverity.medium);

				throw error;
			});
	}

	function getMinDealAmounts() {
		var ajaxer = new tAjaxer();

		var minDealGroupId = UrlResolver.getMinDealGroupId();
		var minDealsVersion = UrlResolver.getMinDealsVersion();
		var minDealsHash = UrlResolver.getMinDealsHash();

		var staticInitialDataMinDealAmountsUrl = function () {
			return UrlResolver.getStaticInitialDataMinDealAmountsUrl(minDealGroupId, minDealsVersion, minDealsHash);
		};

		var initialDataMinDealAmountsFromOriginUrl = function () {
			return "InitialData/MinDealAmountsFromOrigin?groupId=" + minDealGroupId;
		};

		return ajaxer.promises
			.get("TDALNotificationData/getMinDealAmounts", staticInitialDataMinDealAmountsUrl())
			.then(analyzeResponse)
			.fail(function (headers) {
				ErrorManager.onWarning(
					"Min deal group version sync retry failed. Url: " +
						staticInitialDataMinDealAmountsUrl() +
						". Headers: " +
						headers
				);

				return ajaxer.promises
					.get("TDALNotificationData/getMinDealAmounts", initialDataMinDealAmountsFromOriginUrl())
					.then(analyzeResponse);
			});
	}

	function getOvernightFinancing(instrumentId, amount) {
		_lastTimeRequest = timeStamp();
		var ajaxer = tAjaxer();

		var params = new StringBuilder();
		params.append(String.format("instrumentId={0}&", instrumentId));
		params.append(String.format("amount={0}", amount));

		return ajaxer.promises
			.get(
				"dalOrder/getOvernightFinancing",
				"Deals/GetOvernightFinancing",
				params.toString(),
				null,
				null,
				null,
				null,
				false
			)
			.then(function (responseText) {
				var result = analyzeResponse(responseText, eOrderActionType.GetOvernightFinancing);

				return result;
			})
			.fail(function (error) {
				ErrorManager.onError("dalOrder/getOvernightFinancing", error.message, eErrorSeverity.medium);

				throw error;
			});
	}

	function analyzeResponse(responseText, caller) {
		var results = jsonhelper.STR2JSON("dalOreder:analyzeResponse", responseText),
			args;

		if (!results) {
			return [{ status: 0, msgKey: "OrderError1", itemId: "", arguments: null }];
		}

		results.arguments = null;
		//if not array of results - make it as array if one result
		if (!results.length) {
			results = [results];
		}

		for (var i = 0, ii = results.length; i < ii; i++) {
			var resultI = results[i];

			updateMsgKey(resultI, General.isDefinedType(caller) ? caller : resultI.action);

			resultI.arguments = null;

			// parse additional arguments if exists
			if (resultI.responseArgumentsJson) {
				args = jsonhelper.STR2JSON("dalOreder:analyzeResponse", resultI.responseArgumentsJson);

				if (Array.isArray(args)) {
					resultI.arguments = args;
				} else {
					resultI.arguments = [];
					resultI.arguments.push(args);
				}
			}
		}

		return results;
	}

	function updateMsgKey(result, caller) {
		if (result.status == eResult.Success) {
			if (caller == eOrderActionType.NewPriceAlert) {
				result.msgKey = "SuccessPriceAlertAdd";
			} else if (caller == eOrderActionType.NewLimit) {
				result.msgKey = "SuccessLimitAdd";
			} else if (caller == eOrderActionType.EditLimit) {
				result.msgKey = "SuccessLimitEdit";
			} else if (caller == eOrderActionType.DeleteLimit) {
				result.msgKey = "SuccessLimitDelete";
			} else if (caller == eOrderActionType.DeletePriceAlert) {
				result.msgKey = "SuccessPriceAlertDelete";
			} else if (caller == eOrderActionType.NewDeal) {
				result.msgKey = "SuccessDealAdd";
			} else if (caller == eOrderActionType.CloseDeal) {
				result.msgKey = "SuccessDealClose";
			}
		} else {
			result.msgKey = result.result;
		}
	}

	function lastTimeRequest() {
		return _lastTimeRequest;
	}

	function resetTimeRequest() {
		_lastTimeRequest = timeStamp();
	}

	return {
		OpenDeal: openDeal,
		CloseDeals: closeDeals,
		AddLimit: addLimit,
		EditLimit: editLimit,
		SaveLimits: saveLimits,
		DeleteLimit: deleteLimit,
		DeleteLimits: deleteLimits,
		DeletePriceAlerts: deletePriceAlerts,
		lastTimeRequest: lastTimeRequest,
		resetTimeRequest: resetTimeRequest,
		CashBackVolumesInfo: cashBackVolumes,
		GetDealMarginDetails: getDealMarginDetails,
		GetOvernightFinancing: getOvernightFinancing,
		GetMinDealAmounts: getMinDealAmounts,
	};
});

define(
    'initdatamanagers/DealsAmountsManager',
    [
        'require',
        'Q',
        'handlers/general',
        'handlers/HashTable',
        'dataaccess/dalorder'
    ],
    function DealsAmountsManagerDef(require) {
        var Q = require('Q'),
            general = require('handlers/general'),
            hashTable = require('handlers/HashTable'),
            dalOrders = require('dataaccess/dalorder'),
            minDealAmountsDefer = Q.defer();

        function DealsAmountsManager() {
            var minAmounts = new hashTable();

            function init() {
                getInitialMinDealAmounts();
            }

            function setCustomerMinDealsAmounts(minDealAmounts) {
                if (!general.isEmptyValue(minDealAmounts)) {
                    var i,
                        length = minDealAmounts.length;

                    for (i = 0; i < length; i++) {
                        minAmounts.OverrideItem(minDealAmounts[i][eMinDealValue.instrumentID], general.toNumeric(minDealAmounts[i][eMinDealValue.minAmount]));
                    }
                }
            }

            function updateMinDealAmounts(minDealAmounts) {
                setCustomerMinDealsAmounts(minDealAmounts);
            }

            function getDealMinMaxAmounts(instrumentId, instrumentMaxDeal) {
                var minAmount = minAmounts.GetItem(instrumentId);
                var maxAmount = Number(instrumentMaxDeal.replace(/[^0-9\.]+/g, ""));

                if (minAmount > maxAmount) {
                    minAmount = maxAmount;
                }

                return [minAmount, maxAmount];
            }

            function getInitialMinDealAmounts() {
                return dalOrders.GetMinDealAmounts()
                    .then(updateMinDealAmounts)
                    .then(function () { minDealAmountsDefer.resolve(); });
            }

            return {
                Init: init,
                GetDealMinMaxAmounts: getDealMinMaxAmounts,
                UpdateMinDealAmounts: updateMinDealAmounts,
                MinDealAmountsPromise: minDealAmountsDefer.promise
            };
        }

        return new DealsAmountsManager();
    }
);

define(
    'managers/profileinstruments',
    ['knockout', "handlers/Delegate",],
    function ProfileInstrument(ko, delegate) {
        var value = ko.observable({}),
            onUpdate = new delegate();

        function updateInstrumentAmount(instrument, amount) {
            var profileInstr = value();
            var found = false;

            if (profileInstr.list) {
                for (var i = 0; i < profileInstr.list.length; i++) {
                    if (profileInstr.list[i].instrument == instrument) {
                        profileInstr.list[i].defaultAmount = amount.toString();
                        found = true;
                        break;
                    }
                }
            } else {
                profileInstr.list = [];
            }

            if (!found) {
                profileInstr.list.push({ "instrument": instrument, "defaultAmount": amount.toString() });
            }

            profileInstr.selected = instrument;
            value(profileInstr);
        }

        function getSelectedInstrument() {
            return getAll().selected;
        }

        function getAll() {
            return value();
        }

        function init(initValue) {
            value(initValue);

            value.subscribe(function(updatedValue) {
                onUpdate.Invoke(updatedValue);
            });
        }

        return {
            Init: init,
            OnUpdate: onUpdate,
            GetAll: getAll,
            GetSelected: getSelectedInstrument,
            UpdateInstrumentAmount: updateInstrumentAmount
        };
    }
);


define(
    'modules/systeminfo',
    [
        'require',
        'handlers/general'
    ],
    function (require) {
        var general = require('handlers/general');

        window.systemInfo = window.systemInfo || {};

        function save(property, value) {
            if (general.isStringType(property) && property.length > 0 && general.isDefinedType(value)) {
                if (Object.keys(window.systemInfo).length < 1) {
                    // systemInfo was not initialized yet
                    var obj = {};
                    obj[property] = value;
                    save(obj);
                } else {
                    window.systemInfo[property] = value;
                }
            } else if (general.isObjectType(property)) {
                window.systemInfo = property;
            }
        }

        function get(property, defaultValue) {
            if (Object.keys(window.systemInfo).length > 0 && typeof window.systemInfo[property] !== 'undefined') {
                return window.systemInfo[property];
            }

            return defaultValue;
        }

        return {
            save: save,
            get: get
        };
    }
);
var eClientState = {
    portfolioStatic: 0,
    portfolioSummary: 1,
    flags: 2,
    ticks: 3,
    ohlcs: 4,
    deals: 5,
    limits: 6,
    notifications: 7,
    serverTime: 8,
    bonus: 9
};

//-----------------------------------------------------

var eSubscriptionRequestFlags = {
    Balance: 0,
    ClientStateHolder: 1,
    Deals: 2,
    Exposures: 3,
    Flags: 4,
    Limits: 5,
    Notifications: 6,
    PL: 7,
    PortfolioStatic: 8,
    Quotes: 9,
    TradingNotifications: 10,
    All: 11
};

//-----------------------------------------------------

var ePortfolioSummary = {
    csHolder: 0,
    dealPL: 1,
    netExposure: 2,
    isUpdated: 3,
    instrumentVolumes: 4,
    optionIndication: 5
};

//-----------------------------------------------------

var eInstruments = {
    id: 0,
    amountGroupId: 1,
    factor: 2,
    hasSignals: 3,
    ccyPair: 4,
    tradable: 5,
    defaultDealSize: 6,
    signalName: 7,
    maxDeal: 8,
    SLMinDistance: 9,
    TPMinDistance: 10,
    DecimalDigit: 11,
    PipDigit: 12,
    SpecialFontStart: 13,
    SpecialFontLength: 14,
    assetTypeId: 15,
    expirationDate: 16,
    instrumentTypeId: 17,
    baseSymbolId: 18,
    otherSymbolId: 19,
    exchangeInstrumentName: 20,
    exchange: 21,
    contractMonthAndYear: 22,
    instrumentEnglishName: 23,
    weightedVolumeFactor: 24,
    eventDate: 25,
    eventAmount: 26,
    marketPriceTolerance: 27
};

//-----------------------------------------------------

var eQuotes = {
    instrumentID: 0,
    bid: 1,
    ask: 2,
    open: 3,
    high: 4,
    low: 5,
    tradeTime: 6,
    state: 7,
    close: 8
};

//-----------------------------------------------------

var eSymbol = {
    id: 0,
    name: 1
};

//----------------------------------------------------

var eExposure = {
    symbolID: 0,
    amount: 1,
    accountSymbolAmount: 2,
    status: 3
};

//-----------------------------------------------------

var eInstrumentVolume = {
    InstrumentID: 0,
    BaseSymbolNetExposure: 1,
    OtherSymbolNetExposure: 2,
    AccountSymbolAmount: 3,
    RequiredMarginPercentage: 4,
    UsedMargin: 5,
    MarginUtilizationPercentage: 6,
    AvailableMargin: 7,
    MarginUtilizationStatus: 8,
    Status: 9,
    OrdersCounter: 10,
    LastUpdate: 11,
    BaseSymbolAmount: 12,
    OtherSymbolAmount: 13
};

var eMarginUtilizationStatus = {
    NA: 0,
    Low: 1,
    Medium: 2,
    High: 3
};

//-----------------------------------------------------

var ePortfolioStatic = {
    accountSymbol: 0,
    maxExposure: 1,
    securities: 2,
    tradingBonus: 3,
    pendingBonus: 4,
    isActive: 5,
    isDemo: 6,
    kycStatus: 7,
    amlStatus: 8,
    pendingWithdrawals: 9,

    pepStatus: 12,
    cddStatus: 13,
    pendingBonusType: 15,
    pendingBonusVolumePercentage: 16,
    kycReviewStatus: 17

};

//-----------------------------------------------------

var eCSHolder = {
    accountBalance: 0,
    equity: 1,
    netExposure: 2,
    margin: 3,
    exposureCoverage: 4,
    totalEquity: 5,
    openPL: 6,
    usedMargin: 7,
    marginUtilizationPercentage: 8,
    availableMargin: 9,
    marginUtilizationStatus: 10
};

//-----------------------------------------------------

var eCSFlags = {
    exposureCoverageAlert: 0,
    equityAlert: 1,
    exposureAlert: 2,
    marketState: 3,
    systemMode: 4,
    isUpdated: 5,
    limitMultiplier: 6
};

//----------------------------------------------------

var eSystemMode = {
    none: 0,
    active: 1,
    closing: 2,
    inactive: 3,
    shutdown: 4
};

//-----------------------------------------------------

var eCustomer = {
    accountBaseSymbol: 0,
    defaultCcy: 1,
    email: 2,
    accountNumber: 3,
    language: 4,
    dealPermit: 5,
    accountsCcy: 6
};

//-----------------------------------------------------

var eLimit = {
    instrumentID: 0,
    orderID: 1,
    positionNumber: 2,
    orderDir: 3,
    orderRate: 4,
    buySymbolID: 5,
    buyAmount: 6,
    sellSymbolID: 7,
    sellAmount: 8,
    type: 9,
    mode: 10,
    expirationDate: 11,
    entryTime: 12,
    slRate: 13,
    tpRate: 14,
    otherLimitID: 15,
    dealType: 16,
    status: 17
};

//-----------------------------------------------------

var eHistoricalLimit = {
    instrumentID: 0,
    orderID: 1,
    positionNumber: 2,
    orderDir: 3,
    orderRate: 4,
    buySymbolID: 5,
    buyAmount: 6,
    sellSymbolID: 7,
    sellAmount: 8,
    type: 9,
    mode: 10,
    executionDate: 11,
    entryTime: 12,
    slRate: 13,
    tpRate: 14,
    status: 15
};

//-----------------------------------------------------

var eDeal = {
    instrumentID: 0,
    orderID: 1,
    positionNumber: 2,
    orderDir: 3,
    orderRate: 4,
    buySymbolID: 5,
    buyAmount: 6,
    sellSymbolID: 7,
    sellAmount: 8,
    valueDate: 9,
    dealType: 10,
    exeTime: 11,
    slRate: 12,
    slID: 13,
    tpRate: 14,
    tpID: 15,
    additionalPL: 16,
    status: 17,
    spreadDiscount: 20
};

//-----------------------------------------------------

var eDealPL = {
    instrumentID: 0,
    dealID: 1,
    spotRate: 2,
    fwPips: 3,
    closingRate: 4,
    pl: 5,
    lastUpdate: 6,
    commission: 7
};

//-----------------------------------------------------

var eClosedDealsBase = {
    orderID: 0,
    positionNumber: 1,
    instrumentID: 2,
    buyAmount: 3,
    sellAmount: 4,
    orderDir: 5,
    dealType: 6,
    valueDate: 7,
    executionTime: 8,
    forwardPips: 9,
    instrumentEnglishName: 10,
    pipDigit: 11,
    decimalDigit: 12,
    specialFontStart: 13,
    specialFontLength: 14
};

var eClosedDeals = {
    dealRate: 15,
    pl: 16,
    originalPosNum: 17,
    plCCY: 18,
    positionStart: 19,
    additionalPL: 20
};

//-----------------------------------------------------

var eClosedDealsSummaries = {
    orderRateOpen: 15,
    orderRateClosed: 16,
    pl: 17,
    originalPosNum: 18,
    plCCY: 19,
    positionStart: 20,
    additionalPL: 21,
    spreadDiscount: 22,
    commission: 23
};

//-----------------------------------------------------

var eAccountingAction = {
    actionID: 0,
    actionTypeID: 1,
    symbolID: 2,
    date: 3,
    credit: 4,
    debit: 5,
    posNum: 6,
    comment: 7,
    balance: 8,
    totalsum: 9
};

//-----------------------------------------------------

var eContractRollover = {
    actionID: 0,
    posNum: 1,
    symbol: 2,
    date: 3,
    debit: 4,
    credit: 5,
    gap: 6,
    closeMidRate: 7,
    openMidRate: 8,
    spread: 9
};

//-----------------------------------------------------
var eAccountingActionsCategory = {
    All: 0,
    Deposits: 1,
    Withdrawals: 2,
    DealPL: 3,
    OvernightFinancing: 4,
    General: 5,
    OvernightHistory: 6,
    ContractRollover: 7,
    Dividend: 8
};

//-----------------------------------------------------

var eMinDealValue = {
    instrumentID: 0,
    groupID: 1,
    minAmount: 2
};

//-----------------------------------------------------

var eActivityLog = {
    MessageType: 0,
    DateTime: 1,
    SourceType: 2,
    Message: 3
};

var eExpiredOptions = {
    InstrumentID: 0,
    OptionID: 1,
    Amount: 2,
    AmountCCY: 3,
    BaseCCY: 4,
    OtherCCY: 5,
    OpenRate: 6,
    ServerRate: 7,
    ITMReturn: 8,
    OTMReturn: 9,
    EqualReturn: 10,
    OptionReturn: 11,
    USDValue: 12,
    ExpirationTime: 13,
    TimeGenerated: 14,
    ClosingRate: 15,
    Direction: 16,
    Distance: 17,
    ExpirationBid: 18,
    ExpirationAsk: 19,
    ExpirationTradeTime: 20,
    Canceled: 21
};

//-----------------------------------------------------

var eActivityLogFilterType = {
    Positions: 1,
    Limits: 2,
    Account: 3,
    Logins: 5
};

//-----------------------------------------------------

var eCreditCard = {
    CardTypeID: 0,
    Name: 1,
    OrderID: 2,
    Currencies: 3,
    D3SecureStatus: 4,
    DepositingActionType: 5
};

//-----------------------------------------------------

var eDepositCurrency = {
    CurrencyID: 0,
    SortOrderID: 1
};

//-----------------------------------------------------

var eDepositCurrencyWithValidation = {
    CurrencyID: 0,
    SortOrderID: 1,

    MinAmount: 3,
    MaxAmount: 4,
    MaxAmlAmount: 5,
};

//-----------------------------------------------------
var eDepositErrorType = {
    fieldValidation: 0,
    upload: 1,
    claim: 2,
    isInvalidLuhn: 4,
    ccTypeUnknown: 5
};

//-----------------------------------------------------

var ePaymentAuthStatus = {
    Disable: 0,
    Optional: 1,
    Required: 2
};

//-----------------------------------------------------

var eCardView = {
    PaymentID: 0,
    CardHolderName: 1,
    Last4: 2,
    CardNumberLength: 3,
    ExpirationMonth: 4,
    ExpirationYear: 5,
    IsDefault: 6,
    IsCVVRequired: 7,
    CardTypeID: 8,
    First6: 9,
    CcGuid: 10
};

//-----------------------------------------------------

var eWireTransferCountry = {
    CountryID: 0,
    Name: 1
};

//-----------------------------------------------------

var eWireTransferCountryContainer = {
    CountryID: 0,
    Name: 1,
    DefaultCurrencyID: 2,
    DefaultCurrencyName: 3,
    LocalCurrencies: 4,
    InternationalCurrencies: 5
};

//-----------------------------------------------------

var eWireTransferBankCurrency = {
    CurrencyID: 0,
    SortOrderID: 1,
    MinDeposit: 2
};

//-----------------------------------------------------

var eDepositResponse = {
    RequestID: 0,
    EngineStatusID: 1,
    ValidationStatusID: 2,
    ClearingStatusID: 3,
    DepositingTransactionStatusID: 4,
    CreditCardMaintenanceStatusID: 5,
    DepositingRequest3DSecureStatusID: 6,
    CreditCardAuthenticationModeID: 7,
    MessageDetails: 8,
    MoneybookersURL: 9,
    D3SecureURL: 10,
    WireTransferInvoiceInfo: 11,
    GlobalCollectAPMURL: 12,
    ConfirmationCode: 13,
    ClearerRequestUrl: 14,
    ClearerPostData: 15,
    BaseClearerTypeId: 16,
    TransactionDescriptor: 17,
    ClearerUrlHash: 18,
    Last4: 19
};

var ePostData = {
    Name: 0,
    Value: 1
};

//-----------------------------------------------------

var eDepositEngineStatus = {
    Pending: 10,
    Valid: 20,
    Success: 70,
    CCStored: 80,
    Finished: 100,
    Failed: 200
};

//-----------------------------------------------------

var eDepositValidationStatus = {
    CardIDNotFound: 1,
    AccountNumberNotFound: 2,
    Blocked: 3,
    BadLuhn: 4,
    UnkownCCType: 5,
    MaxCCReached: 6,
    Spoofing: 7,
    DoubleUse: 8,
    MinDeposit: 9,
    MaxDeposit: 10,
    DepositRangeValidationFailed: 11,
    InvalidCardType: 12,
    InvalidEmailFormat: 13,
    CreditCardExpired: 14,
    InvalidWMID: 15,
    WMCurrencyMismatch: 16,
    WMAmountMismatch: 17,
    AMLComplianceDenied: 18,
    RequestedCVVNotFound: 19,
    InvalidMobileFormat: 20,
    Valid: 21,
    WhiteList: 23,
    TransactionCancelledByUser: 25,
    RefundableClearer: 26,
    ExceededLimit: 27,
    Unknown: 28,
    MinMaxDepositBlocked: 29,
    MeikoPayMaxAmount: 30,
    InvalidConfiguration: 31,
    CCBinCountryBlacklist: 32,
    NoSupportedClearers: 33,
    MaxCardTypeUSDAmount: 34,
    ShowAdditionalPaymentOnFailedDeposit: 35
};

//-----------------------------------------------------

var eSecureFlow = {
    Need: 0,
    NotNeed: 1,
    Failed: 2
};

//-----------------------------------------------------

var ePaymentAuthMode = {
    None: 1,
    D3Secure: 2
};

//-----------------------------------------------------

var eClearingStatus = {
    TransactionRequired: 0,
    TransactionApproved: 1,
    FailedOn3DMissing: 11,
    FailedOnMoneybookersRequestCanceled: 7
};

//-----------------------------------------------------

var eWireTransferType = {
    NA: 0,
    Local: 1,
    International: 2
};

//------------------Withdrawal----------------------

var eWithdrawalView = {
    withdrawalID: 0,
    actionID: 1,
    amount: 2,
    symbolID: 3,
    requestDate: 4,
    withdrawalStatus: 5,
    rowVersion: 6,
    accountMaxRowVersion: 7,
    symbolName: 8,
    bankName: 9,
    bankAccount: 10,
    bankAddress: 11,
    bankCountryID: 12,
    bankCountryName: 13,
    bankBranch: 14,
    bankBeneficiary: 15,
    bankComments: 16
};

var eWithdrawalStatus = {
    NA: 0,
    pendingWithdrawal: 1,
    Approved: 2,
    Rejected: 3,
    processingWithdrawal: 4
};
//-----------------------------------------------------

var eDepositingRequest3DSecureStatus = {
    WaitngForResponse: 0,
    Enrolled: 1,
    AttemptedNotEnrolled: 2,
    NotEligible: 3,
    NoSupportedClearers: 4
};

//-----------------------------------------------------

var eKeepAlive = {
    Success: 0,
    Error: 1
};

//-----------------------------------------------------

var eQuotesUIOrder = {
    InstrumentID: 0,
    DealAmount: 1
};

//-----------------------------------------------------

var eNotification = {
    NotificationType: 0,
    ItemId: 1,
    RelatedItemId: 2,
    Version: 3
};

//-----------------------------------------------------

var eTransactionsReports = {
    PositionNumber: 0,
    TransactionNumber: 1,
    ExecutionDate: 2,
    BuySell: 3,
    Item: 4,
    UnitPrice: 5,
    QuantityTraded: 6,
    TotalAmountCurrency: 7,
    USDVolume: 8,
    TypeOfOrder: 9,
    OpenRolloverClose: 10,
    BaseCur: 11,
    OtherCur: 12,
    Commission: 13,
    InstrumentId: 14
};

//-----------------------------------------------------

var eInitialScreen = {
    ScreenId: 0,
    IsCustomScreen: 1
};

//-----------------------------------------------------

var ePresetCategory = {
    InstrumentType: 0,
    Presets: 1
};

//-----------------------------------------------------

var ePreset = {
    PresetId: 0,
    InstrumentType: 1,
    IsSelected: 2
};
//-----------------------------------------------------

// TradingSignal data
var eTradingSignal = {
    signalId: 0,
    signalTitle: 1,
    signalDate: 2,
    imagePath: 3,
    mediumTermLevel: 4,
    weekDelta: 5,
    longTermLevel: 6,
    monthDelta: 7,
    summary: 8,
    symbol: 9,
    story: 10,
    shortTerm: 11
};

// AlertSignal data
var eAlertSignal = {
    ma20: 0,
    ma50: 1,
    ma20_50: 2,
    macd_sl: 3,
    macd_0: 4,
    bollinger: 5,
    rsi70: 6,
    rsi30: 7,
    volume: 8,
    periodUnit: 9,
    periodValue: 10,
    id: 11,
    symbol: 12,
    dateTime: 13,
    title: 14
};

// CandlestickSignal data
var eCandlestickSignal = {
    candlestick: 0,
    last: 1,
    opinion: 2,
    invalidation: 3,
    id: 4,
    symbol: 5,
    dateTime: 6,
    title: 7
};

// TechAnalysisSignal data
var eTechAnalysisSignal = {
    week: 0,
    weekDelta: 1,
    month: 2,
    monthDelta: 3,
    id: 4,
    symbol: 5,
    dateTime: 6,
    title: 7
};

var eTicks = {
    instrumentID: 0,
    bid: 1,
    ask: 2,
    tradeTimeOffset: 3,
    state: 4
};

var eOhlc = {
    instrumentID: 0,
    open: 1,
    close: 2,
    high: 3,
    low: 4
};

var eBonus = {
    amountBase: 0,
    amountGivenBase: 1,
    volumeUsd: 2,
    startDate: 3,
    endDate: 4,
    accumulatedVolumeUsd: 5
};

var eNameValuePairIndex = {
    name: 0,
    value: 1
};

var eDepositResponseThreeDIndex = {
    paReq: 0,
    md: 1,
    termUrl: 2,
    acsUrl: 3,
    requiresExtraRedirect: 4,
};

define("enums/DataMembersPositions", function(){});

define(
    'initdatamanagers/InstrumentsManager',
    [
        'require',
        'Q',
        'handlers/general',
        'handlers/Delegate',
        'handlers/HashTable',
        'handlers/Instrument',
        'initdatamanagers/DealsAmountsManager',
        'managers/profileinstruments',
        'modules/systeminfo',
        'enums/DataMembersPositions'
    ],
    function InstrumentsManagerDef(require) {
        var Q = require('Q'),
            general = require('handlers/general'),
            delegate = require('handlers/Delegate'),
            hashTable = require('handlers/HashTable'),
            Instrument = require('handlers/Instrument'),
            DealsAmountsManager = require('initdatamanagers/DealsAmountsManager'),
            ProfileInstruments = require('managers/profileinstruments'),
            systemInfo = require('modules/systeminfo');

        //----------------------------------------------------------------------
        // Instrument - extend
        //----------------------------------------------------------------------

        Instrument.prototype.isOvernightFinancing = function () {
            // temporary logic, it suppose to be dependent on the spread group value (is zero 
            return this.isFuture || this.isShare || (this.isForex && this.isOvernightOnForex);
        };

        Instrument.prototype.getCorporateActionDate = function () {
            // the corporate action date is equal to expiration date
            if (this.isShare)
                return this.expirationDate;
            else
                return null;
        };

        Instrument.prototype.getInstrumentDividendDate = function () {
            if (this.isShare)
                return this.eventDate;
            else
                return null;
        };

        Instrument.prototype.getInstrumentDividendAmount = function () {
            if (this.isShare)
                return this.eventAmount;
            else
                return null;
        };

        Instrument.prototype.getInstrumentRolloverDate = function () {
            if (this.isFuture)
                return this.eventDate;
            else
                return null;
        };

        Instrument.prototype.roundRateToPip = function (rate, orderDir, limitType) {
            var sign = general.addSign(orderDir, limitType),
                value = Format.roundToPip(rate, this.PipDigit, this.DecimalDigit, sign);

            if (value === false) {
                return '';
            }

            return value;
        };

        //----------------------------------------------------------------------
        // InstrumentsManager
        //----------------------------------------------------------------------
        function InstrumentsManager() {
            var instrumentIDs = [],
                // todo consider union with presetInstruments see set customised preset method
                customizedUiOrder = [],
                quotesUiOrder = [],
                instrumentList = new hashTable(),
                presetInstruments = {},
                enhancedInstruments = [],
                onUiOrderChanged = new delegate(),
                onFavoritesPresetChanged = new delegate(),
                onEnhancedInstrumentsChange = new delegate(),
                customerType,
                hasWeightedVolumeFactor,
                profileInstrumentList,
                isOvernightOnForex;

            //---------------------------------------------------------

            function init(config) {
                customerType = config.customerType;
                profileInstrumentList = config.initialProfileInstrument.list;
                hasWeightedVolumeFactor = config.hasWeightedVolumeFactor;
                isOvernightOnForex = config.isOvernightOnForex;

                setCustomizedUiOrder(config.customUiOrder);
                setInitialPresets(config.customUiOrder, config.initialUiOrder, config.initialScreenId);

                buildCollection();
            }

            //---------------------------------------------------------
            function clear() {
                instrumentIDs.length = 0;
                customizedUiOrder.length = 0;
                quotesUiOrder.length = 0;
                instrumentList.Clear();
                presetInstruments = {};
                enhancedInstruments.length = 0;
                onUiOrderChanged.Flush();
                onFavoritesPresetChanged.Flush();
                onEnhancedInstrumentsChange.Flush();

                customerType = null;
                hasWeightedVolumeFactor = null;
                isOvernightOnForex = null;
            }

            //---------------------------------------------------------
            function setInitialPresets(customUiOrder, initialUiOrder, initialScreenId) {
                var initialPresets = {};

                initialPresets[ePresetType.PresetCustomized] = customUiOrder;
                initialPresets[initialScreenId] = initialUiOrder;

                setPresetIntruments(initialPresets);
            }

            //---------------------------------------------------------
            function setPresetIntruments(fullPresetInstruments) {
                var tmpPreset;

                for (var presetId in fullPresetInstruments) {
                    if (!fullPresetInstruments.hasOwnProperty(presetId)) {
                        continue;
                    }

                    tmpPreset = fullPresetInstruments[presetId].map(function (instrument) {
                        var presetItem = [];

                        presetItem[eQuotesUIOrder.InstrumentID] = instrument[eQuotesUIOrder.InstrumentID];
                        presetItem[eQuotesUIOrder.DealAmount] = instrument[eQuotesUIOrder.DealAmount].toLocaleString();

                        return presetItem;
                    });

                    if (general.equals(presetInstruments[presetId], tmpPreset) === false) {
                        presetInstruments[presetId] = tmpPreset;
                    }
                }
            }

            //---------------------------------------------------------

            function clearInstrumentDealMinMaxAmounts(updatedMinDealAmounts) {
                var instruments = systemInfo.get('instruments') || [];

                for (var i = 0, length = instruments.length; i < length; i++) {
                    var instrument = new Instrument(instruments[i], hasWeightedVolumeFactor, isOvernightOnForex);

                    instrument.dealMinMaxAmounts = [];
                    instrumentList.OverrideItem(instrument.id, instrument);
                }

                DealsAmountsManager.UpdateMinDealAmounts(updatedMinDealAmounts);
            }

            //---------------------------------------------------------

            function getUpdatedInstrumentWithDealMinMaxAmounts(instrumentId) {
                var instrument = instrumentList.GetItem(instrumentId);

                if (instrument.dealMinMaxAmounts.length > 0) {
                    return Q({ dealMinMaxAmounts: instrument.dealMinMaxAmounts, defaultDealSize: instrument.defaultDealSize });
                }

                return DealsAmountsManager.MinDealAmountsPromise.then(function () {
                    setInstrumentDealMinMaxAmounts(instrument);
                    instrument = instrumentList.GetItem(instrumentId);

                    return { dealMinMaxAmounts: instrument.dealMinMaxAmounts, defaultDealSize: instrument.defaultDealSize };
                });
            }

            //---------------------------------------------------------
            function setInstrumentDealMinMaxAmounts(instrument) {
                var defaultDealSize,
                    filteredInstrumentFromProfile,
                    length,
                    i;

                var quotesUIOrder = getCustomizedUiOrder();
                instrument.dealMinMaxAmounts = DealsAmountsManager.GetDealMinMaxAmounts(instrument.id, instrument.maxDeal);

                if (profileInstrumentList) {
                    for (i = 0, length = profileInstrumentList.length; i < length; i++) {
                        if (profileInstrumentList[i].instrument == instrument.id) {
                            filteredInstrumentFromProfile = profileInstrumentList[i];

                            break;
                        }
                    }
                }

                if (filteredInstrumentFromProfile) {
                    defaultDealSize = filteredInstrumentFromProfile.defaultAmount;
                } else {
                    defaultDealSize = instrument.defaultDealSize;
                    // Find the default deal size if it has been defined on UIQuotesSettings
                    for (i = 0, length = quotesUIOrder.length; i < length; i++) {
                        if (quotesUIOrder[i][eQuotesUIOrder.InstrumentID] == instrument.id) {
                            defaultDealSize = quotesUIOrder[i][eQuotesUIOrder.DealAmount];
                            break;
                        }
                    }

                    if (customerType === eCustomerType.TradingBonus) {
                        defaultDealSize = instrument.dealMinMaxAmounts[0];
                    }
                }

                // Find the nearest amount from the list
                if (defaultDealSize) {

                    var isDefaultDealSizeOnTheInterval = general.toNumeric(instrument.dealMinMaxAmounts[0]) <= general.toNumeric(defaultDealSize) && general.toNumeric(defaultDealSize) <= general.toNumeric(instrument.dealMinMaxAmounts[1]);

                    if (isDefaultDealSizeOnTheInterval) {
                        instrument.defaultDealSize = general.toNumeric(defaultDealSize);
                    } else {
                        //happens when defaultDealSize is less than instrument.dealMinMaxAmounts[0]
                        instrument.defaultDealSize = instrument.dealMinMaxAmounts[0];
                    }
                } else {
                    instrument.defaultDealSize = instrument.dealMinMaxAmounts[0];
                }

                instrumentList.OverrideItem(instrument.id, instrument);
            }

            //---------------------------------------------------------
            function setInstrumentDealAmount(instrumentId, dealAmount) {
                var instrument = instrumentList.GetItem(instrumentId);

                if (instrument) {
                    instrument.defaultDealSize = dealAmount;
                    instrumentList.SetItem(instrumentId, instrument);
                }

                ProfileInstruments.UpdateInstrumentAmount(instrumentId, dealAmount);
            }

            //---------------------------------------------------------
            function getInstrumentBySignalName(signalName) {
                var returnInstrument;

                instrumentList.ForEach(function (i, instrument) {
                    if (instrument.signalName.trim().toLowerCase() == signalName.trim().toLowerCase()) {
                        returnInstrument = instrument;
                    }
                });

                return returnInstrument;
            }

            //---------------------------------------------------------
            function buildCollection() {
                var instruments = systemInfo.get('instruments') || [];

                for (var i = 0, length = instruments.length; i < length; i++) {
                    var instrument = new Instrument(instruments[i], hasWeightedVolumeFactor, isOvernightOnForex);

                    if (instrument.isTradable) {
                        instrumentIDs.push(instrument.id);
                    }

                    instrumentList.OverrideItem(instrument.id, instrument);
                }

                buildEnhancedInstrumentList();
            }

            //---------------------------------------------------------
            function buildEnhancedInstrumentList() {
                instrumentList.ForEach(function (i, instrument) {
                    if (!general.isDefinedType(instrument['id']) || instrument.weightedVolumeFactor <= 1) {
                        return;
                    }

                    enhancedInstruments.push({
                        id: instrument.id,
                        weightedVolumeFactor: instrument.weightedVolumeFactor
                    });
                });
            }

            //---------------------------------------------------------
            function updateInstruments(instrumentsFromServer) {
                var enhancedInstrumentListBackup = enhancedInstruments.splice(0);

                systemInfo.save('instruments', instrumentsFromServer || []);

                instrumentIDs.length = 0;
                instrumentList.Clear();

                buildCollection();

                if (!general.equals(enhancedInstruments, enhancedInstrumentListBackup)) {
                    onEnhancedInstrumentsChange.Invoke();
                }
            }

            //---------------------------------------------------------
            function getInstrument(instrumentId) {
                return instrumentList.GetItem(instrumentId);
            }

            function isInstrumentStock(instrumentId) {
                var instrument = getInstrument(instrumentId);

                if (!general.isNullOrUndefined(instrument)) {
                    return instrument.isStock;
                }

                return false;
            }

            //---------------------------------------------------------
            function getInstrumentPropUsedForConversion(fromSymbolId, toSymbolId) {
                var instrumentProp = null;

                instrumentList.ForEach(function (i, instrument) {
                    if (instrument.baseSymbol == fromSymbolId && instrument.otherSymbol == toSymbolId) {
                        instrumentProp = { id: instrument.id, factor: instrument.factor, isOppositeInstrumentFound: false };
                    }

                    if (instrument.otherSymbol == fromSymbolId && instrument.baseSymbol == toSymbolId) {
                        instrumentProp = { id: instrument.id, factor: instrument.factor, isOppositeInstrumentFound: true };
                    }
                });

                return instrumentProp;
            }

            //---------------------------------------------------------
            function getEnhancedInstruments() {
                return enhancedInstruments;
            }

            //---------------------------------------------------------
            function getInstrumentName(instrumentId) {
                var instrument = getInstrument(instrumentId);

                if (instrument) {
                    return instrument.ccyPair;
                }

                return instrumentId;
            }

            //---------------------------------------------------------
            function getInstrumentAttribute(instrumentId, attrName) {
                var instrument = getInstrument(instrumentId);

                if (instrument) {
                    return instrument[attrName];
                }

                return '';
            }

            //---------------------------------------------------------
            function getInstrumentIds() {
                return instrumentIDs;
            }

            //---------------------------------------------------------
            function getCustomizedUiOrder() {
                return customizedUiOrder;
            }

            //---------------------------------------------------------
            function getQuotesUiOrder() {
                return quotesUiOrder;
            }

            //---------------------------------------------------------
            function getFavoriteInstruments(top) {
                top = top || customizedUiOrder.length;

                if (top > customizedUiOrder.length) {
                    top = customizedUiOrder.length;
                }

                return getInstrumentsFromPreset(customizedUiOrder, ePresetType.PresetCustomized, top);
            }

            //---------------------------------------------------------
            function getMainMostPopularPresetIds() {
                return [
                    ePresetType.PresetMostPopular,
                    ePresetType.PresetMostPopularWithoutFutures,
                    ePresetType.PresetMostPopularCurrencies,
                    ePresetType.PresetMostPopularWithoutShares,
                    ePresetType.PresetMostPopularWithoutFuturesWithoutShares
                ];
            }

            //---------------------------------------------------------
            function getMainMostPopularPresetId() {
                var mainMostPopularPresetIds = getMainMostPopularPresetIds();

                var mostPopularPresetId = general.objectFirst(mainMostPopularPresetIds, function hasInstruments(presetId) {
                    var preset = presetInstruments[presetId];

                    return preset && preset.length > 0;
                });

                return mostPopularPresetId;
            }

            //---------------------------------------------------------
            function getMainMostPopularInstruments() {
                var mostPopularPresetId = getMainMostPopularPresetId();

                return getInstrumentsFromPreset(presetInstruments[mostPopularPresetId], mostPopularPresetId);
            }

            //---------------------------------------------------------
            function getInstrumentsFromPreset(preset, presetId, count) {
                var instruments = [],
                    instrumentId,
                    instrument;

                if (general.isNullOrUndefined(preset)) {
                    return instruments;
                }

                var length = count || preset.length;

                for (var i = 0; i < length; i++) {
                    instrumentId = preset[i][eQuotesUIOrder.InstrumentID];
                    instrument = getInstrument(instrumentId);

                    if (instrument) {
                        instrument.presetId = presetId;
                        instruments.push(instrument);
                    }
                }

                return instruments;
            }

            //---------------------------------------------------------
            function setQuotesUiOrder(uiOrder, skipRegister, listName) {
                uiOrder = uiOrder || [];
                listName = listName || eRegistrationListName.QuotesTable;
                quotesUiOrder = uiOrder.slice(0);

                if (!skipRegister) {
                    onUiOrderChanged.Invoke(listName, quotesUiOrder);
                }
            }

            //---------------------------------------------------------
            function setCustomizedUiOrder(uiOrder, skipUpdate) {
                uiOrder = uiOrder || [];
                customizedUiOrder = uiOrder.slice(0);

                // todo union this ds in server if not breaking logic on editing custom
                if (general.equals(presetInstruments[ePresetType.PresetCustomized], customizedUiOrder) === false && !skipUpdate) {
                    presetInstruments[ePresetType.PresetCustomized] = customizedUiOrder;
                    onFavoritesPresetChanged.Invoke();
                }
            }

            //---------------------------------------------------------
            function getPresetInstruments(presetId) {
                if (typeof presetId !== 'undefined') {
                    return presetInstruments[presetId];
                }

                return presetInstruments;
            }

            //---------------------------------------------------------
            function getUserDefaultInstrument() {
                var instrumentId = 3631;
                var profileInstrumentId = ProfileInstruments.GetSelected();

                if (profileInstrumentId && getInstrument(profileInstrumentId)) {
                    instrumentId = profileInstrumentId;
                }

                return instrumentId;
            }

            //---------------------------------------------------------
            function foreachIntrument(handler) {
                return instrumentList.ForEach(handler);
            }

            //---------------------------------------------------------
            function hasIntrumentId(instrumentId) {
                return instrumentList.HasItem(instrumentId);
            }

            //---------------------------------------------------------
            function getPresetsForInstrument(instrumentId) {
                var presetsList = [];

                for (var presetId in presetInstruments) {
                    if (!presetInstruments.hasOwnProperty(presetId)) {
                        continue;
                    }

                    var instruments = presetInstruments[presetId];

                    for (var idxInstrument = 0; idxInstrument < instruments.length; idxInstrument++) {
                        if (instruments[idxInstrument][0] === instrumentId) {
                            presetsList.push(presetId);
                            break;
                        }
                    }
                }

                return presetsList;
            }

            //---------------------------------------------------------
            function getInstrumentFirstChar(instrumentId) {
                var instrument = getInstrument(instrumentId);

                return instrument ? instrument.instrumentEnglishName.substring(0, 1) : '***';
            }

            return {
                Init: init,
                Clear: clear,
                SetPresetIntruments: setPresetIntruments,
                GetInstrumentIds: getInstrumentIds,
                GetCustomizedUiOrder: getCustomizedUiOrder,
                SetCustomizedUiOrder: setCustomizedUiOrder,
                GetQuotesUIOrder: getQuotesUiOrder,
                SetQuotesUIOrder: setQuotesUiOrder,
                ForeachInstrument: foreachIntrument,
                GetEnhancedInstruments: getEnhancedInstruments,
                GetInstrument: getInstrument,
                HasInstrumentId: hasIntrumentId,
                GetInstrumentPropUsedForConversion: getInstrumentPropUsedForConversion,
                GetInstrumentName: getInstrumentName,
                GetInstrumentAttribute: getInstrumentAttribute,
                GetFavoriteInstruments: getFavoriteInstruments,
                GetMainMostPopularInstruments: getMainMostPopularInstruments,
                SetInstrumentDealAmount: setInstrumentDealAmount,
                GetUpdatedInstrumentWithDealMinMaxAmounts: getUpdatedInstrumentWithDealMinMaxAmounts,
                ResetInstrumentsDealAmounts: clearInstrumentDealMinMaxAmounts,
                GetPresetInstruments: getPresetInstruments,
                GetInstrumentBySignalName: getInstrumentBySignalName,
                GetUserDefaultInstrumentId: getUserDefaultInstrument,
                UpdateInstruments: updateInstruments,
                OnUiOrderChanged: onUiOrderChanged,
                OnEnhancedInstrumentsChange: onEnhancedInstrumentsChange,
                OnFavoritesPresetChanged: onFavoritesPresetChanged,
                GetPresetsForInstrument: getPresetsForInstrument,
                GetInstrumentFirstChar: getInstrumentFirstChar,
                IsInstrumentStock: isInstrumentStock,
                GetMainMostPopularPresetId: getMainMostPopularPresetId
            };
        }

        var module = window.$instrumentsManager = new InstrumentsManager();

        return module;
    }
);

define(
    'initdatamanagers/SymbolsManager',
    [
        'require',
        'handlers/general',
        'handlers/Logger',
        'handlers/HashTable',
        'Dictionary',
        'initdatamanagers/InstrumentsManager'
    ],
    function SymbolsManagerDef(require) {
        var general = require('handlers/general'),
            logger = require('handlers/Logger'),
            hashTable = require('handlers/HashTable'),
            dictionary = require('Dictionary'),
            instrumentsManager = require('initdatamanagers/InstrumentsManager');

        function Symbol(id, name) {
            this.id = id;
            this.name = name;
        }

        function SymbolsManager() {
            var symbols = new hashTable();

            function init(data) {
                var staticSymbols = data;

                if (!general.isEmptyValue(staticSymbols)) {
                    for (var i = 0, ii = staticSymbols.length; i < ii; i++) {
                        var item = staticSymbols[i];

                        symbols.SetItem(item[eSymbol.id], new Symbol(item[eSymbol.id], item[eSymbol.name]));
                    }
                }
            }

            function getSymbol(id) {
                var symbol = symbols.GetItem(id);

                if (!symbol) {
                    logger.log('TSymbolsManager/getSymbol', String.format('symbol {0} not exist', id));
                }

                return symbol;
            }

            function getTranslatedSymbolById(id) {
                var symbol = dictionary.GetItem('symbol_' + id);

                if (!symbol) {
                    logger.log('TSymbolsManager/getSymbol', String.format('symbol {0} not exist', id));
                }

                return symbol;
            }

            function getTranslatedSymbolByName(name) {
                var lowerCaseName = name ? name.toLowerCase() : '';
                var symbol = dictionary.GetItem('symbolbyname_' + lowerCaseName);

                if (!symbol) {
                    logger.log('TSymbolsManager/getSymbol', String.format('symbol {0} not exist', name));
                }

                return symbol;
            }

            function extractSymbolsNames(instrumentId) {
                var instrument = instrumentsManager.GetInstrument(instrumentId);

                if (instrument) {
                    return {
                        'base': getTranslatedSymbolById(instrument.baseSymbol),
                        'other': getTranslatedSymbolById(instrument.otherSymbol)
                    };
                }

                return;
            }

            return {
                Symbols: symbols,
                Init: init,
                GetSymbol: getSymbol,
                GetTranslatedSymbolById: getTranslatedSymbolById,
                GetTranslatedSymbolByName: getTranslatedSymbolByName,
                ExtractSymbolsNames: extractSymbolsNames
            };
        }

        var module = window.$symbolsManager = new SymbolsManager();

        return module;
    }
);

var eForms = {
    Deals: 2,
    Statement: 5,
    Deposit: 6,
    Withdrawal: 7,
    ActivityLog: 8,
    PersonalDetails: 9,
    ClientQuestionnaire: 10,
    ViewAndPrintWithdrawal: 12,
    TransactionsReport: 13,
    UploadDocuments: 14,
    TradingSignals: 15,
    ThirdParty: 16,
    Tutorials: 19,
    EducationalTutorials: 20,
    AdvinionChart: 21,
    EconomicCalendar: 23,
    AccountCardRecords: 24,
    ContractRollover: 25,
    NotificationsSettings: 26,
    ConcretePaymentForm: 34,
    DepositSuccess: 64,
    DepositPending: 65,
    DepositConfirmation: 66,
    RolledOver: 67,
    Settings: 68,
    PriceAlerts: 69,
    WireTransferSuccess: 70,
    PendingWithdrawal: 71,
    WithdrawalThankYou: 72,
    DocumentVerificationModal: 73
};

var eViewTypes = {
    vQuotes: 1,
    vOpenDeals: 2,
    vLimits: 3,
    vClosedDeals: 4,
    vWallet: 5,
    vNewDeal: 6,
    vClosedDealDetails: 7,
    vNewLimit: 9,
    vBalance: 10,
    vNetExposure: 11,
    vWithdrawal: 12,
    vQuotesPreset: 14,
    vDeposit: 15,
    vEditClosingLimit: 16,
    vContact: 17,
    vPendingWithdrawal: 18,
    vEditLimit: 20,
    vMenu: 21,
    vCharts: 23,
    vAddInstrument: 24,
    vTradingSummery: 25,
    vSummeryView: 26,
    vHomepageContent: 27,
    vSideMenu: 28,
    vChangePassword: 29,
    vPaymentTypes: 30,
    vActivityLog: 31,
    vAccountStatment: 33,
    vPersonalDetails: 34,
    vToolBar: 35,
    vPageTitle: 36,
    vClientQuestionnaire: 38,
    vClosedDealsSummaries: 39,
    vCloseDeal: 40,
    vRolledOver: 41,
    vOrderTabs: 43,
    vMarginStatus: 44,
    vAmlStatus: 45,
    vViewAndPrintWithdrawal: 46,
    vTransactionsReport: 47,
    vRelatedPosition: 48,
    vUploadDocuments: 49,
    vTradingSignals: 52,
    vThirdParty: 53,
    vTradingSignalsTutorials: 54,
    vTutorials: 59,
    vCreditCard3rdParty: 60,
    vEditLimitExpirationDate: 61,
    vEmpCashU: 62,
    vEducationalTutorials: 63,
    vEducationalTutorialsPopup: 64,
    vEpaylinks: 65,
    vMoneyBookers: 72,
    vConcretePaymentForm: 75,
    vSafeChargeCashier: 100,
    vAdvinionChart: 101,
    vMissingCustomerInformation: 102,
    vAstropay: 106,
    vCddFinancialDetails: 107,
    vNetellerGO: 108,
    vPaySafeCard: 109,
    vWireTransfer: 110,
    vAccountSummaryWallet: 111,
    vNewDealSlip: 1000,
    vEconomicCalendar: 112,
    vMarketClosed: 115,
    vCashBack: 116,
    vGlobalCollectAPM: 117,
    vInatecAPMGiropay: 118,
    vInatecAPMPrzelewy24: 119,
    vAccountCardRecords: 120,
    vNoAPIClearer: 121,
    vEcoPayz: 122,
    vSofortDirect: 123,
    vTransactionSwitcher: 125,
    vSignalsTechnicalAnalysisGrid: 126,
    vSignalsAlertGrid: 127,
    vSignalsCandleStickGrid: 128,
    vSignalsService: 129,
    vSignalsDisclamer: 130,
    vKluwp: 131,
    vContractRollover: 132,
    vDealsTabs: 133,
    vNotificationsSettings: 134,
    vClosedDealsDialog: 135,
    vRPN: 136,
    vPayPal: 137,
    vAstropayCard: 138,
    vGenericCreditCard: 139,
    vPayRetailers: 140,
    vDepositSuccessThankYou: 219,
    vDepositPendingThankYou: 220,
    vDepositConfirmation: 221,
    vSettings: 222,
    vAccountPreferences: 223,
    vEnableTrading: 224,
    vPriceAlerts: 226,
    vRisingSunAPM: 227,
    vNewPriceAlert: 228,
    vWireTransferSuccess: 229,
    vJeton: 230,
    vZotapayAPM: 231,
    vWithdrawalThankYou: 232,
    vBitWallet: 233,
    vDocumentVerificationModal: 234,
    vNuveiAPM: 235,
    vGlobePay: 236,
    vAstropayWallet: 237,
    vPerfectMoney: 238
};

var eTemplateNames = {
    editLimitNavigator: 'deal-details-navigator'
};

var eFullScreenControl = {
    TransactionSwitcher: 'TransactionSwitcherDivFullScreen',
    ChartPage: 'ChartPageFullScreen'
};

var eDialog = {
    NewDealSlip: "NewDealSlipDiv",
    NewLimit: "dlgNewLimit",
    TransactionSwitcher: 'TransactionSwitcherDiv',
    NewPriceAlert: 'NewPriceAlertDiv',
    EditLimitExpirationDate: "dlgEditLimitExpirationDate",
    EditClosingLimit: "dlgEditClosingLimit",
    CloseDeal: "dlgCloseDeal",
    ClosedDeal: "dlgClosedDeals",
    RolledOver: "RolledOverDiv",
    EditLimit: "dlgEditLimit",
    MarginStatus: "MarginStatusDiv",
    AmlStatus: "AmlStatusDiv",
    RelatedPosition: "RelatedPositionDiv",
    TradingSignalsTutorials: "TradingSignalsTutorialsDiv",
    EducationalTutorialsPopup: "EducationalTutorialsPopupDiv",
    MissingCustomerInformation: "MissingCustomerInformationDiv",
    MissingCustomerInformationContainer: "#paymentTypesContainerABTesting",
    NetExposuresSummaryDialog: 'fx-component-netexposures-summary',
    CashBackDialog: 'CashBackDiv',
    AccountCardRecords: "AccountCardRecordsDiv",
    ContractRollover: "ContractRolloverDiv",
    ClientQuestionnaire: "KycStatusDiv",
    DepositConfirmation: "DepositConfirmationDiv",
    DocumentVerification: "DocumentVerificationDiv"
};

var eFullScreenTogleControls = {
    TransactionSwitcher: { full: 'TransactionSwitcherDivFullScreen', default: eDialog.TransactionSwitcher },
    ChartPage: { full: 'ChartPageFullScreen', default: eForms.AdvinionChart },
    EditClosingLimit: { full: 'TransactionSwitcherDivFullScreen', default: eDialog.EditClosingLimit },
    CloseDeal: { full: 'TransactionSwitcherDivFullScreen', default: eDialog.CloseDeal },
    EditLimit: { full: 'TransactionSwitcherDivFullScreen', default: eDialog.EditLimit }
};

var eClientExportTable = {
    2: 'tblOpenDeals',
    3: 'tblLimits',
    4: 'tblClosedDeals',
    13: 'tblTransactionsReport',
    66: 'depositsFrame'
};

var eServerExportTable = {
    3: 'tblExportLimits',
    4: 'tblExportClosedDeals',
    5: 'tblExportAccountStatment',
    8: 'tblExportActivityLog'
};

var eComponent = {
    3: 'historical-limits',
    4: 'closed-deals',
    5: 'account-statement',
    8: 'activity-log'
};

var eSettingsViews = {
    PersonalInformation: {
        form: eForms.Settings,
        viewId: eViewTypes.vPersonalDetails
    },
    AccountPreferences: {
        form: eForms.Settings,
        viewId: eViewTypes.vAccountPreferences
    },
    ChangePassword: {
        form: eForms.Settings,
        viewId: eViewTypes.vChangePassword
    },
    NotificationsSettings: {
        form: eForms.Settings,
        viewId: eViewTypes.vNotificationsSettings
    }
};

var eAbTestProps = {
    dealSlipsRevised: 'fx-revised-deal-slips'
};

define("customEnums/ViewsEnums", function(){});

var eResult = {
    Error: 0,
    Success: 1
};

//----------------------------------------------------

var eRequestMode = {
    Initial: 0,
    Correct: 1,
    Failed: 2
};

//----------------------------------------------------

var eOrderResult = {
    OK: 0,
    Error: 1
};

//----------------------------------------------------

var eQuoteStates = {
    None: 0,
    Enabled: 1,
    Locked: 2,
    TimedOut: 3,
    Disabled: 4,
    Up: 5,
    Down: 6,
    NotChanged: 7
};

var eHighLowStates = {
    NA: 0,
    MarketClosed: 1,
    Active: 2
};

//----------------------------------------------------

var eMessages = {
    InvalidLimitRate: 1,
    LimitRateIsEmpty: 2,
    TPRateNotInRange: 3,
    SLRateNotInRange: 4,
    InvalidTPRate: 5,
    InvalidSLRate: 6,
    InvalidDate: 7
};

//----------------------------------------------------

var eOrderDir = {
    Sell: 0,
    Buy: 1,
    None: 2
};

//----------------------------------------------------

var eStartSpinFrom = {
    Below: 0,
    Above: 1,
    None: 2
};

//----------------------------------------------------

var eDateFilter = {
    Yesterday: 0,
    Today: 1,
    Tomorrow: 2,
    ThisWeek: 3,
    NextWeek: 4
};

//----------------------------------------------------

var eImportanceFilter = {
    Low: 1,
    Medium: 2,
    Hight: 3
};

//----------------------------------------------------

var eCountryFilter = {
    AU: 0,
    CA: 1,
    CN: 2,
    DE: 3,
    EU: 4,
    FR: 5,
    IT: 6,
    JP: 7,
    NZ: 8,
    CH: 9,
    UK: 10,
    US: 11
};

//----------------------------------------------------

var eNewDealTool = {
    None: 0,
    Chart: 1,
    MarketLiveInfo: 2,
    EconomicCalendar: 3,
    Signals: 4,
    InstrumentInfo: 5
};

//----------------------------------------------------

var eNewDealValue = {
    Inline: 'Inline',
    Popup: 'Popup',
    None: 'None'
};

//----------------------------------------------------

var eDealPage = {
    NewDeal: 'NewDeal',
    NewLimitViewModel: 'NewLimitViewModel',
    CloseDeal: 'CloseDeal',
    EditClosingLimit: 'EditClosingLimit',
    EditLimitViewModel: 'EditLimitViewModel',
    EditIfDoneLimit: 'EditIfDoneLimit'
};

//----------------------------------------------------

var eTrackingDealVersion = {
    NewDealSlip: '2016',
    OldDealSlip: ''
};

//----------------------------------------------------

var eLimitType = {
    None: 0,
    StopLoss: 1,
    TakeProfit: 2
};

//-----------------------------------------------------

var eLimitMode = {
    None: 0,
    OpenDeal: 1,
    CloseDeal: 2,
    Add: 3, // not used on client
    PriceAlert: 4
};

//----------------------------------------------------

var eLimitValidationMode = {
    All: 0,
    Single: 1,
    Amount: 2,
    Rate: 3,
    Percent: 4
};

//----------------------------------------------------

var eHistoryLimitRequest = {
    All: 0,
    Deleted: 1,
    Edited: 2,
    Expired: 3,
    EitherOr: 4,
    PositionClosed: 5,
    Executed: 6,
    EquityAlert: 7,
    ExposureAlert: 8,
    PositionMissing: 9,
    CloseAllDeals: 10
};

//----------------------------------------------------

var eStatus = {
    New: 0,
    Edited: 1,
    Removed: 2,
    Cancelled: 3
};

//----------------------------------------------------

var eMarketState = {
    Open: 1,
    Close: 2
};

//----------------------------------------------------

var eDealPLState = {
    None: 0,
    Up: 1,
    Down: 2
};

//-----------------------------------------------------

var eMessageBoxIcon = {
    Info: 0,
    Error: 1,
    Warning: 2,
    Question: 3
};

//----------------------------------------------------

var eAMLStatus = {
    NotRequired: 0,
    Unverified: 1,
    Denied: 2,
    Approved: 3,
    Pending: 4,
    Restricted: 5
};

//----------------------------------------------------

var eKYCStatus = {
    NotRequired: 0,
    NotComplete: 1,
    GaveUp: 2,
    Complete: 3,
    // new statuses
    Passed: 4,
    // warning required
    Failed: 5,
    // acknowledged
    FailedAware: 6
};

//----------------------------------------------------

var eCDDStatus = {
    NotRequired: 1,
    NotComplete: 2,
    Complete: 3
};

//----------------------------------------------------

var eCDDAccess = {
    Restricted: 0,
    Access: 1
};

//----------------------------------------------------

var eKYCReviewStatus = {
    NotReviewed: 0,
    Appropriate: 1,
    Rejected: 2,
    Experienced: 3,
    Eligible: 4,
    Review: 5,
    Tested: 6,
    Inappropriate: 7,
    Unsuitable: 8
};

//----------------------------------------------------

var eLocalStorageKeys = {
    QuestionsAnswersCDDKYC: "QuestionsAnswersCDDKYC"
};

//----------------------------------------------------

var ePEPStatus = {
    NotRequired: 1,
    Required: 2,
    No: 3,
    Statement2a: 4,
    Statement2b: 5,
    Statement2c: 6,
    Statement2d: 7,
    Statement2e: 8,
    Statement2f: 9,
    Statement3: 10,
    Statement4a: 11,
    Statement4b: 12
};

//----------------------------------------------------

var eSmartBannerStatus = {
    Invisible: 0,
    Visible: 1
};

//----------------------------------------------------

var eSmartBannerPosition = {
    Wide: 'smartBannerWide',
    Small: 'smartBannerSmall',
    None: 'None'
};

//----------------------------------------------------

var eAccountType = {
    Pending: 0,
    Active: 1
};

//----------------------------------------------------

var eDialogType = {
    Order: 0,
    Other: 1
};

//----------------------------------------------------

var eDealPermit = {
    None: 0,
    Islamic: 3,
    SpotOnly: 4,
    ZeroSpread: 17
};

//----------------------------------------------------

var eDealType = {
    Spot: 2,
    Islamic: 6,
    Future: 7,
    Share: 8
};

//----------------------------------------------------

var eRowAlternatingStyle = {
    EveryRow: 1,
    EveryTwoRows: 2
};

//----------------------------------------------------

var eRateFormatStyle = {
    SevenDigit: 1,
    EightDigit: 2,
    NineDigit: 3
};

//----------------------------------------------------

var exTypes = {
    html: 0,
    array: 1
};

//---------------------------------------------------

var eBrowserType = {
    chrome: 0,
    safari: 1,
    opera: 2,
    ie: 3,
    firefox: 4
};

//---------------------------------------------------

var eDataStatus = {
    partial: 0,
    full: 1
};

//---------------------------------------------------

var eFlagState = {
    Initial: -1,
    NotActive: 0,
    Active: 1
};

//---------------------------------------------------

var eViewMode = {
    simple: 0,
    advance: 1
};

//---------------------------------------------------

var eErrorSeverity = {
    warning: 0,
    low: 1,
    medium: 2,
    high: 3,
    critical: 4
};

//----------------------------------------------------

var eCustomerType = {
    Standard: 1,
    TradingBonus: 39
};

//----------------------------------------------------

var eFolderType = {
    TradingBonus: "10"
};

//----------------------------------------------------

var eFolder = {
    GameFolder: 10,
    IntDebit: 39
};

//----------------------------------------------------

var eUserRole = {
    customer: "FXnet_Customers",
    QA: "FXnet_QA"
};

//----------------------------------------------------

var eRegulationStatus = {
    customer: "FXnet_Customers",
    QA: "FXnet_QA"
};

//---------------------------------------------------

var eOrderAction = {
    NewLimit: "NewLimit",
    EditLimit: "EditLimit",
    DeleteLimit: "DeleteLimit",
    NewDeal: "NewDeal",
    CloseDeal: "CloseDeal",
    SaveLimits: "SaveLimits",
    PendingBonus: "PendingBonus",
    GetOvernightFinancing: "GetOvernightFinancing",
    CashBack: "CashBackGetVolumes",
    NewPriceAlert: "NewPriceAlert"
};

//---------------------------------------------------

var eOrderActionType = {
    None: 0,
    NewLimit: 1,
    EditLimit: 2,
    DeleteLimit: 3,
    NewDeal: 4,
    CloseDeal: 5,
    PendingBonus: 6,
    NewPriceAlert: 7,
    GetOvernightFinancing: 8,
    CashBack: 9,
    DeletePriceAlert: 10
};

//---------------------------------------------------

var eTradingAgreement = {
    Needed: 0,
    NotNeeded: 1
};

//---------------------------------------------------

var eKeepAliveError = {
    None: 0,
    HttpContextRequired: 1,
    SessionMissingOrDuplicate: 2
};

//---------------------------------------------------

var eTradingPermissions = {
    Allowed: 3,
    Required: 2,
    Blocked: 1
};

//---------------------------------------------------

var eNotificationType = {
    InstrumentEdited: 31,
    AmountGroupEdited: 25,
    MinDealGroupEdited: 46
};

//----------------------------------------------------

var eScreenId = {
    CreditCard: 1,
    RegularWireTransfer: 2,
    RealTimeWireTransfer: 3,
    MoneyBooker: 4,
    Cachu: 6
};

//----------------------------------------------------

var eDepositingActionType = {
    NA: 0,
    Regular: 1,
    ForceDeposit: 2,
    Moneybookers: 3,
    PayPal: 5,
    GlobalCollectAPM: 7,
    WireTransfer: 20,
    SafechargePPP: 31,
    EmpCashU: 32,
    SafeChargeCashier: 33,
    Epaylinks: 34,
    Astropay: 36,
    NetellerGO: 37,
    PaySafeCard: 38,
    InatecAPM: 41,
    NoAPIClearer: 42,
    EcoPayz: 43,
    SofortDirect: 44,
    Kluwp: 45,
    RPN: 46,
    AstropayCard: 47,
    PayRetailers: 48,
    RisingSunAPM: 49,
    Jeton: 50,
    ZotapayAPM: 51,
    BitWallet: 52,
    NuveiAPM: 53,
    GlobePay: 54,
    AstropayWallet: 55,
    PerfectMoney: 56
};

//----------------------------------------------------

var eDepositCreditCardType = {
    Unknown: 0,
    AmericanExpress: 1,
    Diners: 2,
    Discover: 3,
    Jcb: 5,
    Laser: 6,
    Mastercard: 7,
    Maestro: 8,
    Solo: 9,
    Switch: 10,
    Visa: 13,
    CUP: 43
};

//----------------------------------------------------

var ePaymentMethods = {
    Regular: "pmCreditCard",
    ForceDeposit: "pmForceDeposit",
    Moneybookers: "pmMoneyBooker",
    CashU: "pmCashU",
    WireTransfer: "pmRegularWireTransfer"
};

//----------------------------------------------------

var eCountryPaymentsInfosResponse = {
    Country: 0,
    DepositingActionType: 1
};

//----------------------------------------------------

var ePaymentsChallengeWindowSize = {
    Fullscreen: '05'
};

//----------------------------------------------------

var eChangePasswordStatus = {
    None: 0,
    Success: 1,
    OldPasswordDoesNotMatch: 2,
    NewPasswordsDoNotMatch: 3,
    InvalidNewPassword: 4,
    PreviousPasswordRecurrence: 5,
    UserLockedOut: 7,
    UserNotFound: 8
};

//----------------------------------------------------

var eClientParams = {
    Interval: 0,
    Device: 1,
    MaxIdleTime: 2,
    IdleTimer: 3,
    TutorialUrlTemplate: 4,
    JsErrorBlacklistRegex: 5,
    ClientStateLatencyInterval: 10
};

//----------------------------------------------------

var eUIOrderType = {
    Default: 0,
    Custom: 1
};

//----------------------------------------------------

var eTileLayout = {
    Single: 1,
    Split: 2,
    FourSplit: 4
};

//----------------------------------------------------

var eChartInstanceType = {
    newDealSlip: 3,
    newDealMobile: 4
};

//----------------------------------------------------

var eChartDirection = {
    Same: 1,
    Opposite: 2
};

//----------------------------------------------------

var eChartParentType = {
    NewDeal: 0,
    NewLimit: 1,
    EditLimit: 2,
    CloseDeal: 3,
    EditClosingLimit: 4,
    NewPriceAlert: 5
};

//----------------------------------------------------

var eChartPeriod = {
    Ticks: 0,
    OneMinute: 1,
    FiveMinutes: 2,
    FifteenMinutes: 3,
    ThirtyMinutes: 4,
    OneHour: 5,
    SixHours: 6,
    TwelveHours: 7,
    OneDay: 8,
    OneWeek: 9,
    OneMonth: 10,
    TenSeconds: 11,
    TwoHours: 12,
    FourHours: 13
};

//----------------------------------------------------

var eChartTimeFramesIds = {
    'tick': '1T',
    '1 Minute': '1M',
    '5 Mintes': '5M',
    '10 Minutes': '10M',
    '15 Minutes': '15M',
    '30 Minutes': '30M',
    '1 Hour': '60M',
    '2 Hours': '2H',
    '4 Hours': '4H',
    '5 Hours': '5H',
    '6 Hours': '6H',
    '7 Hours': '7H',
    '8 Hours': '8H',
    '9 Hours': '9H',
    '10 Hours': '10H',
    '12 Hours': '12H',
    '14 Hours': '14H',
    '1 Day': '1D',
    '1 Week': '1W',
    '1 Month': '1N',
    '3 Months': '3N',
    '6 Months': '6N',
    '1 Year': '1Y'
}

//----------------------------------------------------

var eChartMode = {
    Collapsed: 'collapsed',
    Expanded: 'expanded'
};

//----------------------------------------------------

var eChartRateType = {
    Ask: 0,
    Bid: 1
};

//----------------------------------------------------

var eChartPriceLineType = {
    CurrentRate: 0,
    LimitLevel: 1,
    StopLoss: 2,
    TakeProfit: 3,
    OpenRate: 4,
    PriceAlertRate: 5
};

//----------------------------------------------------

var eChartCustomTemplates = {
    mobile: 'customMobileTemplate',
    mobileDark: 'customMobileTemplateDark',
    web: 'customtemplate',
    webDark: 'customtemplateDark',
}

//----------------------------------------------------

var eCandleHistoryProperites = {
    date: 0,
    open: 1,
    high: 2,
    low: 3,
    close: 4
};

//----------------------------------------------------

var eTickHistoryProperites = {
    date: 0,
    rate: 1
};

//----------------------------------------------------

var eClientStateResult = {
    NotFound: 0,
    Success: 1,
    Failed: 2
};

//----------------------------------------------------

var eOperationStatus = {
    None: 0,
    Success: 1,
    RequestFailed: 2,
    InternalServerError: 3,
    ValidationFailed: 4,
    ExportValidationFailed: 5
};

//----------------------------------------------------

var eViewState = {
    Initial: 0,
    Start: 1,
    Stop: 2,
    Save: 3,
    Update: 4,
    Refresh: 5
};

//----------------------------------------------------

var eLimitsType = {
    Active: "Active",
    Executed: "Executed",
    Deleted: "Deleted"
};

//----------------------------------------------------

var eCSFlagStates = {
    NotActive: 0,
    Active: 1,
    MaintenanceMode: 3
};

//----------------------------------------------------

var eFrameContentValidation = {
    Available: 0,
    NotAvailable: 1,
    SecurityFailure: 2
};

//----------------------------------------------------

var eRegistrationListName = {
    QuotesTable: "QuotesTable",
    ContractQuotesTable: "ContractQuotesTable",
    InBetweenQuote: "InBetweenQuote",
    SingleQuote: "SingleQuote",
    TradingSignals: "TradingSignals",
    Search: "Search"
};

//----------------------------------------------------

var eInstrumentType = {
    Mixed: 0, // Main Tab
    Currencies: 1,
    Commodities: 2,
    Indices: 3,
    Shares: 4,
    ETF: 8,
    Crypto: 9,
    Stocks: 10
};

//----------------------------------------------------

var eAssetType = {
    Forex: 1,
    Future: 2,
    Share: 3,
    Interest: 4
};

//----------------------------------------------------

var ePresetType = {
    PresetCustomized: 0,
    PresetMostPopular: 2,
    PresetMostPopularWithoutFutures: 1,

    PresetMostPopularCurrencies: 3,
    PresetUsdCurrencies: 4,
    PresetEurCurrencies: 5,
    PresetGbpCurrencies: 6,
    PresetJpyCurrencies: 7,
    PresetOtherCurrencies: 8,

    PresetCommodities: 9,
    PresetCommoditiesWithoutFutures: 10,

    IndiciesMostPopular_NoShares: 11,
    PresetShares: 12,

    PresetSharesUS: 13,
    PresetSharesGermany: 15,
    PresetSharesSpain: 16,
    PresetSharesItaly: 17,
    PresetSharesUK: 20,
    PresetSharesFrance: 21,
    PresetSharesJapan: 22,
    PresetSharesRussia: 23,
    PresetCommoditiesAgricultural: 24,
    PresetCommoditiesEnergy: 25,
    PresetCommoditiesMetals: 26,
    IndicesEurope_NoShares: 27,
    IndicesNorthAmerica_NoShares: 28,
    IndicesOther_NoShares: 29,
    PresetSharesSouthCorea: 30,
    PresetSharesNetherlands: 31,
    PresetSharesSwitzerland: 32,
    PresetSharesSweden: 33,
    PresetSharesHongKong: 125,
    PresetSharesAustralia: 126,
    PresetSharesMexico: 127,
    PresetSharesPoland: 128,
    PresetSharesGreece: 129,
    PresetSharesCzechRepublic: 130,
    PresetSharesHungary: 131,
    PresetSharesFinland: 132,
    SharesSaudiArabia: 135,
    PresetSharesIndia: 140,

    // General Tab continued  Most with different permissions
    PresetMostPopularWithoutShares: 18, //with future
    PresetMostPopularWithoutFuturesWithoutShares: 19,

    MainHot: 80,
    CurrenciesHot: 81,
    SharesHot: 82,
    MainHot_NoShares: 83,
    MainHot_NoSharesNoFutures: 84,
    MainTopGainers: 85,
    CurrenciesTopGainers: 86,
    SharesTopGainers: 87,
    MainTopGainers_NoShares: 88,
    MainTopGainers_NoSharesNoFuture: 89,
    MainTopLosers: 90,
    CurrenciesTopLosers: 91,
    SharesTopLosers: 92,
    MainTopLosers_NoShares: 93,
    MainTopLosers_NoSharesNoFutures: 94,
    CommoditiesHot: 95,
    CommoditiesTopGainers: 96,
    CommoditiesTopLosers: 97,
    IndicesHot_NoShares: 98,
    IndicesTopGainers_NoShares: 99,
    IndicesTopLosers_NoShares: 100,
    MainHot_NoFutures: 101,
    MainTopGainers_NoFutures: 102,
    MainTopLosers_NoFutures: 103,
    ETFMostPopular: 104,
    ETFHot: 105,
    ETFTopGainers: 106,
    ETFTopLosers: 107,
    ETFCommodities: 108,
    ETFEquityCountries: 109,
    ETFEquityIndices: 110,
    ETFEquitySectors: 111,
    ETFFixedIncome: 112,
    IndicesMostPopular: 113,
    IndicesHot: 114,
    IndicesTopGainers: 115,
    IndicesTopLosers: 116,
    IndicesEurope: 117,
    IndicesNorthAmerica: 118,
    IndicesOther: 119,

    CryptoMostPopular: 120,
    CryptoHot: 121,
    CryptoTopGainers: 122,
    CryptoTopLosers: 123,
    CryptoCurrencies: 124,

    PresetNewReleases: 136,
    PresetNewReleasesNoFutures: 137,
    PresetNewReleasesNoShares: 138,
    PresetNewReleasesNoSharesNoFutures: 139,
    StocksMostPopular: 141
};

//----------------------------------------------------

var Operation = {
    Add: 0,
    Substruct: 1
};

// topics used for modelview message comunication using ko post-box extension
var eTopic = {
    onCancelPendingRedrawal: 'onCancelPendingRedrawal',
    onDoubleLoginEvent: 'onDoubleLoginEvent',
    onDynamicScriptsLoaded: 'onDynamicScriptsLoaded',
    onCustomQuotesSaved: 'onCustomQuotesSaved'
};

var eShutDownHandlerTopics = {
    stopClientStateManagerCalls: 'onStopClientStateManagerCalls',
    stopKeepAliveCalls: 'onStopKeepAliveCalls',
    stopGetActiveIMCalls: 'onStopGetActiveIMCalls',
    stopGetRatesRecentWebCalls: 'stopGetRatesRecentWebCalls',
    restartClientStateManagerCalls: 'onRestartClientStateManagerCalls',
    restartKeepAliveCalls: 'onRestartKeepAliveCalls',
    restartGetActiveIMCalls: 'onRestartGetActiveIMCalls',
    restartGetRatesRecentWebCalls: 'restartGetRatesRecentWebCalls'
};

var eAppEvents = {
    formChangeEvent: 'formChangeEvent',
    formChangedEvent: 'formChangedEvent',
    amlStatusLoadedEvent: 'amlStatusLoadedEvent',
    cddStatusLoadedEvent: 'cddStatusLoadedEvent',
    dialogClosed: 'dialogClosed',
    exportDataLoadedEvent: 'exportDataLoadedEvent',
    rolledOverDataLoaded: 'rolledOverDataLoaded',
    accountCardRecordsDataLoaded: 'accountCardRecordsDataLoaded',
    contractRolloverDataLoaded: 'contractRolloverDataLoaded',
    customerInformationLoadedEvent: 'customerInformationLoadedEvent',
    depositConfirmationLoadedEvent: 'depositConfirmationLoadedEvent'
};

var eGender = {
    Female: "F",
    Male: "M"
};

var eClaimActionType = {
    Save: 1,
    Fetch: 2,
    Update: 3,
    Delete: 4
};

var eClaimRecordType = {
    photocopyOfIDPassport: 1,
    utilityBill: 2,
    creditCardPhotocopy: 3,
    PhotocopyOfCardholdersID: 4,
    CardHolderAuthorization: 5,
    depositConfirmation: 6,
    withdrawalConfirmation: 7,
    generalDocument: 8,
    AMLapproval: 9,
    TaxCard: 10,
    PEP: 11,
    KeyManager: 12,
    CreditCard: 13,
    Agreement: 14,
    BeneficiaryDeclaration: 15,
    CVV: 16
};

var ePostboxTopic = {
    ClaimRequestFailed: "ClaimRequestFailed",
    UploadCCNumberResult: "UploadResult",
    CCNumberValidation: "CCNumberValidation",
    CVVValidation: "CVVValidation",
    StartTokenizationFlowIfCCValid: "StartTokenizationFlowIfCCValid",
    UsedCCNumber: "UsedCCNumber",
    ClearCCData: "ClearCCData",
    CCNumberIframeReady: "CCNumberIframeReady",
    SetSpinnerVisibility: "SetSpinnerVisibility",
    PaymentDeposit: "payment-deposit",
    PaymentFormValid: "payment-formValid",
    EnableCCFormFieldsValidation: "EnableCCFormFieldsValidation",
    ValidateCCIframeFields: "ValidateCCIframeFields",
    ValidateCCIframeFieldsResult: "ValidateCCIframeFieldsResult",
    ConcretePaymentData: "ConcretePaymentData",
    ReloadConcretePayments: "ReloadConcretePayments",
    ConcretePaymentSelectedCountry: "ConcretePaymentSelectedCountry",
    MissingInfo: "MissingInfo",
    PaymentButtonsVisible: "ButtonsVisible"
};

var eConcretePaymentDataState = {
    Pending: "ConcretePaymentDataPending",
    Success: "ConcretePaymentDataSuccess"
};

var eTokenizationError = {
    frameNotLoaded: 0,
    uploadError: 1,
    claimError: 2,
    frameNotLoadedDepositIntended: 3
};

var eAjaxerState = {
    None: 0,
    Retry: 1,
    SlaCompromised: 2
};

var eUIVersion = {
    Default: 0
};

var eSignalType = {
    TechnicalAnalysis: 1,
    Alert: 2,
    CandleStick: 3,
    Pattern: 4
};

var eDirections = {
    Up: "up",
    Down: "down",
    Bold: "bold"
};

var ePCIValidationType = {
    StartDepositFlow: 0,
    StartDepositValidation: 1,
    ResetValidation: 2
};

var eConcretePaymentCategory = {
    Recommended: 0,
    CreditCard: 1,
    EPayments: 2,
    BankTransfer: 3,
    PrepaidCards: 4,
    LastPayment: 5
};

var eFxNetEvents = {
    Init: 'fx-net-init-event',
    Start: 'fx-net-start-event',
    End: 'fx-net-end-event',
    UiLayerStart: 'fx-net-ui-layer-start-event',
    UiLayerEnd: 'fx-net-ui-layer-end-event',
    CacheLoadStart: 'fx-net-start-cache-load-event',
    CacheLoadEnd: 'fx-net-end-cache-load-event',
    InitialDataStart: 'fx-net-start-initial-data-event',
    InitialDataEnd: 'fx-net-end-initial-data-event',
    WaitHtmlStart: 'fx-net-start-wait-html-event',
    WaitHtmlEnd: 'fx-net-end-wait-html-event',
    ApplyBindingsStart: 'fx-net-start-apply-bindings-event',
    ApplyBindingsEnd: 'fx-net-end-apply-bindings-event',
    SplashScreenRemoved: 'fx-net-splash-screen-removed',
    ExposeUi: 'fx-net-expose-ui-event',
    GtmConfigurationSet: 'fx-net-gtm-configuration-set',
    ChartInit: 'fx-net-chart-instance-init',
    ChartInitComplete: 'fx-net-chart-instance-init-complete',
    ChartStart: 'fx-net-chart-instance-start',
    ChartStartComplete: 'fx-net-chart-instance-start-complete',
    ChartGetHistoryRequest: 'fx-net-chart-get-history-request',
    ChartGetHistoryResponse: 'fx-net-chart-get-history-response',
    FirstQuoteEvent: 'fx-net-first-quote-event',
    Trading_Central_Added: 'Trading_Central_Added',
    Trading_Central_Removed: 'Trading_Central_Removed'
};

var eRefDomElementsIds = {
    newDealRefParentTopElement: "#AccSummaryEquityTitle"
};

var eAvailabilityState = {
    Unknown: -1,
    NotAvailable: 0,
    Available: 1
};

var eApplicationTypes = {
    Web: 0,
    Mobile: 1,
    Dealer: 3
};

//----------------------------------------------------

var eDeepLinkParameterType = {
    Integer: 0,
    Instrument: 1,
    OrderDir: 2,
    Tab: 3,
    Form: 4,
    LoginOption: 5,
    View: 6,
    SettingsView: 7,
    String: 8
};

var eTransactionSwitcher = {
    None: 0,
    NewDeal: 1,
    NewLimit: 2,
    NewPriceAlert: 4
};

var eExpirationDateUIType = {
    Select: 1,
    RadioGroup: 2
};

var ePresetsOrder = {
    None: 0,
    Ascending: 1,
    Descending: 2
};

var eConfigContentValues = {
    False: "0",
    True: "1"
};

var ePlatformSwitch = {
    Demo: "demo",
    Real: "real",
    None: "none"
};

var ePendingBonusType = {
    cashBack: 0,
    spreadDiscount: 1
};

//----------------------------------------------------

var eHistoryStateType = {
    ExitFullscren: 'exitfullscren',
    EnterFullscren: 'enterfullscren',
    CloseAlert: 'closealert',
    CloseDialog: 'closedialog',
    Invalid: 'invalid',
    View: 'view',
    Questionnaire: 'questionnaire',
    Wizard: 'wizard'
};

//----------------------------------------------------

var ePopupType = {
    Alert: 'alert',
    Dialog: 'dialog'
};

//----------------------------------------------------

var eNavigateDirection = {
    Next: 0,
    Prev: 1
};

//----------------------------------------------------

var eSetLimitsTabs = {
    None: 0,
    Rate: 1,
    Amount: 2,
    NoTabs: 3,
    Percent: 4
};

var eUIScreens = {
    FXNetMobileDefault: 11,
    FXNetMobileTradingMajors: 12,
    FXNetMobileTradingMinors: 13,
    FXNetMobileEuroCrosses: 14,
    FXNetMobileGBPCrosses: 15,
    FXNetMobileJPYCrosses: 16,
    FXNetMobileOtherCrosses: 17,
    FXNetMobileCFD: 32,
    FXNetMobileDefaultWithoutfutures: 33
};

//----------------------------------------------------

var eWeekendFinancingTypes = {
    None: 0,
    Friday: 1,
    Thursday: 2
};

//----------------------------------------------------

var eResourcesNames = {
    ChartsResources: 'charts_resources',
    FaqDeposit: 'faqdeposit',
    FaqDepositThankYou: 'faqdepositthankyou',
    Support: 'support',
    FaqUploadDocuments: 'faquploaddocuments'
};

var eStateObjectTopics = {
    ReadyForUse: "ReadyForUse",
    ToolsToggle: "toolsToggle",
    SignalChartToggle: "signalChartToggle",
    CsmOutOfDate: "CsmOutOfDate",
    UserFlowChanged: "UserFlowChanged",
    ClosedDealsUseFilters: 'ClosedDealsUseFilters',
    ScmmFddLoaded: 'ScmmFddLoaded'
}

var eQuestionnaireType = {
    CDD: 0,
    KYC: 1,
    MIFID: 2
};

var eAccountMode = {
    None: "0",
    Demo: "1",
    Real: "2"
};

var eEducationalTutorialsType = {
    Basic: "novice",
    Advanced: "advanced"
};

var eWireTransferStatus = {
    Pending: 3,
    Approved: 4,
    Canceled: 5,
    ApprovalOnPending: 6,
    CanceledPendingDeposit: 7
};

var eUploadDocumentType = {
    ProofOfID: 1,
    ProofOfResidence: 2,
    CreditCardCopy: 3,
    DepositConfirmation: 6,
    WithdrawalPendingRequest: 7,
    OtherDocuments: 8,
    TaxCard: 10
};

var eUploadDocumentStatus = {
    Approved: 1,
    AwaitingDocument: 2,
    Processing: 3,
    Incomplete: 4,
    NotRequired: 5,
    AwaitingSignature: 6,
    AwaitingSignatureHighAmount: 7
};

var eCountryAttributes = {
    Id: 0,
    Name: 1,
    IsActive: 2
};

var eFormActions = {
    newDeal: 'NewDeal',
    newLimit: 'NewLimit',
    deposit: 'Deposit'
};

var eFixPosition = {
    deletePosition: 1,
    restorePosition: 0
};

var registerParams = {
    traderInstrumentId: 'trader_instrumentId=',
    traderOrderDir: '&trader_orderdir=',
    traderFrom: 'trader_from',
};

var eUserFlowSteps = {
    None: -1,
    OpenedAnAccount: 0,
    GeneralInforamtionQuestionnaire: 1,
    TradingKnowledgeQuiz: 2,
    ProofOfIdentity: 3,
    FundYourAccount: 4,
    Trade: 5
};
var eUserStatus = {
    NA: -1,
    NotActivated: 0,
    ReadyToTrade: 1,
    ActiveLimited: 2,
    Active: 3,
    Restricted: 4,
    Locked: 5
};
var eStepStatus = {
    NotActive: 0, // black
    Seamless: 1, // gray
    Error: 2, // red x
    Restricted: 3, // red no entry
    Available: 4, // blue
    Complete: 5, // green
    Hidden: 6
};
var eCta = {
    None: 0,
    Seamless: 1,
    ContactUs: 2,
    ClientQuestionnaire: 3,
    Deposit: 4,
    UploadDocuments: 5
};

var eAccountRedirectForms = {
    WithdrawalAutomation: 1013,
    WireTransfers: 1015,
    NewApproveWireTransfer: 1016,
    WithdrawalProcess: 1017,
    ConvertBalance: 1018,
    ConvertAccountLine: 1019,
    GeneralAccountActions: 1020,
    FixPosition: 1021
};

var eRequestAccessType = {
    Signals: 0,
    VideoLessons: 1,
    Tutorials: 2
};

var eStateObjectAccessRequest = {
    Signals: "Signals",
    VideoLessons: "VideoLessons",
    Tutorials: "Tutorials"
};

var eAccessRequestStatus = {
    RequestNotSubmitted: 1,
    RequestSubmitted: 2,
    ExtensionNotSubmitted: 3,
    ExtensionSubmitted: 4
};

var instrumentInfoProps = {
    pipValue: 'pipValue',
    pipWorth: 'pipWorth',
    requiredMargin: 'requiredMargin',
    offHoursRequiredMargin: 'offHoursRequiredMargin',
    maximumLeverage: 'maximumLeverage',
    minDealAmount: 'minDealAmount',
    maxDealAmount: 'maxDealAmount',
    marketPriceTolerance: 'marketPriceTolerance',
    ofSell: 'ofSell',
    ofBuy: 'ofBuy',
    ofPercentageSell: 'ofPercentageSell',
    ofPercentageBuy: 'ofPercentageBuy',
    overnightFinancingGMT: 'overnightFinancingGMT',
    rolloverDate: 'rolloverDate',
    dividendDate: 'dividendDate',
    dividendAmount: 'dividendAmount',
    weekendFinancing: 'weekendFinancing'
};

var eDealerParams = {
    DealerCurrency: 'dealerCurrency',
    DealerAdvancedWalletView: 'dealerAdvancedWalletView'
};

var ePeriodTabs = {
    None: -1,
    Short: 0,
    Medium: 1,
    Long: 2
};

var eMarketInfoPeriods = {
    FiveMin: 1,
    OneH: 2,
    TwelveHours: 3,
    Today: 4,
    OneDay: 5,
    OneWeek: 6,
    TwoWeeks: 7,
    ThisMonth: 8,
    ThirtyDays: 9,
    NinetyDays: 10,
    FiftyTwoWeeks: 11,
    ThisYear: 12
};

var eRateIDataPositions = {
    Id: 0,
    High: 1,
    Low: 2
};


var eMarketInfoPrefixEvent = {
    NewDeal: 'deal-slip',
    NewLimitViewModel: 'limit-slip',
    CloseDeal: 'close-deal',
    EditLimitViewModel: 'edit-limit',
    EditClosingLimit: 'edit-closing-limit'
};

var eMarketInfoNameEvent = {
    TradingSentiment: 'trading-sentiment',
    MarketInfo: 'market-info',
    HighLow: 'high-low',
    InstrumentInfo: 'instrument-info'
};

var eAccordionState = {
    collapse: 'collapse',
    expand: 'expand'
};

var eMarketInfoEvents = {
    DealSlipTradingSentimentCollapse: 'deal-slip-collapse-trading-sentiment',
    DealSlipTradingSentimentExpand: 'deal-slip-expand-trading-sentiment',
    DealSlipMarketInfoCollapse: 'deal-slip-collapse-market-info',
    DealSlipMarketInfoExpand: 'deal-slip-expand-market-info',
    DealSlipHighLowCollapse: 'deal-slip-collapse-high-low',
    DealSlipHighLowExpand: 'deal-slip-expand-high-low',
    DealSlipInstrumentInfoCollapse: 'deal-slip-collapse-instrument-info',
    DealSlipInstrumentInfoExpand: 'deal-slip-expand-instrument-info',

    LimitSlipTradingSentimentCollapse: 'limit-slip-collapse-trading-sentiment',
    LimitSlipTradingSentimentExpand: 'limit-slip-expand-trading-sentiment',
    LimitSlipMarketInfoCollapse: 'limit-slip-collapse-market-info',
    LimitSlipMarketInfoExpand: 'limit-slip-expand-market-info',
    LimitSlipHighLowCollapse: 'limit-slip-collapse-high-low',
    LimitSlipHighLowExpand: 'limit-slip-expand-high-low',
    LimitSlipInstrumentInfoCollapse: 'limit-slip-collapse-instrument-info',
    LimitSlipInstrumentInfoExpand: 'limit-slip-expand-instrument-info',

    CloseDealTradingSentimentCollapse: 'close-deal-collapse-trading-sentiment',
    CloseDealTradingSentimentExpand: 'close-deal-expand-trading-sentiment',
    CloseDealMarketInfoCollapse: 'close-deal-collapse-market-info',
    CloseDealMarketInfoExpand: 'close-deal-expand-market-info',
    CloseDealHighLowCollapse: 'close-deal-collapse-high-low',
    CloseDealHighLowExpand: 'close-deal-expand-high-low',
    CloseDealInstrumentInfoCollapse: 'close-deal-collapse-instrument-info',
    CloseDealInstrumentInfoExpand: 'close-deal-expand-instrument-info',

    EditClosingLimitTradingSentimentCollapse: 'edit-closing-limit-collapse-trading-sentiment',
    EditClosingLimitTradingSentimentExpand: 'edit-closing-limit-expand-trading-sentiment',
    EditClosingLimitMarketInfoCollapse: 'edit-closing-limit-collapse-market-info',
    EditClosingLimitMarketInfoExpand: 'edit-closing-limit-expand-market-info',
    EditClosingLimitHighLowCollapse: 'edit-closing-limit-collapse-high-low',
    EditClosingLimitHighLowExpand: 'edit-closing-limit-expand-high-low',
    EditClosingLimitInstrumentInfoCollapse: 'edit-closing-limit-collapse-instrument-info',
    EditClosingLimitInstrumentInfoExpand: 'edit-closing-limit-expand-instrument-info',

    EditLimitTradingSentimentCollapse: 'edit-limit-collapse-trading-sentiment',
    EditLimitTradingSentimentExpand: 'edit-limit-expand-trading-sentiment',
    EditLimitMarketInfoCollapse: 'edit-limit-collapse-market-info',
    EditLimitMarketInfoExpand: 'edit-limit-expand-market-info',
    EditLimitHighLowCollapse: 'edit-limit-collapse-high-low',
    EditLimitHighLowExpand: 'edit-limit-expand-high-low',
    EditLimitInstrumentInfoCollapse: 'edit-limit-collapse-instrument-info',
    EditLimitInstrumentInfoExpand: 'edit-limit-expand-instrument-info'
};

var eMarketInfoSectionsProps = {
    tsArea: 0,
    miArea: 1,
    hlArea: 2,
    iiArea: 3
};

var eWithdrawalSteps = {
    setAmount: 1,
    setMethod: 2,
    setBankDetails: 3,
    setCreditCard: 4,
    setApproval: 5
};

var eWithdrawalMethods = {
    card: 0,
    bank: 1
};

var eHelpcSections = {
    default: 'helpc',
    personalguide: 'pg'
};

var eHowtoWthrough = {
    quickTour: 'qpt',
    foundAccount: 'fya',
    openDeal: 'oad',
    uploadDocument: 'uad'
};

var eCustomerStateSuffix = {
    seameless: '_seameless',
    pending: '_pending',
    live: '_live',
    demo: '_demo'
};
define("enums/enums", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.eDepositingActionType;
    };
}(this)));

define("configuration/Containers", [
	"require",
	"customEnums/ViewsEnums",
	"enums/enums",
	"handlers/HashTable",
], function Containers(require) {
	var hashtable = require("handlers/HashTable");
	var viewsCollections = {};
	var formsContainer = new hashtable();
	var _uiVersion;
	var independentViews = [eViewTypes.vAmlStatus, eViewTypes.vMissingCustomerInformation];

	viewsCollections[eUIVersion.Default] = function () {
		formsContainer.SetItem(eForms.Deals, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vDealsTabs,
				eViewTypes.vOpenDeals,
				eViewTypes.vLimits,
				eViewTypes.vClosedDeals,
				eViewTypes.vMenu,
				eViewTypes.vToolBar,
				eViewTypes.vMarketClosed,
				eViewTypes.vEnableTrading,
			],
			hideToggle: true,
			exportSupport: { isExport: true, historicalData: false },
		});

		formsContainer.SetItem(eForms.Statement, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vBalance,
				eViewTypes.vMenu,
				eViewTypes.vToolBar,
				eViewTypes.vPageTitle,
			],
			exportSupport: { isExport: true, historicalData: true },
		});

		formsContainer.SetItem(eForms.Deposit, {
			mappedViews: [eViewTypes.vMenu, eViewTypes.vPaymentTypes, eViewTypes.vPageTitle],
		});

		formsContainer.SetItem(eForms.DepositSuccess, {
			mappedViews: [eViewTypes.vMenu, eViewTypes.vDepositSuccessThankYou, eViewTypes.vPageTitle],
		});

		formsContainer.SetItem(eForms.DepositPending, {
			mappedViews: [eViewTypes.vMenu, eViewTypes.vDepositPendingThankYou, eViewTypes.vPageTitle],
		});

		formsContainer.SetItem(eForms.WireTransferSuccess, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vWireTransferSuccess,
				eViewTypes.vPageTitle,
			],
		});

		formsContainer.SetItem(eForms.Withdrawal, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vMenu,
				eViewTypes.vWithdrawal,
				eViewTypes.vToolBar,
				eViewTypes.vPageTitle,
			],
		});

		formsContainer.SetItem(eForms.ViewAndPrintWithdrawal, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vMenu,
				eViewTypes.vViewAndPrintWithdrawal,
			],
		});

		formsContainer.SetItem(eForms.ActivityLog, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vMenu,
				eViewTypes.vActivityLog,
				eViewTypes.vToolBar,
				eViewTypes.vPageTitle,
			],
			exportSupport: { isExport: true, historicalData: true },
		});

		formsContainer.SetItem(eForms.PersonalDetails, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vPersonalDetails,
				eViewTypes.vMenu,
				eViewTypes.vToolBar,
				eViewTypes.vPageTitle,
			],
		});

		formsContainer.SetItem(eForms.ClientQuestionnaire, {
			mappedViews: [
				eViewTypes.vClientQuestionnaire,
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
			],
		});

		formsContainer.SetItem(eForms.TransactionsReport, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vTransactionsReport,
				eViewTypes.vMenu,
				eViewTypes.vToolBar,
				eViewTypes.vPageTitle,
			],
			exportSupport: { isExport: true, historicalData: false },
		});

		formsContainer.SetItem(eForms.UploadDocuments, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vMenu,
				eViewTypes.vToolBar,
				eViewTypes.vUploadDocuments,
				eViewTypes.vPageTitle,
			],
		});

		formsContainer.SetItem(eForms.ThirdParty, {
			mappedViews: [eViewTypes.vThirdParty],
		});

		formsContainer.SetItem(eForms.TradingSignals, {
			mappedViews: [
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vMenu,
				eViewTypes.vToolBar,
				eViewTypes.vPageTitle,
				eViewTypes.vTradingSignals,
				eViewTypes.vSignalsTechnicalAnalysisGrid,
				eViewTypes.vSignalsAlertGrid,
				eViewTypes.vSignalsCandleStickGrid,
				eViewTypes.vSignalsService,
				eViewTypes.vSignalsDisclamer,
			],
		});

		formsContainer.SetItem(eForms.AdvinionChart, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vAdvinionChart,
			],
		});

		formsContainer.SetItem(eForms.Tutorials, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vToolBar,
				eViewTypes.vTutorials,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
			],
		});

		formsContainer.SetItem(eForms.EducationalTutorials, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vToolBar,
				eViewTypes.vEducationalTutorials,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
			],
		});

		formsContainer.SetItem(eForms.EconomicCalendar, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vToolBar,
				eViewTypes.vEconomicCalendar,
				eViewTypes.vSummeryView,
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
			],
		});

		formsContainer.SetItem(eForms.AccountCardRecords, {
			mappedViews: [eViewTypes.vAccountCardRecords],
		});

		formsContainer.SetItem(eForms.RolledOver, {
			mappedViews: [eViewTypes.vRolledOver],
		});

		formsContainer.SetItem(eForms.ContractRollover, {
			mappedViews: [eViewTypes.vContractRollover],
		});

		formsContainer.SetItem(eForms.NotificationsSettings, {
			mappedViews: [eViewTypes.vMenu, eViewTypes.vToolBar, eViewTypes.vNotificationsSettings],
		});

		formsContainer.SetItem(eForms.ConcretePaymentForm, {
			mappedViews: [eViewTypes.vMenu, eViewTypes.vPageTitle, eViewTypes.vConcretePaymentForm],
		});

		formsContainer.SetItem(eForms.DepositConfirmation, {
			mappedViews: [eViewTypes.vDepositConfirmation],
		});

		formsContainer.SetItem(eForms.DocumentVerificationModal, {
			mappedViews: [eViewTypes.vDocumentVerificationModal],
		});

		formsContainer.SetItem(eForms.Settings, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vPersonalDetails,
				eViewTypes.vChangePassword,
				eViewTypes.vNotificationsSettings,
				eViewTypes.vAccountPreferences
			],
		});

		formsContainer.SetItem(eForms.PriceAlerts, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vPriceAlerts,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vToolBar,
			],
		});

		formsContainer.SetItem(eForms.PendingWithdrawal, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vPendingWithdrawal,
				eViewTypes.vSummeryView,
				eViewTypes.vAccountSummaryWallet,
				eViewTypes.vQuotes,
				eViewTypes.vQuotesPreset,
				eViewTypes.vToolBar,
			],
		});

		formsContainer.SetItem(eForms.WithdrawalThankYou, {
			mappedViews: [
				eViewTypes.vMenu,
				eViewTypes.vPageTitle,
				eViewTypes.vWithdrawalThankYou
			],
		});
	};

	var getUiVersion = function () {
		return _uiVersion;
	};

	var init = function (uiVersion) {
		formsContainer.Clear();

		if (typeof viewsCollections[uiVersion] === "undefined") {
			// Fallback to First version
			uiVersion = eUIVersion.Default;
		}

		viewsCollections[uiVersion]();

		_uiVersion = uiVersion;
	};

	return {
		Init: init,
		IndependentViews: independentViews,
		Forms: formsContainer,
		MainForm: eForms.Deals,
		UiVersion: getUiVersion,
	};
});

/* global General */
var TDALCustomer = function (jsonhelper, general) {
    function getShouldChangePassword() {
        var ajaxer = new TAjaxer(),
            callerInfo = "TDALCustomer/shouldChangePassword";

        return ajaxer.promises
            .get(callerInfo, "Customer/ShouldChangePassword", "")
            .then(processResponse)
            .fail(onError.bind(null, callerInfo));
    }

    function processResponse(responseText) {
        return jsonhelper.STR2JSON("TDALCustomer/processResponse", responseText) || {};
    }

    function onError(callerInfo) {
        ErrorManager.onError(callerInfo, "", eErrorSeverity.medium);
    }

    function getRequiredFieldsForDeposit(onSuccess) {
        var ajaxer = new TAjaxer();

        ajaxer.get("TDALCustomer/getRequiredFieldsForDeposit", "Customer/GetRequiredFieldsForDeposit", "",
            onSuccess,
            function () { ErrorManager.onError("TDALCustomer/getRequiredFieldsForDeposit", "", eErrorSeverity.medium); });
    }

    function updateMissingInformation(missingInformationModel, onSuccess) {
        var ajaxer = new TAjaxer();

        ajaxer.jsonPost("TDALCustomer/updateMissingInformation",
            "Customer/UpdateMissingCustomerInformation" + String.format("?SecurityToken={0}", systemInfo.securityToken),
            JSON.stringify(missingInformationModel),
            onSuccess,
            function (error) { ErrorManager.onError("TDALCustomer/updateMissingInformation", error.message, eErrorSeverity.low); }, 0);
    }

    function isIdNumberValid(valueToValidate, onSuccess, onFailure) {
        var ajaxer = new TAjaxer();

        ajaxer.get("TDALCustomer/isIdNumberValid", "Customer/IsIdNumberValid?" + String.format("valueToValidate={0}", valueToValidate),
            "",
            onSuccess,
            function () {
                ErrorManager.onError("TDALCustomer/getRequiredFieldsForDeposit", "", eErrorSeverity.medium);
                onFailure();
            });
    }

    function getCustomerSignalsPermissions() {
        var ajaxer = new TAjaxer(),
            callerInfo = "TDALTradingSignals/getCustomerSignalsPermissions";

        return ajaxer.promises
            .get(callerInfo, "api/tradingsignals/GetClientSignalsPermissions", "")
            .then(processResponse)
            .fail(onError.bind(null, callerInfo));
    }

    function getCustomerAgreementPhrase(OnLoadComplete) {
        if (!General.isFunctionType(OnLoadComplete)) {
            OnLoadComplete = general.emptyFn;
        }

        var ajaxer = new TAjaxer();
        var params = "countryID=" + $customer.prop.countryID;

        return ajaxer.promises
            .get("TDALCustomer/getCustomerAgreementPhrase", "Account/AgreementPhrase",
                params,
                OnLoadComplete,
                function () {
                    ErrorManager.onError("TDALCustomer/getCustomerAgreementPhrase", "", eErrorSeverity.medium);
                }
            );
    }

    function getCustomerDetails() {
        var ajaxer = new TAjaxer();


        return ajaxer.promises
            .get("TDALCustomer/getCustomerDetails", 'customer/customerDetails',
                null,
                general.emptyFn,
                function () {
                    ErrorManager.onError("TDALCustomer/getCustomerDetails", "", eErrorSeverity.medium);
                }
            );
    }

    function hasMissingInformation() {
        var ajaxer = new TAjaxer();

        return ajaxer.promises
            .get("TDALCustomer/getHasMissingInformation", 'customer/hasMissingInformation',
                null,
                general.emptyFn,
                function () {
                    ErrorManager.onError("TDALCustomer/getHasMissingInformation", "", eErrorSeverity.medium);
                }
            );
    }

    function getEducationalTutorials() {
        var ajaxer = new TAjaxer();

        return ajaxer.promises
            .get("TDALCustomer/getEducationalTutorials", "Tutorials/GetVideoLessons",
                null, null, null, 1, null, null, false
            )
            .then(function (responseText) {
                return jsonhelper.STR2JSON("dalCustomer/getEducationalTutorials", responseText);
            })
            .fail(function (error) {
                ErrorManager.onError("TDALCustomer/getEducationalTutorials", error.message, eErrorSeverity.medium);

                throw error;
            });
    }

    function getCustomer() {
        var ajaxer = new TAjaxer();

        return ajaxer.promises
            .get(
                "TDALCustomer/getCustomer",
                'customer/GetCustomer',
                null)
            .fail(function () {
                ErrorManager.onError("TDALCustomer/getCustomerDetails", "", eErrorSeverity.high);
            })
    }

    function getToken() {
        var ajaxer = new TAjaxer();

        return ajaxer.promises
            .get(
                "GetToken",
                'Account/GetToken',
                null)
            .fail(function () {
                ErrorManager.onError("TDALCustomer/getToken", "", eErrorSeverity.high);
            });
    }

    function initialScmmData(callback) {
        var ajaxer = new TAjaxer();
        return ajaxer.promises
            .get('dalCustomer/initialScmmData', 'Compliance/InitialScmmDataGet')
            .then(callback)
            .fail(function (error) {
                window.ErrorManager.onError('dalCustomer/initialScmmData', error.message, eErrorSeverity.medium);
            });
    }

    return {
        GetShouldChangePassword: getShouldChangePassword,
        getCustomer: getCustomer,
        GetCustomerDetails: getCustomerDetails,
        GetRequiredFieldsForDeposit: getRequiredFieldsForDeposit,
        IsIdNumberValid: isIdNumberValid,
        UpdateMissingInformation: updateMissingInformation,
        getCustomerSignalsPermissions: getCustomerSignalsPermissions,
        GetCustomerAgreementPhrase: getCustomerAgreementPhrase,
        HasMissingInformation: hasMissingInformation,
        GetEducationalTutorials: getEducationalTutorials,
        GetToken: getToken,
        InitialScmmData: initialScmmData
    };
};

define("dataaccess/dalcustomer", ["handlers/Ajaxer","JSONHelper","handlers/general"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (Ajaxer, jsonhelper, general) {
				return this.TDALCustomer(jsonhelper, general);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TDALCustomer;
    };
}(this)));

define("initdatamanagers/Customer", [
	"require",
	"knockout",
	"handlers/general",
	"initdatamanagers/SymbolsManager",
	"configuration/Containers",
	"dataaccess/dalcustomer",
	"global/UrlResolver",
	"JSONHelper",
	"Q",
	"handlers/Logger",
], function TCustomer(require) {
	var ko = require("knockout"),
		general = require("handlers/general"),
		logger = require("handlers/Logger"),
		SymbolsManager = require("initdatamanagers/SymbolsManager"),
		Containers = require("configuration/Containers"),
		dalCustomer = require("dataaccess/dalcustomer"),
		JSONHelper = require("JSONHelper"),
		urlResolver = require("global/UrlResolver"),
		Q = require("Q");

	var prop = {},
		_isAuthenticated = false,
		signalsPermissionsPromise = Q.defer();

	function init(profileCustomer, defaultFirstPage, homePage, sjcKey) {
		prop.brokerType = "3";
		prop.email = profileCustomer.Email;
		prop.minPctEQXP = profileCustomer.MinPctEQXP;
		prop.selectedCcyId = ko.observable(profileCustomer.AccountBaseSymbol);
		prop.baseCcyId = ko.observable(profileCustomer.AccountBaseSymbol);
		prop.defaultCcy = ko.observable(SymbolsManager.GetTranslatedSymbolById(profileCustomer.AccountBaseSymbol));
		prop.sjcKey = sjcKey;

		prop.selectedCcyName = ko.computed(function () {
			return SymbolsManager.GetTranslatedSymbolById(prop.selectedCcyId());
		});

		prop.baseCcyName = ko.computed(function () {
			return SymbolsManager.GetTranslatedSymbolById(prop.baseCcyId());
		});

		prop.accountNumber = profileCustomer.AccountNumber;
		prop.language = profileCustomer.Language;
		prop.dealPermit = profileCustomer.DealPermit;

		prop.isQA = profileCustomer.isQA;
		prop.countryID = profileCustomer.CountryID;
		prop.brokerID = profileCustomer.BrokerID;
		prop.shareStatus = profileCustomer.StocksTradingPermission;
		prop.futureStatus = profileCustomer.FuturesTradingPermission;
		prop.interactiveMessagesToken = profileCustomer.InteractiveMessagesToken;
		prop.interactiveMessagesUrl = profileCustomer.InteractiveMessagesUrl;
		prop.ratesServiceHost = profileCustomer.RatesServiceHost;
		prop.hasTransactionsReport = profileCustomer.HasTransactionsReport;

		prop.tradingPermissions = setStartUpAndMainPageAndTradingPermissions(defaultFirstPage, homePage);
		prop.dateAdded = general.str2Date(profileCustomer.DateAdded);
		prop.isLive = Boolean.parse(profileCustomer.IsLive);
		prop.isPending = Boolean.parse(profileCustomer.IsPending);

		prop.isAccountExpired = profileCustomer.IsAccountExpired;
		prop.customerType = profileCustomer.AccountType;

		prop.SAProcess = profileCustomer.SAProcess;
		prop.serial = profileCustomer.Serial;
		prop.brokerName = profileCustomer.BrokerName;
		prop.brokerAllowLimitsOnNoRates = profileCustomer.BrokerAllowLimitsOnNoRates;
		prop.LiquidationPercentage = profileCustomer.LiquidationPercentage;
		prop.isDemo = Boolean.parse(profileCustomer.IsDemo);
		prop.hasActiveDemo = Boolean.parse(profileCustomer.HasActiveDemo);

		prop.signalsEndDate = profileCustomer.SignalsEndDate;
		prop.hasWeightedVolumeFactor = profileCustomer.HasWeightedVolumeFactor;
		prop.autoConvert = profileCustomer.AutoConvert;

		prop.isOvernightOnForex = profileCustomer.IsOvernightOnForex;

		prop.userName = profileCustomer.UserName;
		prop.firstName = profileCustomer.FirstName;
		prop.lastName = profileCustomer.LastName;
		prop.agreementType = profileCustomer.AgreementType;
		prop.signAgreementDate = general.str2Date(profileCustomer.SignAgreementDate);
		prop.hasMissingInformation = Boolean.parse(profileCustomer.HasMissingInformation);
		prop.sjcKey = profileCustomer.sjcKey;

		prop.idByShufti = profileCustomer.IDByShufti;
		prop.ubByShufti = profileCustomer.UBByShufti;

		prop.abTestings = {
			groupsNames: profileCustomer.ABTestings.map(function (ab) {
				return ab.GroupName;
			}),
			testsNames: profileCustomer.ABTestings.map(function (ab) {
				return ab.TestName;
			}),
			configuration: profileCustomer.ABTestings.reduce(function (accumulator, ab) {
				return Object.assign(accumulator, JSON.parse(ab.Configuration));
			}, {}),
		};

		if (systemInfo.isNative && prop.abTestings.configuration["fx-feedback"] !== false) {
			prop.abTestings.configuration["fx-feedback"] = true;
		}

		// for smart client
		prop.compliance = profileCustomer.compliance;
		prop.maintenanceMarginPercentage = profileCustomer.maintenanceMargin;

		_isAuthenticated = true;

		prop.isAutologin = urlResolver.getIsAutoLogin();

		prop.isSeamless = profileCustomer.IsSeamless;

		prop.csmTrace = ko.observable(false);

		updateSignalsPermissions().done();
		updateShouldChangePassword();
	}

	function isAuthenticated() {
		return _isAuthenticated;
	}

  function hasAbTestConfig(propertyName) {
	  return !!prop.abTestings.configuration[propertyName];
  }


	// mainPage: the main form based on client permission
	// startup form - the start up form based on the default form saved in database
	// defaultFirstPage - the saved page on the custoemr profile, should not be used other than this mapping
	function setStartUpAndMainPageAndTradingPermissions(defaultFirstPage, homePage) {
		var tradingPermissions = {};

		if (!homePage) {
			homePage = Containers.MainForm;
		}

		//default not exists in client profile
		if (defaultFirstPage === 0) {
			defaultFirstPage = Containers.MainForm;
		}

		prop.mainPage = homePage;
		tradingPermissions.hasTransactionsReport = prop.hasTransactionsReport == "True";

		tradingPermissions.isOnlyForexCustomer = true;
		prop.startUpForm = defaultFirstPage;

		return tradingPermissions;
	}

  function isAutologin() {
      return !!prop.isAutologin;
  }


	function logout() {
		_isAuthenticated = false;
	}

	function hasMissingAgreement() {
		return prop.signAgreementDate === null && prop.agreementType === 0;
	}

	function updateMissingInformation(customerUpdated) {
		updateCustomerDetails(customerUpdated);
	}

	function updateCustomerDetails(customerUpdated) {
		prop.userName = customerUpdated.UserName;
		prop.fullName = customerUpdated.FullName;
		prop.personalNumber = customerUpdated.PersonalNumber;
		prop.dateOfBirth = customerUpdated.DateOfBirth;
		prop.agreementType = customerUpdated.AgreementType;
		prop.signAgreementDate = general.str2Date(customerUpdated.SignAgreementDate);
		prop.hasMissingInformation = Boolean.parse(customerUpdated.HasMissingInformation);
		prop.idNumber = customerUpdated.IDNumber;
		prop.address = customerUpdated.Address;
	}

	function updateHasMissingInformation() {
		dalCustomer
			.HasMissingInformation()
			.then(function (response) {
				var parsedResponse = JSONHelper.STR2JSON("customer:updateHasMissingInformation", response);
				prop.hasMissingInformation = parsedResponse.HasMissingInformation;
			})
			.done();
	}

	function updateSignalsPermissions() {
		return dalCustomer.getCustomerSignalsPermissions().then(setSignalsPermissions);
	}

	function setSignalsPermissions(signalsData) {
		prop.AreSignalsAllowed = signalsData && signalsData.status == eResult.Success && signalsData.result == "True";
		prop.signalsEndDate = prop.AreSignalsAllowed ? general.str2Date(signalsData.signalsEndDate).ExtractDate() : "";
		signalsPermissionsPromise.resolve();
	}

	function updateShouldChangePassword() {
		dalCustomer.GetShouldChangePassword().then(setShouldChangePassword).done();
	}

	function setShouldChangePassword(data) {
		if (!general.isNullOrUndefined(data)) {
			prop.showSuggestionChangePassword = data.ShouldChangePassword;
		} else {
			logger.warn("Customer", "Cannot set ShouldChangePassword because it is not available");
		}
	}

	function getCustomerDetails() {
		return dalCustomer.GetCustomerDetails();
	}

	function getCustomer() {
		return dalCustomer.getCustomer();
	}

	function getToken() {
		return dalCustomer.GetToken();
	}

  function initialScmmData(callback) {
    return dalCustomer.InitialScmmData(callback);
  }
	var module = (window.$customer = {
		prop: prop,
		Init: init,
		isAuthenticated: isAuthenticated,
		isAutologin: isAutologin,
		Logout: logout,
		HasMissingAgreement: hasMissingAgreement,
		HasAbTestConfig: hasAbTestConfig,
		UpdateMissingInformation: updateMissingInformation,
		UpdateHasMissingInformation: updateHasMissingInformation,
		SignalsPermissionsReady: signalsPermissionsPromise.promise,
		GetCustomer: getCustomer,
		GetCustomerDetails: getCustomerDetails,
		GetToken: getToken,
    InitialScmmData: initialScmmData
	});

	return module;
});

var CookieHandler = {
    
    CookiesEnabled: function () {
        try {
            document.cookie = 'cookietest=1';
            var cookiesEnabled = document.cookie.indexOf('cookietest=') !== -1;
            document.cookie = 'cookietest=1; expires=Thu, 01-Jan-1970 00:00:01 GMT';
            return cookiesEnabled;
        } catch (e) {
            return false;
        }
    },

    CreateCookie: function (name, value, expireDate) {
        var expires;

        if (!value)
            return;

        if (expireDate)
            expires = "; expires=" + expireDate.toGMTString();
        else
            expires = "";

        document.cookie = name + "=" + value + expires + "; path=/";
    },

    //-----------------------------------------------------------

    ReadCookie: function (name) {

        var nameEQ = name + "=";
        var ca = document.cookie.split(';');

        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    },

    //-----------------------------------------------------------

    EraseCookie: function (name) {
        document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/";
    }
};

define("handlers/Cookie", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.CookieHandler;
    };
}(this)));

define(
    'modules/ThemeSettings',
    [
        'require',
        'handlers/Cookie',
        'handlers/general',
    ],
    function (require) {
        var CookieHandler = require('handlers/Cookie'),
            general = require('handlers/general'),
            ThemeCookieName = 'Theme';

        var ThemeSettings = function () {
            var Themes = {
                light: 'light',
                dark: 'dark' 
            };
 
            function getTheme() {
                var ThemeCookie =  CookieHandler.ReadCookie(ThemeCookieName);
                if (ThemeCookie){
                    return ThemeCookie.split("|")[0];
                }
                else{
                    return Themes.light;
                }
            }
            
            function updateTheme(newTheme, callBack) {
                updateThemeResources(newTheme);
                CookieHandler.CreateCookie(ThemeCookieName, newTheme + '|false', (new Date()).AddMonths(6));

                if (callBack && general.isFunctionType(callBack)) {
                    callBack();
                }
            }

            function updateThemeResources(newTheme) {
                var currentTheme = getTheme(),
                    allLinks = document.getElementsByTagName('link');

                if (general.isNullOrUndefined(Themes[newTheme])) {
                    return;
                }

                if (allLinks.length) {
                    for (var i = 0; i < allLinks.length; i++) {
                        var matchString = currentTheme + '.css',
                            replaceString = newTheme + '.css',
                            node = allLinks[i],
                            href = node.getAttribute('href');

                        if (href.indexOf(matchString) != -1 ) {
                            node.href = href.replace(matchString, replaceString);
                        }
                    }
                }
            }

            return {
                Themes: Themes,
                GetTheme: getTheme,
                UpdateTheme: updateTheme
            };
        };

        return ThemeSettings();
    }
);

/**
 * @license text 2.0.16 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text', ['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.16',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) { }

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                    name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                    text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                        parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                    "define(function () { return '" +
                    content +
                    "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
        typeof process !== "undefined" &&
        process.versions &&
        !!process.versions.node &&
        !process.versions['node-webkit'] &&
        !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
        text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
        typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
        typeof Components !== 'undefined' && Components.classes &&
        Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                    .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                    .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                    Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});
define("vendor/text", function(){});

define("modules/environmentData", [], function EnvironmentDataDef() {
	var environmentData = {};

	return {
		get: function () {
			return environmentData;
		},

		set: function (ed) {
			Object.assign(environmentData, ed);
		},
	};
});

define('fxnet/loader',["global/UrlResolver", "handlers/AjaxError"], function Loader(UrlResolver, AjaxError) {
	var snippetLenghtThreshold = 20; // done to avoid waff responses and not to limit the response length

	function get(url, callback, contentType, nocache) {
		callback = callback || function () {};

		var xhr = new XMLHttpRequest();

		if (nocache) {
			url += url.indexOf("?") < 0 ? "?" : "&";
			url += UrlResolver.getRndKeyValue();
		}

		xhr.onreadystatechange = function () {
			if (this.readyState !== 4) {
				return;
			}
			var headers = xhr.getAllResponseHeaders ? xhr.getAllResponseHeaders() : "";
			if (this.status >= 200 && this.status < 400) {
				callback(null, this.responseText || "");
			} else if (this.status === 401) {
				callback(
					new AjaxError(
						this.status,
						"unauthorized",
						url,
						this.responseText.substring(0, snippetLenghtThreshold)
					)
				);
			} else if (this.status === 403) {
				callback(
					new AjaxError(this.status, "forbidden", url, this.responseText.substring(0, snippetLenghtThreshold))
				);
			} else if (this.status === 420) {
				callback(
					new AjaxError(
						this.status,
						"invalid_version",
						url,
						this.responseText.substring(0, snippetLenghtThreshold)
					)
				);
			} else if (this.status === 417) {
				callback(
					new AjaxError(
						this.status,
						"double_request",
						url,
						this.responseText.substring(0, snippetLenghtThreshold)
					)
				);
			} else if (this.status === 0) {
				callback(new AjaxError(0, "abort" + "response headers: " + headers, url));
			} else {
				callback(
					new AjaxError(this.status, "unknown", url, this.responseText.substring(0, snippetLenghtThreshold))
				);
			}
		};

		xhr.open("GET", url, true);

		if (!UrlResolver.isCors(url)) {
			if (contentType) {
				xhr.setRequestHeader("Content-Type", contentType);
			}
			xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
		}

		xhr.send();
	}

	return {
		get: get,
	};
});

var eLoginLogoutReason = {
	userDemand: 7770000,
	doubleLogin: 7770001,
	FxDenied: 7770002,
	appClose: 7770003,
	idleTime: 7770004,
	clientStateError: 7770005,
	serverError: 7770006,
	webTrader_filepathNotAccessible: 7770007,
	webTrader_noViewModeCookie: 7770008,
	webTrader_noVersionCookie: 7770009,
	webTrader_noBrokerCookie: 7770010,
	webTrader_unsupportedError: 7770011,
	mobileTrader_filepathNotAccessible: 7770012,
	mobileTrader_noViewModeCookie: 7770013,
	mobileTrader_noVersionCookie: 7770014,
	mobileTrader_noBrokerCookie: 7770015,
	mobileTrader_unsupportedError: 7770016,
	preloaderError_noVersion: 7770017,
	preloaderError_noBroker: 7770018,
	preloaderError_noLanguage: 7770019,
	preloaderError_noStaticParams: 7770020,
	preloaderError_ajaxHttp: 7770021,
	preloaderError_other: 7770022,
	preloaderError_jsonParse: 7770051,
	errorManager_httpError: 7770023,
	alert_exitApp: 7770024,
	web_exitAlert: 7770025,
	mobile_exitAlert: 7770026,
	web_postLoginAlertController_serverError: 7770027,
	mobile_postLoginAlertController_serverError: 7770028,
	serverResponseAlert_exit: 7770029,
	initialDataManager_dataError: 7770030,
	initialDataManager_symbolsDataError: 7770031,
	dealAddServerResponseAlert_exit: 7770032,
	dealsClosed_serverResponseAlert_exit: 7770033,
	limitsServerResponseAlert_exit: 7770034,
	activitySupervisor_updateAsStay: 7770035,
	activitySupervisor_exit: 7770036,
	activitySupervisor_logout: 7770037,
	sessionSupervisor_keepAliveHttpContextRequired: 7770038,
	sessionSupervisor_keepAliveCompleteError: 7770039,
	web_doubleLogin1: 7770040,
	web_doubleLogin2: 7770041,
	web_doubleLogin3: 7770042,
	mobile_doubleLogin1: 7770043,
	mobile_doubleLogin2: 7770044,
	mobile_doubleLogin3: 7770045,
	web_registrationFailed: 7770046,
	mobile_registrationFailed: 7770047,
	forgotPasswordLogin: 7770048,
	confirmLogin: 7770049,
	mobileTrader_nocontentStyleBrokerCookie: 7770050,
	changePassword_NoToken: 7770108,
};

define('enums/loginlogoutreasonenum',[], function () {
	return eLoginLogoutReason;
});

define('fxnet/preloader',[
	"require",
	"vendor/text",
	"global/UrlResolver",
	"modules/environmentData",
	"Q",
	"fxnet/loader",
	"handlers/AjaxError",
	"enums/loginlogoutreasonenum",
], function (require, text, UrlResolver, ed, Q, loader, AjaxError, eLoginLogoutReason) {
	var isPageUnloading = false,
		htmlLoadEvent,
		initialDataLoadEvent,
		dataObjects = {
			htmlReady: false,
			initialDataReady: false,
			initialData: {},
		},
		timestamps = {
			start: Date.now(),
			end: 0,
			getDuration: getPreloadDuration,
			htmlStart: 0,
			htmlEnd: 0,
			getHtmlDuration: getHtmlDuration,
			initialDataStart: 0,
			initialDataEnd: 0,
			jsResourceFailureStart: 0,
			jsResourceFailureEnd: 0,
			getInitialDataDuration: getInitialDataDuration,
			getSocketConnectionDuration: getSocketConnectionDuration,
			getSocketFromCompleteConnectionToFirstFrame: getSocketFromCompleteConnectionToFirstFrame,
			getSocketFromCompleteConnectionToFirstQuote: getSocketFromCompleteConnectionToFirstQuote,
			sockets: {
				connectionStart: 0,
				connectionComplete: 0,
				firstFrame: 0,
				firstQuote: 0,
			},
		},
		version,
		cachedVersion,
		language = UrlResolver.getLanguage().toLowerCase(),
		cdnPath = UrlResolver.getCdnPath(),
		applicationRelativePath = UrlResolver.getApplicationRelativePath(),
		applicationType = UrlResolver.getApplicationType(),
		contentStyleBrokerId = UrlResolver.getContentStyleBrokerId(),
		brokerId = UrlResolver.getBroker(),
		minDealGroupId = UrlResolver.getMinDealGroupId(),
		hashParams = UrlResolver.getHashParameters(),
		staticParams = UrlResolver.getStaticParams();

	window.addEventListener(
		"beforeunload",
		function beforeUnload() {
			isPageUnloading = true;
		},
		false
	);

	Q.longStackSupport = true;
	Q.onerror = catchAllErrorHandler;

	version = cachedVersion = UrlResolver.getVersion();

	expireLoginReasonCookie();

	function loadBundlesConfig() {
		var rPath =
			applicationType === "mobile" ? "mobile" : window.environmentData.isDesktop === true ? "desktop" : "web";
		return Q.Promise(function (resolve, reject) {
			require(["fxnet/common/config/bundles." + rPath + ".config"], function () {
				resolve();
			});
		});
	}

	function loadRequireConfig() {
		var rPath =
			applicationType === "mobile"
				? "fxnet/devices/mobile/configuration/require.config"
				: window.environmentData.isDesktop === true
				? "fxnet/devices/desktop/configuration/require.config"
				: "fxnet/devices/web/configuration/require.config";

		return Q.Promise(function (resolve, reject) {
			require([rPath], function (executeConfig) {
				executeConfig();
				resolve(true);
			});
		});
	}

	if (!version) {
		redirectTo(eLoginLogoutReason.preloaderError_noVersion, "login", "Version");
	} else if (!contentStyleBrokerId) {
		redirectTo(eLoginLogoutReason.mobileTrader_nocontentStyleBrokerCookie, "login", "StyleBroker");
	} else if (!language) {
		redirectTo(eLoginLogoutReason.preloaderError_noLanguage, "login", "Language");
	} else if (!staticParams) {
		redirectTo(eLoginLogoutReason.preloaderError_noStaticParams, "login", "StaticParams");
	} else if (!brokerId) {
		redirectTo(eLoginLogoutReason.preloaderError_noBroker, "login", "Broker");
	} else {
		loadEnvironmentData()
			.then(loadRequireConfig)
			.then(loadBundlesConfig)
			.then(function checkVersion() {
				var newVersion = UrlResolver.getVersion();

				if (newVersion !== cachedVersion) {
					return false;
				}

				return true;
			})
			.then(function initSocketConnection(isVersionValid) {
				if (!isVersionValid) {
					window.location.assign(window.location.href.split("?")[0] + "?v=" + version);

					return;
				}
				if (window.isScmmBackOffice || window.environmentData.isDesktop) {
					loadApplication();
				} else {
					// we made this async, however we manually include it in web/mobile bundle
					require(["handlers/websocketconnection"], function (SocketConnection) {
						SocketConnection.init(window.environmentData.CSMPushServiceUrl, timestamps, hashParams)
							.then(loadApplication)
							.catch(loadApplication)
							.done();
					});
				}
			})
			.done();
	}

	function expireLoginReasonCookie() {
		document.cookie = "loginReason=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;";
	}

	function catchAllErrorHandler(err) {
		if (typeof window.onerror === "function" && err && err.message) {
			window.onerror(err.message, "", 0, 0, err);
			return;
		}

		throw err;
	}

	function loadApplication() {
		var promiseArr;
		if (applicationType === "mobile") {
			// mobile
			promiseArr = [
				loadInitialData(),
				loadScripts().then(loadNativeBundle),
				setTitle(window.environmentData.Title),
				setIcons(window.environmentData.Icons || []),
				getAppStyles(),
				loadHtml(),
			];
		} else if (window.isScmmBackOffice) {
			// scmm
			promiseArr = [
				loadInitialData(),
				loadScripts(),
				setTitle(window.environmentData.Title),
				setLabels(window.environmentData.Labels),
				setIcons(window.environmentData.Icons || []),
				getJScmmBackOfficeStyles(),
				loadHtml(),
			];
		} else {
			//web & desktop
			promiseArr = [
				loadInitialData(),
				loadScripts(),
				setTitle(window.environmentData.Title),
				setLabels(window.environmentData.Labels),
				setIcons(window.environmentData.Icons || []),
				getJQueryStyles(),
				getAppStyles(),
				loadHtml(),
			];
		}

		return Q.all(promiseArr)
			.fail(function onFail(error) {
				if (
					error instanceof AjaxError &&
					(error.httpStatus === 401 ||
						error.httpStatus === 403 ||
						error.httpStatus === 420 ||
						error.httpStatus === 424)
				) {
					redirectTo(eLoginLogoutReason.preloaderError_ajaxHttp, "login", error.toString());
				} else {
					redirectTo(eLoginLogoutReason.preloaderError_other, "logout", error.toString());
				}
			})
			.finally(function onFinishedPreloading() {
				timestamps.end = Date.now();
			})
			.done();
	}

	function parseHelper(jsonString) {
		try {
			return JSON.parse(jsonString);
		} catch (err) {
			var msgJson = JSON.stringify(
				{
					error: "JSONHelper.STR2JSON threw an exception",
					name: err.name,
					message: err.message,
					str: jsonString.substr(0, 2500),
					stack: err.stack,
				},
				null,
				4
			);

			redirectTo(eLoginLogoutReason.preloaderError_jsonParse, "logout", msgJson);
		}
	}

	function loadEnvironmentData() {
		var defer = Q.defer();

		loader.get(
			resolveEnvironmentDataUrl(),
			function onReceivedData(error, response) {
				try {
					if (error) {
						throw error;
					}
					// extend existing environmentData
					window.environmentData = extend(parseHelper(response), window.environmentData);

					if (typeof window.isDesktop !== "undefined") {
						window.environmentData.isDesktop = true;
					}
					// update the version
					window.environmentData.version = window.version = version = UrlResolver.getVersion();
					window.environmentData.jsCdnPath = cdnPath;
					window.environmentData.jsImgPath = UrlResolver.getImagePath("", false, true);
					window.environmentData.isReady = true;
					window.environmentData.dealerCurrency = hashParams.dealerCurrency;
					window.environmentData.dealerAdvancedWalletView = hashParams.dealerAdvancedWalletView;

					if (/to=real/.test(location.search)) {
						window.environmentData.switchToPlatform = "real";
					} else if (/to=demo/.test(location.search)) {
						window.environmentData.switchToPlatform = "demo";
					}

					window.systemInfo = {
						config: {},
					};

					ed.set(window.environmentData);

					defer.resolve("environmentDataReady");
				} catch (e) {
					defer.reject(e);
				}
			},
			"application/json; charset=utf-8"
		);

		return defer.promise;
	}

	function setTitle(titleText) {
		if (titleText) {
			window.document.title = titleText;
		}
	}

	function setLabels(labels) {
		if (!labels) {
			return;
		}

		var splashPage = document.getElementById("splash_page");
		if (!splashPage) {
			return;
		}

		var label;
		for (var key in labels) {
			if (labels.hasOwnProperty(key)) {
				label = document.getElementById(key);
				if (label) {
					label.innerHTML = labels[key];
				}
			}
		}

		// override switch to platform label
		if (window.environmentData.switchToPlatform) {
			label = document.getElementById("lblSplashText");
			if (label) {
				if (window.environmentData.switchToPlatform === "demo") {
					label.innerHTML = labels["lblSplashTextDemo"] || "%Your demo account is loading...";
				} else {
					label.innerHTML = labels["lblSplashTextReal"] || "%Your real money account is loading...";
				}
			}
		}

		splashPage.style.display = "";
	}

	function loadScripts() {
		var rPath =
			applicationType === "mobile"
				? "fxnet/devices/mobile/configuration/app"
				: window.environmentData.isDesktop === true
				? "fxnet/devices/desktop/configuration/app"
				: "fxnet/devices/web/configuration/app";
		return Q.promise(function (resolve, reject) {
			require([rPath], function (startFn) {
				if (typeof startFn === "function") {
					window.environmentData.isDesktop === true
						? startFn(window.startForm, window.startCallback)
						: startFn();
				}
				resolve();
			});
		});
	}

	function loadNativeBundle() {
		return Q.Promise(function onNativeBundleLoad(resolve, reject) {
			var fileName, filePath;

            if (UrlResolver.isNativeIos()) {
                fileName = "nativeiosmain.js";
            } else if (UrlResolver.isNativeAndoid()) {
                fileName = "nativeandroidmain.js";
            } else {
                resolve();
                return;
            }

			filePath = UrlResolver.getStaticJSPath(fileName);

			loadJs(filePath, resolve, reject);
		});
	}

	function loadJs(filePath, onLoad, onError) {
		var script = document.createElement("script");
		script.src = filePath;
		script.type = "text/javascript";
		script.crossOrigin = "anonymous";

		script.onerror = function onScriptError(e) {
			loadFailedJsAjax(filePath).then(function onRetryFulfilled(retryMessage) {
				var error = new URIError(
					"The script " + e.target.src + " is not accessible. Retry result: " + retryMessage
				);

				if (typeof onError !== "function") {
					throw error;
				}

				onError(error);
			});
		};

		if (typeof onLoad === "function") {
			script.onload = onLoad;
		}

		document.body.appendChild(script);
	}

	function loadFailedJsAjax(filePath) {
		var defer = Q.defer();

		timestamps.jsResourceFailureStart = Date.now();

		loader.get(filePath, function onFulfilled(error) {
			timestamps.jsResourceFailureEnd = Date.now();
			if (error) {
				defer.resolve(
					"retry script loading failed with status " +
						error.httpStatus +
						". Snippet: " +
						error.responseSnippet +
						". Duration: " +
						(timestamps.jsResourceFailureEnd - timestamps.jsResourceFailureStart) +
						"ms."
				);
			} else {
				defer.resolve(
					"retry script loading successful. Duration: " +
						timestamps.jsResourceFailureEnd -
						timestamps.jsResourceFailureStart
				);
			}
		});

		return defer.promise;
	}

	function getAppStyles() {
		var theme = "." + (window.ApplicationTheme || "light|false").split("|")[0];
		var url = UrlResolver.combine(
			UrlResolver.getAssetsPath(),
			"skins",
			applicationType,
			"broker" + contentStyleBrokerId,
			language,
			"style" + theme + ".css"
		);

		loadCss(url);
	}

	function getJQueryStyles() {
		var theme = "." + (window.ApplicationTheme || "light|false").split("|")[0];
		var url;

		url = UrlResolver.combine(UrlResolver.getAssetsPath(), "skins/web/allbrokers/default/jquery" + theme + ".css");

		loadCss(url);
	}

	function getJScmmBackOfficeStyles() {
		var url;

		url = UrlResolver.combine(UrlResolver.getAssetsPath(), "Skins/Shared/backoffice/scmm/scmm.css");

		loadCss(url);
	}

	function loadCss(href) {
		if (!href) {
			return;
		}

		var head = document.getElementsByTagName("head")[0],
			link = document.createElement("link");

		link.rel = "stylesheet";
		link.href = href;

		head.appendChild(link);
	}

	function setIcons(urls) {
		var head = document.getElementsByTagName("head")[0],
			link,
			i;

		for (i = 0; i < urls.length; i++) {
			if (urls[i] && urls[i].href) {
				link = document.createElement("link");

				link.rel = urls[i].rel || "icon";
				link.href = urls[i].href;
				link.type = urls[i].type || "image/png";

				head.appendChild(link);
			}
		}
	}

	function loadInitialData() {
		var self = this,
			defer = Q.defer(),
			initialDataArray = [
				{ type: "Main", url: resolveInitialDataUrl("GetData"), nocache: true },
				{ type: "Countries", url: resolveStaticInitialDataUrl("Countries") },
				{ type: "Symbols", url: resolveStaticInitialDataUrl("Symbols") },
				{ type: "Instruments", url: resolveStaticInitialDataUrl(UrlResolver.getInstrumentsUrl()) },
			];

		function initialDataCallback(type, error, response) {
			try {
				if (error && (error.httpStatus === 424 || error.httpStatus === 0 || error.httpStatus === 502)) {
					loader.get(
						UrlResolver.getInstrumentsFromOriginUrl(),
						initialDataCallback.bind(self, "Instruments"),
						"application/json; charset=utf-8",
						true
					);

					return;
				}

				if (error) {
					throw error;
				}

				dataObjects.initialData[type] = parseHelper(response);

				invokeInitialDataLoadEvent();
			} catch (e) {
				defer.reject(e);
			}
		}

		function invokeInitialDataLoadEvent() {
			for (var j = 0; j < initialDataArray.length; j++) {
				if (typeof dataObjects.initialData[initialDataArray[j].type] === "undefined") {
					return;
				}
			}

			timestamps.initialDataEnd = Date.now();
			dataObjects.initialDataReady = true;

			defer.resolve("initialDataReady");
		}

		timestamps.initialDataStart = Date.now();

		for (var i = 0; i < initialDataArray.length; i++) {
			loader.get(
				initialDataArray[i].url,
				initialDataCallback.bind(self, initialDataArray[i].type),
				"application/json; charset=utf-8",
				initialDataArray[i].nocache
			);
		}

		return defer.promise.then(function onInitialDataLoaded(value) {
			if (typeof initialDataLoadEvent === "function") {
				initialDataLoadEvent();
			}

			return value;
		});
	}

	function loadHtml() {
		var defer = Q.defer(),
			url = resolveHtmlRequestUrl();

		timestamps.htmlStart = Date.now();

		loader.get(url, function onLoadHtmlFulfilled(error, response) {
			try {
				if (error) {
					throw error;
				}

				var elementToUpdate = document.getElementById("mainTemplate");
				if (elementToUpdate) {
					elementToUpdate.innerHTML = response;
					dataObjects.htmlReady = true;
				}

				defer.resolve("htmlReady");
			} catch (e) {
				defer.reject(e);
			} finally {
				timestamps.htmlEnd = Date.now();
			}
		});

		return defer.promise.then(function onHtmlReady(value) {
			if (typeof htmlLoadEvent === "function") {
				htmlLoadEvent();
			}

			return value;
		});
	}

	function addLoginReasonCookie(reason) {
		if (reason) {
			var d = new Date();
			d.setTime(d.getTime() + 60000);
			document.cookie =
				"loginReason=" + encodeURIComponent(reason) + ";" + ("Expires=" + d.toUTCString()) + "; path=/";
		}
	}

	function redirectTo(errorCode, location, message) {
		if (isPageUnloading) {
			return;
		}

		isPageUnloading = true;

		if (message) {
			addLoginReasonCookie(message);
		}

		window.location.replace(
			UrlResolver.combine(applicationRelativePath, "account", location, "?reason=" + errorCode)
		);
	}

	function resolveInitialDataUrl(action) {
		var url = UrlResolver.combine(applicationRelativePath, "InitialData", action);

		return url;
	}

	function resolveEnvironmentDataUrl() {
		var url = UrlResolver.combine(
			UrlResolver.getStaticPath(),
			UrlResolver.getStaticParams(),
			"initialdata-environmentdata-" + applicationType + ".js?v=" + version
		);

		return url;
	}

	function resolveStaticInitialDataUrl(action) {
		var url = UrlResolver.combine(UrlResolver.getAssetsPath(), "InitialData", action + ".js");

		return url;
	}

	function resolveHtmlRequestUrl() {
		var url = UrlResolver.combine(
			UrlResolver.getStaticPath(),
			UrlResolver.getStaticParams(),
			minDealGroupId,
			version,
			"main.html"
		);

		return url;
	}

	// borrowed from knockout-3.4.0.js
	function extend(target, source) {
		if (source) {
			for (var prop in source) {
				if (source.hasOwnProperty(prop)) {
					target[prop] = source[prop];
				}
			}
		}

		return target;
	}

	function setHtmlLoadEvent(callback) {
		htmlLoadEvent = callback;
	}

	function setInitialDataLoadEvent(callback) {
		initialDataLoadEvent = callback;
	}

	function getHtmlDuration() {
		return timestamps.htmlEnd - timestamps.htmlStart;
	}

	function getInitialDataDuration() {
		return timestamps.initialDataEnd - timestamps.initialDataStart;
	}

	function getPreloadDuration() {
		return timestamps.end - timestamps.start;
	}

	function getSocketConnectionDuration() {
		var duration = timestamps.sockets.connectionComplete - timestamps.sockets.connectionStart;
		return duration < 0 ? 0 : duration;
	}

	function getSocketFromCompleteConnectionToFirstFrame() {
		var duration = timestamps.sockets.firstFrame - timestamps.sockets.connectionComplete;
		return duration < 0 ? 0 : duration;
	}

	function getSocketFromCompleteConnectionToFirstQuote() {
		var duration = timestamps.sockets.firstQuote - timestamps.sockets.connectionComplete;
		return duration < 0 ? 0 : duration;
	}

	return {
		SetInitialDataLoadEvent: setInitialDataLoadEvent,
		SetHtmlLoadEvent: setHtmlLoadEvent,

		DataObjects: dataObjects,
		Timestamps: timestamps,
	};
});

define("trackingIntExt/TrackingEvents", [
	"tracking/EventRaiser",
	"tracking/PerformanceDataCollector",
	"handlers/general",
	"initdatamanagers/Customer",
	"modules/ThemeSettings",
	"enums/enums",
	"fxnet/preloader",
], function TrackingEvents(eventRaiser, PerformanceDataCollector, general, customer, ThemeSettings) {
	var Preloader = require("fxnet/preloader");
	var self = {};

	function removeParametersFromReferrerUrl(referrerUrl) {
		return referrerUrl.split("?")[0];
	}

	self.getCurrentEventData = function () {
		return eventRaiser.eventData;
	};

	self["exposeUI"] = function () {
		var eventData = eventRaiser.eventData;
		eventData.event = "exposeUI";
		eventData.start = Date.now();

		try {
			// Preloader
			eventData.htmlFromCdnDuration = Preloader.Timestamps.getHtmlDuration();
			eventData.initialDataDuration = Preloader.Timestamps.getInitialDataDuration();

			// Static resources
			var contentLoadDuration = PerformanceDataCollector.getResourceTiming(
				UrlResolver.getContentPath("contentdata")
			);
			var cssLoadDuration = PerformanceDataCollector.getResourceTiming(".*.css");
			var faviconLoadDuration = PerformanceDataCollector.getResourceTiming("favicon");
			var preloaderDuration = PerformanceDataCollector.getResourceTiming(
				"assets/" + window.version + "/js/scripts/preloader.js"
			);
			var jsBundleLoadDuration =
				PerformanceDataCollector.getResourceTiming("assets/" + window.version + "/js/main.js") +
				PerformanceDataCollector.getResourceTiming("assets/" + window.version + "/js/mobilemain.js");
			var styleCssLoadDuration = PerformanceDataCollector.getResourceTiming(".*style.css");
			var mainHtmlLoadDuration = PerformanceDataCollector.getResourceTiming(".*main.html");

			// aggregate css, contentdata and favicon.ico -> header duration

			eventData.cssLoadDuration = Math.ceil(cssLoadDuration);
			eventData.contentLoadDuration = Math.ceil(contentLoadDuration);
			eventData.bundleLoadDuration = Math.ceil(jsBundleLoadDuration);
			eventData.preloaderDuration = Math.ceil(preloaderDuration);
			eventData.faviconLoadDuration = Math.ceil(faviconLoadDuration);

			eventData.networkDuration = getNetworkDuration();
			eventData.domParseDuration = getDomParseDuration();
			eventData.applicationStartDuration = getApplicationStartDuration();

			eventData.managersInit =
				PerformanceDataCollector.Timestamps[eFxNetEvents.Start] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.Init];

			// is new version
			eventData.loadedNewVersion = PerformanceDataCollector.isNewVersion();

			// avarage duration for 3 sample files: main.js/mobilemain.js bundle , main.html, style.css
			eventData.average3FilesLoadDuration = Math.ceil(
				(styleCssLoadDuration + mainHtmlLoadDuration + jsBundleLoadDuration) / 3
			);

			// BEGIN Parallel
			// ------------------------------------
			// Duration of waiting for initial data
			eventData.waitInitialDataDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.InitialDataEnd] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.InitialDataStart];

			// Duration of waiting for apply bindings until html is available
			eventData.waitHtmlDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.WaitHtmlEnd] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.WaitHtmlStart];

			// Duration of ko.applyBindings
			eventData.applyBindingsDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.ApplyBindingsEnd] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.ApplyBindingsStart];
			// ------------------------------------
			// END Parallel

			// Duration of CacheManager
			eventData.cacheLoadDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.CacheLoadEnd] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.CacheLoadStart];

			// Duration of UiLayerManager
			eventData.uiLayerDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.UiLayerEnd] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.UiLayerStart];

			// Duration for initializing the applicationm
			// applicationInitDuration = MAX(waitInitialDataDuration, waitHtmlDuration, applyBindingsDuration) + cacheLoadDuration + uiLayerDuration + exposeUIDuration
			eventData.applicationInitDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.ExposeUi] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.Init];

			// Duration between ko.applyBindings and splash screen removed
			eventData.exposeUIDuration =
				PerformanceDataCollector.Timestamps[eFxNetEvents.ExposeUi] -
				PerformanceDataCollector.Timestamps[eFxNetEvents.SplashScreenRemoved];

			eventData.loginDuration = getLoginDuration();

			// from expose UI to getting the first quote MAX(0, First Quote time - ExposeUI time)
			eventData.fromExposeUiToFirstQuote = Math.max(
				0,
				PerformanceDataCollector.Timestamps[eFxNetEvents.FirstQuoteEvent] -
					PerformanceDataCollector.Timestamps[eFxNetEvents.ExposeUi]
			);

			// pure wesocket prformace events:

			// Socket connection duration
			eventData.webSocketStartToComplete = Preloader.Timestamps.getSocketConnectionDuration();

			eventData.webSocketCompleteConnectionToFirstQuote = Preloader.Timestamps.getSocketFromCompleteConnectionToFirstQuote();

			eventData.webSocketsFromCompleteConnectionToFirstFrame = Preloader.Timestamps.getSocketFromCompleteConnectionToFirstFrame();
		} catch (e) {
			eventData.duration = 0;
			// Re-throw the exception, it will be caught by ErrorManager
			throw e;
		} finally {
			eventRaiser.raiseEvent();
		}
	};

	function getNetworkDuration() {
		var fetchStartValue = PerformanceDataCollector.fetchStart();
		var responseEndValue = PerformanceDataCollector.responseEnd();

		if (responseEndValue === "" || fetchStartValue === "") {
			return "";
		} else {
			// network transfer duration - we got all the aspx bytes
			return responseEndValue - fetchStartValue;
		}
	}

	function getDomParseDuration() {
		var responseEndValue = PerformanceDataCollector.responseEnd();
		var loadEventEndValue = PerformanceDataCollector.loadEventEnd();

		if (loadEventEndValue === "" || responseEndValue === "") {
			return "";
		} else {
			// domCompleted - bytes recieved (main aspx) , dom parsed including js on main page
			return loadEventEndValue - responseEndValue;
		}
	}

	function getApplicationStartDuration(eventData) {
		var loadEventEndValue = PerformanceDataCollector.loadEventEnd();

		if (loadEventEndValue === "") {
			return "";
		} else {
			// Duration until application is started
			return PerformanceDataCollector.Timestamps[eFxNetEvents.Init] - loadEventEndValue;
		}
	}

	function getLoginDuration() {
		var fetchStartValue = PerformanceDataCollector.fetchStart();
		if (fetchStartValue === "") {
			return "";
		} else {
			// Duration from login
			return PerformanceDataCollector.Timestamps[eFxNetEvents.ExposeUi] - fetchStartValue;
		}
	}

	self["socket-connection-test"] = function () {
		eventRaiser.eventData.event = "socket-connection-test";

		//eventRaiser.eventData.socketFirstFrameDuration = Preloader.Timestamps.getSocketFirstFrameDuration();

		//eventRaiser.eventData.socketFirstQuoteDuration = Preloader.Timestamps.getSocketFirstQuoteDuration();

		// from expose UI to getting the first quote MAX(0, First Quote time - ExposeUI time)
		//eventRaiser.eventData.fromExposeUiToFirstQuote = Math.max(0, Preloader.Timestamps.webSocketFirstQuote - PerformanceDataCollector.Timestamps[eFxNetEvents.ExposeUi]);

		//eventRaiser.eventData.fromWebSocketTosAjaxFirstQuote = Math.max(0, Preloader.Timestamps.webSocketFirstQuote - PerformanceDataCollector.Timestamps[eFxNetEvents.FirstQuoteEvent]);

		eventRaiser.raiseEvent();
	};

	self["deal-slip-view"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-view";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Instrument = options.instrument;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.DisplayMode = options.displayMode;
		eventRaiser.eventData.InstrumentStatus = options.instrumentStatus;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;

		eventRaiser.eventData.SearchResult = options.SearchResult;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-interaction"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-interaction";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Element = options.element;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-submit"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-submit";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Instrument = options.instrument;
		eventRaiser.eventData.DealSize = options.dealSize;
		eventRaiser.eventData.StopLossType = options.stopLossType;
		eventRaiser.eventData.TakeProfitType = options.takeProfitType;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.EnableSLLimit = options.enableSLLimit;
		eventRaiser.eventData.EnableTPLimit = options.enableTPLimit;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;
		eventRaiser.eventData.Chart = options.chart;
		eventRaiser.eventData.Theme = ThemeSettings.GetTheme();

		eventRaiser.eventData.SearchResult = options.SearchResult;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["switch-main-view"] = function (options) {
		eventRaiser.eventData.event = "switch-main-view";

		eventRaiser.raiseEvent();
	};

	self["new-deal-dragged"] = function (options) {
		eventRaiser.eventData.event = "new-deal-dragged";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-switch-instrument"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-switch-instrument";

		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-switch-tab"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-switch-tab";

		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-expand-limit"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-expand-limit";

		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-collapse-limit"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-collapse-limit";

		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-expand-tools"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-expand-tools";

		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-slip-collapse-tools"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-collapse-tools";

		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;

		eventRaiser.raiseEvent();
	};

	self["deal-chart-collapse-trade-ticket"] = function () {
		eventRaiser.eventData.event = "deal-chart-collapse-trade-ticket";
		eventRaiser.raiseEvent();
	};

	self["deal-chart-expand-trade-ticket"] = function () {
		eventRaiser.eventData.event = "deal-chart-expand-trade-ticket";
		eventRaiser.raiseEvent();
	};

	self["new-limit-view"] = function (options) {
		eventRaiser.eventData.event = "new-limit-view";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Instrument = options.instrument;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.DisplayMode = options.displayMode;
		eventRaiser.eventData.InstrumentStatus = options.instrumentStatus;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["new-limit-submit"] = function (options) {
		eventRaiser.eventData.event = "new-limit-submit";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["limit-slip-interaction"] = function (options) {
		eventRaiser.eventData.event = "limit-slip-interaction";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Element = options.element;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;

		eventRaiser.eventData.SearchResult = options.SearchResult;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["witdrawal-view"] = function () {
		eventRaiser.eventData.event = "withdrawal-view";
		eventRaiser.raiseEvent();
	};

	self["withdrawal-interaction"] = function () {
		eventRaiser.eventData.event = "withdrawal-interaction";
		eventRaiser.raiseEvent();
	};

	self["withdrawal-submit"] = function () {
		eventRaiser.eventData.event = "withdrawal-submit";
		eventRaiser.raiseEvent();
	};

	self["withdrawal-cancel"] = function () {
		eventRaiser.eventData.event = "withdrawal-cancel";
		eventRaiser.raiseEvent();
	};

	self["withdrawal-print"] = function () {
		eventRaiser.eventData.event = "withdrawal-print";
		eventRaiser.raiseEvent();
	};

	self["deposit-view"] = function () {
		eventRaiser.eventData.event = "deposit-view";
		eventRaiser.raiseEvent();
	};

	self["deposit-interaction"] = function () {
		eventRaiser.eventData.event = "deposit-interaction";
		eventRaiser.raiseEvent();
	};

	self["agreement-view"] = function () {
		eventRaiser.eventData.event = "agreement-view";
		eventRaiser.raiseEvent();
	};

	self["agreement-first-interaction"] = function () {
		eventRaiser.eventData.event = "agreement-first-interaction";
		eventRaiser.raiseEvent();
	};

	self["agreement-submit"] = function () {
		eventRaiser.eventData.event = "agreement-submit";
		eventRaiser.raiseEvent();
	};

	self["agreement-success"] = function () {
		eventRaiser.eventData.event = "agreement-success";
		eventRaiser.raiseEvent();
	};

	self["registration-success"] = function () {
		eventRaiser.eventData.event = "registration-success";
		eventRaiser.eventData.Referrer = removeParametersFromReferrerUrl(document.referrer);
		eventRaiser.raiseEvent();
	};

	self["login-success"] = function (isAutologin) {
		eventRaiser.eventData.event = "login-success";
		eventRaiser.eventData.Referrer = removeParametersFromReferrerUrl(document.referrer);
		eventRaiser.eventData.IsAutologin =
			!general.isEmptyType(isAutologin) && JSON.parse(isAutologin) === true ? true : false;
		eventRaiser.raiseEvent();
	};

	self["forgot-password-success"] = function () {
		eventRaiser.eventData.event = "forgot-password-success";
		eventRaiser.raiseEvent();
	};

	self["withdrawal-success"] = function () {
		eventRaiser.eventData.event = "withdrawal-success";
		eventRaiser.raiseEvent();
	};

	self["View"] = function () {
		var currentViewId = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.event = "View";
		eventRaiser.eventData.ViewId = currentViewId;
		eventRaiser.eventData.RefferingView = window.tradingEventsHandler.getRefferingView();
		eventRaiser.eventData.ActionSource = window.tradingEventsHandler.data.actionSource;
		window.tradingEventsHandler.data.actionSource = "Other";
		window.tradingEventsHandler.updateRefferingView(currentViewId);
		eventRaiser.raiseEvent();
	};

	self["instrument-advanced"] = function () {
		eventRaiser.eventData.event = "instrument-advanced";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["instrument-simple"] = function () {
		eventRaiser.eventData.event = "instrument-simple";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["information-maximize"] = function () {
		eventRaiser.eventData.event = "information-maximize";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["information-minimize"] = function () {
		eventRaiser.eventData.event = "information-minimize";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["account-summary-advanced"] = function () {
		eventRaiser.eventData.event = "account-summary-advanced";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["account-summary-simple"] = function () {
		eventRaiser.eventData.event = "account-summary-simple";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["summary-available-margin"] = function () {
		eventRaiser.eventData.event = "account-summary-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Element = "available margin";
		eventRaiser.raiseEvent();
	};

	self["summary-pending-withdrawals"] = function () {
		eventRaiser.eventData.event = "account-summary-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Element = "pending withdrawals";
		eventRaiser.raiseEvent();
	};

	self["summary-used-margin"] = function () {
		eventRaiser.eventData.event = "account-summary-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Element = "used margin";
		eventRaiser.raiseEvent();
	};

	self["summary-margin-utilization"] = function () {
		eventRaiser.eventData.event = "account-summary-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Element = "margin utilization";
		eventRaiser.raiseEvent();
	};

	self["cashback-from-wallet"] = function () {
		eventRaiser.eventData.event = "account-summary-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Element = "cash back";
		eventRaiser.raiseEvent();
	};

	self["cashback-extra-info"] = function () {
		eventRaiser.eventData.event = "cash-back-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Element = "cash back extra-info";
		eventRaiser.raiseEvent();
	};

	self["net-exposure-one-currency"] = function () {
		eventRaiser.eventData.event = "net-exposure-one-currency";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Currency = customer.prop.selectedCcyName();
		eventRaiser.eventData.Element = "pending bonus";
		eventRaiser.raiseEvent();
	};

	self["net-exposure-original-currency"] = function () {
		eventRaiser.eventData.event = "net-exposure-original-currency";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["deal-slip-success"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-success";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.DisplayMode = options.displayMode;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.EnableSLLimit = options.enableSLLimit;
		eventRaiser.eventData.EnableTPLimit = options.enableTPLimit;
		eventRaiser.eventData.Instrument = options.instrument;
		eventRaiser.eventData.Type = options.type;
		eventRaiser.eventData.DealSize = options.dealSize;
		eventRaiser.eventData.StopLossType = options.stopLossType;
		eventRaiser.eventData.TakeProfitType = options.takeProfitType;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["new-limit-success"] = function (options) {
		eventRaiser.eventData.event = "new-limit-success";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Instrument = options.instrument;
		eventRaiser.eventData.Type = options.type;
		eventRaiser.eventData.DealSize = options.dealSize;
		eventRaiser.eventData.AdvancedView = options.advancedView;
		eventRaiser.eventData.ExpirationType = options.expirationType;
		eventRaiser.eventData.StopLossType = options.stopLossType;
		eventRaiser.eventData.TakeProfitType = options.takeProfitType;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["change-currency"] = function () {
		eventRaiser.eventData.event = "change-currency";
		eventRaiser.eventData.Currency = customer.prop.selectedCcyName();
		eventRaiser.raiseEvent();
	};

	self["change-language"] = function () {
		eventRaiser.eventData.event = "change-language";
		eventRaiser.eventData.Language = CookieHandler.ReadCookie("Language");
		eventRaiser.raiseEvent();
	};

	self["sign-out"] = function () {
		eventRaiser.eventData.event = "sign-out";
		eventRaiser.raiseEvent();
	};

	self["cancel-limit"] = function () {
		eventRaiser.eventData.event = "cancel-limit";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["update-limit"] = function () {
		eventRaiser.eventData.event = "update-limit";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["close-deal-selected"] = function () {
		eventRaiser.eventData.event = "close-deal-selected";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Method = "selected";
		eventRaiser.raiseEvent();
	};

	self["close-deal"] = function (options) {
		eventRaiser.eventData.event = "close-deal";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Method = "deal";
		eventRaiser.eventData.Chart = options.chart;
		eventRaiser.raiseEvent();
	};

	self["close-deal-success"] = function () {
		eventRaiser.eventData.event = "close-deal-success";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.Method = "deal";
		eventRaiser.raiseEvent();
	};

	self["switch-tab"] = function (options) {
		eventRaiser.eventData.event = "switch-tab";
		eventRaiser.eventData.CurrentView = options.viewId;
		eventRaiser.eventData.TabName = options.presetName;

		if (options.hasOwnProperty("hierarchy")) {
			eventRaiser.eventData.Hierarchy = options.hierarchy;
		}

		eventRaiser.raiseEvent();
	};

	self["deal-slip-error"] = function (options) {
		eventRaiser.eventData.event = "deal-slip-error";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Referrer = options.referrer;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Limit = options.Limit;
		eventRaiser.eventData.Tools = options.Tools;
		eventRaiser.eventData.Type = options.type;
		eventRaiser.eventData.Reason = options.reason;
		eventRaiser.eventData.NewDeal = eNewDealValue.Popup;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;

		eventRaiser.raiseEvent();
	};

	self["new-limit-error"] = function (options) {
		eventRaiser.eventData.event = "new-limit-error";

		eventRaiser.eventData.Version = options.version;
		eventRaiser.eventData.Type = options.type;
		eventRaiser.eventData.Reason = options.reason;
		eventRaiser.eventData.ElapsedTime = options.ElapsedTime;
		eventRaiser.eventData.SlipExpandedInfoAreas = options.SlipExpandedInfoAreas;
		eventRaiser.raiseEvent();
	};

	self["deposit-submit"] = function () {
		eventRaiser.eventData.event = "deposit-submit";
		eventRaiser.eventData.DepositType = window.tradingEventsHandler.data.depositType;
		eventRaiser.raiseEvent();
	};

	self["deposit-success"] = function () {
		eventRaiser.eventData.event = "deposit-success";
		eventRaiser.eventData.DepositType = window.tradingEventsHandler.data.depositType;
		eventRaiser.raiseEvent();
	};

	self["deposit-error"] = function (options) {
		eventRaiser.eventData.event = "deposit-error";
		eventRaiser.eventData.Type = options.type;
		eventRaiser.eventData.DepositType = window.tradingEventsHandler.data.depositType;

		if (options.hasOwnProperty("errorMessage")) {
			eventRaiser.eventData.ErrorMessage = encodeURI(options.errorMessage);
		}

		if (options.hasOwnProperty("errorMessageKey")) {
			eventRaiser.eventData.ErrorMessageKey = encodeURI(options.errorMessageKey);
		}

		eventRaiser.raiseEvent();
	};

	self["withdrawal-error"] = function (options) {
		eventRaiser.eventData.event = "withdrawal-error";
		eventRaiser.eventData.Reason = options.reason;
		eventRaiser.raiseEvent();
	};

	self["message-view"] = function (messageDetails) {
		eventRaiser.eventData.event = "message-view";
		eventRaiser.eventData.Text = messageDetails.text;
		eventRaiser.eventData.Type = messageDetails.type;
		eventRaiser.raiseEvent();
	};

	self["sb-view-offer-clicked"] = function (messageDetails) {
		eventRaiser.eventData.event = "sb-view-offer-clicked";
		eventRaiser.eventData.Text = messageDetails.text;
		eventRaiser.eventData.Type = messageDetails.type;
		eventRaiser.raiseEvent();
	};

	self["sb-deposit-clicked"] = function (messageDetails) {
		eventRaiser.eventData.event = "sb-deposit-clicked";
		eventRaiser.eventData.Text = messageDetails.text;
		eventRaiser.raiseEvent();
	};

	self["reward-cta-clicked"] = function (messageDetails) {
		eventRaiser.eventData.event = "reward-cta-clicked";
		eventRaiser.raiseEvent();
	};

	self["instrument-show-more"] = function (options) {
		eventRaiser.eventData.event = "instrument-show-more";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Hierarchy = options.tabHierarchy;
		eventRaiser.raiseEvent();
	};

	self["instrument-show-less"] = function (options) {
		eventRaiser.eventData.event = "instrument-show-less";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;
		eventRaiser.eventData.TabName = options.TabName;
		eventRaiser.eventData.Hierarchy = options.tabHierarchy;
		eventRaiser.raiseEvent();
	};

	self["show-sunday-banner-main"] = function (bannerDetails) {
		eventRaiser.eventData.event = "show-sunday-banner-main";
		eventRaiser.eventData.Element = bannerDetails.Element;
		eventRaiser.raiseEvent();
	};

	self["click-sunday-banner-button-main"] = function (bannerDetails) {
		eventRaiser.eventData.event = "click-sunday-banner-button-main";
		eventRaiser.eventData.Element = bannerDetails.Element;
		eventRaiser.raiseEvent();
	};

	self["search"] = function (eventData) {
		eventRaiser.eventData.event = "search";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;

		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.raiseEvent();
	};

	self["search-interaction"] = function (eventData) {
		eventRaiser.eventData.event = "search-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;

		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.raiseEvent();
	};

	self["deal-slip-search"] = function (eventData) {
		eventRaiser.eventData.event = "deal-slip-search";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;

		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.raiseEvent();
	};

	self["deal-slip-search-interaction"] = function (eventData) {
		eventRaiser.eventData.event = "deal-slip-search-interaction";
		eventRaiser.eventData.CurrentView = window.tradingEventsHandler.data.viewId;

		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.raiseEvent();
	};

	self["tutorial-events"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.ViewID = window.tradingEventsHandler.data.viewId;
		eventRaiser.raiseEvent();
	};

	self["signals-menu-click"] = function () {
		eventRaiser.eventData.event = "signals-menu-click";
		eventRaiser.raiseEvent();
	};

	self["signals-drill-down"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "signals-drill-down";
		eventRaiser.raiseEvent();
	};

	self["signals-view-more"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "signals-view-more";
		eventRaiser.raiseEvent();
	};

	self["signals-detail-new-deal"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "signals-detail-new-deal";
		eventRaiser.raiseEvent();
	};

	self["short-term-signal-chart"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "short-term-signal-chart";
		eventRaiser.raiseEvent();
	};

	self["economic-calendar-menu-click"] = function () {
		eventRaiser.eventData.event = "economic-calendar-menu-click";
		eventRaiser.raiseEvent();
	};

	self["questionnaire-navigation"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "questionnaire-navigation";
		eventRaiser.raiseEvent();
	};

	self["questionnaire-question"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "questionnaire-question";
		eventRaiser.raiseEvent();
	};

	self["questionnaire-start"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "questionnaire-start";
		eventRaiser.raiseEvent();
	};

	self["questionnaire-quiz-start"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "questionnaire-quiz-start";
		eventRaiser.raiseEvent();
	};

	self["questionnaire-faq"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "questionnaire-faq";
		eventRaiser.raiseEvent();
	};

	self["deposit-faq"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "deposit-faq";
		eventRaiser.raiseEvent();
	};

	self["upload-documents-faq"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "upload-documents-faq";
		eventRaiser.raiseEvent();
	};

	self["support-interaction"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "support-interaction";
		eventRaiser.raiseEvent();
	};

	self["deal-slip-chart-interaction"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.event = "deal-slip-chart-interaction";

		eventRaiser.raiseEvent();
	};

	self["chart-interaction"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "chart-interaction";

		eventRaiser.raiseEvent();
	};

	self["favorite-instruments-add"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "favorite-instruments-add";

		eventRaiser.raiseEvent();
	};

	self["favorite-instruments-remove"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "favorite-instruments-remove";

		eventRaiser.raiseEvent();
	};

	self["favorite-instruments-reorder"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "favorite-instruments-reorder";

		eventRaiser.raiseEvent();
	};

	self["view-sentiments"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "view-sentiments";
		eventRaiser.raiseEvent();
	};

	self["closed-deals-events"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData.data);

		eventRaiser.eventData.event = eventData.event + "-closed-deals";
		eventRaiser.raiseEvent();
	};

	self["notifications-settings-change"] = function (eventData) {
		eventRaiser.eventData.Element = eventData;

		eventRaiser.eventData.event = "notifications-settings-change";
		eventRaiser.raiseEvent();
	};

	self["chart-performance"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.chartInitDuration =
			PerformanceDataCollector.Timestamps[eFxNetEvents.ChartInitComplete] -
			PerformanceDataCollector.Timestamps[eFxNetEvents.ChartInit];
		eventRaiser.eventData.chartGeselftoryDuration =
			PerformanceDataCollector.Timestamps[eFxNetEvents.ChartGeselftoryResponse] -
			PerformanceDataCollector.Timestamps[eFxNetEvents.ChartGeselftoryRequest];
		eventRaiser.eventData.chartStartDuration =
			PerformanceDataCollector.Timestamps[eFxNetEvents.ChartStartComplete] -
			PerformanceDataCollector.Timestamps[eFxNetEvents.ChartStart];

		eventRaiser.raiseEvent();
	};

	self["tools-chart"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "tools-chart-" + eventRaiser.eventData.event;

		eventRaiser.raiseEvent();
	};

	self["start-callback-request-chat"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "start-callback-request-chat";

		eventRaiser.raiseEvent();
	};

	self["hub-menu-close"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "hub-menu-close";

		eventRaiser.raiseEvent();
	};

	self["hub-menu-open"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "hub-menu-open";

		eventRaiser.raiseEvent();
	};

	self["hub-map-expand"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);

		eventRaiser.eventData.event = "hub-map-expand";

		eventRaiser.raiseEvent();
	};

	self["hub-map-collapse"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.event = "hub-map-collapse";
		eventRaiser.raiseEvent();
	};

	self["price-alerts-menu-view"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.event = "price-alerts-menu-view";
		eventRaiser.raiseEvent();
	};

	self["price-alert-create"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.event = "price-alert-create";
		eventRaiser.raiseEvent();
	};

	self["price-alert-error"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.event = "price-alert-error";
		eventRaiser.raiseEvent();
	};

	self["deal-slip-change-highlow-term"] = function (eventData) {
		eventRaiser.eventData.Element = eventData;
		eventRaiser.eventData.event = "deal-slip-change-highlow-term";
		eventRaiser.raiseEvent();
	};

	self["help-center"] = function (eventData) {
		if (eventData.element) {
			eventRaiser.eventData.element = eventData.element;
		}

		if (eventData.tab) {
			eventRaiser.eventData.tab = eventData.tab;
		}

		eventRaiser.eventData.event = "help-center-" + eventData.event;
		eventRaiser.raiseEvent();
	};

	self["economic-calendar-trade-cta"] = function (eventData) {
		Object.assign(eventRaiser.eventData, eventData);
		eventRaiser.eventData.event = "economic-calendar-trade-cta";
		eventRaiser.raiseEvent();
	};

	var registerEvents = function (eEvents) {
		Object.keys(eEvents).forEach(function (eKey) {
			var eName = eEvents[eKey];

			self[eName] = function (eventData) {
				if (eventData) {
					Object.assign(eventRaiser.eventData, eventData);
				}

				eventRaiser.eventData.event = eName;
				eventRaiser.eventData.SlipExpandedInfoAreas = eventData.SlipExpandedInfoAreas;
				eventRaiser.raiseEvent();
			};
		});
	};

	registerEvents(eMarketInfoEvents);

	return self;
});

function TrackingEventsCollector(ko, eventsCollection, externalPages) {
    var uiLoaded = false, scmmDataLoaded = false,
        customerDataLoaded = false, eventsQueue = [], trackingGlobalData = {};;

    function init(trackingData, evCollection) {
        trackingGlobalData = trackingData;
        eventsCollection = evCollection || eventsCollection;

        if (externalPages) {
            uiLoaded = true;
            scmmDataLoaded = true;
            customerDataLoaded = true;

            // desktop specific elimination :
            if (!window.environmentData || !window.environmentData.isDesktop) {
                window.externalEventsCallbacks.add(consumeEvent);
            }
        }
        else {
            ko.postbox.subscribe('trading-event', consumeEvent);
            ko.postbox.subscribe('ui-loaded', onUiFinishedLoading);
            ko.postbox.subscribe('scmm-data-loaded', onScmmDataLoaded);
            ko.postbox.subscribe('customer-data-loaded', onCustomerDataLoaded);
        }
    }

    function onUiFinishedLoading() {
        uiLoaded = true;

        if (eventsResourcesLoaded()) {
            executeAllQueuedEvents();
        }

        consumeEvent("exposeUI");
    }

    function onScmmDataLoaded() {
        scmmDataLoaded = true;

        if (eventsResourcesLoaded()) {
            executeAllQueuedEvents();
        }
    }

    function onCustomerDataLoaded() {
        customerDataLoaded = true;

        if (eventsResourcesLoaded()) {
            executeAllQueuedEvents();
        }
    }

    function executeAllQueuedEvents() {
        while( eventsQueue.length > 0){
            var element = eventsQueue.shift();
            consumeEvent(element.eventName, element.additionalData);

        }
        
    }

    function consumeEvent(eventName, additionalData) {
        if (!eventsResourcesLoaded()) { // push events to queue if resources for the events did not load yet
            eventsQueue.push({ eventName: eventName, additionalData: additionalData });
            return;
        }

        addGlobalPropertiesToCurrentEvent();

        //on smart client tracking
        if (window.environmentData && window.environmentData.isDesktop) {
            Object.assign(eventsCollection.getCurrentEventData(), additionalData);
            eventsCollection.raiseEvent(eventName);
            return;
        }

        eventsCollection[eventName](additionalData);
    }

    function eventsResourcesLoaded() {
        return uiLoaded && scmmDataLoaded && customerDataLoaded;
    }

    function addGlobalPropertiesToCurrentEvent() {
        Object.assign(eventsCollection.getCurrentEventData(), trackingGlobalData.getProperties());
    }

    return {
        init: init,
        consumeEvent: consumeEvent
    };
};
define("tracking/EventsCollector", ["knockout","trackingIntExt/TrackingEvents"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko, te) {
				var trackingEventsCollector = this.TrackingEventsCollector(ko, te, false);
				return trackingEventsCollector;
			};
        ret = fn.apply(global, arguments);
        return ret || global.TrackingEventsCollector;
    };
}(this)));

var TrackingCommonData = function () {
	return function (storage) {
		var _sessionStorage = storage;

		function getCountryNameByIp() {
			if (typeof systemInfo !== "undefined") return systemInfo.countryNameByIP;
			if (window.Model !== "undefined") return window.Model.CountryNameByIP;

			return "";
		}

		function getBrowserPropertyValue() {
			if (window.CookieHandler) {
				if (
					window.CookieHandler.ReadCookie("NativeIosApp") !== null &&
					window.CookieHandler.ReadCookie("NativeIosApp") === "true"
				) {
					return "App iPhone";
				}

				if (
					window.CookieHandler.ReadCookie("NativeAndroidApp") != null &&
					window.CookieHandler.ReadCookie("NativeAndroidApp") === "true"
				) {
					return "App Android";
				}
			}

			return Browser.getBrowserName();
		}

		function getDevice() {
			return window.environmentData && window.environmentData.isDesktop
				? "Desktop"
				: CookieHandler.ReadCookie("ViewMode");
		}

		function renewTrackingSessionId() {
			var newTrackingSessionId = Math.random();
			_sessionStorage.setItem("TrackingSessionId", newTrackingSessionId.toString());
		}

		function getTrackingSessionId() {
			if (_sessionStorage.getItem("TrackingSessionId") == null) {
				renewTrackingSessionId();
			}

			return _sessionStorage.getItem("TrackingSessionId");
		}

		return {
			IPCountry: getCountryNameByIp(),
			ResolutionScreen: Browser.getScreenResolution(),
			OS: Browser.getOperatingSystemName(),
			OSVersion: Browser.getOperatingSystemNameAndVersion(),
			Browser: getBrowserPropertyValue(),
			BrowserVersion: Browser.getBrowserVersion(),
			Device: getDevice(),
			TrackingSessionId: getTrackingSessionId(),
			Language: CookieHandler.ReadCookie("Language"),
		};
	};
};

(function (root, factory) {
	if (typeof define === "function" && define.amd) {
		// AMD. Register as an anonymous module.
		define('tracking/TrackingCommonData',[], factory);
	} else {
		// Browser globals
		root = factory();
	}
})(typeof self !== "undefined" ? self : this, function () {
	// Use b in some fashion.

	// Just return a value to define the module export.
	// This example returns an object, but the module
	// can return a function as the exported value.
	return TrackingCommonData();
});

var Browser = (function () {
    var inScopeWindowObject = window;
    var iosDevices;

    var getiosDevices = function () {
        if (General.isNullOrUndefined(iosDevices)) {
            iosDevices = {
                older: {
                    iphSeSimilar: inScopeWindowObject.screen.width === 320 && inScopeWindowObject.screen.height === 568 &&
                        inScopeWindowObject.devicePixelRatio === 2
                },
                notch: {
                    iphXSimilar: inScopeWindowObject.screen.width === 375 && inScopeWindowObject.screen.height === 812 &&
                        inScopeWindowObject.devicePixelRatio === 3,
                    iphXr: inScopeWindowObject.screen.width === 414 && inScopeWindowObject.screen.height === 896 &&
                        inScopeWindowObject.devicePixelRatio === 2,
                    iphXsMax: inScopeWindowObject.screen.width === 414 && inScopeWindowObject.screen.height === 896 &&
                        inScopeWindowObject.devicePixelRatio === 3
                }
            };
        }
        return iosDevices;
    };

    var isIosnotchDevice = function () {
        var iosDevices = getiosDevices();
        return (iosDevices.notch.iphXSimilar ||
            iosDevices.notch.iphXr || iosDevices.notch.iphXsMax);
    };

    var forceRepaintIosRotate = function () {
        var styleTimeout, el = document.getElementById('main');
        if (el && isIosnotchDevice()) {
            if (typeof styleTimeout !== "undefined") {
                clearTimeout(styleTimeout);
            }
            el.style.border = '1px solid transparent';
            styleTimeout = setTimeout(function () {
                el.style.border = '';
            }, 200);
        }
    };

    var isIEVersionGreaterThen = function (versionNumber) {

        if (isSpartan()) return true;

        // for test of IE lower than Spartan
        return Number(getBrowserVersion()) > Number(versionNumber);
    };

    var isDefinePropertySupported = function () {
        return typeof Object.defineProperty == 'function' &&
            (!Browser.isInternetExplorer() || Browser.isIEVersionGreaterThen(8));
    };

    var isInternetExplorer = function (excludeEdge /*default false*/) {
        var ua = inScopeWindowObject.navigator.userAgent;

        var msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }

        var trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            var rv = ua.indexOf('rv:');
            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }

        if (excludeEdge) {
            return false;
        }

        return isEdge();
    };

    var isEdge = function () {
        var ua = inScopeWindowObject.navigator.userAgent;

        var edge = ua.indexOf('Edge/');

        if (edge > 0) {
            // IE 12 => return version number
            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }

        // other browser
        return false;
    };

    var isSpartan = function () {
        //Win10 IE browser Spartan introduced numeration like Chrome

        var version = (getBrowserVersion().split('.').length > 2) ? getBrowserVersion().split('.')[0] : getBrowserVersion();
        return Browser.isInternetExplorer() && Number(version) > 40;
    };

    var isOpera = function () {
        return !!inScopeWindowObject.opera || inScopeWindowObject.navigator.userAgent.indexOf(' OPR/') >= 0;
    };

    var isSafari = function () {
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    };

    var getBrowserData = function () {
        var userAgent = inScopeWindowObject.navigator.userAgent,
            match = userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [],
            tempMatch;

        if (/trident/i.test(match[1])) {
            tempMatch = /\brv[ :]+(\d+)/g.exec(userAgent) || [];

            return {
                name: 'IE ',
                version: (tempMatch[1] || '')
            };
        }

        if (match[1] === 'Chrome') {
            tempMatch = userAgent.match(/\b(OPR|Edge)\/(\d+)/);

            if (tempMatch != null) {
                return {
                    name: tempMatch.slice(1)[0].replace('OPR', 'Opera'),
                    version: tempMatch.slice(1)[1]
                };
            }
        }

        match = match[2] ? [match[1], match[2]] : [navigator.appName, navigator.appVersion, '-?'];

        if ((tempMatch = userAgent.match(/version\/(\d+)/i)) != null) {
            match.splice(1, 1, tempMatch[1]);
        }

        return {
            name: match[0],
            version: match[1]
        };
    }

    var getBrowserName = function () {
        var browserName = getBrowserData().name;
        if (isEdge()) return 'Edge';
        if (isInternetExplorer(true)) return 'Internet Explorer';
        if (isOpera()) return 'Opera';
        if (isSafari()) return 'Safari';
        if (browserName === 'Chrome') return 'Chrome';
        if (browserName === 'Mozilla') return 'Mozilla';

        return inScopeWindowObject.navigator.userAgent;
    };

    var getBrowserVersion = function () {
        return getBrowserData().version;
    };

    var getOperatingSystemName = function () {
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows") != -1) return "Windows";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Mac") != -1) return "Mac/iOS";
        if (inScopeWindowObject.navigator.userAgent.indexOf("X11") != -1) return "UNIX";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Linux") != -1) return "Linux";

        return inScopeWindowObject.navigator.userAgent;
    };

    var isChromeOnIOS = function () {
        return navigator.userAgent.indexOf('CriOS') !== -1;
    };

    var isMacOs = function () {
        return navigator.userAgent.indexOf('Mac OS') !== -1;
    };

    var isSafariOnMacIOS = function () {
        return isMacOs() && isSafari();
    };

    var isChrome = function () {
        return navigator.userAgent.indexOf('Chrome') !== -1 && navigator.userAgent.indexOf('Edge') === -1;
    };

    var isChromium = function () {
        return !General.isNullOrUndefined(window.chrome);
    };

    var isAndroidApp = function () {
        var cookie = window.CookieHandler.ReadCookie('NativeAndroidApp');
        return cookie !== null && cookie === 'true';
    };

    var isIosApp = function () {
        var cookie = window.CookieHandler.ReadCookie('NativeIosApp');
        return cookie !== null && cookie === 'true';
    };

    var getOperatingSystemNameAndVersion = function () {
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows NT 10.0") != -1) return "Windows 10";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows NT 6.2") != -1) return "Windows 8";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows NT 6.1") != -1) return "Windows 7";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows NT 6.0") != -1) return "Windows Vista";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows NT 5.1") != -1) return "Windows XP";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Windows NT 5.0") != -1) return "Windows 2000";
        if ((inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10_5") != -1) ||
            (inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10.5") != -1)) return "Mac 10.5";
        if ((inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10_6") != -1) ||
            (inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10.6") != -1)) return "Mac 10.6";
        if ((inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10_7") != -1) ||
            (inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10.7") != -1)) return "Mac 10.7";
        if ((inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10_8") != -1) ||
            (inScopeWindowObject.navigator.userAgent.indexOf("Mac OS X 10.8") != -1)) return "Mac 10.8";
        if (inScopeWindowObject.navigator.userAgent.indexOf("X11") != -1) return "UNIX";
        if (inScopeWindowObject.navigator.userAgent.indexOf("Linux") != -1) return "Linux";

        return inScopeWindowObject.navigator.userAgent;
    };

    var getScreenResolution = function () {
        return inScopeWindowObject.screen.width + 'x' + inScopeWindowObject.screen.height;
    };

    var getLargestResolutionDimension = function () {
        return Math.max(inScopeWindowObject.screen.width, inScopeWindowObject.screen.height);
    };

    var detectPassiveEventListenersSupport = function () {
        try {
            var options = Object.defineProperty({}, "passive", {
                get: function () {
                    passiveSupported = true;
                }
            });

            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
        } catch (err) {
            return false;
        }

        return true;
    };

    var passiveSupported = detectPassiveEventListenersSupport();

    var isPassiveEventListenersSupported = function () {
        return passiveSupported;
    };

    /**
    * https://stackoverflow.com/questions/21741841/detecting-ios-android-operating-system
    * Determine the mobile operating system.
    * This function returns one of 'iOS', 'Android', 'Windows Phone', or 'unknown'.
    *
    * @returns {String}
    */
    var getMobileOperatingSystem = function () {
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;

        // Windows Phone must come first because its UA also contains "Android"
        if (/windows phone/i.test(userAgent)) {
            return "Windows Phone";
        }

        if (/android/i.test(userAgent)) {
            return "Android";
        }

        // iOS detection from: http://stackoverflow.com/a/9039885/177710
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            return "iOS";
        }

        return "unknown";
    }

    var isIeEdgePrivateMode = function () {
        //IE or Edge don't have window.indexedDB
        //window.MSPointerEvent is undefined in Edge

        return (!window.indexedDB && (window.PointerEvent || window.MSPointerEvent));
    }

    var isSafariMobile = function () {
        return navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/);
    }

    function getBrowserDetails() {
        return {
            screenColorDept: screen.colorDepth,
            screenHeight: screen.height,
            screenWidth: screen.width,
            screenResolution: screen.pixelDepth,
            javaEnabled: navigator.javaEnabled(),
            javaScriptEnabled: true,
            language: navigator.language,
            timeZoneOffset: new Date().getTimezoneOffset(),
            userAgent: navigator.userAgent.substr(0, 2048)
        };
    }

    function getAllBrowserInfo() {
        'use strict';

        var module = {
            options: [],
            header: [navigator.platform, navigator.userAgent, navigator.appVersion, navigator.vendor, window.opera],
            dataos: [
                { name: 'Windows Phone', value: 'Windows Phone', version: 'OS' },
                { name: 'Windows', value: 'Win', version: 'NT' },
                { name: 'iPhone', value: 'iPhone', version: 'OS' },
                { name: 'iPad', value: 'iPad', version: 'OS' },
                { name: 'Kindle', value: 'Silk', version: 'Silk' },
                { name: 'Android', value: 'Android', version: 'Android' },
                { name: 'PlayBook', value: 'PlayBook', version: 'OS' },
                { name: 'BlackBerry', value: 'BlackBerry', version: '/' },
                { name: 'Macintosh', value: 'Mac', version: 'OS X' },
                { name: 'Linux', value: 'Linux', version: 'rv' },
                { name: 'Palm', value: 'Palm', version: 'PalmOS' }
            ],
            databrowser: [
                { name: 'Chrome', value: 'Chrome', version: 'Chrome' },
                { name: 'Firefox', value: 'Firefox', version: 'Firefox' },
                { name: 'Safari', value: 'Safari', version: 'Version' },
                { name: 'Internet Explorer', value: 'MSIE', version: 'MSIE' },
                { name: 'Opera', value: 'Opera', version: 'Opera' },
                { name: 'BlackBerry', value: 'CLDC', version: 'CLDC' },
                { name: 'Mozilla', value: 'Mozilla', version: 'Mozilla' }
            ],
            init: function () {
                var agent = this.header.join(' '),
                    os = this.matchItem(agent, this.dataos),
                    browser = this.matchItem(agent, this.databrowser);

                return { os: os, browser: browser };
            },
            matchItem: function (string, data) {
                var i = 0,
                    j = 0,
                    html = '',
                    regex,
                    regexv,
                    match,
                    matches,
                    version;

                for (i = 0; i < data.length; i += 1) {
                    regex = new RegExp(data[i].value, 'i');
                    match = regex.test(string);
                    if (match) {
                        regexv = new RegExp(data[i].version + '[- /:;]([\\d._]+)', 'i');
                        matches = string.match(regexv);
                        version = '';
                        if (matches) { if (matches[1]) { matches = matches[1]; } }
                        if (matches) {
                            matches = matches.split(/[._]+/);
                            for (j = 0; j < matches.length; j += 1) {
                                if (j === 0) {
                                    version += matches[j] + '.';
                                } else {
                                    version += matches[j];
                                }
                            }
                        } else {
                            version = '0';
                        }
                        return {
                            name: data[i].name,
                            version: parseFloat(version)
                        };
                    }
                }
                return { name: 'unknown', version: 0 };
            }
        };

        return module.init();
    }

    return {
        getMobileOperatingSystem: getMobileOperatingSystem,
        isPassiveEventListenersSupported: isPassiveEventListenersSupported,
        isInternetExplorer: isInternetExplorer,
        isEdge: isEdge,
        isIEVersionGreaterThen: isIEVersionGreaterThen,
        isDefinePropertySupported: isDefinePropertySupported,
        getBrowserName: getBrowserName,
        getBrowserVersion: getBrowserVersion,
        getOperatingSystemName: getOperatingSystemName,
        getOperatingSystemNameAndVersion: getOperatingSystemNameAndVersion,
        getScreenResolution: getScreenResolution,
        getLargestResolutionDimension: getLargestResolutionDimension,
        isChromeOnIOS: isChromeOnIOS,
        isMacOs: isMacOs,
        isSafariOnMacIOS: isSafariOnMacIOS,
        isChrome: isChrome,
        isChromium: isChromium,
        isAndroidApp: isAndroidApp,
        isIosApp: isIosApp,
        replaceWindowWith: function (newWindow) { inScopeWindowObject = newWindow; },
        isIeEdgePrivateMode: isIeEdgePrivateMode,
        isSafariMobile: isSafariMobile,
        getiosDevices: getiosDevices,
        forceRepaintIosRotate: forceRepaintIosRotate,
        getBrowserDetails: getBrowserDetails,
        FullBrowserInfo: getAllBrowserInfo()
    };
})();
define("global/browser", function(){});


/*global IMContainer:true*/
/*eslint no-undef: 2*/
var _JSON2 = JSON;
/*	
jQuery pub/sub plugin by Peter Higgins (dante@dojotoolkit.org)
Loosely based on Dojo publish/subscribe API, limited in scope. Rewritten blindly.
Original is (c) Dojo Foundation 2004-2010. Released under either AFL or new BSD, see:
http://dojofoundation.org/license for more information.
*/
function apiIM($) {

    // the topic/subscription hash
    var cache = {};

    $.publish = function (/* String */topic, /* Array? */args) {
        // summary: 
        //		Publish some data on a named topic.
        // topic: String
        //		The channel to publish on
        // args: Array?
        //		The data to publish. Each array item is converted into an ordered
        //		arguments on the subscribed functions. 
        //
        // example:
        //		Publish stuff on '/some/topic'. Anything subscribed will be called
        //		with a function signature like: function(a,b,c){ ... }
        //
        //	|		$.publish("/some/topic", ["a","b","c"]);
        cache[topic] && $.each(cache[topic], function () {
            try {
                this.apply($, args || []);
            } catch (e) {

            }
        });
    };

    $.subscribe = function (/* String */topic, /* Function */callback) {
        // summary:
        //		Register a callback on a named topic.
        // topic: String
        //		The channel to subscribe to
        // callback: Function
        //		The handler event. Anytime something is $.publish'ed on a 
        //		subscribed channel, the callback will be called with the
        //		published array as ordered arguments.
        //
        // returns: Array
        //		A handle which can be used to unsubscribe this particular subscription.
        //	
        // example:
        //	|	$.subscribe("/some/topic", function(a, b, c){ /* handle data */ });
        //
        if (!cache[topic]) {
            cache[topic] = [];
        }
        cache[topic].push(callback);
        return [topic, callback]; // Array
    };

    $.unsubscribe = function (/* Array */handle) {
        // summary:
        //		Disconnect a subscribed function for a topic.
        // handle: Array
        //		The return value from a $.subscribe call.
        // example:
        //	|	var handle = $.subscribe("/something", function(){});
        //	|	$.unsubscribe(handle);

        var t = handle[0];
        cache[t] && $.each(cache[t], function (idx) {
            if (this == handle[1]) {
                cache[t].splice(idx, 1);
            }
        });
    };
    function InitAll(tokenIM, serviceBase, langId, requestInterval, uiActionCallbacks, requestIntervalMode, isAnnoncement, smartBannerCallback) {
        $(document).ready(function () {
            var im = new IMdataService();
            var imLS = new IMlayoutService();

            ConfigureIMDataAndLayoutServices(im, imLS, uiActionCallbacks, isAnnoncement, smartBannerCallback);

            im.init(tokenIM, serviceBase, langId, requestInterval, requestIntervalMode, isAnnoncement);
        });
    }

    function InitAllFallback(tokenIMUrl, serviceBase, langId, requestInterval, uiActionCallbacks, requestIntervalMode, isAnnoncement, smartBannerCallback) {
        $(document).ready(function () {
            var im = new IMdataService();
            var imLS = new IMlayoutService();

            ConfigureIMDataAndLayoutServices(im, imLS, uiActionCallbacks, isAnnoncement, smartBannerCallback);

            var updateCurrentToken = function (currentToken) {
                im.init(currentToken, serviceBase, langId, requestInterval, requestIntervalMode, isAnnoncement);
            };
            im.getTokenIM(tokenIMUrl, updateCurrentToken);
        });
    }

    function ConfigureIMDataAndLayoutServices(im, imLS, uiActionCallbacks, isAnnouncement, smartBannerCallback) {
        im.onErrorIM_Event(onErrorIM);
        im.PopupCssClass.OverlayClass = 'bg_shadow'; //from the CSS file of content
        im.PopupCssClass.PopupClass = 'popupContainer';
        im.PopupCssClass.CloseClass = 'closePopUP';
        if (isAnnouncement == "false") {
            im.onReportIMAction_Event();
            im.onReportIMStatus_Event();
        }

        imLS.init(im);
        imLS.onCompleteShowIM_Subscribe();
        imLS.onPopupClose_Subscribe();
        if (isAnnouncement == "false") {
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.Deposit, uiActionCallbacks.deposit);
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.Accept, uiActionCallbacks.accept);
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.WalkThroughDeal, uiActionCallbacks.walkthrough);
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.PrivacyPolicy, uiActionCallbacks.privacypolicy);
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.imClosedDeals, uiActionCallbacks.imClosedDeals);
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.imOpenDeals, uiActionCallbacks.imOpenDeals);
            imLS.onIMUIAction_Subscribe(imLS.IMUIActionType.imNewDeal, uiActionCallbacks.imNewDeal);
        }
        imLS.onSmartBanner_Subscribe(smartBannerCallback);
    }

    // functions for callback
    var onErrorIM = function (topics, data) {
    };


    $.fn.center = function () {
        this.css("position", "absolute");
        this.css("top", ($(window).height() - this.height()) / 2 + $(window).scrollTop() + "px");
        this.css("left", ($(window).width() - this.width()) / 2 + $(window).scrollLeft() + "px");
        return this;
    };

    $.fn.outerHTML = function (s) {
        return s ? this.before(s).remove() : $("<p>").append(this.eq(0).clone()).html();
    };

    return {
        InitAll: InitAll,
        InitAllFallback: InitAllFallback
    }

};


function removeByValue(arr, property, val) {
    if (arr != null) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i][property] == val) {
                arr.splice(i, 1);
            }
        }
    }
    return arr;
}

//-------------------------------------------------------
// AttachEvent
//-------------------------------------------------------
// uglify mangle throw error.
window.IMContainer = {
    currentActiveProposition: null
};

var IMdataService = function () {
    var Token = null;
    var TokenUrl = null;
    var ServiceBase = null;
    var RetryInterval = 1000;
    var LanguageId = null;
    var Req = null;
    var self = this;
    var Current = 0;
    var ItemsCount = 0; // total number of items
    var MaxRetries = 60;
    var CurrentRetry = 0;
    var RequestInterval = 15000;
    var RequestIntervalMode = 1; // 0 Logon, 1 Ongoing
    var Interval = 0;
    var IsAnnoncement = false;
    var CurrentRowVersion = null;
    var currentActiveProposition = null;
    var CustomerTrackingDetailsRetries = 5;

    var PopupCssClass = {
        // CSS Classes
        PopupClass: 'popupContainer',
        CloseClass: 'closePopUP',
        OverlayClass: 'bg_shadow',
        EnvelopePopupClass: '.new-msg-action',
        EnvelopePopupClassMobile: '.envelope a',
        SmartBannerWideClass: 'smartBannerWide',
        SmartBannerSmallClass: 'smartBannerSmall',
        smartBannerWideViewOfferClass: 'details',
        smartBannerSmallViewOfferClass: 'smartBannerSmall'
    };

    var Events = {
        onCompleteGetActiveIM: 'onCompleteGetActiveIM',
        onCompleteShowIM: 'onCompleteShowIM',
        onErrorIM: 'onErrorIM',
        onPopupClose_Event: 'onPopupClose',
        onReportIMAction: 'onReportIMAction',
        onReportIMStatus: 'onReportIMStatus',
        onSmartBanner: 'onSmartBanner',
        stopGetActiveIMCalls: 'onStopGetActiveIMCalls',
        restartGetActiveIMCalls: 'onRestartGetActiveIMCalls'
    };

    var init = function (token, serviceBase, languageId, requestInterval, requestIntervalMode, isAnnoncement) {
        ServiceBase = serviceBase;
        LanguageId = languageId;
        RequestInterval = requestInterval;
        RequestIntervalMode = requestIntervalMode;
        IsAnnoncement = isAnnoncement;

        IMclearInterval(Interval);
        Token = token;

        var isValidToken = false;
        var pat = /^[a-z0-9]+$/i; // alpha-numeric

        if (Token != null) {
            isValidToken = pat.test(Token);
        }

        if (isValidToken == true) {
            getActiveIM(Token, serviceBase, isAnnoncement);
        }

        if (typeof define !== "function" || !define.amd) {
            return;
        }

        require(["StateObject!SystemNotificationEvents"], function setupStateObjectSubscribers(stateObject) {
            stateObject.set(Events.stopGetActiveIMCalls, null);
            stateObject.set(Events.restartGetActiveIMCalls, null);

            stateObject.subscribe(Events.stopGetActiveIMCalls, function () {
                IMclearInterval(Interval);
            });

            stateObject.subscribe(Events.restartGetActiveIMCalls, function () {
                init(token, serviceBase, languageId, requestInterval, requestIntervalMode, isAnnoncement);
            });
        });
    };

    var proceedNextMessage = function () {
        if (Current + 1 < ItemsCount) { // if there are additional messages show next
            ++Current;
            handleActiveIM();
        } else {
            RequestIntervalMode = 1;
            if (Interval != 0) {
                clearInterval(Interval);
            }
            Interval = setInterval(function () {
                getActiveIM(Token, ServiceBase, IsAnnoncement);
            }, RequestInterval);
        }
    };

    var IMclearInterval = function (interval) {
        clearInterval(interval);
    };


    var getTokenIM = function getTokenIM(tokenUrl, callback) {
        $.ajax({
            url: tokenUrl,
            type: 'POST',
            async: true,
            success: callback
        });
    };

    //  Not Explorer or explorer 10 
    var getDataCORS = function (varUrl, varMethod, varData, onComplete) {

        var version = getInternetExplorerVersion();
        // IE8/9 can do cross domain with XDR (we have a different WCF endpoint and method)

        var methodUrl = varUrl + "/" + varMethod;

        var maxRetries = (varMethod == "CustomerTrackingDetailsGet") ? CustomerTrackingDetailsRetries : null;

        // If from winforms browser control window.external has a value
        if (version == -1 || version >= 10) {
            getDataIE10(methodUrl, varData, onComplete, maxRetries);
        } else if (version >= 8) {
            // IE8/9 can do cross domain with XDR (we have a different WCF endpoint and method)
            methodUrl = varUrl + "/xdr/" + varMethod + "XDR";
            getDataIE8(methodUrl, varData, onComplete, maxRetries);
        } else {
            //alert("No support for IE7");
            // if not, IE7 and lower can't do cross domain
            if (window.external) {
                getDataIE8(methodUrl, varData, onComplete, maxRetries);
            } else {
                //alert("No support for IE7");
            }
        }
    }

    // Regular Chrome or IE10
    function getDataIE10(varUrl, varData, onComplete, maxRetries) {
        $.ajax({
            async: true,
            type: 'POST',
            url: varUrl,
            data: varData,
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            processData: true,
            crossDomain: true,
            success: function (data) { //On Successfull service call
                if (onComplete != null) {
                    if (maxRetries && data.Response === "[]" && maxRetries > 0) {
                        maxRetries = maxRetries--;
                        var getData = getDataIE10.bind(this, varUrl, varData, onComplete, maxRetries);
                        setTimeout(getData, RetryInterval);
                    }
                    else {
                        onComplete(data);
                    }
                } else {
                    //alert("empty");
                }
            },
            error: function (xhr) {
            }
        });

    }

    // IE8 & 9 only Cross domain JSON request
    function getDataIE8(varUrl, varData, onComplete, maxRetries) {
        // IE8 & 9 only Cross domain JSON request
        if (window.XDomainRequest) {
            var xdr = new XDomainRequest();
            if (xdr) {
                xdr.onerror = function () {
                    // alert('Error in getDataIE8');
                };
                xdr.ontimeout = function () {
                    //  alert('Timeout in getDataIE8');
                };
                xdr.onprogress = function () {
                    //  alert("XDR onprogress");
                    // alert("Error while getting data");
                };
                xdr.onload = function () {
                    var data = xdr.responseText;
                    if (data == null || data == '') {
                        // alert("Error while getting data");
                    } else {
                        /*eslint no-undef: 2*/
                        var datajson = JSON.parse(data);
                        if (maxRetries && datajson.Response === "[]" && maxRetries > 0) {
                            maxRetries = maxRetries--;
                            var getData = getDataIE8.bind(this, varUrl, varData, onComplete, maxRetries);
                            setTimeout(getData, RetryInterval);
                        }
                        onComplete(datajson);;
                    }
                }
                xdr.timeout = 10000;
                xdr.open("POST", varUrl);
                xdr.send(JSON.stringify(varData));
            }
        }
    }


    // Get Active messages
    var getActiveIM = function (token, serviceBase, isAnnoncement) {
        var myObject =
        {
            RequestToken: token,
            Mode: RequestIntervalMode,
            CurrentRowVersion: CurrentRowVersion
        };

        var json = _JSON2.stringify(myObject);
        var method = "GetActiveIM";
        getDataCORS(serviceBase, method, json, function () {
            if (isAnnoncement == "true")
                onGetActiveIMAnnoncementComplete.apply(self, arguments);
            else
                onGetActiveIMComplete.apply(self, arguments);
        });
    };

    var onGetActiveIMComplete = function (responseText) {

        Req = removeByValue(responseText, 'MessageType', '14');

        if (Req != null && Req != '') {
            ItemsCount = Req.length;
            Current = 0;

            if (Interval != 0) {
                clearInterval(Interval);
                Interval = 0;
            }

            handleActiveIM();
        } else {
            if (Interval == 0) {
                proceedNextMessage();
            }
        }
    };

    var onGetActiveIMAnnoncementComplete = function (responseText) {

        Req = removeByValue(responseText, 'MessageType', '17');
        Req = removeByValue(Req, 'MessageType', '19');
        Req = removeByValue(Req, 'MessageType', '21');
        Req = removeByValue(Req, 'MessageType', '31');
        Req = removeByValue(Req, 'MessageType', '32');
        Req = removeByValue(Req, 'MessageType', '17');

        if (Req != null && Req != '') {
            ItemsCount = Req.length;
            Current = 0;

            if (Req[Current].ErrorCode == 1) {
                if (ItemsCount > 0) {
                    if (systemInfo.clientApplicationParams[eClientParams.Device] === "FullSite") {
                        require(["StateObject!IM"], function (StateObject) {
                            StateObject.update('message', 'new');

                            $(document).on('click', PopupCssClass.EnvelopePopupClass, function () {
                                showIM(Req[Current]);
                                StateObject.update('message', 'no-new');
                            });
                        });
                    }
                    else {
                        $(PopupCssClass.EnvelopePopupClassMobile).addClass('new');

                        $(document).on('click', PopupCssClass.EnvelopePopupClassMobile, function () {
                            showIM(Req[Current]);
                            $(PopupCssClass.EnvelopePopupClassMobile).removeClass('new');
                            $(PopupCssClass.EnvelopePopupClassMobile).addClass('no-new');
                        });
                    }
                }
                RequestIntervalMode = 1;
            }

        }
    };

    var handleActiveIM = function () {
        if (Req[Current].ErrorCode == 1) { // ErrorCode == 1 customer exist
            // Smart banner
            if (Req[Current].MessageType == 17 && Req[Current].State == 0 && Req[Current].CurrentRowVersion != null) {
                CurrentRowVersion = Req[Current].CurrentRowVersion;
                currentActiveProposition = Req[Current];
                IMContainer.currentActiveProposition = Req[Current];
            }

            if (Req[Current].State != 0 || (Req[Current].MessageType == 31 || Req[Current].MessageType == 32))
                showIM(Req[Current]);
            else
                proceedNextMessage();

            RequestIntervalMode = 1;
        } else { // ErrorCode == 0 customer not exist
            if (CurrentRetry + 1 < MaxRetries) {
                setTimeout(function () { getActiveIM(Token, ServiceBase, IsAnnoncement); }, RetryInterval);
                ++CurrentRetry;
            }
        }
    };

    // Show the message
    var showIM = function (Request) {

        if (Request != null) {
            var myObject =
            {
                RequestToken: Token,
                CustomerMessageID: Request.CustomerMessageID,
                LanguageID: LanguageId,
                IMMetaData: Request
            };
            var json = _JSON2.stringify(myObject);
            var method = "ShowIM";
            Req[Current] = Request;
            getDataCORS(ServiceBase, method, json, onShowIMComplete);
        }
    };

    var onShowIMComplete = function (responseText) {
        if (responseText != null && responseText != '' && Req[Current]) {
            $.publish(Events.onCompleteShowIM, [responseText, Req[Current].CustomerMessageID, responseText.Content, PopupCssClass, Current, ItemsCount, { req: Req }]);
        }
    };

    // Report action to service
    var ReportIMAction = function (args) {

        if (Req != null) {
            var myObject =
            {
                RequestToken: Token,
                CustomerMessageID: args[0],
                ActionTypeID: args[1]
            };
            var json = _JSON2.stringify(myObject);
            var method = "ReportIMAction";
            getDataCORS(ServiceBase, method, json, function () { onReportIMActionComplete.apply(self, arguments); });
        }
    };

    var onReportIMActionComplete = function (responseText) {
        if (responseText != null && responseText != '') {

        }
    };

    var onReportIMAction_Event = function () {
        $.subscribe(Events.onReportIMAction, function () { ReportIMAction(arguments); });
    };


    // Report status to service
    var ReportIMStatus = function (args) {

        if (Req != null) {
            var myObject =
            {
                RequestToken: Token,
                CustomerMessageID: args[0],
                StatusID: args[1]
            };
            var json = _JSON2.stringify(myObject);
            var method = "ReportIMStatus";
            getDataCORS(ServiceBase, method, json, function () { onReportIMStatusComplete.apply(self, arguments); });
        }
    };

    var onReportIMStatusComplete = function (responseText) {
        if (responseText != null && responseText != '') {

        }
    };

    var onReportIMStatus_Event = function () {
        $.subscribe(Events.onReportIMStatus, function () { ReportIMStatus(arguments); });
    };



    var onErrorIM_Event = function (callback) {
        if (callback && typeof (callback) === "function") {
            $.subscribe(Events.onErrorIM, callback);
        }
    };

    var onCompleteGetActiveIM_Event = function (callback) {
        if (callback && typeof (callback) === "function") {
            //$.subscribe(Events.onCompleteGetActiveIM, callback);
        }
    };

    var onCompleteShowIM_Event = function (callback) {
        if (callback && typeof (callback) === "function") {
            $.subscribe(Events.onCompleteShowIM, callback);
        }
    };

    // Returns the version of Internet Explorer or -1
    var getInternetExplorerVersion = function ()
    // Returns the version of Internet Explorer or -1
    {
        var rv = -1; // Return value non-explorer.
        if (navigator.appName == 'Microsoft Internet Explorer') {
            var ua = navigator.userAgent;
            var re = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
            if (re.exec(ua) != null)
                rv = parseFloat(RegExp.$1);
        }
        return rv;
    }

    return {
        init: init,
        onErrorIM_Event: onErrorIM_Event,
        onCompleteGetActiveIM_Event: onCompleteGetActiveIM_Event,
        onCompleteShowIM_Event: onCompleteShowIM_Event,
        PopupCssClass: PopupCssClass,
        Current: Current,
        ItemsCount: ItemsCount,
        Event_onCompleteShowIM: Events.onCompleteShowIM,
        Events_onPopupClose_Event: Events.onPopupClose_Event,
        showIM: showIM,
        Events_onReportIMAction_Event: Events.onReportIMAction,
        Events_onReportIMStatus_Event: Events.onReportIMStatus,
        onReportIMAction_Event: onReportIMAction_Event,
        onReportIMStatus_Event: onReportIMStatus_Event,
        proceedNextMessage: proceedNextMessage,
        IMclearInterval: IMclearInterval,
        Interval: Interval,
        getTokenIM: getTokenIM,
        Events_onSmartBanner_Event: Events.onSmartBanner,
        IsAnnoncement: IsAnnoncement,
        CurrentActiveProposition: function () { return IMContainer.currentActiveProposition; }
    };
};


var IMlayoutService = function () {
    var imDataService;
    var CustomerCustomerMessageID = 0;

    var init = function (im) { imDataService = im; };

    var IMUIActionType = {
        Deposit: 'deposit',
        Notice: 'notice',
        Accept: 'accept',
        WalkThroughDeal: 'walkthroughdeal',
        PrivacyPolicy: 'privacypolicy',
        imClosedDeals: 'imClosedDeals',
        imOpenDeals: 'imOpenDeals',
        imNewDeal: 'imNewDeal'
    };

    var IMUIStatusType = {
        Pending: 'pending',
        Displayed: 'displayed',
        Dismissed: 'dismissed',
        Expired: 'expired'
    };

    var onCompleteShowIM_Subscribe = function () {
        $.subscribe(imDataService.Event_onCompleteShowIM, function () {
            ShowIMComplete(arguments);
        });
    };

    var onPopupClose_Subscribe = function (callback) {
        if (callback && typeof (callback) === "function") {
            $.subscribe(imDataService.Events_onPopupClose_Event, callback);
        }

        $(document).on('click', ("." + imDataService.PopupCssClass.CloseClass), function (e) {
            e.stopPropagation(); //This stops all propagation of the event in the bubbling phase
            e.preventDefault();
            IMPopupClose();
        });
        $(document).on('click', ("#" + imDataService.PopupCssClass.CloseClass), function (e) {
            e.stopPropagation(); //This stops all propagation of the event in the bubbling phase
            e.preventDefault();
            IMPopupClose();
        });
    };

    var onSmartBanner_Subscribe = function (callback) {
        if (callback && typeof (callback) === "function") {
            $.subscribe(imDataService.Events_onSmartBanner_Event, callback);
        }
    };


    // Report action to service
    var onIMUIAction_Subscribe = function (/* String */IMUIAction, /* Function */callback) {
        if (callback && typeof (callback) === "function") {
            $(document).on('click', "#" + (imDataService.PopupCssClass.PopupClass + " ." + IMUIAction), function () {
                IMUIActionClick(IMUIAction);
                IMPopupClose();
            });

            $.subscribe(IMUIAction, callback);
        }
    };

    var IMUIActionClick = function (IMUIAction) {

        var actionTypeId;
        switch (IMUIAction.toLowerCase()) {
            case IMUIActionType.Deposit:
                actionTypeId = 2;
                break;
            case IMUIActionType.Notice:
                actionTypeId = 3;
                break;
            case IMUIActionType.Accept:
                actionTypeId = 5;
                break;
            case IMUIActionType.WalkThroughDeal:
                actionTypeId = 6;
                break;
            case IMUIActionType.PrivacyPolicy:
                actionTypeId = 7;
                break;
            case IMUIActionType.imClosedDeals:
                actionTypeId = 8;
                break;
            case IMUIActionType.imOpenDeals:
                actionTypeId = 9;
                break;
            case IMUIActionType.imNewDeal:
                actionTypeId = 10;
                break;
            default:
                actionTypeId = 2;
        }

        if (CustomerCustomerMessageID != null && CustomerCustomerMessageID != 0) {
            $.publish(imDataService.Events_onReportIMAction_Event, [CustomerCustomerMessageID, actionTypeId]);
        }

        $.publish(IMUIAction, [IMUIAction]);
    };


    // Report status to service
    var onIMUIStatus_Subscribe = function (/* String */IMUIStatus, /* Function */callback) {
        $(document).on('click', ("#" + imDataService.PopupCssClass.PopupClass + " ." + IMUIStatus), function () {
            IMUIStatusClick(IMUIStatus);
            $(".notice-box").hide();
        });

        $.subscribe(IMUIStatus, callback);
    };

    var IMUIStatusClick = function (IMUIStatus) {

        var statusTypeId;
        switch (IMUIStatus.toLowerCase()) {
            case IMUIStatusType.Pending:
                statusTypeId = 0;
                break;
            case IMUIStatusType.Displayed:
                statusTypeId = 1;
                break;
            case IMUIStatusType.Dismissed:
                statusTypeId = 2;
                break;
            case IMUIStatusType.Expired:
                statusTypeId = 3;
                break;
            default:
                statusTypeId = 1;
        }

        if (CustomerCustomerMessageID != null && CustomerCustomerMessageID != 0) {
            $.publish(imDataService.Events_onReportIMStatus_Event, [CustomerCustomerMessageID, statusTypeId]);
        }
        $.publish(IMUIStatus, [IMUIStatus]);
    };


    var ShowIMComplete = function (responseText) {
        CustomerCustomerMessageID = 0;
        if (responseText != null && responseText != '') {
            var current = responseText[4];
            var itemsCount = responseText[5];

            showWin(responseText[2], responseText[3], responseText[6].req[current]);

            CustomerCustomerMessageID = responseText[6].req[current].CustomerMessageID;

            if (current < itemsCount) {
                ++current;
            } else {

            }
        }
    };

    var IMPopupClose = function (responseText) {
        $.publish(imDataService.Events_onPopupClose_Event, responseText, true);
        $("." + imDataService.PopupCssClass.PopupClass).hide();
        $("#" + imDataService.PopupCssClass.OverlayClass).hide();
        require(["StateObject!IM"], function (StateObject) {
            StateObject.update('IMPopUpVisible', false);
        });
        imDataService.proceedNextMessage();
    };

    var showWin = function (content, popupClass, req) {
        var popup = $("." + popupClass.PopupClass);
        if (content != null && content != '') {

            var cssLink = $(content).filter("link").outerHTML();
            if (cssLink != null && cssLink != '') {
                var css = $('link[href*="' + encodeURI(cssLink) + '"]').attr('id', 'im_css');
                if ($("#im_css").length == 0) {
                    $("head").append(css);
                }
                else {
                    $('#im_css').remove();
                    $("head").append(css);
                }
            }

            if (req.MessageType == 31 || req.MessageType == 32) {
                var smartBannerClass = '';
                if (req.MessageType == 31) {
                    smartBannerClass = popupClass.SmartBannerWideClass;
                }
                else if (req.MessageType == 32) {
                    smartBannerClass = popupClass.SmartBannerSmallClass;
                }

                if (imDataService.IsAnnoncement == false) {
                    var viewOfferCallback = function () { imDataService.showIM(imDataService.CurrentActiveProposition()); };
                    var dateObj = new Date(parseInt(req.ExpirationDate.replace('/Date(', '')));
                    $.publish(imDataService.Events_onSmartBanner_Event, [dateObj, req.State, smartBannerClass, req.ContentKey, content, viewOfferCallback]);
                }
                imDataService.proceedNextMessage();
            } else {
                popup.hide();
                $("#" + popupClass.OverlayClass).hide();
                popup.html(content);

                require(["StateObject!IM"], function (StateObject) {
                    StateObject.update('IMPopUpVisible', { MessageType: req.MessageType });
                });

                setTimeout(function () {
                    popup.show();
                    $("#" + popupClass.OverlayClass).fadeIn(500);
                }, 500);
            }
            imDataService.IMclearInterval(imDataService.Interval);
        } else {
            imDataService.proceedNextMessage();
        }
    };

    return {
        init: init,
        showWin: showWin,
        onCompleteShowIM_Subscribe: onCompleteShowIM_Subscribe,
        onPopupClose_Subscribe: onPopupClose_Subscribe,
        onIMUIAction_Subscribe: onIMUIAction_Subscribe,
        onIMUIStatus_Subscribe: onIMUIStatus_Subscribe,
        IMUIActionType: IMUIActionType,
        IMUIStatusType: IMUIStatusType,
        onSmartBanner_Subscribe: onSmartBanner_Subscribe
    };

};



8;
define("global/apiIM", ["jquery"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (jquery) {
				return this.apiIM(jquery);
			};
        ret = fn.apply(global, arguments);
        return ret || global.apiIM;
    };
}(this)));

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('vendor/latinize',factory);
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = factory();
  } else {
    // running in browser
    root.latinize = factory();
  }
})(this, function() {

  function latinize(str) {
    if (typeof str === 'string') {
      return str.replace(/[^A-Za-z0-9]/g, function(x) {
        return latinize.characters[x] || x;
      });
    } else {
      return str;
    }
  }

  latinize.characters = {
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'AA',
    '': 'AE',
    '': 'AE',
    '': 'AE',
    '': 'AO',
    '': 'AU',
    '': 'AV',
    '': 'AV',
    '': 'AY',
    '': 'B',
    '': 'B',
    '': 'B',
    '': 'B',
    '': 'B',
    '': 'B',
    '': 'C',
    '': 'C',
    '': 'C',
    '': 'C',
    '': 'C',
    '': 'C',
    '': 'C',
    '': 'C',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'D',
    '': 'DZ',
    '': 'DZ',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'ET',
    '': 'F',
    '': 'F',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'G',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'H',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'D',
    '': 'F',
    '': 'G',
    '': 'R',
    '': 'S',
    '': 'T',
    '': 'IS',
    '': 'J',
    '': 'J',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'K',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'L',
    '': 'LJ',
    '': 'M',
    '': 'M',
    '': 'M',
    '': 'M',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'N',
    '': 'NJ',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'OI',
    '': 'OO',
    '': 'E',
    '': 'O',
    '': 'OU',
    '': 'P',
    '': 'P',
    '': 'P',
    '': 'P',
    '': 'P',
    '': 'P',
    '': 'P',
    '': 'Q',
    '': 'Q',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'R',
    '': 'C',
    '': 'E',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'S',
    '': 'ss',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'T',
    '': 'A',
    '': 'L',
    '': 'M',
    '': 'V',
    '': 'TZ',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'V',
    '': 'V',
    '': 'V',
    '': 'V',
    '': 'VY',
    '': 'W',
    '': 'W',
    '': 'W',
    '': 'W',
    '': 'W',
    '': 'W',
    '': 'W',
    '': 'X',
    '': 'X',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Y',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'Z',
    '': 'IJ',
    '': 'OE',
    '': 'A',
    '': 'AE',
    '': 'B',
    '': 'B',
    '': 'C',
    '': 'D',
    '': 'E',
    '': 'F',
    '': 'G',
    '': 'G',
    '': 'H',
    '': 'I',
    '': 'R',
    '': 'J',
    '': 'K',
    '': 'L',
    '': 'L',
    '': 'M',
    '': 'N',
    '': 'O',
    '': 'OE',
    '': 'O',
    '': 'OU',
    '': 'P',
    '': 'R',
    '': 'N',
    '': 'R',
    '': 'S',
    '': 'T',
    '': 'E',
    '': 'R',
    '': 'U',
    '': 'V',
    '': 'W',
    '': 'Y',
    '': 'Z',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'aa',
    '': 'ae',
    '': 'ae',
    '': 'ae',
    '': 'ao',
    '': 'au',
    '': 'av',
    '': 'av',
    '': 'ay',
    '': 'b',
    '': 'b',
    '': 'b',
    '': 'b',
    '': 'b',
    '': 'b',
    '': 'b',
    '': 'b',
    '': 'o',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'c',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'd',
    '': 'i',
    '': 'j',
    '': 'j',
    '': 'j',
    '': 'dz',
    '': 'dz',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'et',
    '': 'f',
    '': 'f',
    '': 'f',
    '': 'f',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'g',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'hv',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'd',
    '': 'f',
    '': 'g',
    '': 'r',
    '': 's',
    '': 't',
    '': 'is',
    '': 'j',
    '': 'j',
    '': 'j',
    '': 'j',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'k',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'l',
    '': 'lj',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 'm',
    '': 'm',
    '': 'm',
    '': 'm',
    '': 'm',
    '': 'm',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'nj',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'oi',
    '': 'oo',
    '': 'e',
    '': 'e',
    '': 'o',
    '': 'o',
    '': 'ou',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'p',
    '': 'q',
    '': 'q',
    '': 'q',
    '': 'q',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'c',
    '': 'c',
    '': 'e',
    '': 'r',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 's',
    '': 'g',
    '': 'o',
    '': 'o',
    '': 'u',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 't',
    '': 'th',
    '': 'a',
    '': 'ae',
    '': 'e',
    '': 'g',
    '': 'h',
    '': 'h',
    '': 'h',
    '': 'i',
    '': 'k',
    '': 'l',
    '': 'm',
    '': 'm',
    '': 'oe',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 'r',
    '': 't',
    '': 'v',
    '': 'w',
    '': 'y',
    '': 'tz',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'ue',
    '': 'um',
    '': 'v',
    '': 'v',
    '': 'v',
    '': 'v',
    '': 'v',
    '': 'v',
    '': 'v',
    '': 'vy',
    '': 'w',
    '': 'w',
    '': 'w',
    '': 'w',
    '': 'w',
    '': 'w',
    '': 'w',
    '': 'w',
    '': 'x',
    '': 'x',
    '': 'x',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'y',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'z',
    '': 'ff',
    '': 'ffi',
    '': 'ffl',
    '': 'fi',
    '': 'fl',
    '': 'ij',
    '': 'oe',
    '': 'st',
    '': 'a',
    '': 'e',
    '': 'i',
    '': 'j',
    '': 'o',
    '': 'r',
    '': 'u',
    '': 'v',
    '': 'x',
    '': 'YO',
    '': 'I',
    '': 'TS',
    '': 'U',
    '': 'K',
    '': 'E',
    '': 'N',
    '': 'G',
    '': 'SH',
    '': 'SCH',
    '': 'Z',
    '': 'H',
    '': "'",
    '': 'yo',
    '': 'i',
    '': 'ts',
    '': 'u',
    '': 'k',
    '': 'e',
    '': 'n',
    '': 'g',
    '': 'sh',
    '': 'sch',
    '': 'z',
    '': 'h',
    '': "'",
    '': 'F',
    '': 'I',
    '': 'V',
    '': 'a',
    '': 'P',
    '': 'R',
    '': 'O',
    '': 'L',
    '': 'D',
    '': 'ZH',
    '': 'E',
    '': 'f',
    '': 'i',
    '': 'v',
    '': 'a',
    '': 'p',
    '': 'r',
    '': 'o',
    '': 'l',
    '': 'd',
    '': 'zh',
    '': 'e',
    '': 'Ya',
    '': 'CH',
    '': 'S',
    '': 'M',
    '': 'I',
    '': 'T',
    '': "'",
    '': 'B',
    '': 'YU',
    '': 'ya',
    '': 'ch',
    '': 's',
    '': 'm',
    '': 'i',
    '': 't',
    '': "'",
    '': 'b',
    '': 'yu'
  };

  return latinize;
});

var cConfig = {
    MaxConnectionFailure: 50,
    AmountRoundingThreshold: 10
};

var cTileLayout = {
    FourTilesContainerMinWidth: 1024
};

var cKeyCode = {
    CtrlEnter: 10,
    Enter: 13
};

var cTextMarks = {
    Ltr: '\u200E',
    ZeroWidthNoBreakSpace: '\uFEFF'
};

var cEmptyRate = '.....';

var cArabicChars = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\uFB50-\uFC3F\uFE70-\uFEFC]/;

define("fxnet/common/constants/consts/Const", function(){});

require.config({
	shim: {
		ProChart_Loader: {
			exports: "ProChart_Loader",
		},
		"handlers/Logger": {
			deps: ["dataaccess/dalCommon"],
			exports: "Logger",
			init: function (dc) {
				return this.Logger(dc);
			},
		},
		"handlers/Ajaxer": {
			deps: ["Q", "handlers/AjaxError", "global/UrlResolver"],
			exports: "TAjaxer",
			init: function (q) {
				Q = q;
				return this.TAjaxer;
			},
		},
		"handlers/SyncRequestHelper": {
			exports: "SyncRequestHelper",
			deps: ["global/UrlResolver"],
			init: function (q) {
				Q = q;
				return this.SyncRequestHelper;
			},
		},
		jquery: {
			deps: ["vendor/jquery-3.5.1"],
			exports: "jquery",
		},
		jqueryMigrate: {
			deps: ["vendor/jquery-migrate-3.3.1"],
			exports: "jquery",
		},
		"vendor/jquery.history": {
			deps: ["jquery"],
			exports: "History",
		},
		"vendor/jquery-ui": {
			deps: ["jquery"],
			exports: "jquery",
		},
		"vendor/knockout.validation": {
			deps: ["knockout", "JSONHelper"],
			exports: "ko",
		},
		"vendor/knockout-postbox": {
			deps: ["knockout"],
			exports: "ko",
		},
		"vendor/jquery.validate": {
			deps: ["jquery"],
			exports: "jquery",
		},
		"vendor/jquery.validate.unobtrusive": {
			deps: ["jquery", "vendor/jquery.validate"],
			exports: "jquery",
		},
		"vendor/jquery.numeric": {
			deps: ["jquery"],
			exports: "jquery",
		},
		"helpers/ObservableHashTable": {
			deps: ["knockout", "helpers/KOExtensions"],
			exports: "ObservableHashTable",
			init: function () {
				return this.ObservableHashTable;
			},
		},
		"helpers/observabledataset": {
			deps: ["knockout", "JSONHelper", "helpers/ObservableHashTable"],
			exports: "ObservableDataSet",
			init: function () {
				return this.ObservableDataSet;
			},
		},

		"dataaccess/dalAccountingActions": {
			deps: ["generalmanagers/ErrorManager", "handlers/general", "handlers/Ajaxer"],
			exports: "TDALAccountingActions",
			init: function (em, general) {
				return this.TDALAccountingActions(em, general);
			},
		},
		"dataaccess/dalWithdrawal": {
			deps: ["generalmanagers/ErrorManager", "handlers/general"],
			exports: "TDALWithdrawal",
			init: function (em, general) {
				return this.TDALWithdrawal(em, general);
			},
		},
		"dataaccess/dalNotificationData": {
			deps: ["generalmanagers/ErrorManager"],
			exports: "TDALNotificationData",
			init: function (em) {
				return this.TDALNotificationData(em);
			},
		},
		"dataaccess/dalInitialData": {
			deps: ["generalmanagers/ErrorManager"],
			exports: "TDALInitialData",
			init: function (em) {
				return this.TDALInitialData(em);
			},
		},
		"dataaccess/dalActivityLog": {
			deps: ["generalmanagers/ErrorManager", "handlers/general"],
			exports: "dalActivityLog",
			init: function (em, general) {
				return this.dalActivityLog(em, general);
			},
		},
		"dataaccess/dalTransactionsReport": {
			deps: ["generalmanagers/ErrorManager", "handlers/general"],
			exports: "dalTransactionsReport",
			init: function (em, general) {
				return this.dalTransactionsReport(em, general);
			},
		},
		"dataaccess/dalTutorials": {
			deps: ["generalmanagers/ErrorManager", "handlers/general"],
			exports: "TDALTutorials",
			init: function (em, general) {
				return this.TDALTutorials(em, general);
			},
		},
		"dataaccess/dalTradingSignals": {
			deps: ["generalmanagers/ErrorManager", "handlers/general"],
			exports: "TDALTradingSignals",
			init: function (em, general) {
				return this.TDALTradingSignals(em, general);
			},
		},
		"dataaccess/dalClosedDeals": {
			deps: ["generalmanagers/ErrorManager", "handlers/general"],
			exports: "TDALClosedDeals",
			init: function (em, general) {
				return this.TDALClosedDeals(em, general);
			},
		},
		"dataaccess/dalRetention": {
			deps: ["generalmanagers/ErrorManager"],
			exports: "TDALRetention",
			init: function (em) {
				return this.TDALRetention(em);
			},
		},
		CreditCardManager: {
			deps: [
				"knockout",
				"handlers/HashTable",
				"helpers/ObservableHashTable",
				"CreditCard",
				"FxNet/LogicLayer/Deposit/CreditCard/CreditCardView",
			],
			exports: "TCreditCardManager",
			init: function (ko, obs, ht) {
				return this.TCreditCardManager(ko, obs, ht);
			},
		},
		"FxNet/LogicLayer/Deposit/CreditCard/CreditCardView": {
			exports: "TCreditCardView",
		},
		"tracking/EventsCollector": {
			deps: ["knockout", "trackingIntExt/TrackingEvents"],
			exports: "TrackingEventsCollector",
			init: function (ko, te) {
				var trackingEventsCollector = this.TrackingEventsCollector(ko, te, false);
				return trackingEventsCollector;
			},
		},
		"trackingIntExt/TradingEventsHandler": {
			deps: [
				"knockout",
				"trackingIntExt/TrackingData",
				"devicemanagers/ViewModelsManager",
				"handlers/general",
				"tracking/EventsCollector",
			],
			exports: "TradingEventsHandler",
			init: function (ko, td, vm, ge, ec) {
				return this.TradingEventsHandler(ko, td, vm, ge, ec);
			},
		},
		"viewmodels/QuotesViewModel": {
			deps: [
				"knockout",
				"viewmodels/ViewModelBase",
				"handlers/general",
				"global/debounce",
				"Dictionary",
				"cachemanagers/QuotesManager",
				"modules/FavoriteInstrumentsManager",
				"managers/instrumentTranslationsManager",
				"modules/permissionsmodule",
				"handlers/Delegate",
				"devicemanagers/AlertsManager",
        "cachemanagers/PortfolioStaticManager",
				"vendor/knockout-sortable",
				"enums/enums",
			],
			exports: "QuotesViewModel",
			init: function (ko, vmb, gen, deb, dct, qtm, fim, itm, pm, deg, am, pfm) {
				return this.QuotesViewModel(ko, vmb, gen, deb, dct, qtm, fim, itm, pm, deg, am, pfm);
			},
		},
		"handlers/Cookie": {
			deps: [],
			exports: "CookieHandler",
		},
		"handlers/general": {
			deps: [],
			exports: "General",
			init: function () {
				return this.General;
			},
		},
		"deposit/DepositCurrency": {
			deps: [],
			exports: "TDepositCurrency",
			init: function () {
				return this.TDepositCurrency;
			},
		},
		"handlers/AmountConverter": {
			deps: [],
			exports: "AmountConverter",
			init: function () {
				return this.AmountConverter;
			},
		},
		"dataaccess/dalcustomer": {
			deps: ["handlers/Ajaxer", "JSONHelper", "handlers/general"],
			exports: "TDALCustomer",
			init: function (Ajaxer, jsonhelper, general) {
				return this.TDALCustomer(jsonhelper, general);
			},
		},

		"dataaccess/dalMarketState": {
			deps: ["handlers/Ajaxer", "JSONHelper", "handlers/general"],
			exports: "TDALMarketState",
			init: function (Ajaxer, jsonhelper, general) {
				return this.TDALMarketState(jsonhelper, general);
			},
		},
		"dataaccess/dalDemoAccount": {
			deps: ["handlers/Ajaxer", "JSONHelper"],
			exports: "TDALDemoAccount",
			init: function (Ajaxer, jsonhelper) {
				return this.TDALDemoAccount(jsonhelper);
			},
		},
		"dataaccess/dalInstruments": {
			deps: ["handlers/Ajaxer", "JSONHelper", "handlers/general", "handlers/Logger"],
			exports: "TDALInstruments",
			init: function (ajaxer, jsonHelper, general, logger) {
				var ajx = new ajaxer();
				return this.TDALInstruments(ajx, jsonHelper, general, logger);
			},
		},
		"viewmodels/HeaderViewModel": {
			deps: ["knockout", "modules/permissionsmodule"],
			exports: "HeaderViewModel",
			init: function (ko, pm) {
				return this.HeaderViewModel(pm);
			},
		},
		"viewmodels/ViewAndPrintWithdrawalViewModel": {
			deps: ["knockout", "viewmodels/ViewModelBase", "handlers/general"],
			exports: "ViewAndPrintWithdrawalViewModel",
			init: function (ko, vmb, gen) {
				return this.ViewAndPrintWithdrawalViewModel(ko, vmb, gen);
			},
		},

		"viewmodels/AccountMarketViewModel": {
			deps: ["knockout"],
			exports: "AccountMarketViewModel",
			init: function (ko) {
				return this.AccountMarketViewModel(ko);
			},
		},
		"viewmodels/ActivityLogViewModel": {
			deps: [
				"helpers/ObservableCustomExtender",
				"handlers/general",
				"dataaccess/dalActivityLog",
				"modules/systeminfo",
				"helpers/KOExtensions",
			],
			exports: "ActivityLogViewModel",
			init: function (ko, general, dag, si) {
				return this.ActivityLogViewModel(ko, general, dag, si);
			},
		},
		"viewmodels/TradingSignalsTutorialsViewModel": {
			deps: ["knockout", "viewmodels/ViewModelBase", "handlers/general"],
			exports: "TradingSignalsTutorialsViewModel",
			init: function (ko, vmb, gen) {
				return this.TradingSignalsTutorialsViewModel(ko, vmb, gen);
			},
		},
		"viewmodels/SmartBannerViewModel": {
			deps: [
				"knockout",
				"handlers/general",
				"handlers/HashTable",
				"helpers/ObservableHashTable",
				"customEnums/ViewsEnums",
			],
			exports: "SmartBannerViewModel",
			init: function (ko, general, ht, oht) {
				return this.SmartBannerViewModel(ko, general, oht);
			},
		},
		"viewmodels/CountDownModel": {
			deps: ["knockout"],
			exports: "CountDownModel",
			init: function (ko) {
				return this.CountDownModel(ko);
			},
		},
		"managers/PopupInNewWindowManager": {
			exports: "PopupInNewWindowManager",
		},
		"global/apiIM": {
			deps: ["jquery"],
			exports: "apiIM",
			init: function (jquery) {
				return this.apiIM(jquery);
			},
		},
		"vendor/jcf.selectModule": {
			deps: ["vendor/jcf"],
			exports: "jcf.modules.Select",
			init: function (jcf) {
				return this.jcfselect(jcf);
			},
		},
		"calculators/LimitValuesCalculator": {
			deps: ["handlers/AmountConverter"],
			exports: "LimitValuesCalculator",
			init: function () {
				return this.LimitValuesCalculator;
			},
		},
		"calculators/LimitRangeCalculator": {
			deps: ["enums/enums"],
			exports: "LimitRangesCalculator",
			init: function () {
				return this.LimitRangesCalculator;
			},
		},
		"enums/alertenums": {
			exports: "AlertTypes",
		},
		"enums/enums": {
			exports: "eDepositingActionType",
		},
		"global/swipe": {
			exports: "swipe",
		},
		"vendor/globalize": {
			exports: "Globalize",
		},
		"fx-core-api/StoreAPI": {
			deps: [
				"fx-core-api/core.runtime",
				"fx-core-api/vendors~Components~KoBindings~StoreAPI",
				"fx-core-api/vendors~Components~StoreAPI",
				"fx-core-api/vendors~StoreAPI",
				"fx-core-api/vendors~Components~KoBindings",
				"fx-core-api/vendors~Components",
			],
			exports: "Core.StoreAPI",
		},
		"fx-core-api/Components": {
			deps: [
				"fx-core-api/core.runtime",
				"fx-core-api/vendors~Components~KoBindings~StoreAPI",
				"fx-core-api/vendors~Components~KoBindings",
				"fx-core-api/vendors~Components~StoreAPI",
				"fx-core-api/vendors~Components",
			],
			exports: "Core.Components",
		},
		"fx-core-api/KoBindings": {
			deps: [
				"fx-core-api/core.runtime",
				"fx-core-api/vendors~Components~KoBindings~StoreAPI",
				"fx-core-api/vendors~Components~KoBindings",
			],
			exports: "Core.KoBindings",
		},
		"Global/RevealPassword": {
			deps: [],
			exports: "RevealPassword",
		},
		"devicehelpers/adjustUiPerDevice": {
			deps: [],
			exports: "adjustUiPerDevice",
		},
		"Registration/Common/CustomerValidators": {
			deps: ["vendor/jquery.validate", "vendor/jquery.validate.unobtrusive"],
			exports: "CustomerValidators",
		},
		"handlers/limit": {
			deps: [],
			exports: "TLimit",
		},
	},
	//name: "fxnet/devices/mobile/configuration/startRequire",
	//out: "../../assets/20200413222717/js/main-built.mobile.js",
	deps: [
		"vendor/knockout-postbox",
		"vendor/jquery.validate",
		"vendor/jquery.validate.unobtrusive",
		"vendor/jquery.numeric",
		"vendor/jquery-migrate-3.3.1",
		"helpers/ObservableCustomExtender",
		"extensions/Object",
		"extensions/Array",
		"extensions/Date",
		"extensions/String",
		"extensions/Number",
		"handlers/format",
		"handlers/general",
		"tracking/EventRaiser",
		"tracking/EventsCollector",
		"tracking/PerformanceDataCollector",
		"tracking/TrackingCommonData",
		// Browser should be refactored into r.js - very few dependencies
		"global/browser",
		"global/apiIM",
		"vendor/latinize",
		"enums/DataMembersPositions",
		"fxnet/common/constants/consts/Const",
	],
});

define("fxnet/common/config/common.config", function(){});

define('fxnet/devices/web/configuration/require.config',["require", "modules/environmentData", "global/UrlResolver", "fxnet/common/config/common.config"], function (
	require
) {
	return function () {
		var environmentData = require("modules/environmentData").get(),
			UrlResolver = require("global/UrlResolver"),
			appRelativePath = UrlResolver.getApplicationRelativePath(),
			staticFilePath = UrlResolver.getStaticFilePath(),
			version = "v=" + (environmentData.version || window.version || "");

		//coreAssetsConfig = require("fxnet/CoreAssetsConfig");
		// var coreAssetsPaths = coreAssetsConfig.generatePaths('https://127.0.0.1:9000/');
		//var coreAssetsPaths = coreAssetsConfig.generatePaths(assestPath + "/js/fx-core-api/");
		//var shim = coreAssetsConfig.shim;

		var coreAssetsPaths = {};

		var baseConfig = {
			onNodeCreated: function (node) {
				node.setAttribute("crossorigin", "anonymous");
			},
			urlArgs: version,
			baseUrl: UrlResolver.combine(UrlResolver.getStaticJSPath(), "scripts"),
			config: {
				text: {
					useXhr: function () {
						return true;
					},
				},
			},

			map: {
				"*": {
					jquery: "vendor/jquery-3.5.1",
					"vendor/jquery.signalR": "vendor/jquery.signalR-2.2.2.2",
				},
			},
			paths: generatePath(),
			waitSeconds: 0,
		};

		function generatePath() {
			var corePath = {
				knockout: "vendor/knockout-3.5.1",
				Q: "vendor/q",
				managers: "fxnet/uilayer/managers",
				devicemanagers: "fxnet/devices/web/uilayer/managers",
				widgets: "fxnet/uilayer/objects",
				devicewidgets: "fxnet/devices/web/uilayer/objects",
				generalmanagers: "fxnet/LogicLayer/GeneralManager",
				cachemanagers: "fxnet/logiclayer/cachemanagers",
				calculators: "fxnet/LogicLayer/LimitCalculator",
				userflow: "fxnet/logiclayer/userflows",
				withdrawal: "fxnet/logiclayer/withdrawal",
				modules: "fxnet/uilayer/modules",
				currentAppFolder: "fxnet/devices/web",
				LoadDictionaryContent: "fxnet/uilayer/modules/LoadDictionaryContent",
				viewmodels: "fxnet/uilayer/viewmodels",
				deviceviewmodels: "fxnet/devices/web/uilayer/viewmodels",
				deviceviews: "fxnet/devices/web/uilayer/views",
				devicecustommodules: "fxnet/devices/web/modules",
				payments: "fxnet/uilayer/viewmodels/payments",
				Dictionary: "fxnet/LogicLayer/GeneralManager/Dictionary",
				JSONHelper: "fxnet/common/utils/handlers/jsonhelper",
				dataaccess: "fxnet/dataaccesslayer",
				devicealerts: "fxnet/devices/web/uilayer/alerts",
				initdatamanagers: "fxnet/logiclayer/initialdatamanagers",
				configuration: "fxnet/devices/web/configuration",
				alerts: "fxnet/uilayer/alerts",
				handlers: "fxnet/common/utils/handlers",
				helpers: "fxnet/uilayer/uilayerhelpers",
				devicehelpers: "fxnet/devices/web/uilayer/uilayerhelpers",
				StateObject: "fxnet/uilayer/modules/StateObject",
				deepLinks: "fxnet/LogicLayer/DeepLink",
				devicecustomdeeplinks: "fxnet/devices/web/logiclayer/deeplink",
				customEnums: "fxnet/devices/web/enums",
				extensions: "fxnet/Common/Utils/Extensions",
				enums: "fxnet/Common/constants/enums",
				constsenums: "fxnet/common/constants/consts",
				ProChart_Loader: "AdvinionChart/ChartUI/init/prochart.loader.min",
				trackingIntExt: "tracking/internal",
				deposit: "fxnet/LogicLayer/Deposit",
				"partial-views": staticFilePath,
				controllers: appRelativePath,
				assets: UrlResolver.getAssetsPath(),
				webHtml: UrlResolver.combine(staticFilePath, "scripts/fxnet/devices/web/uilayer/views"),
				mobileHtml: UrlResolver.combine(staticFilePath, "scripts/fxnet/devices/mobile/uilayer/views"),
				html: UrlResolver.combine(staticFilePath, "scripts/fxnet/uilayer/viewmodels"),
				emily: UrlResolver.combine(UrlResolver.getStaticJSPath(), "emily"),
				"fx-core-api": UrlResolver.combine(UrlResolver.getStaticJSPath(), "fx-core-api"),
				html2canvas: "vendor/html2canvas.min",
				SignaturePad: "vendor/signature_pad.min",
			};

			return Object.assign(corePath, coreAssetsPaths);
		}
		requirejs.config(baseConfig);
	};
});

define("helpers/KOExtensions", ['knockout','handlers/general', 'vendor/knockout-postbox'], function(ko, general){
    ko.observableArray.fn.pushSorted = function(sortPropName, asc, value) {
        var array = this();
        var rawValue = ko.toJS(value[sortPropName]);
        var len = array.length;
        var i = 0;

        if (len > 0) {
            var current = ko.toJS(array[len - 1][sortPropName]);
            var comparison = general.CompareValues(current, rawValue, asc);
            if (comparison <= 0) {
                this.push(value);
                return len - 1;
            }

            do {
                current = ko.toJS(array[i][sortPropName]);
                comparison = general.CompareValues(current, rawValue, asc);
                if (comparison >= 0) {
                    this.splice(i, 0, value);
                    return i;
                }

            } while (i++ < len)
        }

        this.push(value);
        return i;
    };

    ko.isObservableArray = function(instance) {
        if (!instance)
            return false;
        return typeof instance["remove"] == "function" &&
            typeof instance["removeAll"] == "function" &&
            typeof instance["destroy"] == "function" &&
            typeof instance["destroyAll"] == "function" &&
            typeof instance["indexOf"] == "function" &&
            typeof instance["replace"] == "function";
    };

    ko.observableArray.fn.sortByProperty = function(sortPropName, asc) {
        this.sort(function(left, right) {
            var rawLeft = ko.toJS(left[sortPropName]);
            var rawRight = ko.toJS(right[sortPropName]);
            return general.CompareValues(rawLeft, rawRight, asc);
        });
    };

    ko.utils.updateShallowFrom = function(source, target, trackProperty) {
        var propertyChanged = false;

        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                if (prop in target) {
                    var rawValue = ko.toJS(source[prop]);
                    var needsTracking = typeof(trackProperty) != 'undefined' && prop == trackProperty;

                    if (ko.isObservable(target[prop])) {
                        if (ko.isWriteableObservable(target[prop])) {
                            if (target[prop]() != rawValue) {
                                propertyChanged = needsTracking;
                                target[prop](rawValue);
                            }
                        }
                    } else {
                        if (target[prop] != rawValue) {
                            propertyChanged = needsTracking;
                            target[prop] = rawValue;
                        }
                    }
                }
            }
        }

        return propertyChanged;
    };

    ko.utils.updateDeepFrom = function (source, target, trackProperty) {
        var propertyChanged = false;

        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                if (prop in target) {
                    var rawValue = ko.toJS(source[prop]);
                    var needsTracking = typeof (trackProperty) != 'undefined' && prop == trackProperty;

                    if (ko.isObservable(target[prop])) {
                        if (ko.isWriteableObservable(target[prop])) {
                            propertyChanged = needsTracking;
                            target[prop](rawValue);
                        }
                    } else {
                        propertyChanged = needsTracking;
                        target[prop] = rawValue;
                    }
                }
            }
        }

        return propertyChanged;
    };

    ko.utils.dirtyGroup = function (target, objects) {
        if (!general.isObjectType(target)) {
            target = {};
        }
        var group = [];
        $.each(objects, function () {
            group.push(this);
        });
        target.dirtyGroup = [];

        var checkdirtygroup = function () {
            ko.utils.arrayForEach(group, function (observable) {
                if (observable && observable.isDirty()) target.dirtyGroup.push(observable);
            });
        };

        //checkdirtygroup();

        target.isDirty = ko.computed(function () {
            target.dirtyGroup = [];
            checkdirtygroup();
            return target.dirtyGroup.length > 0;
        });
    };

    ko.subscribable.fn.subscribeChanged = function (callback) {
        var previousValue;

        this.subscribe(function (_previousValue) {
            previousValue = _previousValue;
        }, null, 'beforeChange');

        return this.subscribe(function (latestValue) {
            callback(latestValue, previousValue);
        });
    };

    
    ko.extenders.asyncValidation = function (target, config) {
        var cfg = ko.utils.extend({ withAsyncValidationFix: true },config);
        if (cfg.withAsyncValidationFix) {
            var normalIsValid = target.isValid;
            target.isValid = function() {
                return !target.isValidating() && normalIsValid.apply(this, arguments);
            }
        }
        target.extend({ asyncValidator: cfg.asyncFunction });
    };

    ko.extenders.initialyVisible = function(target, config) {
        if (config === true) {
            target.isVisible = ko.observable(true);
        } else {
            target.isVisible = ko.observable(false);
        }
    };

    require(['vendor/knockout.validation'],function(){
        ko.validation.registerExtenders();
    });
    
    (function(){
        var emptySubscription = { dispose: function() {} };
        var currentSubscriptions = {};

        function subscribeSingleton(topic, action, target, initializeWithLatestValue) {
            (currentSubscriptions[topic] || emptySubscription).dispose();

            var newSub = ko.postbox.subscribe(topic, action, target, initializeWithLatestValue);
            var originalDispose = newSub.dispose.bind(newSub);

            newSub.dispose = function dispose() {
                originalDispose();
                delete currentSubscriptions[topic];
            }

            currentSubscriptions[topic] = newSub;

            return newSub;
        }

        ko.postbox.subscribeSingleton = subscribeSingleton;
    }());

    ko.extenders.intersectArray = function (target, options) {
        var intersectedArray = ko.pureComputed({
            read: function() {
                var firstArray = target();
                if (!Array.isArray(firstArray) || firstArray.length <= 0) {
                    return [];
                }

                /*eslint no-eq-null: 0*/
                if (options == null || options.withArray == null) {
                    return firstArray;
                }

                var secondArray = options.withArray();
                if (!Array.isArray(secondArray) || secondArray.length <= 0) {
                    if (options.allowEmptyArray){
                        return [];
                    }
                    else {
                        return firstArray;
                    }
                }

                var prop = options.prop;
                var withProp = options.withProp;
                return ko.utils.arrayFilter(firstArray, function (firstItem) {
                    return ko.utils.arrayFirst(secondArray, function (secondItem) {
                        var firstItemCompareValue = (prop ? firstItem[prop] : firstItem).toString();
                        var secondItemCompareValue = (withProp ? secondItem[withProp] : secondItem).toString();
                        return firstItemCompareValue === secondItemCompareValue;
                    });
                });
            },
            write: function(value) {
                target(value);
            }
        }).extend({ notify: 'always' });

        return intersectedArray;
    };
    return ko
});
var AlertTypes = {
    CloseDealAlert: 0,
    ServerResponseAlert: 1,
    SimpleClientAlert: 2,
    MaxIdleTimeAlert: 3,
    DoubleLoginAlert: 4,
    ExposureCoverageAlert: 5,
    MinEquityAlert: 6,
    BonusAlert: 7,
    ExitAlert: 8,
    CCDeposit: 9,
    ClientQuestionnaire: 10,
    CddClientQuestionnaire: 11,
    GeneralOkCancelAlert: 12,
    ClosePositionsConfirmation: 13,
    SignalsDisclaimerAlert: 14,
    GeneralCancelableAlert: 15,
    PopupClientQuestionnaire: 16,
    DealsClosedServerResponseAlert: 17,
    DealAddServerResponseAlert: 18,
    LimitsServerResponseAlert: 19,
    GeneralOkAlert: 20,
    RemoveCreditCardConfirmationAlert: 27,
    MultipleDealsClosedConfirmation: 28,
    ClientKnowledgeQuestionnaire: 29,
    RemoveFingerprintLoginOptionConfirmationAlert: 40,
    AddFingerprintLoginOptionConfirmationAlert: 41,
    ScanFingerprintLoginOptionConfirmationAlert: 42,
    FingerprintLoginActivatedAlert: 43,
    DeviceNotSupportFingerprintAlert: 44,
    DepositSuccessAlert: 45,
    HelpAlert: 46,
    DepositConfirmationEmailSentAlert: 47,
    ContactUsCTAAlert: 48,
    TradingConfirmationRetryAlert: 49,
    MultiplePriceAlertsClosedConfirmation: 50,
    PriceAlertServerResponseAlert: 51,
    PriceAlertClosedServerResponseAlert: 52,
    IframeAlert: 53,
    RequestAccessVideoLessonsAlert: 54,
    RequestAccessTutorialsAlert: 55,
    SessionEndedAlert: 56,
    DepositConfirmationSignatureAlert: 57,
    CreditCardNotApprovedAlert: 58,
    DepositQuestionnaireAlert: 59
};

var PostClientStatesLoginsAlerts = {
    ExposureAlert: 21,
    ExposureCoverageAlert: 22,
    SystemMode: 23,
    MarketState: 24,
    SystemModeApplicationClosing: 25,
    SystemModeApplicationShutDown: 26

};

var PostPortfoliosLoginsAlerts = {
    AmlStatus: 30,
    IsActive: 31,
    IsDemo: 32,
    IsReal: 35,
    KycStatus: 33,
    PepStatus: 34
};

var SaveWithdrawalResponseReturnType = {
    NotPossible: 0,
    EquityLimit: 1,
    AmountLimit: 2,
    Succeded: 3,
    EquityChanged: 4,
    HasOpenPos: 5,
    BalanceError: 6,
    TradingBonusTakeoutRequired: 7,
    TradingBonusTakeoutRequiredRich: 8
};

var KnowledgeAlertTypes = {
    Retry: 0,
    Review: 1,
    Tested: 2,
    Inappropriate: 3,
    Unsuitable: 4
};
define("enums/alertenums", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.AlertTypes;
    };
}(this)));

// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
    var timeout;

    return function debounceHandler() {
        var context = this,
            args = General.argsToArray(arguments);

        function laterHandler() {
            timeout = null;
            if (!immediate) {
                func.apply(context, args);
            }
        }

        var callNow = immediate && !timeout;
        clearTimeout(timeout);

        timeout = setTimeout(laterHandler, wait);
        if (callNow) {
            func.apply(context, args);
        }
    };
}

define("global/debounce", [],function(){ return debounce });
define(
    'viewmodels/dialogs/DialogViewModel',
    [
        'knockout',
        'global/debounce',
        'handlers/general'
    ],
    function DialogModelDef(ko, debounce, general) {
        function DialogModel(name, view, args) {
            this.name = name;
            this.viewType = view || 6;
            this.viewArgs = args;
            this.options = {};
            this.openTimeout = 0;
            this.persistent = true;
            this.position = ko.observable({});
            this.element = null;
            this.OnClose = new TDelegate();

            this.setOptions = function (customOptions, dialogPosition) {
                this.options = {
                    title: '',
                    width: 'auto',
                    height: 'auto',
                    dialogClass: 'fx-dialog',
                    closeText: "",
                    top: -1,
                    left: -1,
                    offset: 0
                };

                this.openTimeout = general.isDefinedType(customOptions.openTimeout) ? customOptions.openTimeout : 0;
                this.persistent = general.isDefinedType(customOptions.persistent) ? customOptions.persistent : true;

                this.element = document.getElementById(this.name);

                if (!this.element) {
                    return;
                }

                if (customOptions.useDialogPosition) {
                    this.options.topOpt = dialogPosition.top;
                    this.options.leftOpt = dialogPosition.left;
                    this.options.offsetOpt = dialogPosition.offset;
                }

                Object.assign(this.options, customOptions)
            }

            this.getOptions = function () {
                return this.options;
            };

            this.dispose = function () {
                this.OnClose.Flush();
                this.position(null);
                this.options = null;
                this.element = null;
            };
        }

        function DialogViewModelClass() {
            var instances = ko.observableArray([]),
                topMostDialog = ko.computed(function () {
                    var length = instances().length;
                    return instances()[length - 1];
                }),
                persistent = ko.computed(function () {
                    var dialog = topMostDialog();
                    if (dialog) {
                        return dialog.persistent;
                    }

                    return true;
                }),
                isOpen = ko.computed(function () {
                    return instances().length > 0;
                }),
                dialogPosition = ko.observable({ top: -1, left: -1, offset: 0 }),
                onPreloadDelegate = new TDelegate(),
                onOpenDelegate = new TDelegate(),
                onCloseDelegate = new TDelegate();

            var open = debounce(function openHandler(name, options, view, args) {
                var dialog = new DialogModel(name, view, args);
                dialog.OnClose.Add(closeHandler);
                dialog.setOptions(options, dialogPosition());

                onOpenDelegate.Invoke(dialog.name, dialog.viewType, dialog.viewArgs);

                instances.push(dialog);
            }, 500, true);

            var openAsync = debounce(function openAsyncHandler(event, name, options, view, args) {
                var subscriber = ko.postbox.subscribe(event, function () {
                    open(name, options, view, args);
                    subscriber.dispose();
                });

                onPreloadDelegate.Invoke(name, view, args);
            }, 500, true);

            function closeHandler(dialog, hasInternalIframe) {
                var index = instances.indexOf(dialog);

                if (index > -1) {
                    if (dialog.options && dialog.options.hasOwnProperty('onCloseCallback') &&
                        general.isFunctionType(dialog.options.onCloseCallback)) {
                        dialog.options.onCloseCallback(dialog);
                    }

                    dialog.dispose();

                    if (!hasInternalIframe) {
                        onCloseDelegate.Invoke(dialog.name, dialog.viewType);
                    }

                    instances.splice(index, 1);
                }
            }

            function close(dialogName, hasInternalIframe) {
                var dialog;

                if (!general.isEmptyValue(dialogName)) {
                    dialog = ko.utils.arrayFirst(instances(), function (item) {
                        return item.name === dialogName;
                    });
                }
                else {
                    dialog = topMostDialog();
                }

                closeHandler(dialog, hasInternalIframe);
            }

            function getCurrentView() {
                var dialog = topMostDialog();

                if (dialog) {
                    return dialog.viewType;
                }

                return null;
            }

            return {
                dialogs: instances,
                open: open,
                openAsync: openAsync,
                close: close,
                isOpen: isOpen,
                persistent: persistent,
                getCurrentView: getCurrentView,
                dialogPosition: dialogPosition,
                OnPreload: onPreloadDelegate,
                OnOpen: onOpenDelegate,
                OnClose: onCloseDelegate
            };
        }

        //----------------------------------------
        window.DialogViewModel = new DialogViewModelClass();

        return window.DialogViewModel;
    }
);

define(
    "cachemanagers/PortfolioStaticManager",
    
    ["handlers/Delegate"],
    function TPortfolioStaticManager(delegate) {
        var onChange = new delegate(),
            portfolio = {
                maxExposure: 0,
                securities: 0,
                tradingBonus: 0,
                pendingBonus: 0,
                pendingWithdrawals: 0,
                kycStatus: 0,
                amlStatus: 0,
                cddStatus: 0,
                kycReviewStatus: 0,
                isDemo: 0,
                isActive: 0,
                pepStatus: 0,
                pendingBonusType: 0,
                spreadDiscountVolumePercentage: 0
            };

        function processData(data) {
            updateData(data);
            onChange.Invoke(portfolio);
        }

        function updateData(data) {
            portfolio.maxExposure = data[ePortfolioStatic.maxExposure];
            portfolio.securities = data[ePortfolioStatic.securities];
            portfolio.tradingBonus = data[ePortfolioStatic.tradingBonus];
            portfolio.pendingBonus = data[ePortfolioStatic.pendingBonus];
            portfolio.kycStatus = data[ePortfolioStatic.kycStatus];
            portfolio.amlStatus = data[ePortfolioStatic.amlStatus];
            portfolio.cddStatus = data[ePortfolioStatic.cddStatus];
            portfolio.kycReviewStatus = data[ePortfolioStatic.kycReviewStatus];
            portfolio.pendingWithdrawals = data[ePortfolioStatic.pendingWithdrawals];
            portfolio.isDemo = data[ePortfolioStatic.isDemo] === 1;
            portfolio.isActive = data[ePortfolioStatic.isActive] === 1;
            portfolio.pepStatus = data[ePortfolioStatic.pepStatus];
            portfolio.pendingBonusType = data[ePortfolioStatic.pendingBonusType];
            portfolio.spreadDiscountVolumePercentage = data[ePortfolioStatic.pendingBonusVolumePercentage];
        }

        return {
            Portfolio: portfolio,
            OnChange: onChange,
            ProcessData: processData
        };
    }
);
define(
    'devicealerts/Alert',
    [
        'require',
        'knockout',
        'handlers/general',
        'viewmodels/dialogs/DialogViewModel',
        'cachemanagers/PortfolioStaticManager',
        'initdatamanagers/Customer',
        'handlers/Delegate',
        'Dictionary'
    ],
    function AlertBaseDef(require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            portfolioManager = require('cachemanagers/PortfolioStaticManager'),
            DialogViewModel = require('viewmodels/dialogs/DialogViewModel'),
            Dictionary = require('Dictionary'),
            delegate = require('handlers/Delegate'),
            customer = require('initdatamanagers/Customer');

        var AlertBase = function AlertBaseClass() {
            var defaultTitle = Dictionary.GetItem('GenericAlert', 'dialogsTitles', ' '),
                visible = ko.observable(false),
                title = ko.observable(defaultTitle),
                body = ko.observable(''),
                messages = ko.observableArray([]),
                disableThisAlertByCookie = ko.observable(false),
                caller = ko.observable(''),
                buttons = ko.observableArray([]),
                onCloseAction = new delegate(),
                theme = ko.observable(),
                timer = null;

            var hasPendingWithdrawals = function () {
                return portfolioManager.Portfolio.pendingWithdrawals.sign() > 0;
            };

            var injectDepositButtons = function (noCancelButton) {
                var thisAlert = this;

                thisAlert.buttons.removeAll();

                var closeOpenedDialog = function () {
                    DialogViewModel.close();
                };

                if (!customer.prop.isDemo) {
                    thisAlert.buttons.push(
                        new thisAlert.buttonProperties(
                            Dictionary.GetItem('DepositeNow'),
                            function () {
                                thisAlert.visible(false);
                                closeOpenedDialog();
                                require(['devicemanagers/ViewModelsManager'], function ($viewModelsManager) {
                                    ko.postbox.publish('action-source', 'InsufficientAvailableMarginPopUp');
                                    $viewModelsManager.VManager.RedirectToForm(eForms.Deposit, {});
                                });

                            },
                            'btnDeposit'
                        )
                    );

                    if (hasPendingWithdrawals()) {
                        thisAlert.buttons.push(
                            new thisAlert.buttonProperties(
                                Dictionary.GetItem('ViewCancel'),
                                function () {
                                    thisAlert.visible(false);
                                    closeOpenedDialog();
                                    require(['devicemanagers/ViewModelsManager'], function ($viewModelsManager) {
                                        $viewModelsManager.VManager.SwitchViewVisible(eForms.PendingWithdrawal);
                                    });

                                },
                                'btnPending disable'
                            )
                        );
                    }
                }

                if (noCancelButton) {
                    return;
                }

                thisAlert.buttons.push(
                    new thisAlert.buttonProperties(
                        Dictionary.GetItem('NotNow'),
                        function () {
                            thisAlert.visible(false);
                        },
                        'btnCancel colored'
                    )
                );
            };

            // callback function
            var closeMe = function (obj) {
                obj = obj || this;
                obj.visible(false);

                if (timer !== null) {
                    clearTimeout(timer);
                    timer = null;
                }

                onCloseAction.Invoke();
            };

            // callback executer
            var closeMeExecutor = function (callback, closeTimeout) {
                if (timer !== null) {
                    clearTimeout(timer);
                }

                timer = setTimeout(callback, closeTimeout);
            };

            return {
                alertName: 'devicealerts/Alert',
                theme: theme,
                visible: visible,
                caller: caller,
                title: title,
                setDefaultTitle: function () {
                    this.title(defaultTitle);
                },
                icon: '',
                body: body,
                messages: messages,
                properties: {},
                DisableThisAlertByCookie: disableThisAlertByCookie,
                NeedToCreateCookie: true,
                cookieName: '',
                buttons: buttons,
                buttonProperties: function (text, click, cssClass) {
                    return {
                        text: text,
                        onclick: click,
                        css_Class: cssClass
                    };
                },
                injectDepositButtons: injectDepositButtons,
                prepareForShow: function () { },
                // virtual override-able
                hide: function () {
                    if (visible()) {
                        visible(false);
                    }
                },
                show: function () {
                    this.theme(this.properties.theme);

                    if (this.prepareForShow) {
                        this.prepareForShow();
                    }
                    visible(true);

                    if (general.isDefinedType(this.properties.closeTimeout)) {
                        var that = this;
                        closeMeExecutor(function () { closeMe(that); }, this.properties.closeTimeout);
                    }
                },
                onCloseAction: onCloseAction,
                onClose: closeMe
            };
        };

        return AlertBase;
    }
);

define(
    'devicealerts/ExitAlert',
    [
        'require',
        'devicealerts/Alert',
        'Dictionary',
        'dataaccess/dalCommon'
    ],
    function ExitAlertDef(require) {
        var ExitAlert = function ExitAlertClass() {
            var AlertBase = require('devicealerts/Alert'),
                Dictionary = require('Dictionary'),
                dalCommon = require('dataaccess/dalCommon');

            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'ExitAlert';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.body(Dictionary.GetItem('areyousurelogout'));
                inheritedAlertInstance.title(Dictionary.GetItem('areyousurelogoutTitle'));
                createButtons();
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem('cancel'),
                        function () {
                            inheritedAlertInstance.hide();
                        },
                        'btnCancel colored'
                    ),
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem('ok'),
                        function () {
                            dalCommon.Logout(eLoginLogoutReason.web_exitAlert);
                        },
                        'btnOk'
                    )
                );
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return ExitAlert;
    }
);

define('devicealerts/BonusAlert', ["require", "knockout", 'devicealerts/Alert', "Dictionary"], function (require) {
    var BonusAlert = function () {
        var ko = require("knockout"),
            Dictionary = require("Dictionary"),
            AlertBase = require('devicealerts/Alert');

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = 'BonusAlert';
            inheritedAlertInstance.body = ko.observable(String.format(Dictionary.GetItem('pendingbonustext'), '', '', ''));

            inheritedAlertInstance.title(Dictionary.GetItem('pendingbonustexttitle'));

            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function () {
                        inheritedAlertInstance.visible(false);
                    },
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return BonusAlert;
});
define('devicealerts/ServerResponseAlert', ["require",
    'handlers/general',
    'devicealerts/Alert',
    'dataaccess/dalCommon',
    "Dictionary"
], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        general = require('handlers/general'),
        dalCommon = require('dataaccess/dalCommon'),
        Dictionary = require("Dictionary");

    var ServerResponseAlert = function () {
        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = 'ServerResponseAlert';
            inheritedAlertInstance.visible(false);
            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();

            // override base on Back => onOk
            var onOk = inheritedAlertInstance.hide = function () {
                var redirectToViewType,
                    viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || "";

                if (!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)) {
                    redirectToViewType = inheritedAlertInstance.properties.redirectToView;
                }

                if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                    inheritedAlertInstance.properties.okButtonCallback();
                }

                inheritedAlertInstance.visible(false);

                //on close do a cleanup
                inheritedAlertInstance.body('');
                inheritedAlertInstance.title('');
                inheritedAlertInstance.messages.removeAll();

                if (!general.isEmptyValue(redirectToViewType)) {
                    if (redirectToViewType === 'exit') {
                        dalCommon.Logout(eLoginLogoutReason.serverResponseAlert_exit);
                    } else {
                        require(['devicemanagers/ViewModelsManager'], function ($viewModelsManager) {
                            $viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);
                        });
                    }
                }
            };

            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    onOk,
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return ServerResponseAlert;
});
define(
    'devicealerts/CloseDealConfirmationAlert',
    [
        "require",
        'devicealerts/Alert',
        "knockout",
        'handlers/general',
        'dataaccess/dalorder',
        "Dictionary"
    ],
    function CloseDealConfirmaionAlertDef(require) {
        var AlertBase = require('devicealerts/Alert'),
            general = require('handlers/general'),
            dalOrders = require('dataaccess/dalorder'),
            Dictionary = require("Dictionary"),
            ko = require("knockout");

        var CloseDealConfirmaionAlert = function CloseDealConfirmaionAlertClass() {
            var inheritedAlertInstance = new AlertBase(),
                defaultProp = { spotRate: ko.observable(0) };

            function init() {
                inheritedAlertInstance.alertName = 'CloseDealConfirmationAlert';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.properties = defaultProp;

                createButtons();
            }

            function createButtons() {
                inheritedAlertInstance.buttons.removeAll();

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem("ok"),
                        function () {
                            var deal = inheritedAlertInstance.properties.deal;

                            if (general.isDefinedType(inheritedAlertInstance.properties.caller)) {
                                inheritedAlertInstance.caller(inheritedAlertInstance.properties.caller);
                            }

                            if (deal) {
                                var tmpDealObj = ko.toJS(deal);

                                inheritedAlertInstance.visible(false);
                                dalOrders.CloseDeals([tmpDealObj], inheritedAlertInstance.caller().OnCloseDealReturn);
                            }
                        },
                        'btnOk'
                    ),
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem("cancel"),
                        function () {
                            inheritedAlertInstance.visible(false);
                        },
                        'btnCancel colored'
                    )
                );
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        }

        return CloseDealConfirmaionAlert;
    }
);

define('devicealerts/MaxIdleTimeAlertWrapper', ["require", 'devicealerts/Alert', "knockout", "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary"),
        ko = require("knockout");

    var MaxIdleTimeAlertWrapper = function() {
        var inheritedAlertInstance = new AlertBase();

        var init = function() {
            inheritedAlertInstance.alertName = 'MaxIdleTimeAlert';
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.body = ko.observable(Dictionary.GetItem('MaxIdleTimeAlert'));
            inheritedAlertInstance.title = Dictionary.GetItem("maxIdleTimeAlertTitle");

            inheritedAlertInstance.onCloseAction.Add(ActivitySupervisor.UpdateStay);

            createButtons();
        };

        var createButtons = function() {
            inheritedAlertInstance.buttons.removeAll();

            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("exit"),
                    function() {
                        inheritedAlertInstance.hide();
                        ActivitySupervisor.Exit();
                    },
                    'Exit colored'
                ),
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("stay"),
                    function () {
                        inheritedAlertInstance.hide();
                        ActivitySupervisor.UpdateStay();
                    },
                    'Stay'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return MaxIdleTimeAlertWrapper;
});
define('devicealerts/DoubleLoginAlert', [
    "require",
    'devicemanagers/AlertsManager',
    "initdatamanagers/Customer",
    'dataaccess/dalCommon'
],
function (require) {
    var customer = require("initdatamanagers/Customer"),
        dalCommon = require('dataaccess/dalCommon');

    var DoubleLoginAlert = (function () {
        var logoutTimer;

        var show = function () {
            if (!customer.isAutologin()) {
                logoutTimer = setTimeout(function () { dalCommon.Logout(eLoginLogoutReason.web_doubleLogin1); }, 180000);
            }
            require(['devicemanagers/AlertsManager'], function () {
                AlertsManager.UpdateAlert(AlertTypes.DoubleLoginAlert);
                AlertsManager.PopAlert(AlertTypes.DoubleLoginAlert);
            });
        };

        return {
            Show: show,
            LogoutTimer: logoutTimer
        };
    })();
    return DoubleLoginAlert;
});


define(
    'devicealerts/DoubleLoginAlertWrapper',
    [
        'require',
        'devicealerts/Alert',
        'knockout',
        'Dictionary',
        'initdatamanagers/Customer',
        'devicealerts/DoubleLoginAlert',
        'dataaccess/dalCommon'
    ],
    function DoubleLoginAlertWrapperDef(require) {
        var AlertBase = require('devicealerts/Alert'),
            customer = require('initdatamanagers/Customer'),
            doubleLoginAlert = require('devicealerts/DoubleLoginAlert'),
            dictionary = require('Dictionary'),
            dalCommon = require('dataaccess/dalCommon');

        var DoubleLoginAlertWrapper = function DoubleLoginAlertWrapperClass() {
            var inheritedAlertInstance = new AlertBase();
            var exitInProcess = false;
            var alertBody = customer.isAutologin() ? dictionary.GetItem('loginDoubleLogin') + ' ' + dictionary.GetItem('loginDoubleLogin_Qus2') : dictionary.GetItem('loginDoubleLogin');

            function init() {
                inheritedAlertInstance.alertName = 'DoubleLoginAlert';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.body = alertBody;
                inheritedAlertInstance.title = dictionary.GetItem('loginDoubleLoginTitle');
                createButtons();
            }

            function clearTimer() {
                if (doubleLoginAlert.LogoutTimer) {
                    clearTimeout(doubleLoginAlert.LogoutTimer);
                }
            }

            function exit() {
                if (exitInProcess) {
                    return;
                }

                exitInProcess = true;
                clearTimer();

                dalCommon.Exit(eLoginLogoutReason.web_doubleLogin3);
            }

            function goToLogin() {
                clearTimer();
                window.location = 'Account/Login/' + '?reason=' + eLoginLogoutReason.web_doubleLogin2;
            }

            function createButtons() {
                inheritedAlertInstance.buttons.removeAll();
                inheritedAlertInstance.hide = exit;
                inheritedAlertInstance.onCloseAction.Add(exit);

                if (customer.isAutologin()) {
                    inheritedAlertInstance.buttons.push(
                        new inheritedAlertInstance.buttonProperties(
                            dictionary.GetItem('doubleLoginReconnect'),
                            goToLogin,
                            'btnLogin'
                        ));

                    inheritedAlertInstance.buttons.push(
                        new inheritedAlertInstance.buttonProperties(
                            dictionary.GetItem('exit'),
                            exit,
                            'btnOk'
                        ));
                }
                else {
                    inheritedAlertInstance.buttons.push(
                        new inheritedAlertInstance.buttonProperties(
                            dictionary.GetItem('doubleLoginReconnect'),
                            exit,
                            'btnOk'
                        ));
                }
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return DoubleLoginAlertWrapper;
    }
);
define('devicealerts/MinEquityAlertWrapper', ["require", 'devicealerts/Alert', "knockout", "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary"),
        ko = require("knockout");

    var MinEquityAlertWrapper = function() {
        var inheritedAlertInstance = new AlertBase();

        var init = function() {
            inheritedAlertInstance.alertName = "MinEquityAlert";
            inheritedAlertInstance.title(Dictionary.GetItem('MarginTipTitle'));

            inheritedAlertInstance.marginTipAlert = ko.observable("");
            inheritedAlertInstance.marginTipInfoMaxSize = ko.observable("");
            inheritedAlertInstance.marginTipInfoFund = ko.observable("");

            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.prepareForShow = prepareForShow;
        };

        var prepareForShow = function() {
            inheritedAlertInstance.injectDepositButtons(true);
            inheritedAlertInstance.marginTipAlert(inheritedAlertInstance.properties.alertText);
            inheritedAlertInstance.marginTipInfoMaxSize(inheritedAlertInstance.properties.infoMaxSizeText);
            inheritedAlertInstance.marginTipInfoFund(inheritedAlertInstance.properties.infoFundText);
        };

        return {
            GetAlert: inheritedAlertInstance,
            Init: init
        };
    };
    return MinEquityAlertWrapper;
});
define('devicealerts/GeneralOkCancelAlert', ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary");

    var GeneralOkCancelAlert = function () {
        var inheritedAlertInstance = new AlertBase();

        var prepareForShow = function () {
            createButtons();
        };

        var init = function () {
            inheritedAlertInstance.alertName = 'GeneralOkCancelAlert';
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.onClose = onClose;
            inheritedAlertInstance.prepareForShow = prepareForShow;

            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    inheritedAlertInstance.properties.okButtonCaption || Dictionary.GetItem("proceed"),
                    function () {
                        inheritedAlertInstance.overwriteNavFlow = inheritedAlertInstance.properties.overwriteNavFlow;
                        inheritedAlertInstance.visible(false);

                        cleanUpOnclose();
                        if (typeof inheritedAlertInstance.properties.okButtonCallback === "function" && !inheritedAlertInstance.overwriteNavFlow) {
                            inheritedAlertInstance.properties.okButtonCallback();
                        }
                    },
                    'btnOk'
                ));

            if (!inheritedAlertInstance.properties.hideCancelButton === true)
                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        inheritedAlertInstance.properties.cancelButtonCaption || Dictionary.GetItem("cancel"),
                        function () {
                            inheritedAlertInstance.overwriteNavFlow = false;
                            inheritedAlertInstance.visible(false);

                            cleanUpOnclose();
                            if (jQuery.isFunction(inheritedAlertInstance.properties.cancelButtonCallback)) {
                                inheritedAlertInstance.properties.cancelButtonCallback();
                            }
                        },
                        'btnCancel colored'
                    )
                );
        };

        var cleanUpOnclose = function () {
            inheritedAlertInstance.body('');
            inheritedAlertInstance.title('');
            inheritedAlertInstance.messages.removeAll();
        };

        var onClose = function () {
            inheritedAlertInstance.visible(false);
            cleanUpOnclose();

            if (jQuery.isFunction(inheritedAlertInstance.properties.onClose)) {
                inheritedAlertInstance.properties.onClose();
            }
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };

    return GeneralOkCancelAlert;
});

define('devicealerts/GeneralOkAlert', ["require", 'devicealerts/Alert', "knockout", "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary");
        
    var GeneralOkAlert = function() {

        var inheritedAlertInstance = new AlertBase();

        var prepareForShow = function() {
            createButtons();
        };

        var init = function() {
            inheritedAlertInstance.alertName = 'GeneralOkAlert';
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.onClose = onClose;
            inheritedAlertInstance.prepareForShow = prepareForShow;

            createButtons();
        };

        var createButtons = function() {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    inheritedAlertInstance.properties.okButtonCaption || Dictionary.GetItem("ok"),
                    function() {
                        inheritedAlertInstance.visible(false);

                        //on close do a cleanup
                        inheritedAlertInstance.body('');
                        inheritedAlertInstance.title('');
                        inheritedAlertInstance.messages.removeAll();

                        if (jQuery.isFunction(inheritedAlertInstance.properties.okButtonCallback)) {
                            inheritedAlertInstance.properties.okButtonCallback();
                        }
                    },
                    'btnOk'
                ));
        };

        var onClose = function() {
            inheritedAlertInstance.visible(false);

            if (jQuery.isFunction(inheritedAlertInstance.properties.onClose)) {
                inheritedAlertInstance.properties.onClose();
            }
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return GeneralOkAlert;
});
define(
    'devicealerts/serverevents/ClientStateAlertExposureAlert',
    [
        "require",
        'devicealerts/Alert',
        "Dictionary"
    ],
    function (require) {
        var AlertBase = require('devicealerts/Alert');
        var Dictionary = require("Dictionary");

        var ClientStateAlertExposureAlert = function () {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'ClientStateAlertExposureAlert';
                inheritedAlertInstance.body(Dictionary.GetItem('OrderError12'));
                createButtons();
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();
                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem("ok"),
                        function () {
                            inheritedAlertInstance.visible(false);
                        },
                        'btnOk'
                    )
                );
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return ClientStateAlertExposureAlert;
    }
);

define(
    'devicealerts/serverevents/ClientStateAlertExposureCoverageAlert',
    [
        'require',
        'devicealerts/Alert',
        'knockout',
        'Dictionary',
        'initdatamanagers/Customer',
        'cachemanagers/PortfolioStaticManager'
    ],
    function ClientStateAlertExposureCoverageAlertDef(require) {
        var ko = require("knockout"),
            AlertBase = require('devicealerts/Alert'),
            Dictionary = require('Dictionary'),
            portfolioManager = require('cachemanagers/PortfolioStaticManager'),
            customer = require('initdatamanagers/Customer');

        var ClientStateAlertExposureCoverageAlert = function ClientStateAlertExposureCoverageAlertClass() {
            var inheritedAlertInstance = new AlertBase();

            function init() {
                inheritedAlertInstance.alertName = 'devicealerts/serverevents/ClientStateAlertExposureCoverageAlert';
                inheritedAlertInstance.popCounter = ko.observable(0);
                inheritedAlertInstance.prepareForShow = prepareForShow;
            }

            function prepareForShow() {
                var isMarginMaintenance = customer.prop.maintenanceMarginPercentage > 0;

                if (isMarginMaintenance) {
                    inheritedAlertInstance.title(Dictionary.GetItem('exposureCoverageTitle'));
                }

                inheritedAlertInstance.body(getAlertBody());
                inheritedAlertInstance.injectDepositButtons(true);
            }

            function getAlertBody() {
                var exposureCoverageCall = Format.toNumberWithThousandsSeparator(customer.prop.minPctEQXP);
                var liquidationPercentage = customer.prop.LiquidationPercentage;
                var isMarginMaintenance = customer.prop.maintenanceMarginPercentage > 0;
                var hasPendingWithdrawals = portfolioManager.Portfolio.pendingWithdrawals.sign() > 0;

                var bodyText;

                if (isMarginMaintenance) {
                    bodyText = Dictionary.GetItem('MARGIN_DEPOSIT_WHEN_MARGIN_MAINTENANCE');

                    if (hasPendingWithdrawals) {
                        bodyText += Dictionary.GetItem('MARGIN_DEPOSIT_2B'); // last row of message (variant with withdrawals): 'Alternatively, you may deposit additional funds or cancel your Pending Withdrawals.'
                    }
                } else {
                    // first part of message: 'Your Exposure Coverage is below {0}%.<br />To reduce your current risk you can decrease your Net Exposure.'
                    bodyText = String.format(Dictionary.GetItem('MARGIN_DEPOSIT_1'), exposureCoverageCall) + '<br />';

                    // liquidation part of message: 'Your position(s) will be liquidated if your Exposure Coverage reaches {0}%.'
                    if (liquidationPercentage > 0) {
                        bodyText += String.format(Dictionary.GetItem('MARGIN_DEPOSIT_11'), liquidationPercentage) +
                            '<br />';
                    }

                    if (hasPendingWithdrawals) {
                        bodyText += Dictionary.GetItem('MARGIN_DEPOSIT_1B'); // last row of message (variant with withdrawals): 'Alternatively, you may deposit additional funds or cancel your Pending Withdrawals.'
                    } else {
                        bodyText += Dictionary.GetItem('MARGIN_DEPOSIT_1A'); // last row of message (variant without withdrawals): 'Alternatively, you may deposit additional funds.'
                    }
                }

                return bodyText;
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return ClientStateAlertExposureCoverageAlert;
    }
);

define("devicealerts/serverevents/ClientStateAlertSystemMode", ["require", 'devicealerts/Alert', "Dictionary", 'dataaccess/dalCommon'], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary"),
        dalCommon = require('dataaccess/dalCommon');
   
    var ClientStateAlertSystemMode = function() {

        var inheritedAlertInstance = new AlertBase();

        var init = function() {
            inheritedAlertInstance.alertName = "ClientStateAlertSystemMode";
            inheritedAlertInstance.body(Dictionary.GetItem('maintenanceAlertContent'));
            inheritedAlertInstance.title(Dictionary.GetItem('maintenanceAlertContentTitle'));
            createButtons();
        };

        var createButtons = function() {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function() {
                        inheritedAlertInstance.visible(false);
                        dalCommon.Logout(eLoginLogoutReason.clientStateError);
                    },
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return ClientStateAlertSystemMode;
});
define("devicealerts/serverevents/ClientStateAlertApplicationClosing", ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary");
   
    var ClientStateAlertApplicationClosing = function() {

        var inheritedAlertInstance = new AlertBase();

        var init = function() {
            inheritedAlertInstance.alertName = "ClientStateAlertSystemModeApplicationClosing";
            inheritedAlertInstance.body(Dictionary.GetItem('statusApplicationClosing'));
            inheritedAlertInstance.title(Dictionary.GetItem('statusApplicationClosingTitle'));
            createButtons();
        };

        var createButtons = function() {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function() {
                        inheritedAlertInstance.visible(false);
                    },
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };

    return ClientStateAlertApplicationClosing;
});
define("devicealerts/serverevents/ClientStateAlertApplicationShutDown", ["require", 'devicealerts/Alert', 'dataaccess/dalCommon', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary"),
        dalCommon = require('dataaccess/dalCommon');
    
    var ClientStateAlertApplicationShutDown = function() {

        var inheritedAlertInstance = new AlertBase();

        var init = function() {
            inheritedAlertInstance.alertName = "ClientStateAlertApplicationShutDown";
            inheritedAlertInstance.body(Dictionary.GetItem('statusApplicationShutdown'));
            inheritedAlertInstance.title(Dictionary.GetItem('statusApplicationShutdownTitle'));
            createButtons();
        };
        var createButtons = function() {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function() {
                        inheritedAlertInstance.visible(false);
                        dalCommon.Logout(eLoginLogoutReason.clientStateError);
                    },
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return ClientStateAlertApplicationShutDown;
});
define("devicealerts/serverevents/PortfolioAlertIsReal", ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert');
    var Dictionary = require("Dictionary");

    var PortfolioAlertIsReal = function () {

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = "PortfolioAlertIsReal";
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.body(Dictionary.GetItem("realLoginAlert"));
            inheritedAlertInstance.title(Dictionary.GetItem("realLoginAlertTitle"));
            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function () {
                        inheritedAlertInstance.visible(false);
                    },
                    'btnCancel'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return PortfolioAlertIsReal;
});
define('devicealerts/serverevents/PortfolioAlertIsDemo', ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert');
    var Dictionary = require("Dictionary");

    var PortfolioAlertIsDemo = function () {

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = 'PortfolioAlertIsDemo';
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.body(Dictionary.GetItem("demoLoginAlertWeb"));
            inheritedAlertInstance.title(Dictionary.GetItem("demoLoginAlertTitle"));
            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function () {
                        inheritedAlertInstance.visible(false);
                    },
                    'btnCancel'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return PortfolioAlertIsDemo;
});
define(
    'devicealerts/serverevents/PortfolioAlertIsActive',
    [
        "require",
        'devicealerts/Alert',
        "Dictionary"
    ],
    function (require) {
        var AlertBase = require('devicealerts/Alert');
        var Dictionary = require("Dictionary");

        var PortfolioAlertIsActive = function () {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'PortfolioAlertIsActive';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.body(Dictionary.GetItem("OrderError105"));
                inheritedAlertInstance.title(Dictionary.GetItem("rcCustomerPendingTitle", 'dialogsTitles'));
                //createButtons();

                inheritedAlertInstance.prepareForShow = prepareForShow;
            };

            var prepareForShow = function () {
                inheritedAlertInstance.injectDepositButtons();
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return PortfolioAlertIsActive;
    }
);

define(
    'devicealerts/serverevents/PortfolioAlertKycStatus',
    [
        'require',
        'devicealerts/Alert',
        'Dictionary'
    ],
    function PortfolioAlertKycStatusDef(require) {
        var AlertBase = require('devicealerts/Alert');
        var Dictionary = require('Dictionary');

        var PortfolioAlertKycStatus = function PortfolioAlertKycStatusClass() {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'PortfolioAlertKycStatus';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.body(Dictionary.GetItem('lblP1'));
                inheritedAlertInstance.title(Dictionary.GetItem('lblImportent'));

                createButtons();
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem('btnCompleteQuestionnaire'),
                        function () {
                            inheritedAlertInstance.visible(false);
                            closeDialog();

                            require(['devicemanagers/ViewModelsManager'], function ($viewModelsManager) {
                                $viewModelsManager.VManager.SwitchViewVisible(eForms.ClientQuestionnaire);
                            });
                        },
                        'btnCancel colored'
                    )
                );
            };

            var closeDialog = function () {
                DialogViewModel.close();
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return PortfolioAlertKycStatus;
    }
);

define(
    "dataaccess/dalKycClientQuestionnaire",
    [
        "require",
        "handlers/Ajaxer",
        'JSONHelper',
        'handlers/general'
    ],
    function (require) {
        var self = {},
            callerInfo = 'dalKycClientQuestionnaire',
            JSONHelper = require('JSONHelper'),
            general = require('handlers/general'),
            ajaxer = require('handlers/Ajaxer');

        // public service api
        self.post = function (customerAnswers, successFn, errorFn) {
            var customerAnswersUrl = "compliance/KycCustomerAnswers";

            new ajaxer().jsonPost(callerInfo, customerAnswersUrl, JSON.stringify(customerAnswers),
                function (response) {
                    var model = JSONHelper.STR2JSON("dalKycClientQuestionnaire:post", response);

                    if (general.isFunctionType(successFn)) {
                        successFn(model);
                    }
                },
                function (responseError) {
                    if (general.isFunctionType(errorFn)) {
                        errorFn(responseError);
                    }
                });
        };

        // public service api
        self.postKycKnowledgeQuestionnaire = function (customerAnswers, successFn, errorFn) {
            var customerAnswersUrl = "compliance/KycKnowledgeCustomerAnswers";

            new ajaxer().jsonPost(callerInfo, customerAnswersUrl, JSON.stringify(customerAnswers),
                function (response) {
                    var model = JSONHelper.STR2JSON("dalKycClientQuestionnaire:postKycKnowledgeQuestionnaire", response);

                    if (general.isFunctionType(successFn)) {
                        successFn(model);
                    }
                },
                function (responseError) {
                    if (general.isFunctionType(errorFn)) {
                        errorFn(responseError);
                    }
                });
        };

        self.postCustomerFailedAware = function (onResponse) {
            var customerFailedAwareUrl = "compliance/CustomerFailedAware";

            new ajaxer().jsonPost(callerInfo, customerFailedAwareUrl, null, function (response) {
                if (onResponse) {
                    var responseObj = JSONHelper.STR2JSON("dalKycClientQuestionnaire:postCustomerFailedAware", response);

                    onResponse(responseObj);
                }
            });
        };

        self.get = function (successFn, errorFn) {
            var getCustomerAnswersUrl = "compliance/CustomerAnswers";

            new ajaxer().get(
                callerInfo,
                getCustomerAnswersUrl,
                null,
                function (response) {
                    var serverModel = JSONHelper.STR2JSON("dalKycClientQuestionnaire:selfGet", response);

                    if (general.isFunctionType(successFn)) {
                        successFn(serverModel);
                    }
                },
                function (error) {
                    if (general.isFunctionType(errorFn)) {
                        errorFn(error);
                    }

                    throw new Error("Client Questionnaire Dal- ajax request failed:" + getCustomerAnswersUrl);
                }
            );
        };

        return self;
    }
);

define(
    'cachemanagers/ClientStateFlagsManager',
    [
        'handlers/Delegate'
    ],
    function TClientStateFlagsManager(delegate) {
        var onChange = new delegate(),
            csFlags = {
                exposureCoverageAlert: '',
                equityAlert: '',
                exposureAlert: '',
                marketState: '',
                systemMode: '',
                limitMultiplier: ''
            };

        function processData(csflags) {
            if (csflags[eCSFlags.isUpdated]) {
                updateData(csflags);
                onChange.Invoke(csFlags);
            }
        }

        function updateData(csflags) {
            csFlags.exposureCoverageAlert = csflags[eCSFlags.exposureCoverageAlert];
            csFlags.equityAlert = csflags[eCSFlags.equityAlert];
            csFlags.exposureAlert = csflags[eCSFlags.exposureAlert];
            csFlags.marketState = csflags[eCSFlags.marketState];
            csFlags.systemMode = csflags[eCSFlags.systemMode];
            csFlags.limitMultiplier = csflags[eCSFlags.limitMultiplier];
        }

        return {
            CSFlags: csFlags,
            OnChange: onChange,
            ProcessData: processData
        };
    }
);

define(
    'dataaccess/dalCompliance',
    [
        'require',
        'Q',
        'handlers/general',
        'handlers/Ajaxer',
        'JSONHelper'
    ],
    function (require) {
        var Q = require('Q'),
            JSONHelper = require('JSONHelper'),
            general = require('handlers/general'),
            TAjaxer = require('handlers/Ajaxer');

        function onDalAjaxError(error, callerInfo) {
            //using window. to avoid cyclic failure in r.js
            window.ErrorManager.onError(callerInfo, error.message, eErrorSeverity.medium);
        }

        function setPepStatus(pepStatus, onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var ajaxer = new TAjaxer(),
                params = 'dataPep=' + pepStatus;

            ajaxer.post(
                'TDALRegulation/setPepStatus',
                'Compliance/SetPepComplianceStatus',
                params,
                onLoadComplete,
                function (error) {
                    window.ErrorManager.onError('DalCompliance/setPepStatus', error.message, eErrorSeverity.medium);
                }
            );
        }

        function getPepStatus(onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var ajaxer = new TAjaxer();

            ajaxer.jsonPost(
                'TDALRegulation/getPepStatus',
                'Compliance/GetPepComplianceStatus',
                null,
                onLoadComplete,
                function () {
                    window.ErrorManager.onError('DalCompliance/getPepStatus', '', eErrorSeverity.medium);
                }
            );
        }

        function getNotificationsSettings(onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var ajaxer = new TAjaxer();

            return ajaxer.promises.get(
                'TDALRegulation/getNotificationsSettings',
                'Compliance/GetNotificationsSettings',
                '',
                onLoadComplete,
                function () {
                    window.ErrorManager.onError('DalCompliance/getNotificationsSettings', '', eErrorSeverity.medium);
                }
            );
        }

        function setNotificationsSettings(notificationsSettings, onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var params = JSON.stringify(notificationsSettings);
            var ajaxer = new TAjaxer();

            return ajaxer.promises.jsonPost(
                'TDALRegulation/setNotificationsSettings',
                'Compliance/SetNotificationsSettings',
                params,
                onLoadComplete,
                function (error) {
                    window.ErrorManager.onError('DalCompliance/setNotificationsSettings', error.message, eErrorSeverity.medium);
                }
            );
        }

        function logUploadResult(params, onLoadComplete) {
            var ajaxer = new TAjaxer();

            ajaxer.jsonPost(
                'TDALCompliance/LogUploadedDocsActionResult',
                'Compliance/LogUploadedDocsActionResult',
                JSON.stringify(params),
                onLoadComplete,
                function (error) {
                    window.ErrorManager.onError('DalCompliance/LogUploadedDocsActionResult', error.message, eErrorSeverity.medium);
                }
            );
        }

        function logUserShouldCompleteCdd(getRequestData) {
            var ajaxer = new TAjaxer();
            var requestData = JSON.stringify(getRequestData());
            var customerFailedAwareUrl = 'compliance/LogUserShouldCompleteCdd';

            ajaxer.jsonPost(
                'TDALCompliance/LogUserShouldCompleteCdd',
                customerFailedAwareUrl,
                requestData,
                null,
                function (error) {
                    window.ErrorManager.onError('DalCompliance/LogUserShouldCompleteCdd', error.message, eErrorSeverity.medium);
                }
            );
        }

        function getVerificationDocumentUrl(uploadDocType) {
            var ajaxer = new TAjaxer();

            return ajaxer.promises
                .get('TDALCompliance/getVerificationDocumentUrl', 'Compliance/GetVerificationDocumentUrl?uploadDocType=' + uploadDocType)
                .fail(function (error) {
                    window.ErrorManager.onError('DalCompliance/getVerificationDocumentUrl', error.message, eErrorSeverity.medium);
                });
        }

        function getUploadDocumentsData() {
            var ajaxer = new TAjaxer();

            return ajaxer.promises
                .post('TDALCompliance/getUploadDocumentsData', 'Compliance/GetUploadDocumentsData', null)
                .fail(function (error) {
                    window.ErrorManager.onError('DalCompliance/getUploadDocumentsData', error.message, eErrorSeverity.medium);
                });
        }

        function getDocumentsDataForAccountHub() {
            var ajaxer = new TAjaxer();

            return ajaxer.promises
                .post('TDALCompliance/getDocumentsDataForAccountHub', 'Compliance/GetDocumentsDataForAccountHub', null)
                .fail(function (error) {
                    window.ErrorManager.onError('DalCompliance/getDocumentsDataForAccountHub', error.message, eErrorSeverity.medium);
                });
        }

        function getwithdrawalrequeststatus(onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var ajaxer = new TAjaxer();

            ajaxer.post(
                'TDALCompliance/getwithdrawalrequeststatus',
                'Compliance/GetWithdrawalRequestStatus',
                null,
                function (result) { onLoadComplete(JSONHelper.STR2JSON('WithdrawalViewModel/onLoadComplete', result, eErrorSeverity.medium)); },
                function (error) {
                    window.ErrorManager.onError('DalCompliance/getwithdrawalrequeststatus', error.message, eErrorSeverity.medium);
                }
            );
        }

        function sendDepositConfirmation(onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var ajaxer = new TAjaxer();

            ajaxer.post(
                'TDALCompliance/sendDepositConfirmation',
                'Compliance/SendDepositConfirmation',
                null,
                onLoadComplete,
                function (error) {
                    window.ErrorManager.onError('DalCompliance/SendDepositConfirmation', error.message, eErrorSeverity.medium);
                }
            );
        }

        function sendExposureCoverage(coverage, onLoadComplete) {
            if (!general.isFunctionType(onLoadComplete)) {
                onLoadComplete = general.emptyFn;
            }

            var ajaxer = new TAjaxer();

            ajaxer.post(
                'TDALCompliance/SendExposureCoverage',
                'Compliance/SendExposureCoverage',
                coverage.toString(),
                onLoadComplete,
                function (error) {
                    window.ErrorManager.onError('DalCompliance/SendExposureCoverage', error.message, eErrorSeverity.medium);
                }
            );
        }

        function sendRequestAccess(requestAccessType) {
            var ajaxer = new TAjaxer();

            return ajaxer.promises
                .jsonPost(
                    'TDALCompliance/RequestAccess',
                    'Compliance/RequestAccess/?' + Math.random(),
                    JSON.stringify({ RequestType: requestAccessType })
                )
                .then(JSON.parse)
                .fail(function (error) {
                    onDalAjaxError(error, 'TDALCompliance/RequestAccess');
                    return Q.reject();
                });
        }

        return {
            setPepStatus: setPepStatus,
            getPepStatus: getPepStatus,
            logUploadResult: logUploadResult,
            getNotificationsSettings: getNotificationsSettings,
            setNotificationsSettings: setNotificationsSettings,
            logUserShouldCompleteCdd: logUserShouldCompleteCdd,
            getUploadDocumentsData: getUploadDocumentsData,
            getDocumentsDataForAccountHub: getDocumentsDataForAccountHub,
            getwithdrawalrequeststatus: getwithdrawalrequeststatus,
            sendDepositConfirmation: sendDepositConfirmation,
            sendExposureCoverage: sendExposureCoverage,
            sendRequestAccess: sendRequestAccess,
            getVerificationDocumentUrl: getVerificationDocumentUrl
        };
    }
);
function ObservableHashTable(ko, general, _keyProperty, _sortingParams) {
    var keyProperty = ko.observable(_keyProperty);
    var array = ko.observableArray([]);
    var keys = new THashTable(general);
    var sortingParams = (typeof (_sortingParams) == 'undefined') ? { enabled: false, sortProperty: '', asc: true} : _sortingParams;
    var sortPropreties = ko.observable(sortingParams);

    var clear = function () {
        keys.Clear();

        ko.utils.arrayForEach(array(), function(item) {
            if (item && typeof item.dispose === "function") {
                item.dispose();
            }
        });

        array.removeAll();
    };

    var getkey = function (value) {
        var underlineValue = ko.unwrap(value);
        return ko.toJS(underlineValue[keyProperty()]);
    };

    // isPeekMode (default = false ) is for AddRange
    // get a reference to our underlying array, push to it, then call .valueHasMutated()
    var checkAndAdd = function (value, index, isPeekMode) {
        // push sorted is defined on ko.observableArray.fn.pushSorted
        var targetArray = (isPeekMode && !sortingParams.enabled) ? array() : array;
        var key = getkey(value);

        if (!keys.HasItem(key)) {
            if (sortingParams.enabled) {
                targetArray.pushSorted(sortingParams.sortProperty, sortingParams.asc, value);
            } else if (typeof index == 'number') {
                targetArray.splice(index, 0, value);
            } else {
                targetArray.push(value);
            }

            keys.SetItem(key, value);

            return true;
        }

        return false;
    };

    var addAt = function (index, value) {
        return checkAndAdd(value, index);
    };

    var add = function (value) {
        return checkAndAdd(value);
    };

    //Adds the array of values to the internal observable collection with the rowBuilder function as an al
    // see preformace improvement
    // http://www.knockmeout.net/2012/04/knockoutjs-performance-gotcha.html
    var addRange = function (arrayOfValues) {
        for (var i = 0; i < arrayOfValues.length; i++) {
            checkAndAdd(arrayOfValues[i], null, true);
        }

        // on sorted object the add range is notifying mutation on each item: no performance improvement here
        if (!sortingParams.enabled) {
            array.valueHasMutated();
        }
    };

    var updateSorting = function (value) {
        if (sortingParams.enabled) {
            var item = value;
            array.remove(item);
            array.pushSorted(sortingParams.sortProperty, sortingParams.asc, value);
        }
    };

    var update = function (key, value) {
        var item = keys.GetItem(key);

        if (item !== null && ko.utils.updateShallowFrom(value, item, sortingParams.sortProperty)) {
            updateSorting(item);
        }
    };
    //use this to update even if the item exists - good for subscribers to items
    var updateAlways = function (key, value) {
        var item = keys.GetItem(key);

        if (item !== null && ko.utils.updateDeepFrom(value, item, sortingParams.sortProperty)) {
            updateSorting(item);
        }
    };

    var get = function (key) {
        return keys.GetItem(key);
    };

    var contains = function (key) {
        return keys.HasItem(key);
    };

    var remove = function (key) {
        var item = keys.GetItem(key);

        if (item === null) {
            return false;
        }

        keys.RemoveItem(key);
        array.remove(item);

        return true;
    };

    var initialSort = function () {
        array.sortByProperty(sortingParams.sortProperty, sortingParams.asc);
    };

    var reverse = function () {
        array.reverse();
    };

    var setSorting = function (enabled, sortProperty, asc) {
        var doInitialSort = ((!sortingParams.enabled && enabled) || (sortingParams.sortProperty != sortProperty));
        var doReverse = (sortingParams.asc != asc);

        sortingParams.enabled = enabled;
        sortingParams.sortProperty = sortProperty;
        sortingParams.asc = asc;

        sortPropreties(sortingParams);

        if (array().length > 1) {
            if (doInitialSort)
                initialSort();
            else if (doReverse)
                reverse();
        }
    };

    var hasItems = function() {
        return keys.hasItems();
    };

    return {
        Clear: clear,
        Add: add,
        AddRange: addRange,
        AddAt: addAt,
        Update: update,
        UpdateAlways: updateAlways,
        Get: get,
        Contains: contains,
        Remove: remove,
        SetSorting: setSorting,
        SortProperties: sortPropreties,
        Keys: keys,
        HasItems: hasItems,
        Values: array,
        KeyProperty: keyProperty
    };
}

define('helpers/ObservableHashTable', ['handlers/HashTable'], function(){ return ObservableHashTable });

/* globals eUploadDocumentType, eUploadDocumentStatus */
define(
    'generalmanagers/StatesManager',
    [
        'require',
        'knockout',
        'handlers/general',
        'initdatamanagers/Customer',
        'cachemanagers/ClientStateFlagsManager',
        'cachemanagers/PortfolioStaticManager',
        'dataaccess/dalCompliance',
        'Dictionary',
        'helpers/ObservableHashTable',
        'JSONHelper'
    ],
    function (require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            Customer = require('initdatamanagers/Customer'),
            ClientStateFlagsManager = require('cachemanagers/ClientStateFlagsManager'),
            PortfolioStaticManager = require('cachemanagers/PortfolioStaticManager'),
            Dictionary = require('Dictionary'),
            dalCompliance = require('dataaccess/dalCompliance'),
            JSONHelper = require('JSONHelper'),
            observableHashTable = require('helpers/ObservableHashTable');

        function StatesManager() {
            var stateNamesPriorities = {
                // the state names and priorities, the state container will initialize by this priority
                SystemMode: 1,
                DemoStatus: 2,
                IsActive: 3,
                AmlStatus: 4,
                KycStatus: 5,
                MarketState: 6,
                EquityAlert: 7,
                ExposureAlert: 8,
                ExposureCoverageAlert: 9,
                ServerErrorStatus: 10,
                PepStatus: 11,
                CddStatus: 12,
                Forbidden: 13,
                KycReviewStatus: 14,

                //documents status
                docProofOfID: 15,
                docProofOfResidence: 16,
                docCreditCardCopy: 17,
                docDepositConfirmation: 18,
                docWithdrawalPendingRequest: 19,
                docTaxCard: 20,
                docOtherDocuments: 21,

                //customer 'flags'
                Folder: 22,
                FolderType: 23,
                FolderTypeId: 24,
                fxDenied: 25,
                minDepositGroup: 26,
                signAgreementDate: 27,
                IsQuizPassed: 28,
                UploadDocumentsAfterFirstDepositCountdown: 29,
                SignAgreementCountdown: 30,
                CDDRenewalCountdown: 31
            };
            var states = {};
            var isGetDocumentsStatus = false;
            var isGetDocumentsForAccountHubStatus = false;
            var statesContainer = observableHashTable(ko, general, 'StateType', { enabled: true, sortProperty: 'Priority', asc: true });

            function TState(type, value, priority) {
                this.StateType = type;
                this.Value = ko.observable(value);
                this.Priority = priority;
            }

            function pushState(type, value, priority) {
                var state = new TState(type, value, priority);

                if (!statesContainer.Add(state)) {
                    statesContainer.UpdateAlways(type, state);
                }
            }

            function getStateValue(type) {
                var state = statesContainer.Get(type);

                if (state) {
                    return state.Value;
                }

                return null;
            }

            function init() {
                initStateValues();
                initStatesObject();
                registerToAPI();
            }

            function initStateValues() {
                //need to initilize by the order of priorities

                for (var stateName in stateNamesPriorities) {
                    if (stateNamesPriorities.hasOwnProperty(stateName)) {
                        pushState(stateNamesPriorities[stateName], eFlagState.Initial, stateNamesPriorities[stateName]);
                    }
                }
            }

            function initStatesObject() {
                //documents status
                states.docProofOfID = getStateValue(stateNamesPriorities.docProofOfID);
                states.docProofOfResidence = getStateValue(stateNamesPriorities.docProofOfResidence);
                states.docCreditCardCopy = getStateValue(stateNamesPriorities.docCreditCardCopy);
                states.docDepositConfirmation = getStateValue(stateNamesPriorities.docDepositConfirmation);
                states.docWithdrawalPendingRequest = getStateValue(stateNamesPriorities.docWithdrawalPendingRequest);
                states.docTaxCard = getStateValue(stateNamesPriorities.docTaxCard);
                states.docOtherDocuments = getStateValue(stateNamesPriorities.docOtherDocuments);

                //customer 'flags'
                states.Folder = getStateValue(stateNamesPriorities.Folder);
                states.FolderType = getStateValue(stateNamesPriorities.FolderType);
                states.FolderTypeId = getStateValue(stateNamesPriorities.FolderTypeId);
                states.fxDenied = getStateValue(stateNamesPriorities.fxDenied);
                states.minDepositGroup = getStateValue(stateNamesPriorities.minDepositGroup);
                states.signAgreementDate = getStateValue(stateNamesPriorities.signAgreementDate);

                states.EquityAlert = getStateValue(stateNamesPriorities.EquityAlert);
                states.ExposureAlert = getStateValue(stateNamesPriorities.ExposureAlert);
                states.ExposureCoverageAlert = getStateValue(stateNamesPriorities.ExposureCoverageAlert);

                states.MarketState = getStateValue(stateNamesPriorities.MarketState);
                states.SystemMode = getStateValue(stateNamesPriorities.SystemMode);

                states.IsActive = getStateValue(stateNamesPriorities.IsActive);
                states.AmlStatus = getStateValue(stateNamesPriorities.AmlStatus);

                states.DemoStatus = getStateValue(stateNamesPriorities.DemoStatus);
                states.KycStatus = getStateValue(stateNamesPriorities.KycStatus);

                states.PepStatus = getStateValue(stateNamesPriorities.PepStatus);
                states.CddStatus = getStateValue(stateNamesPriorities.CddStatus);

                states.KycReviewStatus = getStateValue(stateNamesPriorities.KycReviewStatus);

                states.CDDRenewalCountdown = getStateValue(stateNamesPriorities.CDDRenewalCountdown);
                states.SignAgreementCountdown = getStateValue(stateNamesPriorities.SignAgreementCountdown);
                states.UploadDocumentsAfterFirstDepositCountdown = getStateValue(stateNamesPriorities.UploadDocumentsAfterFirstDepositCountdown);

                states.isIntDebit = ko.computed(function () {
                    return this.Folder() === eFolder.IntDebit;
                }, states);

                states.IsDemo = ko.computed(function () {
                    return this.DemoStatus() === eFlagState.Active;
                }, states);

                states.IsMarketClosed = ko.computed(function () {
                    return this.MarketState() === eCSFlagStates.NotActive;
                }, states);

                states.IsPortfolioInactive = ko.computed(function () {
                    return this.IsActive() === false;
                }, states);

                states.IsAmlRestricted = ko.computed(function () {
                    var res = this.AmlStatus();
                    return res === eAMLStatus.Restricted || res === eAMLStatus.Unverified;
                }, states);

                states.IsAmlPending = ko.computed(function () {
                    var res = this.AmlStatus();
                    return res === eAMLStatus.Pending;
                }, states);

                states.IsKycStatusRequired = ko.computed(function () {
                    var res = this.KycStatus();
                    return res === eKYCStatus.NotComplete;
                }, states);

                states.IsKycReviewStatusRequired = ko.computed(function () {
                    return (this.KycStatus() === eKYCStatus.Failed) && (this.KycReviewStatus() === eKYCReviewStatus.NotReviewed || this.KycReviewStatus() === eKYCReviewStatus.Review || this.KycReviewStatus() === eKYCReviewStatus.Tested);
                }, states);

                states.IsCddStatusNotComplete = ko.computed(function () {
                    var res = this.CddStatus();
                    return res === eCDDStatus.NotComplete;
                }, states);

                states.IsCddStatusRequired = ko.computed(function () {
                    var res = this.CddStatus();
                    return res === eCDDStatus.NotComplete || res === eCDDStatus.Complete;
                }, states);

                states.IsPepRequired = ko.computed(function () {
                    return this.PepStatus() == ePEPStatus.Required;
                }, states);

                states.IsActiveButNotSinceTradingBonus = ko.computed(function () {
                    return this.IsActive() == eFlagState.Active && Customer.prop.customerType !== eCustomerType.TradingBonus;
                }, states);

                states.IsTradingBonusGoingToCDDAfterDeposit = ko.computed(function () {
                    var res = this.CddStatus();
                    return (Dictionary.GetItem('TradingBonusGoesToCDDAfterDeposit', 'application_configuration') === '1' && Customer.prop.customerType === eCustomerType.TradingBonus && res === eCDDStatus.NotRequired);
                }, states);

                states.IsCddOrKycRequired = ko.computed(function () {
                    return this.KycStatus() !== eKYCStatus.NotRequired || this.CddStatus() !== eCDDStatus.NotRequired;
                }, states);

                states.ServerErrorStatus = getStateValue(stateNamesPriorities.ServerErrorStatus).extend({ notify: 'always' });

                states.Forbidden = getStateValue(stateNamesPriorities.Forbidden).extend({ notify: 'always' });

                states.IsCddStatusNotRequired = ko.computed(function () {
                    return this.CddStatus() === eCDDStatus.NotRequired;
                }, states);

                // should redirect to CDD
                states.shouldCddRedirect = ko.computed(function () {
                    return this.IsActive() == eFlagState.Active && (
                        this.CddStatus() === eCDDStatus.NotComplete ||
                        this.KycStatus() === eKYCStatus.NotComplete || (
                            this.KycStatus() === eKYCStatus.Failed && (
                                this.KycReviewStatus() === eKYCReviewStatus.NotReviewed ||
                                this.KycReviewStatus() === eKYCReviewStatus.Review ||
                                this.KycReviewStatus() === eKYCReviewStatus.Tested)
                        )
                    );
                }, states);

                states.IsQuizPassed = getStateValue(stateNamesPriorities.IsQuizPassed);

                states.IsCDDRestricted = ko.observable(false);
            }

            function onCSFlagsChanged(csFlags) {
                pushState(stateNamesPriorities.EquityAlert, csFlags.equityAlert, stateNamesPriorities['EquityAlert']);
                pushState(stateNamesPriorities.ExposureAlert, csFlags.exposureAlert, stateNamesPriorities['ExposureAlert']);
                pushState(stateNamesPriorities.ExposureCoverageAlert, csFlags.exposureCoverageAlert, stateNamesPriorities['ExposureCoverageAlert']);
                pushState(stateNamesPriorities.MarketState, csFlags.marketState, stateNamesPriorities['MarketState']);
                pushState(stateNamesPriorities.SystemMode, csFlags.systemMode, stateNamesPriorities['SystemMode']);
            }

            function onPortfolioStaticChanged(portfolioStatic) {
                // The positions of pushState calls is important!
                pushState(stateNamesPriorities.PepStatus, portfolioStatic.pepStatus, stateNamesPriorities['PepStatus']);
                pushState(stateNamesPriorities.CddStatus, portfolioStatic.cddStatus, stateNamesPriorities['CddStatus']);
                pushState(stateNamesPriorities.AmlStatus, portfolioStatic.amlStatus, stateNamesPriorities['AmlStatus']);
                pushState(stateNamesPriorities.IsActive, portfolioStatic.isActive, stateNamesPriorities['IsActive']);
                pushState(stateNamesPriorities.DemoStatus, portfolioStatic.isDemo ? eFlagState.Active : eFlagState.NotActive, stateNamesPriorities['DemoStatus']);
                pushState(stateNamesPriorities.KycStatus, portfolioStatic.kycStatus, stateNamesPriorities['KycStatus']);
                pushState(stateNamesPriorities.KycReviewStatus, portfolioStatic.kycReviewStatus, stateNamesPriorities['KycReviewStatus']);

                updateCustomer();

                updateCustomerData();
            }

            function updateCustomer() {
                Customer
                    .GetCustomer()
                    .then(function (response) {
                        var data = JSONHelper.STR2JSON('StatesManager:updateCustomer', response);

                        if (!general.isNullOrUndefined(data)) {
                            states.Folder(data.folder);
                            states.FolderType(data.folderType);
                            states.FolderTypeId(data.folderTypeId);
                            states.fxDenied(data.allowFXnet == 0);
                            states.minDepositGroup(data.minDepositGroup);
                            states.signAgreementDate(general.str2Date(data.signAgreementDate));
                            ko.postbox.publish('customer-data-loaded');
                        }
                    })
                    .done();
            }

            function updateDocumentStatus() {
                dalCompliance
                    .getUploadDocumentsData()
                    .then(processUploadDocumentsData);
            }

            function updateCustomerData() {
                dalCompliance
                    .getDocumentsDataForAccountHub()
                    .then(processCustomerData);
            }

            function processUploadDocumentsData(data) {
                var docs = JSONHelper.STR2JSON('StatesManager/processUploadDocumentsData', data, eErrorSeverity.medium);
                if (docs) {
                    processDocsData(docs);
                }
            }

            function processCustomerData(data) {
                var customerData = JSONHelper.STR2JSON('StatesManager/processCustomerData', data, eErrorSeverity.medium);

                if (customerData) {
                    if (customerData.DocumentsData) {
                        processDocsData(customerData.DocumentsData);
                    }

                    processCustomerStatuses(customerData);
                }
            }

            function processCustomerStatuses(customerData) {
                states.IsQuizPassed(customerData.IsQuizPassed);

                if (general.isNumber(customerData.CDDAccess)) {
                    states.IsCDDRestricted(states.CddStatus() === eCDDStatus.Complete && customerData.CDDAccess === eCDDAccess.Restricted);
                }

                if (general.isNumber(customerData.UploadDocumentsAfterFirstDepositCountdown)) {
                    states.UploadDocumentsAfterFirstDepositCountdown(customerData.UploadDocumentsAfterFirstDepositCountdown);
                }

                if (general.isNumber(customerData.SignAgreementCountdown)) {
                    states.SignAgreementCountdown(customerData.SignAgreementCountdown);
                }

                if (general.isNumber(customerData.CDDRenewalCountdown)) {
                    states.CDDRenewalCountdown(customerData.CDDRenewalCountdown);
                }
            }

            function processDocsData(docs) {
                if (docs.Data) {
                    docs.Data.forEach(function (docDataFromServer) {
                        if (docDataFromServer.DocumentTypeID === eUploadDocumentType.ProofOfID) {
                            states.docProofOfID(docDataFromServer.DocumentStatus);
                        }
                        else if (docDataFromServer.DocumentTypeID === eUploadDocumentType.ProofOfResidence) {
                            states.docProofOfResidence(docDataFromServer.DocumentStatus);
                        }
                        else if (docDataFromServer.DocumentTypeID === eUploadDocumentType.CreditCardCopy) {
                            states.docCreditCardCopy(docDataFromServer.DocumentStatus);
                        }
                        else if (docDataFromServer.DocumentTypeID === eUploadDocumentType.DepositConfirmation) {
                            states.docDepositConfirmation(docDataFromServer.DocumentStatus);
                        }
                        else if (docDataFromServer.DocumentTypeID === eUploadDocumentType.WithdrawalPendingRequest) {
                            states.docWithdrawalPendingRequest(docDataFromServer.DocumentStatus);
                        }
                        else if (docDataFromServer.DocumentTypeID === eUploadDocumentType.TaxCard) {
                            states.docTaxCard(docDataFromServer.DocumentStatus);
                        }
                        else if (docDataFromServer.DocumentTypeID === eUploadDocumentType.OtherDocuments) {
                            states.docOtherDocuments(docDataFromServer.DocumentStatus);
                        }
                    });
                }
            }

            function registerToAPI() {
                ClientStateFlagsManager.OnChange.Add(onCSFlagsChanged);
                PortfolioStaticManager.OnChange.Add(onPortfolioStaticChanged);

            }

            function startGetDocumentsStatus() {
                if (!isGetDocumentsStatus) {
                    isGetDocumentsStatus = true;
                    updateDocumentStatus();
                }
            }

            function startGetCustomerData() {
                if (!isGetDocumentsForAccountHubStatus) {
                    isGetDocumentsForAccountHubStatus = true;
                    updateCustomerData();
                }
            }

            function initFromCustomer(customerCompliance) {
                pushState(stateNamesPriorities.PepStatus, customerCompliance.PepStatus, stateNamesPriorities['PepStatus']);
                pushState(stateNamesPriorities.CddStatus, customerCompliance.CddStatus, stateNamesPriorities['CddStatus']);
                pushState(stateNamesPriorities.AmlStatus, customerCompliance.AmlStatus, stateNamesPriorities['AmlStatus']);
                pushState(stateNamesPriorities.IsActive, customerCompliance.IsActive, stateNamesPriorities['IsActive']);
                pushState(stateNamesPriorities.KycStatus, customerCompliance.KycStatus, stateNamesPriorities['KycStatus']);
                pushState(stateNamesPriorities.KycReviewStatus, customerCompliance.KycReviewStatus, stateNamesPriorities['KycReviewStatus']);
            }

            function getStates() {
                return states;
            }

            return {
                StartGetDocumentsStatus: startGetDocumentsStatus,
                StartGetCustomerData: startGetCustomerData,
                Init: init,
                StateValue: getStateValue,
                States: states,
                GetStates: getStates,
                PushState: pushState,
                StatePropertiesEnum: stateNamesPriorities, //  ComputedHandle: computedHandle
                InitFromCustomer: initFromCustomer
            };
        }

        var module = window.$statesManager = new StatesManager();

        return module;
    }
);
/*
 * require
 * Enum.js for kycStatus
 * $viewModelsManager for $viewModelsManager.VManager.SwitchViewVisible
 */
define(
    'alerts/QuestionnaireValidationAlert',
    [
        "require",
        'devicealerts/Alert',
        "Dictionary",
        "dataaccess/dalKycClientQuestionnaire",
        'generalmanagers/StatesManager',
        "initdatamanagers/Customer"
    ],
    function (require) {
        var AlertBase = require('devicealerts/Alert');
        var Dictionary = require("Dictionary");
        var dal = require('dataaccess/dalKycClientQuestionnaire');
        var statesManager = require('generalmanagers/StatesManager');
        var customer = require("initdatamanagers/Customer");

        var QuestionnaireValidationAlert = function () {
            // inheritance with Constructor function
            var self = AlertBase.call(this),
                alertsContents = {
                    title: "lblImportent",
                    messages: ["KYC_Failed_p1", "KYC_Failed_p2", "KYC_Failed_p3", "KYC_Failed_p4"],
                    buttons: ["btnIAmAware", "btnIAmExit"]
                };
            var popUpManager = window.PopUpManager;
            // public virtual: different implementation on desktop version where go to trading view is close current 
            // external window.
            self.goToTradingView = function () {
                require(['devicemanagers/ViewModelsManager'], function (viewModelsManager) {
                    return viewModelsManager.VManager.SwitchViewVisible(customer.prop.startUpForm);
                });
            };

            self.goToDepositView = function () {
                require(['devicemanagers/ViewModelsManager'], function (viewModelsManager) {
                    return viewModelsManager.VManager.RedirectToForm(eForms.Deposit);
                });
            };

            self.defer = Q.defer();

            self.alertName = "ClientQuestionnaire";
            self.visible(false);

            // implement alert interface
            self.Init = function () { };

            // implement alert interface
            self.redirectAfterResponseAlert = function () {
                // trading bonus or not deposit required - send to main
                if (customer.prop.customerType === eCustomerType.TradingBonus || Dictionary.GetItem('preDepositRequired') !== "1") {
                    self.goToTradingView();
                    return;
                } else {
                    self.goToDepositView();
                    return;
                }
            };

            // public this manager main entry point
            self.popAlert = function () {
                var buttonProperties = self.buttonProperties,
                    translatedMessages = [],
                    i,
                    len,
                    failedAwareCallback = function () {
                        if (!window.require) {
                            throw new Error("KYC: logic error: compliance dal must be called after require is loaded");
                        }

                        self.visible(false);
                        dal.postCustomerFailedAware(function (responseObj) {
                            if (!responseObj || (responseObj.status === 1 && responseObj.result === true)) {
                                statesManager.States.KycStatus(eKYCStatus.FailedAware);
                                self.defer.resolve();
                            }
                        });

                    };

                // create buttons

                self.buttons.removeAll();

                // 1. im aware button
                self.buttons.push(buttonProperties(
                    Dictionary.GetItem(alertsContents.buttons[0]),
                    function () {
                        failedAwareCallback();
                        $statesManager.States.KycStatus(eKYCStatus.FailedAware);
                    })
                );

                // 2. cancel button
                self.buttons.push(buttonProperties(
                    Dictionary.GetItem(alertsContents.buttons[1]),
                    function () {

                        if (Dictionary.GetItem('preDepositRequired', 'application_configuration') !== "1") {
                            self.visible(false);
                        } else {
                            self.visible(false);
                            popUpManager.ClosePopup();
                        }
                        self.defer.resolve();
                    })
                );


                for (i = 0, len = alertsContents.messages.length; i < len; i++) {
                    translatedMessages.push(Dictionary.GetItem(alertsContents.messages[i]));
                }

                // parameters : alertType, title, body, messages, properties, withoutLineBrakes
                AlertsManager.UpdateAlert(
                    AlertTypes.ClientQuestionnaire,
                    Dictionary.GetItem(alertsContents.title),
                    undefined, // eslint-disable-line
                    translatedMessages
                );


                // show the alert
                AlertsManager.PopAlert(AlertTypes.ClientQuestionnaire);

                return self.defer.promise;
            };

            // implement alert base interface
            self.GetAlert = self;

            return self;
        };

        return QuestionnaireValidationAlert;
    }
);

define('devicealerts/CddQuestionnaireAlert', ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary");

    var CddQuestionnaireAlert = function () {

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = "CddClientQuestionnaire";
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.body(Dictionary.GetItem('cddNOtCompleteTryOpenDeal'));
            inheritedAlertInstance.title(Dictionary.GetItem('lblImportent'));
            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
               new inheritedAlertInstance.buttonProperties(
                   Dictionary.GetItem("btnCompleteQuestionnaire"),
                   function () {
                       inheritedAlertInstance.visible(false);
                       closeDialog();
                       require(['devicemanagers/ViewModelsManager'], function ($viewModelsManager) {
                           $viewModelsManager.VManager.SwitchViewVisible(eForms.ClientQuestionnaire);
                       });
                   },
                   'btnCancel colored'
               )
           );
        };

        var closeDialog = function () {
            DialogViewModel.close();
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return CddQuestionnaireAlert;
});


define('devicealerts/SignalsDisclaimerAlert', ["require",'handlers/Cookie', 'devicealerts/Alert', "knockout"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        CookieHandler = require('handlers/Cookie'),
        ko = require("knockout");

    var SignalsDisclaimerAlert = function () {

        var tradingSignalsDisclaimerAlert = new AlertBase();
        var disclaimerAlertProperties = {
            prepareForShow: prepareForShowHandler
        };

        var init = function () {
            Object.assign(tradingSignalsDisclaimerAlert, disclaimerAlertProperties);
        };

        function prepareForShowHandler() {
            tradingSignalsDisclaimerAlert.alertName = 'SignalsDisclaimerAlert';
            tradingSignalsDisclaimerAlert.body(Dictionary.GetItem('LitContent', 'controls_ctlsignalcompliance'));
            tradingSignalsDisclaimerAlert.title(Dictionary.GetItem('LitTitle', 'controls_ctlsignalcompliance'));
            tradingSignalsDisclaimerAlert.checked = ko.observable(false);
            tradingSignalsDisclaimerAlert.lblChecked = Dictionary.GetItem('ChkAgree', 'controls_ctlsignalcompliance');
            tradingSignalsDisclaimerAlert.isSetComplianceDate = ko.observable(false);
            tradingSignalsDisclaimerAlert.buttons([
                new tradingSignalsDisclaimerAlert.buttonProperties(
                    Dictionary.GetItem('BtnContinue', 'controls_ctlsignalcompliance'),
                    function () {
                        if (!tradingSignalsDisclaimerAlert.checked()) {
                            return;
                        }
                        CookieHandler.CreateCookie("TsComplianceDate", new Date().toDateString(), (new Date()).AddMonths(12));
                        tradingSignalsDisclaimerAlert.isSetComplianceDate(true);
                        tradingSignalsDisclaimerAlert.visible(false);
                    },
                    'disclaimer-button-continue'
                ),
                new tradingSignalsDisclaimerAlert.buttonProperties(
                    Dictionary.GetItem('BtnClose', 'controls_ctlsignalcompliance'),
                    function () {
                        tradingSignalsDisclaimerAlert.visible(false);
                    },
                    'disclaimer-button-close'
                )
            ]);
        }

        return {
            Init: init,
            GetAlert: tradingSignalsDisclaimerAlert
        };
    };
    return SignalsDisclaimerAlert;
});

define('devicealerts/SimpleClientAlert', ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary");

    var SimpleClientAlert = function () {

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = 'SimpleClientAlert';
            inheritedAlertInstance.visible(false);
            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    function () {
                        inheritedAlertInstance.visible(false);
                    },
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return SimpleClientAlert;
});
define("alerts/KnowledgeQuestionnaireAlert", ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        Dictionary = require("Dictionary");

    var KnowledgeQuestionnaireAlert = function () {
        var self = AlertBase.call(this),
            alertsContents = {
                titles: ["pleaseNoteTitle", "tradingKnowledgeTitle", "tradingKnowledgeTitle", "tradingKnowledgeTitle", "questionnaireTitle"],
                messages: [["KYC_Knowledge_Retry_p1"], ["KYC_Knowledge_Review_p1"], ["KYC_Knowledge_Tested_p1"], ["KYC_Knowledge_Inappropriate_p1"], ["KYC_Knowledge_Unsuitable_p1"]],
                buttons: ["btnRetry", "btnContinue", "btnRetry", "btnContinue", "btnContinue"]
            };

        self.alertName = "ClientKnowledgeQuestionnaire";
        self.visible(false);

        self.Init = function () { };

        self.popAlert = function (kycKnowledgeCallback, knowledgeAlertType) {
            var buttonProperties = self.buttonProperties,
                translatedMessages = [], i, len;

            self.buttons.removeAll();

            self.buttons.push(buttonProperties(
                Dictionary.GetItem(alertsContents.buttons[knowledgeAlertType]),
                function () {
                    self.visible(false);
                    kycKnowledgeCallback();
                })
            );

            for (i = 0, len = alertsContents.messages[knowledgeAlertType].length; i < len; i++) {
                translatedMessages.push(Dictionary.GetItem(alertsContents.messages[knowledgeAlertType][i]));
            }

            AlertsManager.UpdateAlert(
                AlertTypes.ClientKnowledgeQuestionnaire,
                Dictionary.GetItem(alertsContents.titles[knowledgeAlertType]),
                '',
                translatedMessages
            );

            AlertsManager.PopAlert(AlertTypes.ClientKnowledgeQuestionnaire);
        };

        self.GetAlert = self;

        return self;
    };

    return KnowledgeQuestionnaireAlert;
});

define('devicealerts/GeneralCancelableAlert', ["require", 'devicealerts/Alert', "Dictionary"], function (require) {
    var AlertBase = require('devicealerts/Alert');
    var Dictionary = require("Dictionary");

    var GeneralCancelableAlert = function () {

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.setDefaultTitle = function () { }
            inheritedAlertInstance.alertName = 'devicealerts/GeneralCancelableAlert';
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.title(Dictionary.GetItem("msgtype240") || Dictionary.GetItem("GenericAlert"));
            createButtons();
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };

    return GeneralCancelableAlert;
});
define(
    'alerts/DealsClosedServerResponseAlert',
    [
        'require',
        'handlers/general',
        'devicealerts/Alert',
        'Dictionary',
        'initdatamanagers/InstrumentsManager',
        'dataaccess/dalCommon',
        'JSONHelper'
    ],
    function DealsClosedServerResponseAlertDef(require) {
        var AlertBase = require('devicealerts/Alert'),
            general = require('handlers/general'),
            instrumentsManager = require('initdatamanagers/InstrumentsManager'),
            Dictionary = require('Dictionary'),
            JSONHelper = require('JSONHelper'),
            dalCommon = require('dataaccess/dalCommon');

        var DealsClosedServerResponseAlert = function DealsClosedServerResponseAlertClass() {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'DealsClosedServerResponseAlert';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.prepareForShow = prepareForShow;
                createButtons();
            };

            var prepareForShow = function () {
                this.dataRecords = this.properties.serverResponses;
                var title = (1 >= this.dataRecords.length) ? Dictionary.GetItem('CloseDealConfirmation') : Dictionary.GetItem('CloseDealsConfirmation');

                this.title(title);

                for (var idx = 0; idx < this.dataRecords.length; idx++) {
                    var data = this.dataRecords[idx],
                        requestItem = this.properties.requestData.find(function (item) {
                            return item.positionNumber == data.itemId;
                        });

                    var instrument = instrumentsManager.GetInstrument(data.instrumentId ? data.instrumentId : (requestItem ? requestItem.instrumentID : '')),
                        translateResult = function (result) {
                            var msg = Dictionary.GetItem(result.msgKey || 'InternalError'),
                                args = result.arguments;

                            if (general.isNullOrUndefined(args)) {
                                return msg;
                            }

                            return String.format(msg, args);
                        };

                    if (data.status !== eResult.Success) {
                        switch (data.result) {
                            case 'OrderError116':
                            case 'OrderError120':
                                data.arguments = JSONHelper.STR2JSON('DealsClosedServerResponseAlert:prepareForShow', data.responseArgumentsJson);

                                var instrumentId = data.arguments.pop(),
                                    translatedInstrument = $instrumentTranslationsManager.Long(instrumentId);

                                if (translatedInstrument) {
                                    data.arguments[0] = translatedInstrument;
                                }

                                instrument = $instrumentsManager.GetInstrument(instrumentId);
                                data.msgKey = data.result;
                                data.message = translateResult(data);
                                break;

                            default:
                                var key = !general.isStringType(data.result) || Dictionary.ValueIsEmpty(data.result) ? 'InternalError' : data.result;
                                data.message = Dictionary.GetItem(key);
                                break;
                        }
                    }

                    general.extendType(data, {
                        amount: data.usdValue,
                        openedRate: requestItem ? requestItem.dealRate || requestItem.orderRate : '',
                        instrumentId: instrument ? instrument.id : '',
                        closingRate: requestItem ? data.rateCalc : '',
                        pl: data.plAccountCcy,
                        orderDir: data.direction ? '1closed' : '0closed',
                        baseSymbolId: instrument ? instrument.baseSymbol : '',
                        otherSymbolId: instrument ? instrument.otherSymbol : ''
                    });
                }

                var firstValidResult = general.objectFirst(this.dataRecords, function (result) {
                    return result.status == 1;
                });

                this.plTotal = firstValidResult ? firstValidResult.bulkPlAccountCcy : '0';

                this.rowsValid = this.dataRecords.reduce(function getSum(total, result) {
                    return total + result.status;
                }, 0);

                var closedDealsSucceeded = this.dataRecords.filter(function (result) { return result.status == 1; }).length;

                if (this.dataRecords.length <= 1) {
                    if (0 < closedDealsSucceeded) {
                        this.body(Dictionary.GetItem('YourDealWasClosedSuccessfully'));
                    }
                    else {
                        this.body(Dictionary.GetItem('YourDealWasNotClosedSuccessfully'));
                    }
                }
                else {
                    this.body(String.format(Dictionary.GetItem('countOfYourDealsWhereClosedSuccessfully'), closedDealsSucceeded));
                }
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();

                // override base on Back => onOk
                var onOk = inheritedAlertInstance.onBack = function () {
                    var redirectToViewType,
                        viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || '';

                    if (!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)) {
                        redirectToViewType = inheritedAlertInstance.properties.redirectToView;
                    }

                    if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                        inheritedAlertInstance.properties.okButtonCallback();
                    }

                    inheritedAlertInstance.visible(false);

                    if (!general.isEmptyValue(redirectToViewType)) {
                        if (redirectToViewType === 'exit') {
                            dalCommon.Logout(eLoginLogoutReason.dealsClosedServerResponseAlert_exit);
                        }
                        else {
                            require(['devicemanagers/ViewModelsManager'], function (viewModelsManager) {
                                viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);
                            });
                        }
                    }
                };

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem('ok'),
                        onOk,
                        'btnOk'
                    )
                );
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance,
            };
        };

        return DealsClosedServerResponseAlert;
    }
);
define('devicemanagers/StatesManager', ['generalmanagers/StatesManager'], function StatesManager(statesManager) {
    return statesManager;
});
define(
    "viewmodels/SeamlessPermissionsBase",
    [
        "require",
        'handlers/general',
        "initdatamanagers/Customer",
        "Dictionary"
    ],
    function (require) {
        var Customer = require("initdatamanagers/Customer"),
            general = require('handlers/general'),
            Dictionary = require("Dictionary");

        var SeamlessPermissionsBase = function () {

            function checkSeamless() {
                return Customer.prop.isSeamless === true;
            }


            function registerLeadType(formId, actionName, args) {
                var from = '';

                if (formId && formId === eForms.Deposit) {
                    from = "&" + registerParams.traderFrom + "=" + eFormActions.deposit;
                }

                if (!general.isNullOrUndefined(actionName)) {
                    if (actionName.toLowerCase() === eFormActions.newDeal.toLowerCase()) {
                        from = "&" + registerParams.traderFrom + "=" + eFormActions.newDeal;
                    } else if (actionName.toLowerCase() === eFormActions.newLimit.toLowerCase()) {
                        from = "&" + registerParams.traderFrom + "=" + eFormActions.newLimit;
                    }
                }
               
                if (args && args.register) {
                    from += '&' + args.register;
                }

                require(['managers/viewsmanager'], function ($viewsManager) {
                    window.location.href = Dictionary.GetItem("SeamlessRegisterLink") + "&saprocess=&trader_viewid=" + $viewsManager.Activeform().type + from;
                })
            }

            function isFormRestricted(eForm, allowedForms, allowedDemoForms) {
                if (!checkSeamless())
                    return false;
                if (!Customer.prop.isDemo)
                    return allowedForms.indexOf(eForm) < 0;
                else
                    return allowedForms.indexOf(eForm) < 0 && allowedDemoForms.indexOf(eForm) < 0; 
            }

            function isFormVisibleRestricted(eForm, visibleRestrictedForms) {
                if (!checkSeamless())
                    return false;
                return visibleRestrictedForms.indexOf(eForm) !== -1; 
            }

            function isActionRestricted(actionName, restrictedActions, restrictedDemoActions) {
                if (!checkSeamless())
                    return false;
                if (Customer.prop.isDemo === true)
                    return restrictedDemoActions.indexOf(actionName) !== -1;
                return restrictedActions.indexOf(actionName) !== -1;
            }

            function getMessage(formId) {
                var message;
                switch (formId) {
                    case eForms.Deposit:
                        message = Dictionary.GetItem('SeamlessRegisterDeposit');
                        break;
                    case eForms.Withdrawal:
                        message = Dictionary.GetItem('SeamlessRegisterWithdrawal');
                        break;
                    case eForms.ClientQuestionnaire:
                        message = Dictionary.GetItem('SeamlessRegisterQuestionnaire');
                        break;
                    default:
                        message = Dictionary.GetItem('SeamlessRegister');
                }
                return message;
            }

            function redirectToAllowedForm(allowedForms, allowedDemoForms, visibleRestrictedForms) {
                var eForm = $viewModelsManager.VManager.Activeform().type;
                require(['managers/viewsmanager'], function ($viewsManager) {
                    if (isFormRestricted(eForm, allowedForms, allowedDemoForms) || isFormVisibleRestricted(eForm, visibleRestrictedForms))
                        $viewsManager.SwitchViewVisible(Customer.prop.mainPage);
                });
            }

            return {
                CheckSeamless: checkSeamless,
                IsFormRestricted: isFormRestricted,
                IsActionRestricted: isActionRestricted,
                RegisterLeadType: registerLeadType,
                GetMessage: getMessage,
                IsFormVisibleRestricted: isFormVisibleRestricted,
                RedirectToAllowedForm: redirectToAllowedForm
            };
        };
        return SeamlessPermissionsBase; 
    }
);
define(
    'devicecustommodules/SeamlessPermissionsModule',
    [
        'require',
        'enums/alertenums',
        'handlers/general',
        'Dictionary',
        'viewmodels/SeamlessPermissionsBase',
        'customEnums/ViewsEnums'
    ],
    function SeamlessPermissionsModuleDef(require) {
        var Dictionary = require('Dictionary'),
            general = require('handlers/general'),
            SeamlessPermissionsBase = require('viewmodels/SeamlessPermissionsBase');

        var SeamlessPermissionsModule = general.extendClass(SeamlessPermissionsBase, function SeamlessPermissionsModuleClass() {
            var parent = this.parent,
                allowedForms = [eForms.Deals, eForms.Statement, eForms.ActivityLog, eForms.Tutorials, eForms.EducationalTutorials, eForms.AdvinionChart, eForms.TransactionsReport],
                allowedDemoForms = [];

            var restrictedActions = [
                'logout',
                'newDeal',
                'newLimit',
                'signals',
                'addFavorite',
                'accountNumber'
            ];

            var restrictedDemoActions = [
                'accountNumber',
                'signals',
                'logout'
            ];

            var visibleRestrictedForms = [eForms.Tutorials, eForms.EducationalTutorials];

            function isFormVisibleRestricted(eForm) {
                return parent.IsFormVisibleRestricted(eForm, visibleRestrictedForms);
            }

            function isFormRestricted(eForm) {
                return parent.IsFormRestricted(eForm, allowedForms, allowedDemoForms);
            }

            function isActionRestricted(actionName) {
                return parent.IsActionRestricted(actionName, restrictedActions, restrictedDemoActions);
            }

            function popAlert(formId, actionName, viewArgs) {
                var message = parent.GetMessage(formId);

                var buttonsProperties = {
                    onClose: function () {
                        parent.RedirectToAllowedForm(allowedForms, allowedDemoForms, visibleRestrictedForms);
                    },
                    okButtonCaption: Dictionary.GetItem('RegisterForFree'),
                    okButtonCallback: function () {
                        parent.RegisterLeadType(formId, actionName, viewArgs);
                    }
                };

                require(['devicemanagers/AlertsManager'], function (alertsManager) {
                    alertsManager.UpdateAlert(AlertTypes.GeneralOkAlert,
                        Dictionary.GetItem('PleaseNote'),
                        message,
                        null,
                        buttonsProperties);

                    alertsManager.PopAlert(AlertTypes.GeneralOkAlert);
                });
            }

            return {
                CheckSeamless: parent.CheckSeamless,
                PopAlert: popAlert,
                IsFormRestricted: isFormRestricted,
                IsActionRestricted: isActionRestricted,
                RegisterLeadType: parent.RegisterLeadType,
                IsFormVisibleRestricted: isFormVisibleRestricted
            };
        });

        return new SeamlessPermissionsModule();
    }
);
define(
    'modules/permissionsmodule',
    [
        'require',
        'modules/systeminfo',
        'devicecustommodules/SeamlessPermissionsModule'
    ],
    function PermissionsModule(require) {
        var systemInfo = require('modules/systeminfo'),
            seamlessPermissionsModule = require('devicecustommodules/SeamlessPermissionsModule');

        var actions = [
            'commonLogout',
            'uploadDocuments',
            'chat',
            'deposit',
            'tutorials',
            'apiIM',
            'gtm',
            'customerProfile',
            'changePassword',
            'notificationsSettings',
            'addEditRemovePriceAlert',
            'requestTradingSignalsAccess'
        ];

        function checkPermissions(actionName) {
            if (isRestrictedUser() &&
                actions.indexOf(actionName) !== -1) {
                return false;
            }

            return true;
        }

        function checkActionAllowed(actionName, popAlert, actionArgs) {
            if (seamlessPermissionsModule.IsActionRestricted(actionName)) {
                if (popAlert) {
                    seamlessPermissionsModule.PopAlert(null, actionName, actionArgs);
                }

                return false;
            }

            return true;
        }

        function checkFormPermissions(form, popAlert, formArgs) {
            if (seamlessPermissionsModule.IsFormRestricted(form)) {
                if (popAlert) {
                    seamlessPermissionsModule.PopAlert(form, null, formArgs);
                }

                return false;
            }

            if (seamlessPermissionsModule.IsFormVisibleRestricted(form)) {
                seamlessPermissionsModule.PopAlert(form, null, formArgs);
            }

            return true;
        }

        function isRestrictedUser() {
            return systemInfo.get('isRestrictedUser', false);
        }

        function hasTradingPermission() {
            return systemInfo.get('hasTradingPermission', false);
        }

        function isTradingUser() {
            return isRestrictedUser() && hasTradingPermission();
        }

        function registerLeadType() {
            seamlessPermissionsModule.RegisterLeadType();
        }

        return {
            CheckPermissions: checkPermissions,
            CheckFormPermissions: checkFormPermissions,
            CheckActionAllowed: checkActionAllowed,
            IsRestrictedUser: isRestrictedUser,
            RegisterLeadType: registerLeadType,
            IsTradingUser: isTradingUser
        };
    }
);
define(
    "modules/KoComponentLoader",
    [
        "require",
        "knockout",
        'handlers/general',
        "Q"
    ],
    function(require) {
        var ko = require("knockout"),
            general = require('handlers/general'),
            Q = require("Q");

        function KoComponentLoader() {
            var components = {};
            var isRegistered = false;

            var exists = function(name) {
                return ko.components.isRegistered(name);
            };

            var preload = function(name) {
                return Q.Promise(function(resolve, reject) {
                    ko.components.get(name, function(component) {
                        if (component) {
                            resolve(component);
                        } else {
                            reject(new Error(String.format("'{0}' component could not be loaded.")));
                        }
                    });
                });
            };

            var register = function() {
                if (isRegistered) {
                    return;
                }

                var loader = {
                    loadComponent: function (componentName, config, callback) {
                        components[componentName] = false;

                        if (general.isArrayType(config.deps) && config.deps.length) {
                            require(config.deps, function () {
                                ko.components.defaultLoader.loadComponent(componentName, config, function() {
                                    components[componentName] = true;
                                    callback.apply(null, general.argsToArray(arguments));
                                });
                            });
                        } else {
                            ko.components.defaultLoader.loadComponent(componentName, config, function() {
                                components[componentName] = true;
                                callback.apply(null, general.argsToArray(arguments));
                            });
                        }
                    }
                };

                ko.components.loaders.unshift(loader);
            };

            var unregister = function() {
                if (isRegistered) {
                    ko.components.loaders.shift();
                }
            };

            return {
                Register: register,
                Unregister: unregister,
                Preload: preload,
                Exists: exists,
                Components: components
            };
        }

        return new KoComponentLoader();
    }
);
define(
    'handlers/RequireError',
    [
        "require",
        "initdatamanagers/Customer",
        'modules/KoComponentLoader'
    ],
    function (require) {
        var Customer = require("initdatamanagers/Customer"),
            KoComponentLoader = require('modules/KoComponentLoader');

        function RequireError(message, innerError) {
            this.message = message;

            if (!Error.captureStackTrace) {
                this.stack = (new Error()).stack;
            } else {
                Error.captureStackTrace(this, this.constructor);
            }

            this.innerError = innerError;
            this.loadedUrls = Object.keys(requirejs.s.contexts._.urlFetched);
            this.pendingModules = Object.keys(requirejs.s.contexts._.registry);
            this.loadedModules = Object.keys(requirejs.s.contexts._.defined);

            var fxnetComponents = Object.keys(KoComponentLoader.Components);

            this.loadedComponents = fxnetComponents.filter(function (name) {
                return KoComponentLoader.Components[name] === true;
            });
            this.pendingComponents = fxnetComponents.filter(function (name) {
                return KoComponentLoader.Components[name] === false;
            });
        }

        RequireError.prototype = Object.create(Error.prototype);
        RequireError.prototype.constructor = RequireError;
        RequireError.prototype.getFullExceptionMessage = function () {
            var self = this;

            var messageObj = {
                Message: self.message,
                LoadedUrls: self.loadedUrls,
                PendingModules: self.pendingModules,
                //LoadedModules: self.loadedModules,
                PendingComponents: self.pendingComponents,
                //LoadedComponents: self.loadedComponents,
                StackTrace: (self.stack || '').replace(self.message, '').replace(/\n|\r\n/g, ' ').replace(/\s\s+/g, ' '),
                AccountNumber: Customer.prop.accountNumber,
                UserAgent: window.navigator.userAgent
            };

            return JSON.stringify(messageObj);
        };

        return RequireError;
    }
);


/* eslint no-extend-native: 0 */
define("generalmanagers/ErrorManager", [
	"require",
	"handlers/Logger",
	"handlers/general",
	"devicemanagers/StatesManager",
	"initdatamanagers/Customer",
	"modules/permissionsmodule",
	"global/UrlResolver",
	"handlers/RequireError",
	"StateObject!ViewsManager",
], function (require) {
	var Logger = require("handlers/Logger"),
		general = require("handlers/general"),
		StatesManager = require("devicemanagers/StatesManager"),
		Customer = require("initdatamanagers/Customer"),
		permissionsModule = require("modules/permissionsmodule"),
		UrlResolver = require("global/UrlResolver"),
		RequireError = require("handlers/RequireError"),
		StateObject = require("StateObject!ViewsManager");

	function ErrorManager() {
		// Extend Error prototype
		Error.prototype.getFullExceptionMessage = function () {
			var self = this;

			var messageObj = {
				Message: self.message,
				StackTrace: (self.stack || "")
					.replace(self.message, "")
					.replace(/\n|\r\n/g, " ")
					.replace(/\s\s+/g, " "),
				Form: "",
				Views: [],
				AccountNumber: Customer.prop.accountNumber,
				UserAgent: window.navigator.userAgent,
			};

			if (window.trackingData) {
				var errorTrackingData = window.trackingData.getErrorTrackingData();

				for (var trakingProperty in errorTrackingData) {
					if (errorTrackingData.hasOwnProperty(trakingProperty)) {
						messageObj[trakingProperty] = errorTrackingData[trakingProperty];
					}
				}
			}

			try {
				messageObj.Form = general.urlDecode(window.location.search)["view"] || "";

				if (StateObject) {
					messageObj.Views = StateObject.get("ActiveViews");
				}
			} catch (e) {
				// empty
			}

			return JSON.stringify(messageObj);
		};

		function redirectTologin() {
			window.location.replace(
				UrlResolver.combine(
					UrlResolver.getApplicationRelativePath(),
					"account/login?reason=" + eLoginLogoutReason.errorManager_httpError
				)
			);
		}

		function handleHttpError(error) {
			if (error && (error.httpStatus === 403 || error.httpStatus === 401 || error.httpStatus === 420)) {
				if (permissionsModule.IsRestrictedUser()) {
					return true;
				}

				redirectTologin();

				return true;
			}

			return false;
		}

		function onException(msg, url, lineNumber, columnNumber, error) {
			if (general.isNullOrUndefined(error)) {
				return true;
			}

			if (handleHttpError(error)) {
				return true;
			}

			if (error && typeof error.handler === "function") {
				// This is a custom error
				error.handler();

				return true;
			}

			handleUnknownException(msg, error);

			throw error;
		}

		function handleUnknownException(msg, error) {
			if (typeof systemInfo !== "undefined" && typeof Logger !== "undefined") {
				var blackList = systemInfo.clientApplicationParams
					? systemInfo.clientApplicationParams[eClientParams.JsErrorBlacklistRegex] || ""
					: "";

				var blacklistReObj = new RegExp(blackList, "i");

				var shouldIgnoreMessageLog =
					blackList.length > 0 &&
					((msg.length > 0 && blacklistReObj.test(msg)) ||
						(error && error.message.length > 0 && blacklistReObj.test(error.message)));

				// log the UnknownError if the error is not in the blacklist
				if (!shouldIgnoreMessageLog) {
					var loggedMessage = (error && error.getFullExceptionMessage()) || msg;
					Logger.log("UnknownError", loggedMessage);
				}
			}
		}

		function onError(functionName, strError, severityLevel) {
			severityLevel = severityLevel || eErrorSeverity.low;

			/*if (strError === "http403") {
				StatesManager.PushState(
					StatesManager.StatePropertiesEnum.Forbidden,
					eErrorSeverity.medium,
					StatesManager.StatePropertiesEnum["Forbidden"]
				);
			} else {
				switch (severityLevel) {
					case eErrorSeverity.critical:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.critical,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;

					case eErrorSeverity.high:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.high,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;

					case eErrorSeverity.medium:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.medium,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;

					case eErrorSeverity.low:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.low,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;
				}

				var error = {
					Message: strError,
					AccountNumber: Customer.prop.accountNumber,
					UserAgent: window.navigator.userAgent,
				};

				Logger.error(functionName, JSON.stringify(error), general.emptyFn, severityLevel);
			}*/
		}

		function onWarning(source, warningMessage) {
			var warning = {
				Message: warningMessage,
				AccountNumber: Customer.prop.accountNumber,
				UserAgent: window.navigator.userAgent,
			};

			Logger.warn(source, JSON.stringify(warning));
		}

		function getFullExceptionMessage(ex) {
			return ex.getFullExceptionMessage();
		}

		/*
		 * Utility function to create custom Error types
		 *
		 * To create a custom error type, derived from Error JS object
		 *
		 * @param {string} name an unique name for the newly custom error type
		 * @param {function} handler a function used to handle the created type of error
		 *
		 * var myCustomError = ErrorManager.createErrorType("CustomError", function() {
		 *     // this keyword refers to the current error instance
		 *     console.log(this.message);
		 * });
		 *
		 * throw new myCustomError("This is a custom error");
		 *
		 */
		function createErrorType(name, handler) {
			function BaseError(message) {
				this.name = name;
				this.message = message;

				if (!Error.captureStackTrace) {
					this.stack = new Error().stack;
				} else {
					Error.captureStackTrace(this, this.constructor);
				}
			}

			BaseError.prototype = Object.create(Error.prototype);
			BaseError.prototype.name = name;
			BaseError.prototype.constructor = BaseError;
			BaseError.prototype.handler = typeof handler === "function" ? handler : function () {};

			return BaseError;
		}

		function onRequireError(error) {
			if (error.requireType === "mismatch") {
				throw new RequireError("Mismatched anonymous define() module", error);
			}

			throw error;
		}

		return {
			getFullExceptionMessage: getFullExceptionMessage,
			onRequireError: onRequireError,
			onError: onError,
			onWarning: onWarning,
			onException: onException,
			createErrorType: createErrorType,
		};
	}

	var module = (window.ErrorManager = new ErrorManager());

	return module;
});

define(
    'generalmanagers/RegistrationManager',
    [
        'handlers/general',
        'handlers/Delegate',
        'handlers/HashTable',
        'enums/DataMembersPositions'
    ],
    function RegistrationManager(general, delegate, hashtable) {
        var onRegistrationListChanged = new delegate();
        var registrationList = [];
        var requests = new hashtable();

        //------------------------------------------------
        // check if fromList contains every element in to list
        function compareListContents(fromList, toList) {
            for (var i = 0, len = toList.length, instrument; i < len; i += 1) {
                instrument = toList[i];
                if (fromList.indexOf(instrument) < 0) {
                    return false;
                }
            }
            return true;
        }

        //------------------------------------------------

        function register(flag, isReinitialized) {
            var requestList = buildRequestList();

            if (isReinitialized || compareListContents(registrationList, requestList) !== true) {
                registrationList = requestList.slice();

                onRegistrationListChanged.Invoke(registrationList, flag, isReinitialized);
            }
        }

        //------------------------------------------------

        function buildRequestList() {
            var list = [];

            requests.ForEach(function iterator(key, val) {
                if (val) {
                    if (typeof val === 'object') {
                        if (key == eRegistrationListName.QuotesTable || key == eRegistrationListName.Search) {
                            for (var j = 0, len = val.length; j < len; j++) {
                                list.addUnique(general.toNumeric(val[j][eQuotesUIOrder.InstrumentID]));
                            }
                        } else {
                            for (var jj = 0, lenj = val.length; jj < lenj; jj++) {
                                list.addUnique(general.toNumeric(val[jj]));
                            }
                        }
                    } else {
                        list.addUnique(general.toNumeric(val));
                    }
                }
            });

            return list;
        }

        //------------------------------------------------

        function update(controlName, iList) {
            requests.OverrideItem(controlName, iList);

            register(eSubscriptionRequestFlags.All, false);
        }

        //------------------------------------------------

        var module = window.$regManager = {
            Register: register,
            Update: update,
            OnRegistrationListChanged: onRegistrationListChanged
        };

        return module;
    }
);

/* global UrlResolver */
define("handlers/SyncRequestHelper", ["global/UrlResolver"], function (UrlResolver) {
	function SyncRequestHelper(requestUrl, params) {
		var req,
			appRelativePath = UrlResolver.getApplicationRelativePath();

		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
		} else if (window.ActiveXObject) {
			var versions = [
				"MSXML2.XmlHttp.6.0",
				"MSXML2.XmlHttp.5.0",
				"MSXML2.XmlHttp.4.0",
				"MSXML2.XmlHttp.3.0",
				"MSXML2.XmlHttp.2.0",
				"Microsoft.XmlHttp",
				"Microsoft.XMLHTTP", // old
			];

			for (var i = 0; i < versions.length; i++) {
				try {
					req = new ActiveXObject(versions[i]);
				} catch (e) {
					// empty
				}
			}
		}

		function getUrl(url) {
			var prefix;

			url = UrlResolver.getUrlWithRndKeyValue(url);

			prefix = url.startsWith(appRelativePath) || url.startsWith("http") ? String.empty : appRelativePath;

			return UrlResolver.combine(prefix, url);
		}

		if (req) {
			req.open("POST", getUrl(requestUrl), false);

			if (params) {
				//here we check if the user request a security token when not authenticated(initialized)
				//to prevent a call for security token that which will return an error
				var patt = /SecurityToken/i;
				var result = params.match(patt);

				if (result && !$customer.isAuthenticated()) {
					return false;
				} else {
					req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
					req.send(params);
				}
			} else {
				req.send();
			}
		}

		return req;
	}

	return SyncRequestHelper;
});

define(
    "dataaccess/dalClientState",
    [
        "require",
        'generalmanagers/ErrorManager',
        'handlers/SyncRequestHelper',
        'handlers/Logger',
        "handlers/Ajaxer"
    ],
    function (require) {
        var ErrorManager = require('generalmanagers/ErrorManager'),
            SyncRequestHelper = require('handlers/SyncRequestHelper'),
            Logger = require('handlers/Logger');

        function TDALClientState() {
            var dataAjaxer = new TAjaxer(),
                quotesAjaxer = new TAjaxer(),
                clientStateSlaTimeout = systemInfo.slaTimeout || 1000,
                maxRetries = 1000;

            function logWrittenSuccessfully() {
                clientStateSlaTimeout += 1000;
            }

            function checkAjaxerStatus(status) {
                status.State = status.State || eAjaxerState.None;

                if (status.State === eAjaxerState.SlaCompromised) {
                    status.Data = status.Data || {};
                    var warningMessage = "SLA has been compromised: " + JSON.stringify(status);

                    if (typeof Logger !== 'undefined') {
                        Logger.warn("TDALClientState", warningMessage, logWrittenSuccessfully, eErrorSeverity.warning);
                    }
                }
                else if (status.State === eAjaxerState.Retry) {
                    // console.log("Retry the last request: " + JSON.stringify(status.Data));
                }
            }

            function getData(requestMode, OnLoadComplete) {
                var promise = dataAjaxer.promises.get(
                    "TDALClientState/getData",
                    "api/clientstate/GetData/" + requestMode + '/' + $initialDataManager.prop.csmg,
                    "",
                    OnLoadComplete,
                    function () {
                        ErrorManager.onError("TDALClientState/getData", "", eErrorSeverity.high);
                    },
                    0,
                    maxRetries,
                    clientStateSlaTimeout
                );

                promise.progress(checkAjaxerStatus)
                    .done();
            }

            function getQuotesData(requestMode, OnLoadComplete) {
                var promise = quotesAjaxer.promises.get(
                    "TDALClientState/getQuotesData",
                    "api/clientstate/GetQuotesData/" + requestMode + '/' + $initialDataManager.prop.csmg,
                    "",
                    OnLoadComplete,
                    function () {
                        ErrorManager.onError("TDALClientState/getQuotesData", "", eErrorSeverity.high);
                    },
                    0,
                    maxRetries,
                    clientStateSlaTimeout
                );

                promise.progress(checkAjaxerStatus)
                    .done();
            }

            function register(list) {
                var params = "SecurityToken=" + systemInfo.securityToken;

                return quotesAjaxer.promises.post("api/ClientState/Register",
                    "api/clientstate/Register/" + $initialDataManager.prop.csmg + "?instruments=" + JSON.stringify(list),
                    params)
                    .then(function (response) {
                        return response.toString() === eOperationStatus.Success.toString();
                    });
            }

            function unregister() {
                var params = "SecurityToken=" + systemInfo.securityToken;
                return quotesAjaxer.promises.post("api/ClientState/Unregister",
                    "api/clientstate/Unregister/" + $initialDataManager.prop.csmg,
                    params)
                    .then(function (response) {
                        return response.toString() === eOperationStatus.Success.toString();
                    });
            }

            function setDisplaySymbol(symbolId) {
                var params = "SecurityToken=" + systemInfo.securityToken;
                var response = SyncRequestHelper("api/clientstate/SetDisplaySymbol/" + $initialDataManager.prop.csmg + "/" + symbolId, params);

                if (response && response.status == 200) {
                    return response.responseText == eOperationStatus.Success;
                }

                return false;
            }

            function getclientStateSlaTimeout() {
                return clientStateSlaTimeout;
            }

            return {
                GetData: getData,
                GetQuotesData: getQuotesData,
                Register: register,
                Unregister: unregister,
                SetDisplaySymbol: setDisplaySymbol,
                GetclientStateSlaTimeout: getclientStateSlaTimeout
            };
        }

        return new TDALClientState();
    }
);


define(
    'cachemanagers/AjaxCacheManager',
    [
        'require',
        'Q',
        'JSONHelper',
        'dataaccess/dalClientState',
        'handlers/general',
        'generalmanagers/ErrorManager',
        'StateObject!Csm',
        'StateObject!SystemNotificationEvents',
        "handlers/Delegate",
    ],
    function (require) {
        var
            Q = require('Q'),
            JSONHelper = require('JSONHelper'),
            general = require('handlers/general'),
            dalClientState = require('dataaccess/dalClientState'),
            ErrorManager = require('generalmanagers/ErrorManager'),
            csmStateObject = require('StateObject!Csm'),
            stateObject = require("StateObject!SystemNotificationEvents"),
            delegate = require("handlers/Delegate");


        function AjaxCacheManager(clientStateDataProcessor) {
            var requestMode = eRequestMode.Initial,
                stopAll = false,
                csmTimerId = 0,
                regTimerId = 0,
                csmOutOfDateTimerId = 0,
                lastUpdateTime = new Date().getTime(),
                firstLoad = Q.defer(),
                onLoadRequest = new delegate(),
                onRegisterRequest = new delegate(),
                forceInitial = false,
                csmOutOfDateTimeoutCounter = 0;

            function onLoadComplete(defer, mode, responseText) {
                var response = JSONHelper.STR2JSON("CacheManager/onLoadComplete", responseText, eErrorSeverity.high);
                response = response || {};

                if (response.status == eOperationStatus.Success) {
                    response.clientStateResult = response.clientStateResult || eClientStateResult.NotFound;
                    // on error register all
                    if (response.clientStateResult != eClientStateResult.Success) {

                        getRegistrationNextDataCall(function registrationNextDataCall() {
                            onRegisterRequest.Invoke(eSubscriptionRequestFlags.All, true);
                            csmStateObject.update(eStateObjectTopics.CsmOutOfDate, true);
                        });
                        defer.resolve();
                    } else {
                        var isReinitialized = mode === eRequestMode.Initial;

                        processData(response.data, isReinitialized);

                        csmStateObject.update(eStateObjectTopics.CsmOutOfDate, false);
                        if (csmOutOfDateTimerId) {
                            clearTimeout(csmOutOfDateTimerId);
                            csmOutOfDateTimerId = 0;
                        }
                        defer.resolve();
                    }
                }

                getCSMNextDataCall(function csmNextDataCall() {
                    var clientStateLatencyInterval =
                        parseInt(systemInfo.clientApplicationParams[eClientParams.ClientStateLatencyInterval]) +
                        dalClientState.GetclientStateSlaTimeout();

                    onLoadRequest.Invoke();

                    csmOutOfDateTimerId = setTimeout(function onCsmOutOfDate() {
                        csmOutOfDateTimeoutCounter += 1;
                        ErrorManager.onWarning("AjaxerCacheManager", 'CSM out-dated data: latency_of=' +
                            clientStateLatencyInterval + ",counter=" + csmOutOfDateTimeoutCounter);
                        //csmStateObject.update(eStateObjectTopics.CsmOutOfDate, true);
                    }, clientStateLatencyInterval);
                });
            }

            function loadData(reqmode) {
                var mode = general.isDefinedType(reqmode) ? reqmode : requestMode;
                var defer = Q.defer();

                if (!stopAll) {
                    lastUpdateTime = new Date().getTime();
                    dalClientState.GetData(mode, onLoadComplete.bind(this, defer, mode));
                }

                return defer.promise;
            }

            function setDisplaySymbol(newSymbol) {
                if (dalClientState.SetDisplaySymbol(newSymbol)) {
                    reloadInitialData(eSubscriptionRequestFlags.All);
                }
            }

            function setRequestMode(state) {
                if (state == eRequestMode.Initial) {
                    requestMode = eRequestMode.Initial;
                    //do not touch this param, its critical to sync between register and csm threads
                    forceInitial = true;
                } else {
                    requestMode = eRequestMode.Correct;
                }
            }

            function reloadInitialData(flags) {
                switch (flags) {
                    case eSubscriptionRequestFlags.Quotes:
                        dalClientState.GetQuotesData(eRequestMode.Initial, onReLoadQuotesInitialComplete);
                        break;
                    case eSubscriptionRequestFlags.All:
                        setRequestMode(eRequestMode.Initial);
                        break;
                    default:
                        break;
                }
            }

            function onReLoadQuotesInitialComplete(responseText) {
                var response = JSONHelper.STR2JSON("CacheManager/onLoadInitialComplete", responseText, eErrorSeverity.high);

                if (response) {
                    processData(response.data);
                }
            }

            function processData(data, reinitialize) {
                if (data && data.length > 0) {
                    clientStateDataProcessor.processData(data, reinitialize);
                    setRequestMode(eRequestMode.Correct);
                }

                firstLoad.resolve();
            }

            function calculateNextPeriod() {
                var clientInterval = parseInt(systemInfo.clientApplicationParams[eClientParams.Interval]);
                var nowTime = new Date().getTime();
                var diff = nowTime - lastUpdateTime;
                var nextUpdate = clientInterval - diff;
                nextUpdate = nextUpdate < 0 ? 0 : nextUpdate;

                return nextUpdate;
            }

            function getRegistrationNextDataCall(method) {
                if (regTimerId) {
                    clearTimeout(regTimerId);
                    regTimerId = 0;
                }

                regTimerId = setTimeout(method, calculateNextPeriod());
            }

            function getCSMNextDataCall(method) {
                if (csmTimerId) {
                    clearTimeout(csmTimerId);
                    csmTimerId = 0;
                }
                if (forceInitial) {
                    setRequestMode(eRequestMode.Initial);// not neccesery, double check
                    forceInitial = false;
                }
                csmTimerId = setTimeout(method, calculateNextPeriod(), requestMode);
            }

            function register(requestList, flag, isReinitialized) {
                dalClientState.Register(requestList)
                    .then(function (response) {
                        if (response) {
                            reloadInitialData(flag);
                        } else if (isReinitialized) {
                            setTimeout(function retryHandler() {
                                onRegisterRequest.Invoke(eSubscriptionRequestFlags.All, true);
                                csmStateObject.update(eStateObjectTopics.CsmOutOfDate, true);
                            }, systemInfo.clientApplicationParams[eClientParams.Interval]);
                        }
                    })
                    .done();
            }

            function unregister() {
                whenLoadFinished()
                    .then(function () {
                        return dalClientState.Unregister();
                    })
                    .done();
            }

            function whenLoadFinished() {
                return firstLoad.promise;
            }
            stateObject.set(eShutDownHandlerTopics.stopClientStateManagerCalls, null);
            stateObject.subscribe(eShutDownHandlerTopics.stopClientStateManagerCalls, function () {
                stopAll = true;

                if (csmTimerId) {
                    clearTimeout(csmTimerId);
                    csmTimerId = 0;
                }
                if (regTimerId) {
                    clearTimeout(regTimerId);
                    regTimerId = 0;
                }
                if (csmOutOfDateTimerId) {
                    clearTimeout(csmOutOfDateTimerId);
                    csmOutOfDateTimerId = 0;
                }
            });

            return {
                Register: register,
                Unregister: unregister,
                LoadData: loadData,
                SetDisplaySymbol: setDisplaySymbol,
                LoadFinished: whenLoadFinished,

                OnLoadRequest: onLoadRequest,
                OnRegisterRequest: onRegisterRequest
            };
        }

        return AjaxCacheManager;
    }
);

define(
    'dataaccess/dalCustomerProfile',
    [
        "require",
        'generalmanagers/ErrorManager',
        'handlers/general',
        'JSONHelper'
    ],
    function DalCustomerProfileDef(require) {
        var ErrorManager = require('generalmanagers/ErrorManager'),
            JSONHelper = require('JSONHelper'),
            general = require('handlers/general');

        function DalCustomerProfile() {
            function saveStartUpPage(clientProfileModel, onLoadComplete) {
                if (!isValidModel(clientProfileModel)) {
                    return;
                }

                var ajaxer = new TAjaxer(),
                    params = JSON.stringify(clientProfileModel);

                ajaxer.post(
                    "TDALCustomerProfile/SaveStartUpPage",
                    "api/clientprofile/SaveStartUpPage",
                    params,
                    onLoadComplete,
                    function (error) {
                        ErrorManager.onError("TDALCustomerProfile/SaveStartUpPage", error.message, eErrorSeverity.medium);
                    }
                );
            }

            function saveProfile(clientProfileModel, onLoadComplete) {
                if (!isValidModel(clientProfileModel)) {
                    return;
                }

                var ajaxer = new TAjaxer(),
                    params = JSON.stringify(clientProfileModel);


                ajaxer.post(
                    "TDALCustomerProfile/SaveProfile",
                    "api/clientprofile/SaveProfile",
                    params,
                    onLoadComplete,
                    function (error) {
                        ErrorManager.onError("TDALCustomerProfile/SaveProfile", error.message, eErrorSeverity.medium);
                    },
                    1,
                    2
                );
            }

            function saveSentimentsToProfileWebMobile(clientProfileModel, onLoadComplete) {
                if (!isValidModel(clientProfileModel)) {
                    return;
                }

                var ajaxer = new TAjaxer(),
                    params = JSON.stringify(clientProfileModel);

                ajaxer.post(
                    "TDALCustomerProfile/SaveProfileWebMobile",
                    "api/clientprofile/SaveSentimentsToProfileWebMobile",
                    params,
                    onLoadComplete,
                    function (error) {
                        ErrorManager.onError("TDALCustomerProfile/SaveSentimentsToProfileWebMobile", error.message, eErrorSeverity.medium);
                    }
                );
            }

            function saveProfileInstrument(clientProfileModel, onLoadComplete) {
                if (!isValidModel(clientProfileModel)) {
                    return;
                }

                var ajaxer = new TAjaxer(),
                    params = JSON.stringify(clientProfileModel);

                ajaxer.post(
                    "TDALCustomerProfile/SaveProfile",
                    "api/clientprofile/SaveProfileInstrument",
                    params,
                    onLoadComplete,
                    function (error) {
                        ErrorManager.onError("TDALCustomerProfile/SaveProfileInstrument", error.message, eErrorSeverity.medium);
                    }
                );
            }

            function saveClientScreen(clientProfileModel) {
                if (!isValidModel(clientProfileModel)) {
                    return;
                }

                var ajaxer = new TAjaxer(),
                    params = JSON.stringify(clientProfileModel);

                var method = "TDALCustomerProfile/saveClientScreen",
                    url = "api/clientprofile/UpdateScreen";

                return ajaxer.promises
                    .post(method, url, params, null, null, 1, 2)
                    .then(function (responseText) {
                        checkAndLogServerError(method, params, responseText);
                        return JSONHelper.STR2JSON(method + "/onLoadComplete", responseText);
                    })
                    .fail(function (error) {
                        ErrorManager.onError(method, "", eErrorSeverity.medium);

                        throw error;
                    });
            }

            function checkAndLogServerError(method, params, serverResponse) {
                if (serverResponse.indexOf("ServerError") > -1) {
                    ErrorManager.onWarning(method, "Server Error; Params: " + params);
                }
            }

            function isValidModel(clientProfileModel) {
                return !general.isEmptyValue(clientProfileModel) && !isEmptyObject(clientProfileModel);
            }

            function isEmptyObject(object) {
                if (general.isNullOrUndefined(object)) {
                    return true;
                }

                if (!general.isObjectType(object)) {
                    return false;
                }

                return general.equals(object, {})
            }

            return {
                SaveStartUpPage: saveStartUpPage,
                SaveProfile: saveProfile,
                SaveProfileInstrument: saveProfileInstrument,
                SaveClientScreen: saveClientScreen,
                SaveSentimentsToProfileWebMobile: saveSentimentsToProfileWebMobile
            };
        }

        return new DalCustomerProfile();
    }
);

define(
    'managers/CustomerProfileManager',
    [
        'require',
        'helpers/ObservableCustomExtender',
        'dataaccess/dalCustomerProfile',
        'managers/profileinstruments',
        'modules/permissionsmodule',
        'StateObject!DealerParams',
        'JSONHelper'
    ],
    function CustomerProfileManager(require) {
        var ko = require('helpers/ObservableCustomExtender'),
            dalCustomerProfile = require('dataaccess/dalCustomerProfile'),
            ProfileInstruments = require('managers/profileinstruments'),
            stateObjectDealerParams = require('StateObject!DealerParams'),
            JSONHelper = require('JSONHelper'),
            permissionsModule = require('modules/permissionsmodule');

        var profileCustomer = ko.observable({}).extend({ dirty: false }),
            startUpForm = ko.observable(0).extend({ dirty: false }),
            cashBackVolume = ko.observable(''),
            maxCashBack = ko.observable(''),
            lastSelectedPresetId = ko.observable(-1).extend({ dirty: false }),
            period = 10000,
            timeoutHold,
            startUpFormChanged = new TDelegate(),
            initialScreenChanged = new TDelegate(),
            oldChart = {};

        function setInitialAdvancedView() {
            var isAdvanced = !!(
                stateObjectDealerParams.get(eDealerParams.DealerAdvancedWalletView) ||
                profileCustomer().advancedWalletView
            );
            updateIsAdvancedView(isAdvanced);
        }

        function updateIsAdvancedView(isAdvanced) {
            var pc = profileCustomer();
            pc.advancedWalletView = isAdvanced ? 1 : 0;
            profileCustomer(pc);
        }

        function updateProfile() {
            // disable if dealer mode
            if (!permissionsModule.CheckPermissions('customerProfile')) {
                return;
            }
            if (startUpForm.isDirty()) {
                var defaultPageValue = startUpForm();
                var clientProfileModel = {
                    defaultFirstPage: defaultPageValue,
                };

                startUpForm.markClean();

                startUpFormChanged.Invoke(startUpForm());

                dalCustomerProfile.SaveStartUpPage(clientProfileModel);
            }

            if (profileCustomer.isDirty()) {
                profileCustomer.markClean();
                dalCustomerProfile.SaveProfile(profileCustomer());
            }

            if (lastSelectedPresetId.isDirty()) {
                dalCustomerProfile
                    .SaveClientScreen({ ScreenId: lastSelectedPresetId() })
                    .then(function (result) {
                        if (result && result.status == eOperationStatus.Success) {
                            lastSelectedPresetId.markClean();
                            initialScreenChanged.Invoke(lastSelectedPresetId());
                        }
                    })
                    .done();
            }

            clearTimeout(timeoutHold);
            timeoutHold = setTimeout(updateProfile, period);
        }

        function init(
            _customerProfile,
            _startUpForm,
            _profileInstruments,
            initialScreenId) {
            lastSelectedPresetId(initialScreenId);
            lastSelectedPresetId.markClean();

            startUpForm(_startUpForm);
            startUpForm.markClean();

            ProfileInstruments.Init(_profileInstruments);
            ProfileInstruments.OnUpdate.Add(function (value) {
                dalCustomerProfile.SaveProfileInstrument(value);
            });

            processProfileCustomer(_customerProfile);
            setInitialAdvancedView();

            timeoutHold = setTimeout(updateProfile, period);
        }

        function processProfileCustomer(customerProfile) {
            customerProfile = customerProfile || {};

            if (
                customerProfile.chartUserSettings ||
                customerProfile.tileChartSettings ||
                customerProfile.tileSettings ||
                customerProfile.chartFavorites ||
                customerProfile.chartIndicatorsSettings ||
                customerProfile.chartsZoomSettings) {
                // try to load from legacy
                oldChart.chartUserSettings = customerProfile.chartUserSettings
                    ? JSONHelper.STR2JSON("CustomerProfileManager:chartUserSettings", customerProfile.chartUserSettings)
                    : {};
                oldChart.tileChartSettings = customerProfile.tileChartSettings
                    ? JSONHelper.STR2JSON("CustomerProfileManager:tileChartSettings", customerProfile.tileChartSettings)
                    : [];
                oldChart.tileSettings = customerProfile.tileSettings
                    ? JSONHelper.STR2JSON("CustomerProfileManager:tileSettings", customerProfile.tileSettings)
                    : {};
                oldChart.chartFavorites = customerProfile.chartFavorites
                    ? JSONHelper.STR2JSON("CustomerProfileManager:chartFavorites", customerProfile.chartFavorites)
                    : {};
                oldChart.chartIndicatorsSettings = customerProfile.chartIndicatorsSettings
                    ? JSONHelper.STR2JSON("CustomerProfileManager:chartIndicatorsSettings", customerProfile.chartIndicatorsSettings)
                    : {};
                oldChart.chartsZoomSettings = customerProfile.chartsZoomSettings
                    ? JSONHelper.STR2JSON("CustomerProfileManager:chartsZoomSettings", customerProfile.chartsZoomSettings)
                    : {};

                // delete legacy
                delete customerProfile.chartUserSettings;
                delete customerProfile.tileChartSettings;
                delete customerProfile.tileSettings;
                delete customerProfile.chartFavorites;
                delete customerProfile.chartIndicatorsSettings;
                delete customerProfile.chartsZoomSettings;

                profileCustomer(customerProfile);
            } else {
                profileCustomer(customerProfile);
                profileCustomer.markClean();
            }
        }

        function getUiVersion() {
            return profileCustomer().dealSlipVersion || eUIVersion.Default;
        }

        function dispose() {
            startUpFormChanged.Flush();
            initialScreenChanged.Flush();

            clearTimeout(timeoutHold);
        }

        window.CustomerProfileManager = window.$customerProfileManager = {
            ProfileCustomer: profileCustomer,
            OldChart: function () {
                return oldChart;
            },
            LastSelectedPresetId: lastSelectedPresetId,
            UpdateIsAdvancedView: updateIsAdvancedView,
            DefaultPage: startUpForm,
            GetUiVersion: getUiVersion,
            CashBackVolume: cashBackVolume,
            MaxCashBack: maxCashBack,
            Init: init,
            Dispose: dispose,
            Events: {
                onStartUpFormChanged: startUpFormChanged,
                onInitialScreenChanged: initialScreenChanged,
            },
        };

        return window.CustomerProfileManager;
    }
);

define('handlers/websocketstate',["fxnet/loader", "global/UrlResolver", "Q"], function (loader, urlResolver, Q) {
	var empty = "";

	var connectionData = {
		connectionToken: empty,
		jwtToken: empty,
		CSMPushEnabled: empty,
	};

	var states = {
		enabled: "1",
		disabled: "0",
	};

	function init(params) {
		connectionData.connectionToken = params.connectionToken || empty;
		connectionData.jwtToken = params.jwtToken || empty;
		connectionData.CSMPushEnabled = params.CSMPushEnabled || empty;
	}

	function isCSMPushServiceEnabled() {
		return connectionData.CSMPushEnabled === states.enabled;
	}

	function getConnectionToken() {
		return connectionData.connectionToken;
	}

	function getJwtToken() {
		return connectionData.jwtToken;
	}

	function canConnect() {
		return (
			isCSMPushServiceEnabled() &&
			connectionData.jwtToken &&
			connectionData.jwtToken.length > 0 &&
			connectionData.connectionToken &&
			connectionData.connectionToken.length > 0
		);
	}

	function tryConnect() {
		var deferred = Q.defer();

		if (connectionData.CSMPushEnabled === states.disabled) {
			deferred.reject("CSMPushService disabled for this account");
		}

		if (canConnect()) {
			deferred.resolve();
		}

		if (connectionData.CSMPushEnabled === empty) {
			return loadJWT(deferred);
		}

		return deferred.promise;
	}

	// if token is invalid (browser refresh), then go to server and bring one as fallback.
	function loadJWT(deferred) {
		//just in case, support calling this method without parent promise
		if (deferred === null || typeof deferred === "undefined") {
			deferred = Q.defer();
		}

		loader.get(
			urlResolver.combine(urlResolver.getApplicationRelativePath(), "Account/GetJWTAndConnectionId"),
			function (error, token) {
				if (error) {
					deferred.reject(error);
				}

				updateConnectionData(token);

				if (!isCSMPushServiceEnabled()) {
					deferred.reject("server refused web sockets");
				}

				deferred.resolve();
			},
			"application/json; charset=utf-8",
			true
		);

		return deferred.promise;
	}

	function updateConnectionData(result) {
		if (!result || result.indexOf("$") === -1) {
			return;
		}

		var _params = result.split("$");

		for (var i = 0; i < _params.length; i++) {
			var param = _params[i].substring(3, _params[i].length);

			if (_params[i].indexOf("ct=") !== -1) {
				connectionData.connectionToken = param;
			}

			if (_params[i].indexOf("jt=") !== -1) {
				connectionData.jwtToken = param;
			}

			if (_params[i].indexOf("en=") !== -1) {
				connectionData.CSMPushEnabled = param;
			}
		}
	}

	function resetConnectionData() {
		connectionData.connectionToken = empty;
		connectionData.jwtToken = empty;
		connectionData.CSMPushEnabled = empty;
	}

	return {
		IsCSMPushServiceEnabled: isCSMPushServiceEnabled,
		GetConnectionToken: getConnectionToken,
		GetJwtToken: getJwtToken,
		CanConnect: canConnect,
		TryConnect: tryConnect,
		ResetConnectionData: resetConnectionData,
		Init: init,
	};
});

/* global UrlResolver, ErrorManager, Loader,Q*/
// singleton web socket connection wrapperisReady

define('handlers/websocketconnection',[
	"Q",
	"global/UrlResolver",
	"generalmanagers/ErrorManager",
	"fxnet/loader",
	"handlers/websocketstate",
], function (Q, UrlResolver, ErrorManager, Loader, wsState) {
	var //_wsUrl,
		_socket = null,
		_timestamps,
		hasStarted,
		messageHandler,
		reconnectedHandler,
		notAvailableHandler,
		disconnectedHandler,
		isShutDownMode = false,
		isStartMode = true,
		retriesOnDisconnectedFailedConnection = 0, // initial value
		disconnectedMaxRetries = 1, // =1 on init and then =3 on network failure
		receiveActions = {
			reconnected: "reconnected",
			ack: "ack",
			reconnectOnError: "reconnectOnError",
			disconnect: "disconnect",
		},
		lastKeepAliveMsg,
		isNotFirstKeepAlive = false,
		//receiveTimeoutPeriod = 15,
		receiveKeepAliveTimeout = null,
		socketConfig = null,
		defaultKeepAlivePeriod = 5,
		defaultKeepAliveBuffer = 1,
		eventsCalledOnce,
		onDisconnectedIsAlreadyRunning = false;

	function log(message) {
		var connectionToken = wsState.GetConnectionToken(),
			messageData = {
				Location: "SocketConnection (" + connectionToken + ") ",
				Info: message,
			},
			params = {
				loggedErrorString: JSON.stringify(messageData),
			},
			xmlhttp = new XMLHttpRequest();

		xmlhttp.open("POST", UrlResolver.getUrlWithRndKeyValue("Error/Warn"));
		xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
		xmlhttp.send(JSON.stringify(params));
	}

	//event - socket performace  event
	//value - current value for that event
	//conditionalInitValue -  for items that need to be updated once, update only when previous value equals to conditionalInitValue (0)
	function updatePerformanceCounter(event, value, conditionalInitValue) {
		if (_timestamps.sockets) {
			var temp = _timestamps.sockets[event];

			if (typeof conditionalInitValue !== "undefined") {
				if (temp === conditionalInitValue) {
					_timestamps.sockets[event] = value;
				}

				return;
			}
			_timestamps.sockets[event] = value;
		}

		return; // for better code readability
	}

	function updatefirstFrameCounter(event) {
		if (!eventsCalledOnce[event]) {
			updatePerformanceCounter(event, Date.now(), 0);
			eventsCalledOnce[event] = true;
		}
	}

	function onReceived(messageEvent) {
		// time stamp on first frame
		updatefirstFrameCounter("firstFrame");

		if (messageEvent && messageEvent.data) {
			if (messageEvent.data === "OK") {
				return;
			}
			var messageData = JSON.parse(messageEvent.data);
			var receivedMessage = { msgId: 0 };

			if (messageData && messageData.M && messageData.M.length > 0) {
				for (var i = 0; i < messageData.M.length; i++) {
					try {
						if (messageData.M[i] === "OK") {
							continue;
						}
						var msgObj = JSON.parse(messageData.M[i]);

						receivedMessage.msgId = msgObj.msgId || receivedMessage.msgId;

						if (msgObj.clientStateResult) {
							// time stamp on first quote
							updatefirstFrameCounter("firstQuote");
						}
						// acknowledgment action
						if (msgObj.action === receiveActions.ack) {
							sendAck(msgObj.msgId);
						}
						//server error and it still connected but asks to reconnect - we will reconnect
						else if (msgObj.action === receiveActions.reconnected) {
							onReconnectedAction();
							return;
						} else if (msgObj.action === receiveActions.reconnectOnError) {
							onDisconnected();
							return;
						} else if (msgObj.action === receiveActions.disconnect) {
							onDisconnected();
							return;
						}

						if (messageHandler) {
							messageHandler(msgObj);
						}
					} catch (err) {
						log("onReceived - failed to parse message data:" + messageData.M[i]);
					}
				}

				onReceivedKeepAlive(receivedMessage);
			}
		}
	}

	function clearKeepAliveTimeInterval() {
		log("clearKeepAliveTimeInterval");

		if (receiveKeepAliveTimeout) {
			clearInterval(receiveKeepAliveTimeout);
			receiveKeepAliveTimeout = null;
		}
	}

	function onReceivedKeepAlive(message) {
		retriesOnDisconnectedFailedConnection = 0;
		lastKeepAliveMsg = { date: new Date(), id: message.msgId };
	}

	function checkKeepAlive() {
		if (!lastKeepAliveMsg) {
			return;
		}

		var actualDate = new Date();

		var timeBetweenMessages = Math.abs((actualDate.getTime() - lastKeepAliveMsg.date.getTime()) / 1000);

		if (
			!isStartMode &&
			!isShutDownMode &&
			timeBetweenMessages > socketConfig.keepAlivePeriod + socketConfig.keepAliveBuffer &&
			isNotFirstKeepAlive
		) {
			log(
				"Time out...try to reconnect at: " +
					actualDate +
					", last keep alive message date: " +
					lastKeepAliveMsg.date +
					", last keep alive message id: " +
					lastKeepAliveMsg.id
			);
			isNotFirstKeepAlive = false;
			onDisconnected();
			return;
		}

		isNotFirstKeepAlive = true;
	}

	function onerror(event, source) {
		try {
			if (typeof event !== "undefined" && typeof source !== "undefined") {
				log(
					"Socket_connection_error,source=" +
						source +
						",reason=" +
						(typeof event === "string"
							? event
							: (event.reason || "CloseEvent") +
							  ",code=" +
							  (event.code || 0) +
							  ",wasClean=" +
							  (event.wasClean || true) +
							  ",message=" +
							  (event.message || "") +
							  ",target=" +
							  (event.target || ""))
				);
			}

			wsState.ResetConnectionData();
			tryCloseSocket(true);
			hasStarted.reject(event);
		} catch (e) {
			if (e && e.message) {
				log("onerror failed, error: " + e.message);
			}
		}
	}

	function connect(error) {
		try {
			if (!wsState.CanConnect()) {
				hasStarted.reject("cannot connect");
				return;
			}

			if (error) {
				log("get jwt failed, error: " + error.message);
				hasStarted.reject(error);

				return;
			}

			_timestamps.jwtComplete = Date.now();

			//account is not websockets abtesting and no session storage
			var jwtToken = wsState.GetJwtToken(),
				connectionToken = wsState.GetConnectionToken(),
				url =
					//_wsUrl +
					"wss://csmdev.fihtrader.com/csmstream/connect?transport=webSockets&clientProtocol=1.5&connectionToken=" +
					connectionToken +
					"&jwt=" +
					jwtToken;

			_socket = new WebSocket(url);

			_socket.onerror = function (event) {
				onerror(event, "socket_onerror");
			};

			_socket.onopen = function onOpen() {
				updatePerformanceCounter("connectionComplete", Date.now());

				isStartMode = false;
				if (_socket.readyState === WebSocket.OPEN) {
					log("start connection done, transport = webSockets");
					disconnectedMaxRetries = 25;
					retriesOnDisconnectedFailedConnection = 0;
					hasStarted.resolve(true);

					if (!receiveKeepAliveTimeout) {
						receiveKeepAliveTimeout = setInterval(checkKeepAlive, socketConfig.keepAlivePeriod * 1000);
					}
					return;
				}
				hasStarted.reject();
			};

			// set event handlers
			_socket.onmessage = onReceived;
			_socket.onclose = function (event) {
				// Only handle a socket close if the close is from the current socket.
				// Sometimes on disconnect the server will push down an onclose event
				// to an expired socket.
				if (this !== _socket) {
					log("onclose called on a wrong socket instance");
					return;
				}

				if (!isStartMode && typeof event.wasClean !== "undefined" && event.wasClean === false) {
					// Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but
					// I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.
					onerror(event, "socket_onclose_unclean_disconnect");
					return;
				}

				tryCloseSocket(true);
				hasStarted.reject();
			};
		} catch (e) {
			hasStarted.reject(e);

			if (e && e.message) {
				log("start connection failed, error: " + e.message);
			}
		}
	}

	function start() {
		isStartMode = true;
		updatePerformanceCounter("connectionStart", Date.now());
		hasStarted = Q.defer();

		wsState
			.TryConnect()
			.then(connect)
			.catch(function onFallback(error) {
				hasStarted.reject(error);
			})
			.done();

		return hasStarted.promise;
	}

	function isConnected() {
		return !socketIsNull() && _socket.readyState === WebSocket.OPEN;
	}
	function canSend(method) {
		var isconnected = isConnected();
		var isconnectionAvailable = !isShutDownMode && isconnected;

		if (!isconnectionAvailable) {
			log(
				"canSend=false" +
					",method=" +
					method +
					",isShutDownMode=" +
					isShutDownMode +
					",isconnected=" +
					isconnected +
					",sockeState=" +
					(_socket === null ? "null" : _socket.readyState)
			);
		}
		return isconnectionAvailable;
	}

	function sendAck(msgId) {
		if (canSend("ack")) {
			_socket.send(JSON.stringify({ ack: msgId }));
		}
	}

	//server send reconnect action
	function onReconnectedAction() {
		if (reconnectedHandler) {
			reconnectedHandler();
		}
	}
	// #endregion Private methods

	function init(url, timestamps, hashParams) {
		_wsUrl = url.replace("https://", "wss://").replace("http://", "ws://");
		_timestamps = timestamps;

		setDefaultConfig();

		wsState.Init(hashParams);
		return start();
	}

	function isNullOrNaN(value) {
		return typeof value === "undefined" || value === null || value === "" || isNaN(parseFloat(value));
	}

	function setDefaultConfig() {
		var csmPushServicekeepAlivePeriod = window.environmentData.csmPushServicekeepAlivePeriod;
		var csmPushServicekeepAliveBuffer = window.environmentData.csmPushServicekeepAliveBuffer;

		socketConfig = {
			keepAlivePeriod: !isNullOrNaN(csmPushServicekeepAlivePeriod)
				? parseFloat(csmPushServicekeepAlivePeriod)
				: defaultKeepAlivePeriod,
			keepAliveBuffer: !isNullOrNaN(csmPushServicekeepAliveBuffer)
				? parseFloat(csmPushServicekeepAliveBuffer)
				: defaultKeepAliveBuffer,
		};
		isShutDownMode = false;
		isStartMode = true;
		lastKeepAliveMsg = null;
		eventsCalledOnce = {
			firstFrame: false,
			firstQuote: false,
		};
	}

	function socketIsNull() {
		return _socket === null || typeof _socket === "undefined";
	}

	function tryCloseSocket(disposeOnly) {
		if (socketIsNull()) {
			return false;
		}
		disposeOnly = disposeOnly || false;
		_socket.onopen = null;
		_socket.onerror = null;
		_socket.onmessage = null;
		_socket.onclose = null;
		if (!disposeOnly) _socket.close();
		_socket = null;

		return true;
	}

	function stopConnection(shutDownMode) {
		if (!tryCloseSocket()) return;
		if (shutDownMode) {
			clearKeepAliveTimeInterval();
		}
		var stack = new Error().stack ? new Error().stack : "not supported by this browser";
		log("stopping, stack: " + stack.toString().substring(0, 1500));
		isShutDownMode = shutDownMode;
	}

	function onDisconnected() {
		if (onDisconnectedIsAlreadyRunning) {
			return;
		}

		onDisconnectedIsAlreadyRunning = true;

		try {
			clearKeepAliveTimeInterval();
			tryCloseSocket();

			if (disconnectedHandler) {
				disconnectedHandler();
			}

			if (isShutDownMode) {
				log("disconnect reason: isShutDownMode");
			} else if (isStartMode) {
				log("disconnect reason: connection not successful on start");

				if (hasStarted) {
					hasStarted.reject("disconnected while is starting connection");
				}
			} else {
				reconnect();
			}
		} catch (e) {
			onDisconnectedIsAlreadyRunning = false;
		}
	}

	function reconnect() {
		retriesOnDisconnectedFailedConnection += 1;
		if (retriesOnDisconnectedFailedConnection < 5 || retriesOnDisconnectedFailedConnection % 5 === 0) {
			log("onDisconnected- retry: " + retriesOnDisconnectedFailedConnection);
		}

		if (retriesOnDisconnectedFailedConnection <= disconnectedMaxRetries) {
			wsState.ResetConnectionData();
			start()
				.then(function () {
					onReconnected(retriesOnDisconnectedFailedConnection);
					onDisconnectedIsAlreadyRunning = false;
				})
				.fail(reconnect)
				.done();
		} else {
			var errorMessage = "socket disconnect max retries breached";

			log(errorMessage);

			if (notAvailableHandler) {
				notAvailableHandler();
			}

			stopConnection(false);
			onDisconnectedIsAlreadyRunning = false;
		}
	}

	function onReconnected(retries) {
		if (reconnectedHandler) {
			reconnectedHandler();
		}

		if (retries > 1) {
			log("Reconnected after " + retries + " attempts");
		}
	}

	function send(methodName, params) {
		if (canSend(methodName)) {
			_socket.send(JSON.stringify({ methodName: methodName, params: params }));
		}
	}

	return {
		init: init,
		setNotAvailableHandler: function (fnHandler) {
			notAvailableHandler = fnHandler;
		},
		hasStarted: function () {
			return hasStarted.promise;
		},
		setMessageHandler: function (fnHandler) {
			messageHandler = fnHandler;
		},
		setReconnectedHandler: function (fnHandler) {
			reconnectedHandler = fnHandler;
		},
		setDisconnectedHandler: function (fnHandler) {
			disconnectedHandler = fnHandler;
		},
		send: send,
		stop: function () {
			stopConnection(true);
		},
		isConnected: isConnected,
		setdisconnectedMaxRetries: function (maxRetries) {
			disconnectedMaxRetries = maxRetries;
		},
	};
});

/* global eShutDownHandlerTopics, ko, eDealerParams */
define("dataaccess/dalsocketclientstate", [
	"require",
	"StateObject!DealerParams",
	"managers/CustomerProfileManager",
	"initdatamanagers/Customer",
	"handlers/websocketconnection",
], function (require) {
	var stateObjectDealerParams = require("StateObject!DealerParams"),
		CustomerProfileManager = require("managers/CustomerProfileManager"),
		Customer = require("initdatamanagers/Customer"),
		SocketConnection = require("handlers/websocketconnection");
		

	function TDALSocketClientState() {
		if (!SocketConnection.isConnected()) {
			throw new Error("Cannot establish web socket connection");
		}

		var isFirstRegistration = true;

		var register = function (list, flag, isReinitialized) {
			var methodName,
				profileCustomer = CustomerProfileManager.ProfileCustomer(),
				dealerCurrency = stateObjectDealerParams.get(eDealerParams.DealerCurrency);
			var customCurrency = dealerCurrency || profileCustomer.displaySymbol;
			if (isFirstRegistration || flag === eSubscriptionRequestFlags.All || isReinitialized) {
				isFirstRegistration = false;
				methodName = "RegisterQuotesAndGetInitialAll";
				var cust = Customer.prop || {};
				SocketConnection.send(methodName, {
					instruments: list,
					symbol: customCurrency !== cust.baseCcyId() ? customCurrency : null,
				});
			} else {
				methodName = "RegisterQuotesAndGetInitialQuotes";
				SocketConnection.send(methodName, {
					instruments: list,
				});
			}
			
		};

		function unregister() {
			SocketConnection.send("Unregister");
		}

		function setDisplaySymbol(symbolId) {
			SocketConnection.send("SetDisplaySymbol", { symbol: symbolId });
		}

		function registerMessageCallback(fnHandler) {
			SocketConnection.setMessageHandler(fnHandler);
		}

		function registerReconnectedCallback(fnHandler) {
			SocketConnection.setReconnectedHandler(fnHandler);
		}

		function registerDisconnectedCallback(fnHandler) {
			SocketConnection.setDisconnectedHandler(fnHandler);
		}

		return {
			registerMessageCallback: registerMessageCallback,
			registerReconnectedCallback: registerReconnectedCallback,
			registerDisconnectedCallback: registerDisconnectedCallback,
			StopConnection: function () {
				SocketConnection.stop();
			},
			Register: register,
			Unregister: unregister,
			SetDisplaySymbol: setDisplaySymbol,
			HasStarted: SocketConnection.hasStarted,
		};
	}

	return TDALSocketClientState;
});

define(
    'cachemanagers/SocketCacheManager',
    [
        'require',
        'handlers/general',
        'dataaccess/dalsocketclientstate',
        'generalmanagers/ErrorManager',
        'StateObject!SystemNotificationEvents',
        "handlers/Delegate",
        "initdatamanagers/Customer"
    ],
    function (require) {
        var TDALSocketClientState = require('dataaccess/dalsocketclientstate'),
            general = require('handlers/general'),
            ErrorManager = require('generalmanagers/ErrorManager'),
            stateObject = require("StateObject!SystemNotificationEvents"),
            delegate = require("handlers/Delegate"),
            customer = require("initdatamanagers/Customer"),
            csmStateObject = require('StateObject!Csm');

        function SocketCacheManager(clientStateDataProcessor) {
            var dalSocketClientState;
            var firstLoad = Q.defer();
            var onLoadRequest = new delegate();
            var onRegisterRequest = new delegate();
            
            
            // var clientStateBurstInterval = 100;
            var messageGapThreshold = 1;
            var prevMessageId = -1;
            var prevMsgServerTime = null;
            var prevMsgClientTime = null;

            try {
                dalSocketClientState = new TDALSocketClientState();
                dalSocketClientState.registerMessageCallback(onLoadComplete);
                dalSocketClientState.registerReconnectedCallback(onReconnected);
                dalSocketClientState.registerDisconnectedCallback(onDisconnected);

            } catch (e) {
                ErrorManager.onError("SocketCacheManager/SocketCacheManager", "cannot establish socket connection", eErrorSeverity.medium);
                throw e;
            }

            function onReconnected() {
                whenConnectionReady()
                    .then(function () {
                        onRegisterRequest.Invoke(eSubscriptionRequestFlags.All, true);
                    }).then(function () {
                        csmStateObject.update(eStateObjectTopics.CsmOutOfDate, false); 
                    })
                    .done();
            }

            function onDisconnected() {
                csmStateObject.update(eStateObjectTopics.CsmOutOfDate, true); 
            }

            function messageNumberSequenced(msgId, msgServerTime) {
                //if received initial start count again
                //Initial: msgId=0, Update:msgId>0
                if (!general.isNumber(msgId)) {
                    return false;
                }

                var msgClientTime = new Date().toISOString();

                if (msgId > 0 && prevMessageId > -1 && Math.abs(msgId - prevMessageId) > messageGapThreshold) {

                    ErrorManager.onWarning("missed messages," +
                        "\nprevious=" + prevMessageId + ", serverTime: " + prevMsgServerTime + ", clientTime: " + prevMsgClientTime + "," +
                        "\nnext=" + msgId + ", serverTime: " + msgServerTime + ", clientTime: " + msgClientTime);

                    onReconnected();
                    prevMessageId = -1;

                    return false;
                }
                prevMessageId = msgId;
                prevMsgServerTime = msgServerTime;
                prevMsgClientTime = msgClientTime;

                return true;
            }

            function onLoadComplete(msgObj) {
                //error message do not have msgid     
                if (!general.isNullOrUndefined(msgObj.msgId) && !messageNumberSequenced(msgObj.msgId, msgObj.time)) {
                    return;
                }
                var _isReinitialized = msgObj.message === "INITIAL";

                if (_isReinitialized || (customer && customer.prop.csmTrace()) ){
                    ErrorManager.onWarning("msgObj_mode: " + msgObj.message + ", msgObj_id: " + msgObj.msgId + ", msgObj_id: " + msgObj.time);
                }


                onLoadRequest.Invoke();
                processData(msgObj.data, _isReinitialized);
            }

            // supporting cache manager interface with nop that return fulfilled
            function loadData() {
                return Q.all([whenConnectionReady(), firstLoad.promise]);
            }

            function setDisplaySymbol(newSymbol) {
                whenConnectionReady()
                    .then(function () {
                        dalSocketClientState.SetDisplaySymbol(newSymbol);
                    })
                    .done();
            }

            function processData(data, reinitialize) {
                if (data && data.length > 0) {
                    clientStateDataProcessor.processData(data, reinitialize);
                }

                firstLoad.resolve();
            }

            function register(requestList, flag, _isReinitialized) {
                whenConnectionReady()
                    .then(function () {
                        dalSocketClientState.Register(requestList, flag, _isReinitialized);
                    })
                    .done();
            }

            function unregister() {}

            function whenConnectionReady() {
                return dalSocketClientState.HasStarted();
            }

            stateObject.set(eShutDownHandlerTopics.stopClientStateManagerCalls, null);
            stateObject.subscribe(eShutDownHandlerTopics.stopClientStateManagerCalls, function () {
                ErrorManager.onWarning("connection stop eShutDownHandlerTopics.stopClientStateManagerCalls");
                dalSocketClientState.StopConnection();
            });

            return {
                Register: register,
                LoadData: loadData,
                Unregister: unregister,
                SetDisplaySymbol: setDisplaySymbol,
                LoadFinished: loadData,
                OnLoadRequest: onLoadRequest,
                OnRegisterRequest: onRegisterRequest
            };
        }

        return SocketCacheManager;
    }
);
var TDALNotificationData = function () {
    function getUpdatedCacheElementsData(url) {
        var ajaxer = new TAjaxer();

        return ajaxer.promises.get("TDALNotificationData/getUpdatedCacheElementsData", url, null, null, null, null, null, null, false);
    }

    return {
        GetUpdatedCacheElementsData: getUpdatedCacheElementsData
    };
};

define("dataaccess/dalNotificationData", ["generalmanagers/ErrorManager"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (em) {
				return this.TDALNotificationData(em);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TDALNotificationData;
    };
}(this)));

define(
    'cachemanagers/NotificationsManager',
    [
        'require',
        'JSONHelper',
        'global/UrlResolver',
        'global/debounce',
        'handlers/Cookie',
        'handlers/Delegate',
        'generalmanagers/ErrorManager',
        'dataaccess/dalNotificationData',
        'enums/DataMembersPositions'
    ],
    function TNotificationManager(require) {
        var JSONHelper = require('JSONHelper'),
            UrlResolver = require('global/UrlResolver'),
            debounce = require('global/debounce'),
            CookieHandler = require('handlers/Cookie'),
            delegate = require('handlers/Delegate'),
            ErrorManager = require('generalmanagers/ErrorManager'),
            dalNotificationData = require('dataaccess/dalNotificationData'),
            onInstrumentsUpdated = new delegate(),
            onMinDealAmountsUpdated = new delegate(),
            notifications = [];

        function processData(data) {
            //loop trough all notications and raise the relevant events
            for (var i = 0, length = data.length; i < length; i++) {
                notifications[data[i][eNotification.NotificationType]].Invoke({ id: data[i][eNotification.ItemId], ver: data[i][eNotification.RelatedItemId], hash: data[i][eNotification.Version] });
            }
        }

        //------------------------------------------------
        // register the relevant delegates to each notification type
        //------------------------------------------------
        function notificationEvents() {
            notifications[eNotificationType.InstrumentEdited] = new delegate();
            notifications[eNotificationType.InstrumentEdited].Add(onInstrumentModified);

            notifications[eNotificationType.MinDealGroupEdited] = new delegate();
            notifications[eNotificationType.MinDealGroupEdited].Add(onMinDealGroupModified);
        }

        var getUpdatedData = debounce(function (url, version, notificationType) {
            var context = getDataTypeToUpdate(notificationType);

            dalNotificationData
                .GetUpdatedCacheElementsData(url)
                .then(function (responseText) {
                    onUpdateDataComplete(version, context, responseText);
                })
                .fail(function () {
                    ErrorManager.onWarning('NotificationsManager/onRetryUpdate' + context.updateditem, context.updateditem + ' version sync retry failed');
                })
                .done();
        }, 5000);

        function onMinDealGroupModified(newVersion) {
            if (newVersion.id !== UrlResolver.getMinDealGroupId()) {
                return;
            }

            if (newVersion.ver !== UrlResolver.getMinDealsVersion()) {
                var url = UrlResolver.getStaticInitialDataMinDealAmountsUrl(newVersion.id, newVersion.ver, newVersion.hash);
                getUpdatedData(url, newVersion, eNotificationType.MinDealGroupEdited);
            }
        }

        function onInstrumentModified(newVersion) {
            if (newVersion.ver !== UrlResolver.getInstrumentsVersion()) {
                var url = UrlResolver.getStaticInitialDataInstrumentsUrl(newVersion.ver, newVersion.hash);
                getUpdatedData(url, newVersion, eNotificationType.InstrumentEdited);
            }
        }

        function onUpdateDataComplete(version, context, responseText) {
            var data = JSONHelper.STR2JSON('NotificationsManager/onUpdate' + context.updateditem + 'Complete', responseText, eErrorSeverity.high);

            if (data) {
                CookieHandler.CreateCookie('B', CookieHandler.ReadCookie('B').replace(context.regex, '$1' + version.ver + '$3' + version.hash + '$5'), (new Date()).AddMonths(6));
                context.callback.Invoke(data);
            }
        }

        function getDataTypeToUpdate(notificationType) {
            var regexstring;
            var callback;
            var prop;

            var enumNameFromValue = function (val) {
                for (prop in eNotificationType) {
                    if (eNotificationType[prop] === val) {
                        return prop;
                    }
                }
            };

            switch (notificationType) {
                case eNotificationType.InstrumentEdited:
                    callback = onInstrumentsUpdated;
                    regexstring = /(.*\|)([\d]+)(-VER\|)([\w]+)(-H)/i;
                    break;

                case eNotificationType.MinDealGroupEdited:
                    regexstring = /(.*\|)([\d]+)(-MVER\|)([\w]+)(-MH)/i;
                    callback = onMinDealAmountsUpdated;
                    break;
            }

            return { updateditem: enumNameFromValue(notificationType), regex: regexstring, callback: callback }
        }

        notificationEvents();

        return {
            ProcessData: processData,
            OnInstrumentsUpdated: onInstrumentsUpdated,
            OnMinDealAmountsUpdated: onMinDealAmountsUpdated
        };
    }
);

define(
    'cachemanagers/ClientStateHolderManager',
    [
        'require',
        'handlers/general',
        'handlers/Delegate',
        'initdatamanagers/Customer'
    ],
    function ClientStateHolderManager(require) {
        var general = require('handlers/general'),
            delegate = require('handlers/Delegate'),
            customer = require('initdatamanagers/Customer');

        var onChange = new delegate(),
            csHolder = {
                accountBalance: 0,
                equity: 0,
                netExposure: 0,
                margin: 0,
                exposureCoverage: 0,
                totalEquity: 0,
                openPL: 0,
                usedMargin: 0,
                marginUtilizationPercentage: 0,
                availableMargin: 0,
                marginUtilizationStatus: 0,
                maintenanceMargin: 0
            };

        function processData(data) {
            updateData(data);
            onChange.Invoke(csHolder);
        }

        function updateData(data) {
            csHolder.accountBalance = data[eCSHolder.accountBalance];
            csHolder.equity = data[eCSHolder.equity];
            csHolder.netExposure = data[eCSHolder.netExposure];
            csHolder.margin = data[eCSHolder.margin];
            csHolder.exposureCoverage = data[eCSHolder.exposureCoverage];
            csHolder.totalEquity = data[eCSHolder.totalEquity];
            csHolder.openPL = data[eCSHolder.openPL];

            csHolder.usedMargin = data[eCSHolder.usedMargin];

            csHolder.maintenanceMargin = general.formatNumberWithThousandsSeparator(
                (general.toNumeric(csHolder.usedMargin) * customer.prop.maintenanceMarginPercentage / 100).toFixed(2));

            csHolder.marginUtilizationPercentage = data[eCSHolder.marginUtilizationPercentage];
            csHolder.availableMargin = data[eCSHolder.availableMargin];
            csHolder.marginUtilizationStatus = data[eCSHolder.marginUtilizationStatus];
        }

        return {
            CSHolder: csHolder,
            OnChange: onChange,
            ProcessData: processData
        };
    }
);
define(
    'cachemanagers/InstrumentVolumeManager',
    [
        'require',
        'handlers/general',
        'handlers/Delegate',
        'handlers/HashTable'
    ],
    function InstrumentVolumeManager(require) {
        var general = require('handlers/general'),
            delegate = require('handlers/Delegate'),
            hashTable = require('handlers/HashTable');

        function InstrumentVolume() {
            this.InstrumentID = 0;
            this.BaseSymbolNetExposure = 0;
            this.OtherSymbolNetExposure = 0;
            this.AccountSymbolAmount = 0;
            this.RequiredMarginPercentage = 0;
            this.UsedMargin = 0;
            this.MarginUtilizationPercentage = 0;
            this.AvailableMargin = 0;
            this.MarginUtilizationStatus = eMarginUtilizationStatus.NA;
            this.Status = eStatus.Removed;
            this.LastUpdate = '';
            this.BaseSymbolAmount = 0;
            this.OtherSymbolAmount = 0;
        }

        var instrumentVolumes = new hashTable();
        var onChange = new delegate();

        function update(item, delta) {
            for (var prop in eInstrumentVolume) {
                if (eInstrumentVolume.hasOwnProperty(prop)) {
                    if (general.isDefinedType(item[prop])) {
                        item[prop] = delta[eInstrumentVolume[prop]];
                    }
                }
            }
        }

        function create(data) {
            var newItem = new InstrumentVolume();

            update(newItem, data);

            return newItem;
        }

        function processData(data) {
            var items = { newItems: [], editedItems: [], removedItems: [] }

            for (var i = 0, length = data.length; i < length; i++) {
                var id = data[i][eInstrumentVolume.InstrumentID];

                switch (data[i][eInstrumentVolume.Status]) {
                    case eStatus.New:
                    case eStatus.Edited:
                        if (instrumentVolumes.GetItem(id)) {
                            update(instrumentVolumes.GetItem(id), data[i]);
                            items.editedItems.push(id);
                        }
                        else {
                            instrumentVolumes.SetItem(id, create(data[i]));
                            items.newItems.push(id);
                        }
                        break;

                    case eStatus.Removed:
                        if (instrumentVolumes.GetItem(id)) {
                            instrumentVolumes.RemoveItem(id);
                            items.removedItems.push(id);
                        }
                        break;
                }
            }

            onChange.Invoke(items);
        }

        return {
            InstrumentVolumes: instrumentVolumes,
            OnChange: onChange,
            ProcessData: processData
        };
    }
);
define(
    'cachemanagers/NetExposureManager',
    [
        'require',
        'handlers/Delegate',
        'handlers/HashTable'
    ],
    function NetExposureManager(require) {
        var delegate = require('handlers/Delegate'),
            hashTable = require('handlers/HashTable');

        var exposures = new hashTable(),
            onChange = new delegate();

        function Exposure() {
            this.symbolId = '';
            this.amount = '';
            this.accountSymbolAmount = '';
            this.status = '';
        }

        function processData(data) {
            var items = [],
                i,
                len = data.length,
                item;

            if (len > 0) {
                for (i = 0; i < len; i++) {
                    item = exposures.GetItem(data[i][eExposure.symbolID]);

                    if (!item) {
                        item = new Exposure();
                        exposures.SetItem(data[i][eExposure.symbolID], item);
                    }

                    items.push(item);
                    updateExposure(item, data[i]);
                }

                onChange.Invoke(items);
            }
        }

        function updateExposure(exposure, data) {
            exposure.symbolId = data[eExposure.symbolID];
            exposure.amount = data[eExposure.amount];
            exposure.accountSymbolAmount = data[eExposure.accountSymbolAmount];
            exposure.status = data[eExposure.status];
        }

        return {
            Exposures: exposures,
            OnChange: onChange,
            ProcessData: processData
        };
    }
);

define(
    'cachemanagers/QuotesManager',
    [
        'require',
        'tracking/PerformanceDataCollector',
        'handlers/HashTable',
        'handlers/Delegate',
        'enums/DataMembersPositions'
    ],
    function TQuotesManager(require) {
        function TQuote(instrumentId) {
            this.id = instrumentId;
            this.bid = 0;
            this.ask = '';
            this.open = '';
            this.high = '';
            this.low = '';
            this.highBid = '';
            this.lowAsk = '';
            this.tradeTime = '';
            this.change = 0;
            this.changePips = 0;
            this.state = eQuoteStates.NotChanged;
            this.close = '';
        }

        TQuote.prototype.isActive = function () {
            return this.state !== eQuoteStates.Disabled && this.state !== eQuoteStates.TimedOut && this.state !== eQuoteStates.Locked;
        }

        var PerformanceDataCollector = require('tracking/PerformanceDataCollector');
        var onChange = require('handlers/Delegate');
        var quotes = require('handlers/HashTable');

        onChange = new onChange();
        quotes = new quotes();

        onChange.Add(onFirstQuote);

        function onFirstQuote() {
            PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.FirstQuoteEvent);
            onChange.Remove(onFirstQuote);
        }

        function processTickData(data, serverTime) {
            resetStates();

            var delta = [];
            for (var i = 0, length = data.length; i < length; i++) {
                var quote = quotes.GetItem(data[i][eTicks.instrumentID]);

                if (!quote) {
                    quote = new TQuote(data[i][eTicks.instrumentID]);
                    quotes.SetItem(quote.id, quote);
                }

                updateQuoteFromTick(quote, data[i], serverTime);
                delta.push(quote.id);
            }

            onChange.Invoke(delta);
        }

        function processOhlcData(data) {
            var delta = [];

            for (var i = 0, length = data.length; i < length; i++) {
                var quote = quotes.GetItem(data[i][eOhlc.instrumentID]);

                if (!quote) {
                    quote = new TQuote(data[i][eOhlc.instrumentID]);
                    quotes.SetItem(quote.id, quote);
                }

                updateQuoteFromOhlc(quote, data[i]);
                delta.push(quote.id);
            }

            onChange.Invoke(delta);
        }

        function resetStates() {
            quotes.ForEach(function iterator(key, item) {
                if (item.isActive()) {
                    item.state = eQuoteStates.NotChanged;
                }
            });
        }

        function updateQuoteFromTick(quote, delta, serverTime) {
            quote.state = getState(quote, delta);
            quote.bid = delta[eTicks.bid];
            quote.ask = delta[eTicks.ask];

            if (serverTime) {
                var currentTradeTime = new Date(serverTime.getTime());
                currentTradeTime.AddSeconds(-delta[eTicks.tradeTimeOffset]);
                quote.tradeTime = currentTradeTime.ExtractDateShortYear() + ' ' + currentTradeTime.ExtractFullTime();
            }

            quote.changePips = quote.bid - quote.close;
            quote.change = (quote.close != 0) ? (quote.bid / quote.close - 1) * 100 : 0;
        }

        function updateQuoteFromOhlc(quote, delta) {
            quote.open = delta[eOhlc.open];
            quote.highBid = delta[eOhlc.high];
            quote.lowAsk = delta[eOhlc.low];
            quote.close = delta[eOhlc.close];
        }

        function getState(quote, delta) {
            if (delta[eTicks.state] != eQuoteStates.Enabled) {
                return delta[eTicks.state];
            }

            if (quote.bid < delta[eTicks.bid]) {
                return eQuoteStates.Up;
            }

            if (quote.bid > delta[eTicks.bid]) {
                return eQuoteStates.Down;
            }

            return eQuoteStates.NotChanged;
        }

        function removeItems(items) {
            for (var i = 0, length = items.length; i < length; i++) {
                quotes.Remove(items[i]);
            }
        }

        var module = window.$quotesManager = {
            OnChange: onChange,
            Quotes: quotes,
            ProcessTickData: processTickData,
            ProcessOhlcData: processOhlcData,
            GetState: getState,
            RemoveItems: removeItems
        };

        return module;
    }
);
function TLimit(orderID, data) {
    data = data || [];

    this.orderID = orderID;
    this.instrumentID = data[eLimit.instrumentID];
    this.baseSymbol = data[eLimit.baseSymbol];
    this.otherSymbol = data[eLimit.otherSymbol];
    this.positionNumber = data[eLimit.positionNumber];
    this.accountNumber = data[eLimit.accountNumber];
    this.orderDir = data[eLimit.orderDir];
    this.orderRate = data[eLimit.orderRate];
    this.buySymbolID = data[eLimit.buySymbolID];
    this.buyAmount = data[eLimit.buyAmount];
    this.sellSymbolID = data[eLimit.sellSymbolID];
    this.sellAmount = data[eLimit.sellAmount];
    this.type = data[eLimit.type];
    this.mode = data[eLimit.mode];
    this.expirationDate = data[eLimit.expirationDate];
    this.entryTime = data[eLimit.entryTime];
    this.slRate = data[eLimit.slRate];
    this.tpRate = data[eLimit.tpRate];
    this.otherLimitID = data[eLimit.otherLimitID];
    this.status = "";
}

TLimit.prototype.Update = function(data) {
    this.orderID = data[eLimit.orderID];
    this.instrumentID = data[eLimit.instrumentID];
    this.baseSymbol = data[eLimit.baseSymbol];
    this.otherSymbol = data[eLimit.otherSymbol];
    this.positionNumber = data[eLimit.positionNumber];
    this.accountNumber = data[eLimit.accountNumber];
    this.orderDir = data[eLimit.orderDir];
    this.orderRate = data[eLimit.orderRate];
    this.buySymbolID = data[eLimit.buySymbolID];
    this.buyAmount = data[eLimit.buyAmount];
    this.sellSymbolID = data[eLimit.sellSymbolID];
    this.sellAmount = data[eLimit.sellAmount];
    this.type = data[eLimit.type];
    this.mode = data[eLimit.mode];
    this.expirationDate = data[eLimit.expirationDate];
    this.entryTime = data[eLimit.entryTime];
    this.slRate = data[eLimit.slRate];
    this.tpRate = data[eLimit.tpRate];
    this.otherLimitID = data[eLimit.otherLimitID];
};
define("handlers/limit", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.TLimit;
    };
}(this)));

define(
    'cachemanagers/activelimitsmanager',
    [
        'handlers/Delegate',
        'handlers/HashTable',
        'handlers/limit'
    ],
    function ActiveLimitsManager(delegate, hashtable, tlimit) {
        var onChange = new delegate(),
            onPriceAlert = new delegate(),
            limits = new hashtable();

        function processData(data, isReinitialized) {
            var items = { newLimits: [], editedLimits: [], removedLimits: [] };
            var i, length, id, limit;

            if (isReinitialized) {
                limits.ForEach(function iterator(orderId) {
                    var isInData = false,
                        newData = [];

                    for (i = 0, length = data.length; i < length; i++) {
                        if (data[i][eLimit.orderID] == orderId) {
                            isInData = true;
                            break;
                        }
                    }

                    if (!isInData) {
                        newData[eLimit.status] = eStatus.Removed;
                        newData[eLimit.orderID] = orderId;

                        data.push(newData);
                    }
                });
            }

            for (i = 0, length = data.length; i < length; i++) {
                id = data[i][eLimit.orderID];
                limit = limits.GetItem(id);

                switch (data[i][eLimit.status]) {
                    case eStatus.New:
                    case eStatus.Edited:
                        if (limit) {
                            limit.Update(data[i]);
                            items.editedLimits.push(id);
                        }
                        else {
                            limit = new tlimit(id, data[i]);
                            limits.SetItem(id, limit);
                            items.newLimits.push(id);
                        }
                        break;

                    case eStatus.Removed:
                        if (limit) {
                            limits.RemoveItem(id);
                            items.removedLimits.push(id);
                        }
                        break;
                }
            }

            onPriceAlert.Invoke(limits.Container);
            onChange.Invoke(items);
        }

        var getPriceAlerts = function () {
            return limits.Filter(function (orderId, limit) {
                return limit.mode === eLimitMode.PriceAlert;
            });
        };

        var hasPriceAlerts = function (instrumentId) {
            return limits
                .Find(function (orderId, limit) {
                    return limit.instrumentID === instrumentId && limit.mode === eLimitMode.PriceAlert;
                })
                .hasItems();
        };

        return {
            limits: limits,
            GetPriceAlerts: getPriceAlerts,
            HasPriceAlerts: hasPriceAlerts,

            OnChange: onChange,
            ProcessData: processData,
            OnPriceAlert: onPriceAlert,
        };
    }
);

function TDeal(data, plData) {
    data = data || [];
    plData = plData || [];

    this.instrumentID = data[eDeal.instrumentID];
    this.orderID = data[eDeal.orderID];
    this.baseSymbol = data[eDeal.baseSymbol];
    this.otherSymbol = data[eDeal.otherSymbol];
    this.positionNumber = data[eDeal.positionNumber];
    this.accountNumber = data[eDeal.accountNumber];
    this.orderDir = data[eDeal.orderDir];
    this.orderRate = data[eDeal.orderRate];
    this.orderRateNumeric = parseFloat((this.orderRate || '').replace(',', ''));
    this.buySymbolID = data[eDeal.buySymbolID];
    this.buyAmount = data[eDeal.buyAmount];
    this.sellSymbolID = data[eDeal.sellSymbolID];
    this.sellAmount = data[eDeal.sellAmount];
    this.valueDate = data[eDeal.valueDate];
    this.dealType = data[eDeal.dealType];
    this.exeTime = data[eDeal.exeTime];
    this.slRate = data[eDeal.slRate];
    this.slID = data[eDeal.slID];
    this.tpRate = data[eDeal.tpRate];
    this.tpID = data[eDeal.tpID];
    this.additionalPL = data[eDeal.additionalPL] || 0;
    this.spreadDiscount = data[eDeal.spreadDiscount] || 0;

    this.spotRate = plData[eDealPL.spotRate] || 0;
    this.fwPips = plData[eDealPL.fwPips] || 0;
    this.closingRate = plData[eDealPL.closingRate] || 0;
    this.pl = plData[eDealPL.pl] || 0;
    this.plNumeric = parseFloat((this.pl || '').replace(',', ''));
    this.lastUpdate = plData[eDealPL.lastUpdate];
    this.commission = plData[eDealPL.commission] || 0;

}

TDeal.prototype.Update = function(data) {
    this.instrumentID = data[eDeal.instrumentID];
    this.baseSymbol = data[eDeal.baseSymbol];
    this.otherSymbol = data[eDeal.otherSymbol];
    this.orderID = data[eDeal.orderID];
    this.positionNumber = data[eDeal.positionNumber];
    this.accountNumber = data[eDeal.accountNumber];
    this.orderDir = data[eDeal.orderDir];
    this.orderRate = data[eDeal.orderRate];
    this.buySymbolID = data[eDeal.buySymbolID];
    this.buyAmount = data[eDeal.buyAmount];
    this.sellSymbolID = data[eDeal.sellSymbolID];
    this.sellAmount = data[eDeal.sellAmount];
    this.valueDate = data[eDeal.valueDate];
    this.dealType = data[eDeal.dealType];
    this.exeTime = data[eDeal.exeTime];
    this.slRate = data[eDeal.slRate];
    this.slID = data[eDeal.slID];
    this.tpRate = data[eDeal.tpRate];
    this.tpID = data[eDeal.tpID];
    this.additionalPL = data[eDeal.additionalPL];
    this.spreadDiscount = data[eDeal.spreadDiscount] || 0;
};

TDeal.prototype.UpdatePL = function(plData) {
    this.spotRate = plData[eDealPL.spotRate];
    this.fwPips = plData[eDealPL.fwPips];
    this.closingRate = plData[eDealPL.closingRate];
    this.pl = plData[eDealPL.pl];
    this.lastUpdate = plData[eDealPL.lastUpdate];
    this.commission = plData[eDealPL.commission]; 
    this.plNumeric = parseFloat((this.pl || '').replace(',', ''));
};


define("handlers/Deal", [],function () { return TDeal });
define(
    'cachemanagers/dealsmanager',
    [
        'require',
        'handlers/HashTable',
        'handlers/Delegate',
        'handlers/Deal'
    ],
    function DealsManagerDef(require) {
        var hashtable = require('handlers/HashTable'),
            delegate = require('handlers/Delegate'),
            Deal = require('handlers/Deal');

        function DealsManager() {
            var deals = new hashtable(),
                onDealsChange = new delegate(),
                onDealsRemoved = new delegate(),
                onDealsPLChange = new delegate();

            function processDeals(data, isReinitialized) {
                var items = { newItems: [], editedItems: [], removedItems: [] };
                var i, length, id, deal;

                if (isReinitialized) {
                    deals.ForEach(function iterator(dealId) {
                        var isInData = false,
                            newData = [];

                        for (var idx = 0, len = data.length; idx < len; idx++) {
                            if (data[idx][eDeal.orderID] == dealId) {
                                isInData = true;
                                break;
                            }
                        }

                        if (!isInData) {
                            newData[eDeal.status] = eStatus.Removed;
                            newData[eDeal.orderID] = dealId;

                            data.push(newData);
                        }
                    });
                }

                for (i = 0, length = data.length; i < length; i++) {
                    id = data[i][eDeal.orderID];
                    deal = deals.GetItem(id);

                    switch (data[i][eDeal.status]) {
                        case eStatus.New:
                        case eStatus.Edited:
                            if (deal) {
                                deal.Update(data[i]);
                                items.editedItems.push(id);
                            }
                            else {
                                deal = new Deal(data[i]);
                                deals.SetItem(id, deal);
                                items.newItems.push(id);
                            }
                            break;

                        case eStatus.Removed:
                            if (deal) {
                                deals.RemoveItem(id);
                                items.removedItems.push(id);
                            }
                            break;
                    }
                }

                onDealsChange.Invoke(items);

                if (items.removedItems.length) {
                    onDealsRemoved.Invoke(items.removedItems);
                }
            }

            function processDealsPL(plData) {
                var dealsIDs = [],
                    dealsObj = {},
                    i, length,
                    id,
                    deal;

                for (i = 0, length = plData.length; i < length; i++) {
                    id = plData[i][eDealPL.dealID];
                    deal = deals.GetItem(id);

                    if (deal) {
                        deal.UpdatePL(plData[i]);
                        dealsIDs.push(deal.orderID);
                        dealsObj[deal.orderID] = deal;
                    }
                }

                onDealsPLChange.Invoke({ dealsIDs: dealsIDs, dealsObj: dealsObj });
            }

            return {
                Deals: deals,
                OnDealsChange: onDealsChange,
                OnDealsRemoved: onDealsRemoved,
                OnDealsPLChange: onDealsPLChange,
                ProcessDeals: processDeals,
                ProcessDealsPL: processDealsPL
            };
        }

        return new DealsManager();
    }
);

define(
    'cachemanagers/bonusmanager',
    [
        'require',
        'knockout',
        'handlers/general',
        'handlers/Delegate',
        'enums/DataMembersPositions'
    ],
    function BonusManager(require) {
        // model example: {'VolumeUsd': 10000000, 'AmountBase': 500, 'AmountGivenBase': 570, 'StartDate ': '01/01/2017', 'EndDate': '01/01/2018'}
        var ko = require('knockout'),
            general = require('handlers/general'),
            delegate = require('handlers/Delegate');

        var module = {};
        module.onChange = new delegate();

        module.bonus = ko.observable({
            volumeUsd: null,
            amountBase: null,
            amountGivenBase: null,
            startDate: null,
            endDate: null,
            accumulatedVolumeUsd: null
        });

        module.ProcessData = function (bonusData) {
            module.bonus({
                volumeUsd: general.toNumeric(bonusData[eBonus.volumeUsd]),
                amountBase: general.toNumeric(bonusData[eBonus.amountBase]),
                amountGivenBase: general.toNumeric(bonusData[eBonus.amountGivenBase]),
                startDate: bonusData[eBonus.startDate],
                endDate: bonusData[eBonus.endDate],
                accumulatedVolumeUsd: general.toNumeric(bonusData[eBonus.accumulatedVolumeUsd])
            });
            module.onChange.Invoke();
        }

        return module;
    }
);

define(
    'cachemanagers/clientstatedataprocessor',
    [
        "require",
        'handlers/general',
        'cachemanagers/NotificationsManager',
        'cachemanagers/ClientStateFlagsManager',
        'cachemanagers/ClientStateHolderManager',
        "cachemanagers/PortfolioStaticManager",
        'cachemanagers/InstrumentVolumeManager',
        'cachemanagers/NetExposureManager',
        'cachemanagers/QuotesManager',
        'cachemanagers/activelimitsmanager',
        'cachemanagers/dealsmanager',
        'cachemanagers/bonusmanager',
        "StateObject!PerformaceEvents"
    ],
    function ClientStateDataProcessor(require) {
        var serverTime = null,
            general = require('handlers/general'),
            quotesManager = require('cachemanagers/QuotesManager'),
            activeLimits = require('cachemanagers/activelimitsmanager'),
            dealsManager = require('cachemanagers/dealsmanager'),
            notificationsManager = require('cachemanagers/NotificationsManager'),
            netExposureManager = require('cachemanagers/NetExposureManager'),
            portfolioStatic = require("cachemanagers/PortfolioStaticManager"),
            csFlags = require('cachemanagers/ClientStateFlagsManager'),
            csHolder = require('cachemanagers/ClientStateHolderManager'),
            instrumentVolumeManager = require('cachemanagers/InstrumentVolumeManager'),
            bonusManager = require('cachemanagers/bonusmanager'),
            stateObject = require("StateObject!PerformaceEvents");

        function processData(data, reinitialize) {
            if (data && data.length > 0) {

                if (data[eClientState.serverTime] && data[eClientState.serverTime].length > 0) {
                    var splitDate = general.SplitDateTime(data[eClientState.serverTime]);
                    serverTime = new Date(splitDate.year, splitDate.month - 1, splitDate.day, splitDate.hour, splitDate.min, splitDate.sec, splitDate.ms);
                }

                if (data[eClientState.portfolioStatic] && data[eClientState.portfolioStatic].length > 0) {
                    portfolioStatic.ProcessData(data[eClientState.portfolioStatic]);
                }

                if (data[eClientState.ohlcs] && data[eClientState.ohlcs].length > 0) {
                    quotesManager.ProcessOhlcData(data[eClientState.ohlcs]);
                }

                if (data[eClientState.ticks] && data[eClientState.ticks].length > 0) {
                    quotesManager.ProcessTickData(data[eClientState.ticks], serverTime);
                }

                if (data[eClientState.flags] && data[eClientState.flags].length > 0) {
                    csFlags.ProcessData(data[eClientState.flags]);
                }

                if (reinitialize || (data[eClientState.limits] && data[eClientState.limits].length > 0)) {
                    activeLimits.ProcessData(data[eClientState.limits], reinitialize);
                }

                if (reinitialize || (data[eClientState.deals] && data[eClientState.deals].length > 0)) {
                    dealsManager.ProcessDeals(data[eClientState.deals], reinitialize);
                }

                if (data[eClientState.portfolioSummary] && data[eClientState.portfolioSummary].length > 0) { //should check that portfolioSummary is not empty before accessing inner collections
                    if (data[eClientState.portfolioSummary][ePortfolioSummary.dealPL].length > 0) {
                        dealsManager.ProcessDealsPL(data[eClientState.portfolioSummary][ePortfolioSummary.dealPL]);
                    }

                    if (data[eClientState.portfolioSummary][ePortfolioSummary.csHolder].length > 0) {
                        csHolder.ProcessData(data[eClientState.portfolioSummary][ePortfolioSummary.csHolder]);
                    }

                    if (data[eClientState.portfolioSummary][ePortfolioSummary.netExposure].length > 0) {
                        netExposureManager.ProcessData(data[eClientState.portfolioSummary][ePortfolioSummary.netExposure]);
                    }

                    if (data[eClientState.portfolioSummary][ePortfolioSummary.instrumentVolumes].length > 0) {
                        instrumentVolumeManager.ProcessData(data[eClientState.portfolioSummary][ePortfolioSummary.instrumentVolumes]);
                    }
                }

                if (data[eClientState.notifications] && data[eClientState.notifications].length > 0) {
                    notificationsManager.ProcessData(data[eClientState.notifications]);
                }

                if (data[eClientState.bonus] && data[eClientState.bonus].length > 0) {
                    bonusManager.ProcessData(data[eClientState.bonus]);
                }
            }
        }

        function getServerTime() {
            return serverTime;
        }
        stateObject.set('InitialDataLoadCompleted', null);
        stateObject.subscribe('InitialDataLoadCompleted', function (initialServerTime) {
            var splitDate = general.SplitDateTime(initialServerTime);
            serverTime = new Date(splitDate.year, splitDate.month - 1, splitDate.day, splitDate.hour, splitDate.min, splitDate.sec);
        });

        return {
            processData: processData,
            ServerTime: getServerTime
        };
    }
);
/* global Preloader, SocketConnection*/
define("cachemanagers/CacheManager", [
	"require",
	"Q",
	"generalmanagers/ErrorManager",
	"generalmanagers/RegistrationManager",
	"cachemanagers/AjaxCacheManager",
	"cachemanagers/SocketCacheManager",
	"cachemanagers/clientstatedataprocessor",
	"handlers/websocketconnection",
], function CacheManagerDef(require) {
	var Q = require("Q"),
		ErrorManager = require("generalmanagers/ErrorManager"),
		RegistrationManager = require("generalmanagers/RegistrationManager"),
		AjaxCacheManager = require("cachemanagers/AjaxCacheManager"),
		SocketCacheManager = require("cachemanagers/SocketCacheManager"),
		ClientStateDataProcessor = require("cachemanagers/clientstatedataprocessor"),
		SocketConnection = require("handlers/websocketconnection");

	function CacheManager() {
		var isInstanceLoaded = Q.defer(),
			instance;

		function init() {
			SocketConnection.hasStarted()
				.then(function onInit() {
					instance = new SocketCacheManager(ClientStateDataProcessor);

					SocketConnection.setNotAvailableHandler(function notAvailableHandler() {
						// only for fallback during application run after cache manager init was called
						ErrorManager.onWarning(
							"SocketConnection",
							"Socket connection is not available when PushService is enabled, falling back to ajax"
						);

						if (instance) {
							instance = new AjaxCacheManager(ClientStateDataProcessor);

							instance.OnRegisterRequest.Add(RegistrationManager.Register);
							instance.OnLoadRequest.Add(function () {
								loadData().done();
							});

							instance.LoadData().done();
						}
					});

					isInstanceLoaded.resolve();
				})
				.catch(function onError() {
					instance = new AjaxCacheManager(ClientStateDataProcessor);
					isInstanceLoaded.resolve();

					ErrorManager.onWarning("SocketConnection", "WebSocket not supported");
				})
				.done();

			isInstanceLoaded.promise
				.then(function setHandlers() {
					instance.OnRegisterRequest.Add(RegistrationManager.Register);
					instance.OnLoadRequest.Add(function () {
						loadData().done();
					});
				})
				.done();
		}

		function loadData() {
			return whenInstanceIsAvailable().then(function () {
				return instance.LoadData();
			});
		}

		function setDisplaySymbol(newSymbol) {
			whenInstanceIsAvailable()
				.then(function () {
					instance.SetDisplaySymbol(newSymbol);
				})
				.done();
		}

		function loadFinished() {
			return whenInstanceIsAvailable().then(function () {
				return instance.LoadFinished;
			});
		}

		function register(requestList, flag, isReinitialized) {
			loadFinished()
				.then(function () {
					instance.Register(requestList, flag, isReinitialized);
				})
				.done();
		}

		function unregister() {
			loadFinished()
				.then(function () {
					instance.Unregister();
				})
				.done();
		}

		function whenInstanceIsAvailable() {
			return isInstanceLoaded.promise;
		}

		return {
			Init: init,
			Register: register,
			Unregister: unregister,
			LoadData: loadData,
			SetDisplaySymbol: setDisplaySymbol,
			ServerTime: ClientStateDataProcessor.ServerTime,
		};
	}

	var module = (window.$cacheManager = new CacheManager());

	return module;
});

define(
    'FxNet/LogicLayer/Deal/DealLifeCycle',
    [
        'require',
        'handlers/general',
        'cachemanagers/CacheManager'
    ],
    function DealLifeCycle(require) {
        var CacheManager = require('cachemanagers/CacheManager'),
            general = require('handlers/general');

        var getIslamicValueDateBeforeDeal = function(assetTypeId, dealPermit) {
            var isDealOnIslamicAccount = (assetTypeId === eAssetType.Share || assetTypeId === eAssetType.Future) && dealPermit === eDealPermit.Islamic,
                serverTime,
                valueDate;

            if (isDealOnIslamicAccount) {
                serverTime = new Date(CacheManager.ServerTime().getTime());
                valueDate = serverTime.toLaterDate().skipWeekendDays();
                return valueDate;
            }
            return null;
        };

        var sharesIsCorporateActionDateSignificant_BeforeDeal = function(dealPermit, assetTypeId, corporateActionDate) {
            return assetTypeId === eAssetType.Share &&
            ((dealPermit !== eDealPermit.Islamic && !!corporateActionDate) ||
            (dealPermit === eDealPermit.Islamic && !!corporateActionDate &&
                general.str2Date(corporateActionDate, "d/m/Y H:M") < getIslamicValueDateBeforeDeal(assetTypeId, dealPermit)));
        };

        var sharesIsDividendDateSignificant_BeforeDeal = function(dealPermit, assetTypeId, corporateActionDate, dividendDate) {
            return assetTypeId === eAssetType.Share &&
            ((dealPermit !== eDealPermit.Islamic && !corporateActionDate && !!dividendDate) ||
            (dealPermit === eDealPermit.Islamic && !corporateActionDate && !!dividendDate &&
                general.str2Date(dividendDate, "d/m/Y H:M") < getIslamicValueDateBeforeDeal(assetTypeId, dealPermit)));
        };

        var futuresIsRolloverDateSignificant_BeforeDeal = function(dealPermit, assetTypeId, rolloverDate) {
            return assetTypeId === eAssetType.Future &&
            ((dealPermit !== eDealPermit.Islamic && !!rolloverDate) ||
            (dealPermit === eDealPermit.Islamic && !!rolloverDate && general.str2Date(rolloverDate, "d/m/Y H:M") < getIslamicValueDateBeforeDeal(assetTypeId, dealPermit)));
        };

        var futuresIsRolloverDateSignificant_AfterDeal = function (assetTypeId, instrumentRolloverDate, valueDate) {
            if (assetTypeId === eAssetType.Future && !!instrumentRolloverDate) 
                return (!valueDate || general.str2Date(instrumentRolloverDate, 'd,m,y,H,M,S') < general.str2Date(valueDate, 'd,m,y,H,M,S'));
            return false;
        };

        var sharesIsCorporateActionDateSignificant_AfterDeal = function (assetTypeId, instrumentCorporateActionDate, valueDate) {
            if (assetTypeId === eAssetType.Share && !!instrumentCorporateActionDate) 
                return (!valueDate ||
                    general.str2Date(instrumentCorporateActionDate, 'd,m,y,H,M,S') < general.str2Date(valueDate, 'd,m,y,H,M,S'));
            return false;
        };

        var sharesIsDividendDateSignificant_AfterDeal = function (assetTypeId, instrumentDividendDate, instrumentCorporateActionDate, valueDate) {
            if (assetTypeId === eAssetType.Share && !!instrumentDividendDate && !instrumentCorporateActionDate) {
                return (!valueDate ||
                    general.str2Date(instrumentDividendDate, 'd,m,y,H,M,S') < general.str2Date(valueDate, 'd,m,y,H,M,S'));
            }
            return false;
        };

        return {
            getIslamicValueDateBeforeDeal: getIslamicValueDateBeforeDeal,
            sharesIsCorporateActionDateSignificant_BeforeDeal: sharesIsCorporateActionDateSignificant_BeforeDeal,
            sharesIsDividendDateSignificant_BeforeDeal: sharesIsDividendDateSignificant_BeforeDeal,
            futuresIsRolloverDateSignificant_BeforeDeal: futuresIsRolloverDateSignificant_BeforeDeal,
            futuresIsRolloverDateSignificant_AfterDeal: futuresIsRolloverDateSignificant_AfterDeal,
            sharesIsCorporateActionDateSignificant_AfterDeal: sharesIsCorporateActionDateSignificant_AfterDeal,
            sharesIsDividendDateSignificant_AfterDeal: sharesIsDividendDateSignificant_AfterDeal
        };
    }
);

define('alerts/DealAddServerResponseAlert', [
    "require",
    'handlers/general',
    'devicealerts/Alert',
    "FxNet/LogicLayer/Deal/DealLifeCycle",
    "Dictionary"
], function (require) {
    var AlertBase = require('devicealerts/Alert'),
        general = require('handlers/general'),
        lifeCycleModule = require("FxNet/LogicLayer/Deal/DealLifeCycle"),
        Dictionary = require("Dictionary");

    var DealAddServerResponseAlert = function () {

        var inheritedAlertInstance = new AlertBase(),
            resourceName = "alerts_deals";

        var init = function () {
            inheritedAlertInstance.alertName = "DealAddServerResponseAlert";
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.prepareForShow = prepareForShow;
            createButtons();
        };

        var parseExtraInfo = function (result, properties, messagesArr) {
            var instrument = properties.instrument,
                valueDate = result.arguments && result.arguments.length > 0 ? result.arguments[0] : null;

            if (instrument && instrument.isFuture) {

                if (lifeCycleModule.futuresIsRolloverDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getInstrumentRolloverDate(), valueDate)) {
                    messagesArr.push(String.format(Dictionary.GetItem("FutureSuccess"), instrument.eventDate));
                }

                return;
            }
            if (instrument && instrument.isShare) {

                if (lifeCycleModule.sharesIsCorporateActionDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getCorporateActionDate(), valueDate)) {
                    messagesArr.push(String.format(Dictionary.GetItem("shareSuccessHasDate"), instrument.getCorporateActionDate()));
                } else if (lifeCycleModule.sharesIsDividendDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getInstrumentDividendDate(), instrument.getCorporateActionDate(), valueDate)) {
                    messagesArr.push(String.format(Dictionary.GetItem("ShareDividendSuccess"), instrument.getInstrumentDividendDate()));
                } else {
                    messagesArr.push(String.format(Dictionary.GetItem("ShareSuccess2"), $instrumentTranslationsManager.Long(instrument.id)));
                }


                return;
            }
        }
        var prepareForShow = function () {
            this.resourceName = resourceName;
            this.title(Dictionary.GetItem("OpenDeal"));
            this.messages.removeAll();

            var serverResults = this.properties.serverResponses;
            for (var idx = 0; idx < serverResults.length; idx++) {
                var data = serverResults[idx],
                    instrument = $instrumentsManager.GetInstrument(data.instrumentId);

                parseExtraInfo(data, this.properties, this.messages);


                general.extendType(data, {
                    dealAmount: data.usdValue,
                    openedRate: data.rateCalc,
                    orderDir: data.direction ? "1closed" : "0closed",
                    pl: '',
                    baseSymbolId: instrument ? instrument.baseSymbol : '',
                    otherSymbolId: instrument ? instrument.otherSymbol : '',
                    slRate: Format.toRate(parseFloat(this.properties.requestData.slRate), false, data.instrumentId) || '',
                    tpRate: Format.toRate(parseFloat(this.properties.requestData.tpRate), false, data.instrumentId) || ''
                });
            }

            this.body(Dictionary.GetItem("SuccessDealOpen")); //"Your deal was opened successfully"));
            this.dataRecords = serverResults;
        };

        var createButtons = function () {
            inheritedAlertInstance.buttons.removeAll();

            // override base on Back => onOk
            var onOk = inheritedAlertInstance.onBack = function () {
                var redirectToViewType,
                    viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || "";

                if (!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)) {
                    redirectToViewType = inheritedAlertInstance.properties.redirectToView;
                }

                if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                    inheritedAlertInstance.properties.okButtonCallback();
                }

                inheritedAlertInstance.visible(false);

                if (!general.isEmptyValue(redirectToViewType)) {
                    if (redirectToViewType === 'exit') {
                        dalCommon.Logout(eLoginLogoutReason.dealAddServerResponseAlert_exit);
                    } else {
                        require(['devicemanagers/ViewModelsManager'], function (viewModelsManager) {
                            viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);
                        });
                        
                    }
                }
            };

            inheritedAlertInstance.buttons.push(
                new inheritedAlertInstance.buttonProperties(
                    Dictionary.GetItem("ok"),
                    onOk,
                    'btnOk'
                )
            );
        };

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };
    return DealAddServerResponseAlert;
});
define(
    "alerts/LimitsServerResponseAlert",
    [
        "require",
        'handlers/general',
        'devicealerts/Alert',
        "FxNet/LogicLayer/Deal/DealLifeCycle",
        "Dictionary",
        'initdatamanagers/InstrumentsManager'
    ],
    function LimitsServerResponseAlertDef(require) {
        var AlertBase = require('devicealerts/Alert'),
            general = require('handlers/general'),
            lifeCycleModule = require("FxNet/LogicLayer/Deal/DealLifeCycle"),
            Dictionary = require("Dictionary"),
            $instrumentsManager = require('initdatamanagers/InstrumentsManager');

        var LimitsServerResponseAlert = function LimitsServerResponseAlertClass() {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = "LimitsServerResponseAlert";
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.prepareForShow = prepareForShow;
                createButtons();
            };

            var prepareForShowSuccessLimitAdd = function (data, properties, messagesArr) {
                var instrument = properties.instrument,
                    valueDate = data.arguments && data.arguments.length > 0 ? data.arguments[0] : null;

                if (general.isEmptyValue(valueDate) && !general.isEmptyValue(properties.valueDate)) {
                    valueDate = properties.valueDate;
                }

                if (instrument && instrument.isFuture) {
                    if (lifeCycleModule.futuresIsRolloverDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getInstrumentRolloverDate(), valueDate)) {
                        messagesArr.push(String.format(Dictionary.GetItem("FutureSuccess"), instrument.eventDate));
                    }

                    return;
                }

                if (instrument && instrument.isShare) {
                    if (lifeCycleModule.sharesIsCorporateActionDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getCorporateActionDate(), valueDate)) {
                        messagesArr.push(String.format(Dictionary.GetItem("shareSuccessHasDate"), instrument.getCorporateActionDate()));
                    }
                    else {
                        if (lifeCycleModule.sharesIsDividendDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getInstrumentDividendDate(), instrument.getCorporateActionDate(), valueDate)) {
                            messagesArr.push(String.format(Dictionary.GetItem("ShareDividendSuccess"), instrument.getInstrumentDividendDate()));
                        }
                        else {
                            messagesArr.push(String.format(Dictionary.GetItem("ShareSuccess2"), $instrumentTranslationsManager.Long(instrument.id)));
                        }
                    }

                    return;
                }
            };

            var prepareForSuccessLimitEdit = function (data, properties, messagesArr) {
                var instrument = properties.instrument,
                    valueDate = data.arguments && data.arguments.length > 0 ? data.arguments[0] : null;

                if (general.isEmptyValue(valueDate) && !general.isEmptyValue(properties.valueDate)) {
                    valueDate = properties.valueDate;
                }

                if (instrument && instrument.isFuture) {
                    if (lifeCycleModule.futuresIsRolloverDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getInstrumentRolloverDate(), valueDate)) {
                        messagesArr.push(String.format(Dictionary.GetItem("FutureSuccess"), instrument.eventDate));
                    }

                    return;
                }

                if (instrument && instrument.isShare) {
                    if (lifeCycleModule.sharesIsCorporateActionDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getCorporateActionDate(), valueDate)) {
                        messagesArr.push(String.format(Dictionary.GetItem("shareSuccessHasDate"), instrument.getCorporateActionDate()));
                    } else {
                        if (lifeCycleModule.sharesIsDividendDateSignificant_AfterDeal(instrument.assetTypeId, instrument.getInstrumentDividendDate(), instrument.getCorporateActionDate(), valueDate)) {
                            messagesArr.push(String.format(Dictionary.GetItem("ShareDividendSuccess"), instrument.getInstrumentDividendDate()));
                        } else {
                            messagesArr.push(String.format(Dictionary.GetItem("ShareSuccess2"), $instrumentTranslationsManager.Long(instrument.id)));
                        }
                    }

                    return;
                }
            };

            var prepareForShow = function () {
                var serverResults = this.properties.serverResponses;
                this.dataRecords = serverResults;

                if (!serverResults || !serverResults.length) {
                    return;
                }

                var data = serverResults[0],
                    instrument = $instrumentsManager.GetInstrument(data.instrumentId),
                    dataRequested = this.properties.requestData;

                general.extendType(data, {
                    limitAmount: dataRequested.amount,
                    limitLevel: data.limLevel,
                    orderDir: data.direction ? "1" : "0",
                    baseSymbolId: instrument ? instrument.baseSymbol : '',
                    otherSymbolId: instrument ? instrument.otherSymbol : '',
                    messages: [],

                    type: general.isDefinedType(dataRequested.type) ? dataRequested.type : data.type,
                    mode: general.isDefinedType(dataRequested.mode) ? dataRequested.mode : data.mode,
                    action: general.isDefinedType(dataRequested.action) ? dataRequested.action : data.action,
                    removedIfDoneSLRate: dataRequested.removedIfDoneSLRate,
                    removedIfDoneTPRate: dataRequested.removedIfDoneTPRate
                });

                this.messages.removeAll();

                switch (data.msgKey) {
                    case "SuccessLimitAdd":
                        this.title(Dictionary.GetItem(data.type == eLimitType.None ? "NewLimit" : "AddLimit"));
                        this.body(Dictionary.GetItem("YourLimitWasAddedSuccessfully"));
                        prepareForShowSuccessLimitAdd(data, this.properties, this.messages);
                        break;

                    case "SuccessLimitEdit":
                        this.title(Dictionary.GetItem(data.type == eLimitType.None ? "UpdateLimit" : "EditStopLossTakeProfit"));
                        this.body(Dictionary.GetItem(data.type == eLimitType.None ? "YourLimitWasUpdatedSuccessfully" : "YourStopLossTakeProfitWasUpdated"));
                        prepareForSuccessLimitEdit(data, this.properties, this.messages);
                        break;

                    case "SuccessLimitDelete":
                        this.title(Dictionary.GetItem("RemoveLimit"));
                        this.body(Dictionary.GetItem("YourLimitWasRemoveddSuccessfully"));
                        break;
                }
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();

                // override base on Back => onOk
                var onOk = inheritedAlertInstance.onBack = function () {
                    var redirectToViewType,
                        viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || "";

                    if (!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)) {
                        redirectToViewType = inheritedAlertInstance.properties.redirectToView;
                    }

                    if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                        inheritedAlertInstance.properties.okButtonCallback();
                    }

                    inheritedAlertInstance.visible(false);

                    if (!general.isEmptyValue(redirectToViewType)) {
                        if (redirectToViewType === 'exit') {
                            dalCommon.Logout(eLoginLogoutReason.limitsServerResponseAlert_exit);
                        } else {
                            require(['devicemanagers/ViewModelsManager'], function (viewModelsManager) {
                                viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);

                            });
                        }
                    }
                };

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem("ok"),
                        onOk,
                        'btnOk'
                    )
                );
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return LimitsServerResponseAlert;
    }
);

define(
    'alerts/RemoveCreditCardConfirmationAlert',
    [
        "require",
        'devicealerts/Alert',
        'handlers/general'
    ],
    function (require) {
        var AlertBase = require('devicealerts/Alert'),
            general = require('handlers/general');

        var RemoveCreditCardConfirmationAlert = function () {
            var inheritedAlertInstance = new AlertBase();

            function init() {
                inheritedAlertInstance.alertName = "RemoveCreditCardConfirmationAlert";
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.prepareForShow = createButtons;
            }

            function createButtons() {
                inheritedAlertInstance.buttons.removeAll();

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem(inheritedAlertInstance.properties.cancelButtonCaption || "cancel"),
                        function () {
                            inheritedAlertInstance.visible(false);

                            if (general.isFunctionType(inheritedAlertInstance.properties.cancelButtonCallback)) {
                                inheritedAlertInstance.properties.cancelButtonCallback();
                            }
                        },
                        'btnCancel colored'
                    ),
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem(inheritedAlertInstance.properties.okButtonCaption || "proceed"),
                        function () {
                            inheritedAlertInstance.visible(false);

                            if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                                inheritedAlertInstance.properties.okButtonCallback();
                            }
                        },
                        'btnOk'
                    )
                );
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };
        return RemoveCreditCardConfirmationAlert;
    }
);

define(
    "alerts/MultipleDealsClosedConfirmation",
    [
        "require",
        "knockout",
        'handlers/general',
        'devicealerts/Alert',
        'initdatamanagers/InstrumentsManager',
        "Dictionary"
    ],
    function (require) {
        var AlertBase = require('devicealerts/Alert'),
            ko = require("knockout"),
            general = require('handlers/general'),
            Dictionary = require("Dictionary"),
            $instrumentsManager = require('initdatamanagers/InstrumentsManager');

        var MultipleDealsClosedConfirmation = function () {
            var inheritedAlertInstance = new AlertBase(),
                LS = StorageFactory(StorageFactory.eStorageType.local);

            function init() {
                inheritedAlertInstance.alertName = 'alerts/MultipleDealsClosedConfirmation';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.prepareForShow = prepareForShow;
                inheritedAlertInstance.hideConfirmation = ko.observable(false);
                inheritedAlertInstance.lblChecked = Dictionary.GetItem('dontshowagain');
            }

            function getInstrumentData(instrumentId) {
                var instrument = $instrumentsManager.GetInstrument(instrumentId);

                return {
                    instrumentId: instrument.id,
                    baseSymbolId: instrument.baseSymbol,
                    otherSymbolId: instrument.otherSymbol
                };
            }

            function prepareForShow() {
                var self = this,
                    storageName =  !general.isEmptyValue(this.properties.selectedData) &&
                                    this.properties.selectedData[0].mode === eLimitMode.PriceAlert ?
                                    'hideConfRemovePAlerts' : 'hideConfCloseDeals';
                this.selectedData = this.properties.selectedData || [];

                this.getInstrumentData = getInstrumentData;
                this.confirmationCloseDeal = function () {
                    if (inheritedAlertInstance.hideConfirmation()) {
                        LS.setItem(storageName, 'true');
                    }

                    inheritedAlertInstance.visible(false);
                    self.properties.confirmationCloseDeal();
                };
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return MultipleDealsClosedConfirmation;
    }
);
define('devicealerts/DepositSuccessAlert',
    [
        "require",
        'knockout',
        'devicealerts/Alert',
        'dataaccess/dalCommon',
        "Dictionary"
    ],
    function (require) {
        var AlertBase = require('devicealerts/Alert'),
            general = require('handlers/general'),
            dalCommon = require('dataaccess/dalCommon'),
            Dictionary = require("Dictionary");

        var DepositSuccessAlert = function () {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'devicealerts/DepositSuccessAlert';
                inheritedAlertInstance.visible(false);
                createButtons();
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();

                // override base on Back => onOk
                var onOk = inheritedAlertInstance.hide = function () {
                    var redirectToViewType,
                        viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || "";

                    if (!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)) {
                        redirectToViewType = inheritedAlertInstance.properties.redirectToView;
                    }

                    if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                        inheritedAlertInstance.properties.okButtonCallback();
                    }

                    inheritedAlertInstance.visible(false);

                    if (!general.isEmptyValue(redirectToViewType)) {
                        if (redirectToViewType === 'exit') {
                            dalCommon.Logout(eLoginLogoutReason.serverResponseAlert_exit);
                        } else {
                            require(['devicemanagers/ViewModelsManager'], function (viewModelsManager) {
                                viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);
                            });
                        }
                    }
                };

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem("ok"),
                        onOk,
                        'btnOk'
                    )
                );
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };
        return DepositSuccessAlert;
    });
/**
 *
 * Use it as dependency for other require modules to load content for specific resources.
 * The loaded content will be automatically loaded and added to Dictionary
 *
 * Example:
 * define('MyAwesomeViewModel', ['LoadDictionaryContent!MyAwesomeContentResourceName'], function() {
 *
 * });
 *
 */
define("LoadDictionaryContent", [
	"require",
	"Dictionary",
	"global/UrlResolver",
	"JSONHelper",
	"handlers/Ajaxer",
], function (require) {
	var Dictionary = require("Dictionary"),
		UrlResolver = require("global/UrlResolver"),
		JSONHelper = require("JSONHelper");

	return {
		load: function (resourceName, localRequire, onloadCallback, config) {
			if (config && config.isBuild) {
				onloadCallback(null);

				return;
			}

			var cachedValue = Dictionary.GetAllItemsForResource(resourceName);

			if (cachedValue) {
				onloadCallback(cachedValue);
			} else {
				var callerName = "LoadDictionaryContent!" + resourceName;
				var contentToLoadUrl = UrlResolver.getContentPath(resourceName);

				var ajaxer = new TAjaxer();
				ajaxer.get(
					callerName,
					contentToLoadUrl,
					"",
					function (responseText) {
						var content = JSONHelper.STR2JSON(callerName, responseText) || {};

						if (resourceName === "contentdata") {
							Object.keys(content).forEach(function (key, index) {
								Dictionary.AddResource(key, content[key]);
							});
						} else {
							Dictionary.AddResource(resourceName, content);
						}

						onloadCallback(content);
					},
					null,
					null,
					null,
					null,
					false
				);
			}
		},
	};
});


define(
    'devicealerts/ContactUsCTAAlert',
    [
        'require',
        'devicealerts/Alert',
        'Dictionary',
        'LoadDictionaryContent!account_ContactUs'
    ],
    function ContactUsCtaAlertDef(require) {
        var AlertBase = require('devicealerts/Alert'),
            Dictionary = require('Dictionary');

        var ContactUsCtaAlert = function ContactUsCtaAlertClass() {
            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'devicealerts/ContactUsCTAAlert';
                inheritedAlertInstance.visible(false);

            };

            inheritedAlertInstance.lnkCallBack = Dictionary.GetItem('PhoneusLink', 'account_ContactUs');
            inheritedAlertInstance.lnkEmailResponse = Dictionary.GetItem('EmailusLink', 'account_ContactUs');
            inheritedAlertInstance.title = Dictionary.GetItem('lblContactUsTitle');

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            };
        };

        return ContactUsCtaAlert;
    }
);

define('alerts/TradingConfirmationRetryAlert', ["require", 'devicealerts/Alert'], function (require) {
    var AlertBase = require('devicealerts/Alert');

    var TradingConfirmationRetryAlert = function () {

        var inheritedAlertInstance = new AlertBase();

        var init = function () {
            inheritedAlertInstance.alertName = 'alerts/TradingConfirmationRetryAlert';
            inheritedAlertInstance.visible(false);
            inheritedAlertInstance.prepareForShow = prepareForShow;
        };

        var prepareForShow = function () {
            var self = this;
            this.selectedData = this.properties.selectedData;
            this.confirmationCloseDeal = function () {
                inheritedAlertInstance.visible(false);
                if (self.properties &&
                    self.properties.hasOwnProperty('tradingEnabledRetry') &&
                    typeof self.properties.tradingEnabledRetry === 'function') {
                    self.properties.tradingEnabledRetry(self.properties.requestData);
                }
            };
        }

        return {
            Init: init,
            GetAlert: inheritedAlertInstance
        };
    };

    return TradingConfirmationRetryAlert;
});
define("alerts/PriceAlertServerResponseAlert", [
	"require",
	"handlers/general",
	"devicealerts/Alert",
	"FxNet/LogicLayer/Deal/DealLifeCycle",
	"Dictionary",
	"handlers/Cookie",
	"initdatamanagers/InstrumentsManager",
	"modules/environmentData",
], function PriceAlertServerResponseAlertDef(require) {
	var AlertBase = require("devicealerts/Alert"),
		general = require("handlers/general"),
		Dictionary = require("Dictionary"),
		CookieHandler = require("handlers/Cookie"),
		instrumentsManager = require("initdatamanagers/InstrumentsManager"),
		environmentData = require("modules/environmentData").get();

	var PriceAlertServerResponseAlert = function PriceAlertServerResponseAlertClass() {
		var inheritedAlertInstance = new AlertBase();

		function init() {
			inheritedAlertInstance.alertName = "PriceAlertServerResponseAlert";
			inheritedAlertInstance.visible(false);
			inheritedAlertInstance.prepareForShow = prepareForShow;
			createButtons();
		}

		function prepareForShow() {
			var serverResults = this.properties.serverResponses;
			this.dataRecords = serverResults;

			if (!serverResults || !serverResults.length) {
				return;
			}

			var data = serverResults[0],
				instrument = instrumentsManager.GetInstrument(data.instrumentId),
				dataRequested = this.properties.requestData;

			general.extendType(data, {
				limitLevel: data.limLevel,
				orderDir: data.direction ? "1" : "0",
				baseSymbolId: instrument ? instrument.baseSymbol : "",
				otherSymbolId: instrument ? instrument.otherSymbol : "",
				messages: [],
				type: general.isDefinedType(dataRequested.type) ? dataRequested.type : data.type,
				mode: general.isDefinedType(dataRequested.mode) ? dataRequested.mode : data.mode,
				action: general.isDefinedType(dataRequested.action) ? dataRequested.action : data.action,
			});

			this.messages.removeAll();

			switch (data.msgKey) {
				case "OrderError20":
					this.title(Dictionary.GetItem("PleaseNote"));
					this.body("");
					this.messages.push(
						String.format(Dictionary.GetItem("priceAlertExceedAmount"), environmentData.maxPriceAlertsCount)
					);
					this.dataRecords.pop();
					break;

				case "OrderError22":
					this.title(Dictionary.GetItem("newPriceAlert"));
					this.body("");
					this.messages.push(
						String.format(
							Dictionary.GetItem("generalPriceAlertFailure"),
							environmentData.maxPriceAlertsCount
						)
					);
					this.dataRecords.pop();
					break;

				default:
					//SuccessPriceAlertAdd
					this.title(Dictionary.GetItem("priceAlertSet"));
					this.body(Dictionary.GetItem("priceAlertSetSuccessfully"));
					this.messages.push(Dictionary.GetItem("priceAlertNotificationsEnableNote"));
					break;
			}
		}

		function createButtons() {
			inheritedAlertInstance.buttons.removeAll();

			// override base on Back => onOk
			var onOk = (inheritedAlertInstance.onBack = function () {
				var redirectToViewType,
					viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || "";

				// redirect to price alert grid only on mobile
				if (
					CookieHandler.ReadCookie("ViewMode").toLowerCase() === "mobile" &&
					!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)
				) {
					redirectToViewType = inheritedAlertInstance.properties.redirectToView;
				}

				if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
					inheritedAlertInstance.properties.okButtonCallback();
				}

				inheritedAlertInstance.visible(false);

				if (!general.isEmptyValue(redirectToViewType)) {
					if (redirectToViewType === "exit") {
						dalCommon.Logout(eLoginLogoutReason.limitsServerResponseAlert_exit);
					} else {
						require(["devicemanagers/ViewModelsManager"], function ($viewModelsManager) {
							$viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);
						});
					}
				}
			});

			inheritedAlertInstance.buttons.push(
				new inheritedAlertInstance.buttonProperties(Dictionary.GetItem("ok"), onOk, "btnOk")
			);
		}

		return {
			Init: init,
			GetAlert: inheritedAlertInstance,
		};
	};

	return PriceAlertServerResponseAlert;
});

define(
    'alerts/PriceAlertClosedServerResponseAlert',
    [
        'require',
        'handlers/general',
        'devicealerts/Alert',
        'Dictionary',
        'initdatamanagers/InstrumentsManager'
    ],
    function PriceAlertClosedServerResponseAlertDef(require) {
        var AlertBase = require('devicealerts/Alert');
        var general = require('handlers/general');
        var $instrumentsManager = require('initdatamanagers/InstrumentsManager');
        var Dictionary = require('Dictionary');

        var PriceAlertClosedServerResponseAlert = function PriceAlertClosedServerResponseAlertClass() {

            var inheritedAlertInstance = new AlertBase();

            var init = function () {
                inheritedAlertInstance.alertName = 'PriceAlertClosedServerResponseAlert';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.prepareForShow = prepareForShow;
                createButtons();
            };

            var prepareForShow = function () {
                this.dataRecords = this.properties.serverResponses;

                this.title(Dictionary.GetItem(1 >= this.dataRecords.length ? 'RemovePriceAlert' : 'RemovePriceAlerts'));


                for (var idx = 0; idx < this.dataRecords.length; idx++) {
                    var data = this.dataRecords[idx],
                        requestItem = this.properties.find(function (item) {
                            return item.orderID == data.itemId;
                        });

                    var instrument = $instrumentsManager.GetInstrument(data.instrumentId ? data.instrumentId : (requestItem ? requestItem.instrumentID : ''));
                    if (data.status !== eResult.Success && this.dataRecords.length > 1) {
                        data.message = Dictionary.GetItem(data.result);
                    }

                    Object.assign(data, {
                        baseSymbolId: instrument ? instrument.baseSymbol : '',
                        otherSymbolId: instrument ? instrument.otherSymbol : '',
                        orderDir: requestItem.orderDir,
                        orderRate: requestItem.orderRate,
                        entryTime: requestItem.entryTime
                    });
                }

                var closedPriceAlertsSucceeded = this.dataRecords.filter(function (result) { return result.status == eResult.Success; }).length;

                if (this.dataRecords.length === 1) {
                    if (closedPriceAlertsSucceeded === 1) {
                        this.body(Dictionary.GetItem('YourPriceAlertWasClosedSuccessfully'));
                    } else {
                        data.status = 1;
                        this.body(Dictionary.GetItem('YourPriceAlertWasNotClosedSuccessfully'));
                    }
                } else {
                    this.body(String.format(Dictionary.GetItem('countOfYourPriceAlertsWhereClosedSuccessfully'), closedPriceAlertsSucceeded));
                }
            };

            var createButtons = function () {
                inheritedAlertInstance.buttons.removeAll();

                // override base on Back => onOk
                var onOk = inheritedAlertInstance.onBack = function () {
                    var redirectToViewType,
                        viewArgs = inheritedAlertInstance.properties.redirectToViewArgs || '';

                    if (!general.isEmptyValue(inheritedAlertInstance.properties.redirectToView)) {
                        redirectToViewType = inheritedAlertInstance.properties.redirectToView;
                    }

                    if (general.isFunctionType(inheritedAlertInstance.properties.okButtonCallback)) {
                        inheritedAlertInstance.properties.okButtonCallback();
                    }

                    inheritedAlertInstance.visible(false);

                    if (!general.isEmptyValue(redirectToViewType)) {
                        if (redirectToViewType === 'exit') {
                            dalCommon.Logout(eLoginLogoutReason.PriceAlertClosedServerResponseAlert_exit);
                        } else {

                            require(['devicemanagers/ViewModelsManager'], function ($viewModelsManager) {
                                $viewModelsManager.VManager.SwitchViewVisible(redirectToViewType, viewArgs);
                            });

                        }
                    }
                };

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem('ok'),
                        onOk,
                        'btnOk'
                    )
                );
            };

            return {
                Init: init,
                GetAlert: inheritedAlertInstance,
            };
        };
        return PriceAlertClosedServerResponseAlert;
    }
);


define(
    'devicealerts/RequestAccessAlert',
    [
        'require',
        'knockout',
        'devicealerts/Alert',
        'dataaccess/dalCompliance',
        'StateObject!RequestAccess',
    ],
    function (require) {
        var ko = require('knockout'),
            AlertBase = require('devicealerts/Alert'),
            dalCompliance = require('dataaccess/dalCompliance'),
            stateRequestAccess = require('StateObject!RequestAccess');

        var RequestAccessAlert = function () {
            var inheritedAlertInstance = new AlertBase();
            var stateAccessRequestKey;

            var init = function () {
                inheritedAlertInstance.alertName = 'RequestAccessAlert';
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.prepareForShow = prepareForShow;
            };

            var setObservables = function () {
                inheritedAlertInstance.isRequestSubmitted = ko.observable(false);
            };

            var setAlertContent = function () {
                stateAccessRequestKey = inheritedAlertInstance.properties.stateAccessRequestKey;

                if (!stateRequestAccess.containsKey(stateAccessRequestKey)) {
                    stateRequestAccess.set(
                        stateAccessRequestKey,
                        eAccessRequestStatus.RequestNotSubmitted
                    );
                }
                else {
                    var requestStatus = stateRequestAccess.get(stateAccessRequestKey);

                    inheritedAlertInstance.isRequestSubmitted(
                        requestStatus === eAccessRequestStatus.RequestSubmitted
                    );

                    if (inheritedAlertInstance.isRequestSubmitted()) {
                        inheritedAlertInstance.title(
                            Dictionary.GetItem('lblRequestSubmittedTitle', 'accessRequest')
                        );
                    }
                }
            };

            function handleRequestOnSuccess() {
                inheritedAlertInstance.isRequestSubmitted(true);

                stateRequestAccess.update(
                    stateAccessRequestKey,
                    eAccessRequestStatus.RequestSubmitted
                );

                inheritedAlertInstance.title(
                    Dictionary.GetItem('lblRequestSubmittedTitle', 'accessRequest')
                );
            }

            var onClickRequestAccess = function () {
                dalCompliance
                    .sendRequestAccess(inheritedAlertInstance.properties.requestAccessType)
                    .then(function (statusResponse) {
                        if (statusResponse === eOperationStatus.Success) {
                            handleRequestOnSuccess();
                        }
                    })
                    .fail(function () {
                        inheritedAlertInstance.hide();
                    });
            };

            var onClickOk = function () {
                inheritedAlertInstance.hide();
            };

            function prepareForShow() {
                this.onClickRequestAccess = onClickRequestAccess;
                this.onClickOk = onClickOk;

                setObservables();
                setAlertContent();
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance,
            };
        };

        return RequestAccessAlert;
    }
);

define(
    'alerts/SessionEndedAlert',
    [
        'devicealerts/Alert',
        "Dictionary",
        'handlers/general'
    ],
    function (AlertBase, Dictionary, general) {
        function SessionEndedAlert() {
            var inheritedAlertInstance = new AlertBase();

            function doCloseAction() {
                if (general.isFunctionType(inheritedAlertInstance.properties.onCloseAction)) {
                    inheritedAlertInstance.properties.onCloseAction();
                }
            }

            function onOk() {
                inheritedAlertInstance.onClose();
            }

            function createButtons() {
                inheritedAlertInstance.buttons.removeAll();

                inheritedAlertInstance.buttons.push(
                    new inheritedAlertInstance.buttonProperties(
                        Dictionary.GetItem("sessionEndedReconnectBtn"),
                        onOk,
                        'btnOk'
                    )
                );
            }

            function init() {
                inheritedAlertInstance.alertName = "SessionEndedAlert";
                inheritedAlertInstance.visible(false);
                inheritedAlertInstance.onCloseAction.Add(doCloseAction);

                createButtons();
            }

            return {
                Init: init,
                GetAlert: inheritedAlertInstance
            }
        }

        return SessionEndedAlert;
    }
);

define(
    'devicealerts/AlertFactory',
    [
        'require',
        'handlers/general',
        'devicealerts/ExitAlert',
        'devicealerts/BonusAlert',
        'devicealerts/ServerResponseAlert',
        'devicealerts/CloseDealConfirmationAlert',
        'devicealerts/MaxIdleTimeAlertWrapper',
        'devicealerts/DoubleLoginAlertWrapper',
        'devicealerts/MinEquityAlertWrapper',
        'devicealerts/GeneralOkCancelAlert',
        'devicealerts/GeneralOkAlert',
        'devicealerts/serverevents/ClientStateAlertExposureAlert',
        'devicealerts/serverevents/ClientStateAlertExposureCoverageAlert',
        'devicealerts/serverevents/ClientStateAlertSystemMode',
        'devicealerts/serverevents/ClientStateAlertApplicationClosing',
        'devicealerts/serverevents/ClientStateAlertApplicationShutDown',
        'devicealerts/serverevents/PortfolioAlertIsReal',
        'devicealerts/serverevents/PortfolioAlertIsDemo',
        'devicealerts/serverevents/PortfolioAlertIsActive',
        'devicealerts/serverevents/PortfolioAlertKycStatus',
        'alerts/QuestionnaireValidationAlert',
        'devicealerts/CddQuestionnaireAlert',
        'devicealerts/SignalsDisclaimerAlert',
        'devicealerts/SimpleClientAlert',
        'alerts/KnowledgeQuestionnaireAlert',
        'devicealerts/GeneralCancelableAlert',
        'alerts/DealsClosedServerResponseAlert',
        'alerts/DealAddServerResponseAlert',
        'alerts/LimitsServerResponseAlert',
        'alerts/RemoveCreditCardConfirmationAlert',
        'alerts/MultipleDealsClosedConfirmation',
        'devicealerts/DepositSuccessAlert',
        'devicealerts/ContactUsCTAAlert',
        'alerts/TradingConfirmationRetryAlert',
        'alerts/PriceAlertServerResponseAlert',
        'alerts/PriceAlertClosedServerResponseAlert',
        'devicealerts/RequestAccessAlert',
        'alerts/SessionEndedAlert'
    ],
    function AlertFactoryDef(require) {
        var general = require('handlers/general'),
            ExitAlert = require('devicealerts/ExitAlert'),
            BonusAlert = require('devicealerts/BonusAlert'),
            ServerResponseAlert = require('devicealerts/ServerResponseAlert'),
            CloseDealConfirmaionAlert = require('devicealerts/CloseDealConfirmationAlert'),
            MaxIdleTimeAlertWrapper = require('devicealerts/MaxIdleTimeAlertWrapper'),
            DoubleLoginAlertWrapper = require('devicealerts/DoubleLoginAlertWrapper'),
            MinEquityAlertWrapper = require('devicealerts/MinEquityAlertWrapper'),
            GeneralOkCancelAlert = require('devicealerts/GeneralOkCancelAlert'),
            GeneralOkAlert = require('devicealerts/GeneralOkAlert'),
            ClientStateAlertExposureAlert = require('devicealerts/serverevents/ClientStateAlertExposureAlert'),
            ClientStateAlertExposureCoverageAlert = require('devicealerts/serverevents/ClientStateAlertExposureCoverageAlert'),
            ClientStateAlertSystemMode = require('devicealerts/serverevents/ClientStateAlertSystemMode'),
            ClientStateAlertApplicationClosing = require('devicealerts/serverevents/ClientStateAlertApplicationClosing'),
            ClientStateAlertApplicationShutDown = require('devicealerts/serverevents/ClientStateAlertApplicationShutDown'),
            PortfolioAlertIsReal = require('devicealerts/serverevents/PortfolioAlertIsReal'),
            PortfolioAlertIsDemo = require('devicealerts/serverevents/PortfolioAlertIsDemo'),
            PortfolioAlertIsActive = require('devicealerts/serverevents/PortfolioAlertIsActive'),
            PortfolioAlertKycStatus = require('devicealerts/serverevents/PortfolioAlertKycStatus'),
            QuestionnaireValidationAlert = require('alerts/QuestionnaireValidationAlert'),
            CddQuestionnaireAlert = require('devicealerts/CddQuestionnaireAlert'),
            SignalsDisclaimerAlert = require('devicealerts/SignalsDisclaimerAlert'),
            SimpleClientAlert = require('devicealerts/SimpleClientAlert'),
            KnowledgeQuestionnaireAlert = require('alerts/KnowledgeQuestionnaireAlert'),
            GeneralCancelableAlert = require('devicealerts/GeneralCancelableAlert'),
            DealsClosedServerResponseAlert = require('alerts/DealsClosedServerResponseAlert'),
            DealAddServerResponseAlert = require('alerts/DealAddServerResponseAlert'),
            LimitsServerResponseAlert = require('alerts/LimitsServerResponseAlert'),
            PriceAlertServerResponseAlert = require('alerts/PriceAlertServerResponseAlert'),
            RemoveCreditCardConfirmationAlert = require('alerts/RemoveCreditCardConfirmationAlert'),
            MultipleDealsClosedConfirmation = require('alerts/MultipleDealsClosedConfirmation'),
            DepositSuccessAlert = require('devicealerts/DepositSuccessAlert'),
            ContactUsCTAAlert = require('devicealerts/ContactUsCTAAlert'),
            TradingConfirmationRetryAlert = require('alerts/TradingConfirmationRetryAlert'),
            PriceAlertClosedServerResponseAlert = require('alerts/PriceAlertClosedServerResponseAlert'),
            RequestAccessAlert = require('devicealerts/RequestAccessAlert'),
            SessionEndedAlert = require('alerts/SessionEndedAlert');

        function AlertFactory() {
            //-------------- Alert Properties ----------------
            var createAlert = function (alertType) {
                var alert;

                switch (alertType) {
                    case AlertTypes.ExitAlert:
                        alert = new ExitAlert();
                        break;

                    case AlertTypes.BonusAlert:
                        alert = new BonusAlert();
                        break;

                    case AlertTypes.ServerResponseAlert:
                        alert = new ServerResponseAlert();
                        break;

                    case AlertTypes.SimpleClientAlert:
                        alert = new SimpleClientAlert();
                        break;

                    case AlertTypes.CloseDealAlert:
                        alert = new CloseDealConfirmaionAlert();
                        break;

                    case AlertTypes.MaxIdleTimeAlert:
                        alert = new MaxIdleTimeAlertWrapper();
                        break;

                    case AlertTypes.DoubleLoginAlert:
                        alert = new DoubleLoginAlertWrapper();
                        break;

                    case AlertTypes.MinEquityAlert:
                        alert = new MinEquityAlertWrapper();
                        break;

                    case AlertTypes.GeneralOkCancelAlert:
                        alert = new GeneralOkCancelAlert();
                        break;

                    case AlertTypes.GeneralOkAlert:
                    case AlertTypes.DepositConfirmationEmailSentAlert:
                    case AlertTypes.DepositQuestionnaireAlert:
                        alert = new GeneralOkAlert();
                        break;

                    //-------------------Post logins Client State Alerts      
                    case PostClientStatesLoginsAlerts.ExposureAlert:
                        alert = new ClientStateAlertExposureAlert();
                        break;

                    case PostClientStatesLoginsAlerts.ExposureCoverageAlert:
                        alert = new ClientStateAlertExposureCoverageAlert();
                        break;

                    case PostClientStatesLoginsAlerts.SystemMode:
                        alert = new ClientStateAlertSystemMode();
                        break;

                    case PostClientStatesLoginsAlerts.SystemModeApplicationClosing:
                        alert = new ClientStateAlertApplicationClosing();
                        break;

                    case PostClientStatesLoginsAlerts.SystemModeApplicationShutDown:
                        alert = new ClientStateAlertApplicationShutDown();
                        break;

                    case PostPortfoliosLoginsAlerts.IsActive:
                        alert = new PortfolioAlertIsActive();
                        break;

                    case PostPortfoliosLoginsAlerts.IsDemo:
                        alert = new PortfolioAlertIsDemo();
                        break;

                    case PostPortfoliosLoginsAlerts.IsReal:
                        alert = new PortfolioAlertIsReal();
                        break;

                    //-------------------Post logins Client State Alerts  

                    case PostPortfoliosLoginsAlerts.KycStatus:
                        alert = new PortfolioAlertKycStatus();
                        break;

                    //-----------------------------------------
                    case AlertTypes.ClientQuestionnaire:
                        alert = new QuestionnaireValidationAlert();
                        break;

                    //-----------------------------------------
                    case AlertTypes.ClientKnowledgeQuestionnaire:
                        alert = new KnowledgeQuestionnaireAlert();
                        break;

                    //-----------------------------------------
                    case AlertTypes.CddClientQuestionnaire:
                        alert = new CddQuestionnaireAlert();
                        break;

                    case AlertTypes.SignalsDisclaimerAlert:
                        alert = new SignalsDisclaimerAlert();
                        break;

                    case AlertTypes.GeneralCancelableAlert:
                        alert = new GeneralCancelableAlert();
                        break;

                    case AlertTypes.DealsClosedServerResponseAlert:
                        alert = new DealsClosedServerResponseAlert();
                        break;

                    case AlertTypes.DealAddServerResponseAlert:
                        alert = new DealAddServerResponseAlert();
                        break;

                    case AlertTypes.LimitsServerResponseAlert:
                        alert = new LimitsServerResponseAlert();
                        break;

                    case AlertTypes.RemoveCreditCardConfirmationAlert:
                        alert = new RemoveCreditCardConfirmationAlert();
                        break;

                    case AlertTypes.MultipleDealsClosedConfirmation:
                        alert = new MultipleDealsClosedConfirmation();
                        break;

                    case AlertTypes.DepositSuccessAlert:
                        alert = new DepositSuccessAlert();
                        break;

                    case AlertTypes.ContactUsCTAAlert:
                        alert = new ContactUsCTAAlert();
                        break;

                    case AlertTypes.TradingConfirmationRetryAlert:
                        alert = new TradingConfirmationRetryAlert();
                        break;

                    case AlertTypes.MultiplePriceAlertsClosedConfirmation:
                        alert = new MultipleDealsClosedConfirmation();
                        break;

                    case AlertTypes.PriceAlertClosedServerResponseAlert:
                        alert = new PriceAlertClosedServerResponseAlert();
                        break;

                    case AlertTypes.PriceAlertServerResponseAlert:
                        alert = new PriceAlertServerResponseAlert();
                        break;

                    case AlertTypes.RequestAccessVideoLessonsAlert:
                        alert = new RequestAccessAlert();
                        break;

                    case AlertTypes.RequestAccessTutorialsAlert:
                        alert = new RequestAccessAlert();
                        break;

                    case AlertTypes.SessionEndedAlert:
                        alert = new SessionEndedAlert();
                        break;

                    case AlertTypes.CreditCardNotApprovedAlert:
                        alert = new GeneralOkCancelAlert();
                        break;
                }

                if (alert) {
                    alert.Init();
                    alert = alert.GetAlert;
                }

                return alert;
            };

            var setAlertProperties = function (alert, alertType, title, body, messages, properties, withoutLineBrakes) {
                alert.messages.removeAll();

                if (title) {
                    alert.title(title);
                }
                if (title === null) {
                    alert.setDefaultTitle();
                }

                if (body) {
                    try {
                        if (general.isArrayType(body)) {
                            for (var i = 0; i < body.length; i++) {
                                body[i] = applyLineBreaks(body[i], withoutLineBrakes);

                            }
                        }
                        else {
                            // is string
                            body = applyLineBreaks(body, withoutLineBrakes);
                        }
                    }
                    catch (e) {
                        // empty
                    }

                    alert.body(body);
                }

                if (messages) {
                    while (messages.length > 0) {
                        var msg = messages.shift();
                        msg = applyLineBreaks(msg, withoutLineBrakes);

                        alert.messages.push(msg);
                    }
                }

                if (properties) {
                    alert.properties = properties;
                }
                else {
                    alert.properties = {};
                }

                return alert;
            };

            var applyLineBreaks = function (str, withoutLineBrakesReplacer) {
                if (withoutLineBrakesReplacer) {
                    return str;
                }

                return str.replace(/\\r\\n|\\n|\\r/gm, '<br />').replace(/(\r\n|\n|\r)/gm, '<br />'); // removes all 3 types of line breaks;
            };

            return {
                CreateAlert: createAlert,
                UpdateAlert: setAlertProperties
            };
        }

        return AlertFactory;
    }
);

define(
    'managers/AlertsManager',
    [
        'require',
        'enums/alertenums',
        'devicealerts/AlertFactory',
        'knockout',
        'handlers/Delegate'
    ],
    function AlertsManagerDef(require) {
        var AlertsManager = function AlertsManagerClass() {
            var AlertFactory = require('devicealerts/AlertFactory'),
                delegate = require('handlers/Delegate'),
                ko = require('knockout');

            var alertfactory = new AlertFactory(),
                alerts = {},
                alertCounter = ko.observable(0),
                onShowAlert = new delegate(),
                visiblePriorityAlerts = [],
                priorityAlerts = [
                    AlertTypes.MaxIdleTimeAlert,
                    AlertTypes.DoubleLoginAlert,
                    AlertTypes.SessionEndedAlert
                ];

            function visiblePriorityAlertOnClose() {
                visiblePriorityAlerts.pop();
            }

            function priorityAlertCanBeShow() {
                return 0 >= visiblePriorityAlerts.length;
            }

            var hasAlert = ko.computed(function () {
                return alertCounter() > 0;
            });

            hasAlert.subscribe(function (value) {
                if (value) {
                    $('body').addClass('mobilePopupVisible');
                } else {
                    $('body').removeClass('mobilePopupVisible');
                }
            });

            //-------------- public Methods -----------------------------

            function getAlert(alertType) {
                var alert = alerts[alertType];

                if (!alert) {
                    alert = alertfactory.CreateAlert(alertType);

                    if (alert) {
                        alerts[alertType] = alert;

                        alert.visible.subscribe(function (isVisible) {
                            if (isVisible) {
                                alertCounter(alertCounter() + 1);
                            } else {
                                alertCounter(alertCounter() - 1);
                            }
                        });
                    }
                }

                return alerts[alertType];
            }

            function popAlert(alertType) {
                var alert = getAlert(alertType);

                if (alert && !alert.visible()) {
                    if (priorityAlerts.indexOf(alertType) >= 0) {
                        if (priorityAlertCanBeShow()) {
                            alert.onCloseAction.Remove(visiblePriorityAlertOnClose);
                            alert.onCloseAction.Add(visiblePriorityAlertOnClose);
                            visiblePriorityAlerts.push(priorityAlerts.indexOf(alertType));
                        } else {
                            return;
                        }
                    }

                    alert.show();

                    onShowAlert.Invoke(alertType, alert);
                }
            }

            function updateAlert(alertType, title, body, messages, properties, withoutLineBrakes) {
                var alert = getAlert(alertType);
                if (alert) {
                    alertfactory.UpdateAlert(alert, alertType, title, body, messages, properties, withoutLineBrakes);
                }
            }

            function showAlert(alertType, title, body, messages, properties, withoutLineBrakes) {
                updateAlert(alertType, title, body, messages, properties, withoutLineBrakes);
                popAlert(alertType);
            }

            return {
                HasAlert: hasAlert,
                PopAlert: popAlert,
                GetAlert: getAlert,
                UpdateAlert: updateAlert,
                ShowAlert: showAlert,
                OnShowAlert: onShowAlert
            };
        };

        var module = window.AlertsManager = AlertsManager();
        return module;
    }
);
define('devicemanagers/AlertsManager', ['managers/AlertsManager'], function FxNet(alertsManager) {
    return alertsManager;
});
define('devicealerts/MaxIdleTimeAlert', ["require", 'devicemanagers/AlertsManager'], function (require) {
    var AlertsManager = require('devicemanagers/AlertsManager');

    var MaxIdleTimeAlert = (function() {

        var show = function() {
            AlertsManager.UpdateAlert(AlertTypes.MaxIdleTimeAlert);
            AlertsManager.PopAlert(AlertTypes.MaxIdleTimeAlert);
        };

        return {
            Show: show
        };
    })();

    return MaxIdleTimeAlert;
});


/*global timeStamp, setTimeout, clearTimout, systemInfo*/
define(
    "generalmanagers/ActivitySupervisor", 
    [
        "require",
        "dataaccess/dalorder",
        'handlers/general',
        "dataaccess/dalCommon",
        'devicealerts/MaxIdleTimeAlert',
        'extensions/Date',
        'initdatamanagers/Customer',
    ],
    function (require) {
        var 
            dalOrders = require("dataaccess/dalorder"),
            customer = require('initdatamanagers/Customer'),
            general = require('handlers/general'),
            dalCommon = require("dataaccess/dalCommon"),
            MaxIdleTimeAlert = require('devicealerts/MaxIdleTimeAlert');
          

        function ActivitySupervisor() {
            var settingsMaxIdleTime = null,
                settingsAlertTime = null,
                checkActivityTimer = null,
                lastCheckTime = timeStamp(),
                stayAlertTimer = null,
                settingTotalMaxIdleTime;

            function check() {
                // initialization:  wait till setting gets from server ////////////////
                if (settingsMaxIdleTime === null && !general.isDefinedType(systemInfo.clientApplicationParams)) {
                    setTimeout(check, 1000);
                    return false;
                }

                // setting from server available: initialize
                if (settingsMaxIdleTime === null) {
                    settingsMaxIdleTime = parseInt(systemInfo.clientApplicationParams[eClientParams.MaxIdleTime], 10);
                    settingsAlertTime = parseInt(systemInfo.clientApplicationParams[eClientParams.IdleTimer], 10);
                    settingTotalMaxIdleTime = settingsMaxIdleTime + settingsAlertTime;
                }
                // initialization done ///////////

                var isActive = checkActivity();

                if (isActive) {
                    checkActivityTimer = setTimeout(check, 30000);
                    return true;
                } else {
                    var logoutTimeout = timeTillLogout()<0 ? 0: timeTillLogout();
                    stayAlertTimer = setTimeout(logout, logoutTimeout);
                    MaxIdleTimeAlert.Show();

                    return false;
                }
            }

            function logout() {
                if (checkActivityTimer) {
                    clearTimeout(checkActivityTimer);
                    checkActivityTimer = null;
                }

                if (stayAlertTimer) {
                    clearTimeout(stayAlertTimer);
                    stayAlertTimer = null;
                }
                
                if (customer.isAutologin()) {
                    dalCommon.Exit(eLoginLogoutReason.activitySupervisor_logout);
                } else {
                    dalCommon.Logout(eLoginLogoutReason.MaxIdleTimeAlert);
                }
            }

            function exit() {
                dalCommon.Exit(eLoginLogoutReason.activitySupervisor_exit);
            }

            function checkActivity() {
                lastCheckTime = timeStamp();

                return getIdleTime() < settingsMaxIdleTime;
            }

            function resetTimeRequest() {
                if (timeStamp() - lastCheckTime > settingTotalMaxIdleTime) {
                    logout();
                }

                dalOrders.resetTimeRequest();
            }

            function resumeChecking() {
                dalOrders.resetTimeRequest();
                check();
            }

            function updateAsStay() {
                if (stayAlertTimer) {
                    clearTimeout(stayAlertTimer);
                    stayAlertTimer = null;
                } else {
                    dalCommon.Login(eLoginLogoutReason.activitySupervisor_updateAsStay);
                }

                resumeChecking();
            }

            function start() {
                check();
            }

            function getIdleTime() {
                return timeStamp() - dalOrders.lastTimeRequest();
            }

            // if positive than time has passed and need to logout, if negative time has not passed yet
            function timeTillLogout() {
                return settingTotalMaxIdleTime - getIdleTime();
            }

            //------------------------------------------------------
            return {
                Start: start,
                ResetTimeRequest: resetTimeRequest,
                UpdateStay: updateAsStay,
                Logout: logout,
                Exit: exit
            };
        }

        var module = window.ActivitySupervisor = new ActivitySupervisor();

        return module;
    }
);
define(
    'helpers/ObservableHelper',
    [
        "require",
        "knockout",
        'handlers/general',
        'helpers/KOExtensions'
    ],
    function(require) {
        var ko = require("knockout"),
            general = require('handlers/general');

        function ObservableHelper() {
            function generatePrimitiveTypeArray(koObj) {
                var obj = [];

                for (var key in koObj) {
                    if (koObj.hasOwnProperty(key)) {
                        if (!general.isFunctionType(koObj[key])) {
                            obj[key] = koObj[key];
                        }
                    }
                }

                return obj;
            }

            function cleanKoObservableSimpleObject(koObj, computablesDispose) {
                var clonedObject = general.cloneHardCopy(koObj);

                for (var key in clonedObject) {
                    if (clonedObject.hasOwnProperty(key)) {
                        var property = clonedObject[key];

                        if (!general.isFunctionType(property)) {
                            continue;
                        }

                        if (ko.isWriteableObservable(property)) {
                            property(getEmptyPropertyValue(property));
                        }

                        if (computablesDispose && ko.isComputed(property)) {
                            property.dispose();
                        }
                    }
                }

                return clonedObject;
            }

            function getEmptyPropertyValue(property) {
                if (ko.isObservableArray(property)) {
                    return [];
                }

                if (ko.isObservable(property)) {
                    var value = ko.unwrap(property);

                    if (general.isBooleanType(value)) {
                        return false;
                    }

                    if (general.isObjectType(value)) {
                        // if the observable contains an json object (like validation options)
                        // just return the object
                        return value;
                    }
                }

                return "";
            }

            return {
                GeneratePrimitiveTypeArray: generatePrimitiveTypeArray,
                CleanKoObservableSimpleObject: cleanKoObservableSimpleObject
            };
        }

        return new ObservableHelper();
    }
);
/* global UrlResolver */
var InitConfiguration = function () {
	var applicationConfiguration = {
		applicationType: window.eApplicationTypes.Web,
		doubleTabListenInterval: 500,
	};

	var newDealConfiguration = {
		onSuccessRedirectTo: false,
		setlimitsConfiguration: {
			defaultTab: eSetLimitsTabs.NoTabs,
			parentView: eViewTypes.vNewDealSlip,
		},
		dealAmountPrefixKey: "dealAmountLabel_",
		profileKeyForDefaultTab: "defaultTab",
		currentRateDirectionSwitch: false,
		chart: {
			direction: eChartDirection.Same,
			allowDragLine: true,
			keys: {
				stopLoss: "chartline_StopLoss",
				takeProfit: "chartline_TakeProfit",
				currentRate: "chartline_CurrentRate",
			},
		},
	};

	var defaultChartConfiguration = {
		direction: eChartDirection.Same,
		allowDragLine: true,
		keys: {
			stopLoss: "chartline_IfDoneStopLoss",
			takeProfit: "chartline_IfDoneTakeProfit",
			currentRate: "chartline_CurrentRate",
			limitLevel: "chartline_LimitLevel",
		},
	};

	var newLimitConfiguration = {
		onSuccessRedirectTo: false,
		setlimitsConfiguration: {
			defaultTab: eSetLimitsTabs.NoTabs,
			parentView: eViewTypes.vNewLimit,
		},
		dealAmountPrefixKey: "dealAmountLabel_",
		profileKeyForDefaultTab: "defaultTab",
		chart: defaultChartConfiguration,
	};

	var priceAlertConfiguration = {
		onSuccessRedirectTo: false,
		setlimitsConfiguration: {
			defaultTab: eSetLimitsTabs.NoTabs,
		},
		profileKeyForDefaultTab: "defaultTab",
		chart: {
			parentType: eChartParentType.NewPriceAlert,
			direction: eChartDirection.Same,
			allowDragLine: true,
			keys: {
				currentRate: "chartline_CurrentRate",
				priceAlertRate: "chartline_PriceAlertRate",
			},
		},
	};

	var editClosingLimitConfiguration = {
		setlimitsConfiguration: {
			defaultTab: eSetLimitsTabs.Rate,
		},
		profileKeyForDefaultTab: "editClosingLimitTab",
		showValidationTooltips: true,
		currentRateDirectionSwitch: true,
		chart: {
			direction: eChartDirection.Opposite,
			allowDragLine: true,
			keys: {
				stopLoss: "chartline_StopLoss",
				takeProfit: "chartline_TakeProfit",
				currentRate: "chartline_ClosingRate",
				openRate: "chartline_OpenRate",
			},
		},
	};

	var editLimitSettingsConfiguration = {
		setlimitsConfiguration: {
			defaultTab: eSetLimitsTabs.NoTabs,
		},
		profileKeyForDefaultTab: "editLimitTab",
		showValidationTooltips: true,
		showExpirationCalendar: true,
	};

	var closeDealSettingsConfiguration = {
		profileKeyForDefaultTab: "closeDealTab",
		currentRateDirectionSwitch: true,
		chart: {
			direction: eChartDirection.Opposite,
			allowDragLine: false,
			keys: {
				stopLoss: "chartline_StopLoss",
				takeProfit: "chartline_TakeProfit",
				currentRate: "chartline_ClosingRate",
				openRate: "chartline_OpenRate",
			},
		},
	};

	var extendedCloseDealSettingsConfiguration = {
		profileKeyForDefaultTab: "closeDealTab",
		currentRateDirectionSwitch: true,
		chart: {
			direction: eChartDirection.Opposite,
			allowDragLine: false,
			keys: {
				stopLoss: "chartline_StopLoss",
				takeProfit: "chartline_TakeProfit",
				currentRate: "chartline_ClosingRate",
				openRate: "chartline_OpenRate",
			},
		},
		rangeForPLCalculation: {
			far: function () {
				return 0;
			},
			near: function () {
				return 20000;
			},
		},
	};

	var activeLimitsConfiguration = {
		defaultLimitMode: eLimitMode.OpenDeal,
	};

	var limitsConfiguration = {
		defaultLimitType: eLimitsType.Active,
	};

	var openDealsConfiguration = {
		closeSelected: true,
		itemsPerRender: 50,
	};

	var withdrawalConfiguration = {
		withdrawalRequestSuccessRedirectToView: eForms.ViewAndPrintWithdrawal,
		stepLoadFailRedirectView: eForms.Deals,
		wizardConfig: {
			defaultForm: eForms.Withdrawal,
			defaultStep: eWithdrawalSteps.setAmount,
			useBrowserHistory: true,
			steps: {
				1: {
					component: "fx-component-withdrawal-amount",
					previousStep: {
						label: "lblBack",
						valid: true,
						visible: false,
					},
					nextStep: {
						label: "lblContinue",
						valid: false,
						visible: false,
					},
				},
				2: {
					component: "fx-component-withdrawal-method",
					previousStep: {
						label: "lblBack",
						valid: true,
						visible: true,
					},
					nextStep: {
						label: "lblContinue",
						valid: false,
						visible: true,
					},
				},
				3: {
					component: "fx-component-withdrawal-setbankdetails",
					previousStep: {
						label: "lblBack",
						valid: true,
						visible: true,
					},
					nextStep: {
						label: "lblContinue",
						valid: false,
						visible: true,
					},
				},
				4: {
					component: "fx-component-withdrawal-setccdetails",
					previousStep: {
						label: "lblBack",
						valid: true,
						visible: true,
					},
					nextStep: {
						label: "lblContinue",
						valid: false,
						visible: true,
					},
				},
				5: {
					component: "fx-component-withdrawal-setapproval",
					previousStep: {
						label: "lblBack",
						valid: true,
						visible: true,
					},
					nextStep: {
						label: "lblApprove",
						valid: false,
						visible: true,
					},
				},
			},
		},
	};

	var quotesGridConfiguration = {
		minRowsToDisplay: 9,
	};

	var favoriteInstrumentsConfiguration = {
		favoriteInstrumentsLimit: 50,
	};

	var quotesPresetConfiguration = {
		areQuotesVisible: true,
	};

	var pendingWithdrawalConfiguration = {};

	var walletConfiguration = {
		formatConditionalVolume: false,
		useAdvancedView: true,
	};

	var balanceConfiguration = {
		pageSize: 250,
	};

	var closedDealsConfiguration = {
		pageSize: 2000,
		threshold: 2000,
		scrollMaxVisible: 10,
	};

	var csvConfiguration = {
		pageSize: 1000,
	};

	var printConfiguration = {
		pageSize: 1000,
	};

	var economicCalendarConfiguration = {
		hubname: "econoCalendarHub",
		eventsMaxImportance: 3,
		contentKeySection: "ec",
		invertedDirectionEvents: [
			2471280,
			195,
			2,
			4241147,
			55,
			73,
			181,
			185,
			192,
			1371097,
			1561129,
			1591134,
			1891180,
			2121218,
			2461277,
			2471280,
			2831382,
			3631549,
			3641551,
			3641552,
			4221618,
			4221619,
			4231627,
			4241147,
			4241150,
			2611297,
			2611423,
			121,
		],
	};

	var marketInfoConfiguration = {
		hubname: "sentimentsHub",
	};

	var gtmConfiguration = {
		gtmContentKey: "googleTagManagerId",
		disabledGTMToken: "#",
	};

	var signalsConfiguration = {
		pageSize: 10,
	};

	var tradingSignalsConfig = {
		durationFilterBySignalType: {
			technicalAnalisys: { detailed: -14, nondetailed: -8 },
			generic: { detailed: -8, nondetailed: -4 },
		},
		rowsPerGridPage: {
			technicalAnalisys: 10,
			alerts: 5,
			candleStick: 5,
		},
		rowGridHeight: 28.5, //this figure should be in synk with the css - less grid row hight
		defaultPage: 1,
	};

	var contractRolloverConfiguration = {
		defaultPage: 1,
		pageSize: 1000,
		scrollMaxVisible: 8,
	};

	var advinionChartConfiguration = {
		rootPath: UrlResolver.getStaticJSPath("Scripts/AdvinionChart"),
		cssLoaderPath: UrlResolver.getAssetsPath() + "/Skins/Web/Broker" + UrlResolver.getDefaultBroker() + "/Default/",
	};

	var accountCardRecordsConfiguration = {
		pageSize: 10,
	};

	var dealTabsConfiguration = {
		view: eViewTypes.vDealsTabs,
		tabs: [
			{
				type: eViewTypes.vOpenDeals,
				headerComponent: "fx-component-open-deals-grid-tab-header",
				bodyComponent: "fx-component-open-deals-grid",
				tabTitle: "openDeals_tabTitle",
			},
			{
				type: eViewTypes.vLimits,
				headerComponent: "fx-component-limits-grid-tab-header",
				bodyComponent: "fx-component-limits-grid",
				tabTitle: "openingLimits_tabTitle",
			},
			{
				type: eViewTypes.vClosedDeals,
				headerComponent: "fx-component-closed-deals-grid-tab-header",
				bodyComponent: "fx-component-closed-deals-grid",
				tabTitle: "closedDeals_tabTitle",
			},
		],
	};

	var uploadDocumentsConfiguration = {
		interWindowsCommunicationLimit: 30000,
		uploadFrameReloadTimeout: 10000,
		uploadFrameRetryCount: 3,
	};

	var amlConfiguration = {
		countriesWithDisabledUpload: ["Hungary"],
		countriesWithVideoId: ["Hungary"],
		countriesWithDisabledAlternativeSend: ["Hungary"],
	};

	var thankYouConfiguration = {
		brokersThatShouldShowAmlNotice: ["3"],
	};

	var depositConfirmationConfiguration = {
		excludeList: {
			idList: ["ClearAction", "SendActionContainer", "DisableOverlay"],
			tagList: {
				IFRAME: null,
				LINK: {
					rel: ["dns-prefetch", "preconnect", "prefetch", "manifest"],
				},
			},
		},
	};

	var autoCompleteConfiguration = {
		IEFirstSearchTimeOut: 3500,
	};

	var personalGuideConfiguration = {
		DoNotShowForms: [
			eForms.Deposit,
			eForms.ConcretePaymentForm,
			eForms.DepositConfirmation,
			eForms.DepositPending,
			eForms.DepositSuccess,
		],
		PersonalAssistants: {
			Max: {
				name: "Max",
				version: "6",
				variation: 2
			},
			Lexi: {
				name: "Lexi",
				version: "2",
				variation: 2
			},
			MaxSA: {
				name: "MaxSA",
				version: "1",
				variation: 3
			},
			LexiTestVariation4: {
				name: "Lexi",
				version: "2",
				variation: 2
			},
			MaxTestVariation4: {
				name: "Max",
				version: "6",
				variation: 2
			}
		},
	};

	var dynamicTitleConfiguration = {
		dynamicTitleKey: "dynamicSlipTitle",
	};

	return {
		ApplicationConfiguration: applicationConfiguration,

		NewDealConfiguration: newDealConfiguration,
		EditClosingLimitConfiguration: editClosingLimitConfiguration,
		CloseDealSettingsConfiguration: closeDealSettingsConfiguration,
		ExtendedCloseDealSettingsConfiguration: extendedCloseDealSettingsConfiguration,
		NewLimitConfiguration: newLimitConfiguration,
		PriceAlertConfiguration: priceAlertConfiguration,
		EditLimitSettingsConfiguration: editLimitSettingsConfiguration,

		ActiveLimitsConfiguration: activeLimitsConfiguration,
		LimitsConfiguration: limitsConfiguration,
		OpenDealsConfiguration: openDealsConfiguration,
		WithdrawalConfiguration: withdrawalConfiguration,
		PendingWithdrawalConfiguration: pendingWithdrawalConfiguration,

		QuotesPresetConfiguration: quotesPresetConfiguration,
		WalletConfiguration: walletConfiguration,
		BalanceConfiguration: balanceConfiguration,
		ClosedDealsConfiguration: closedDealsConfiguration,
		PrintConfiguration: printConfiguration,
		CsvConfiguration: csvConfiguration,
		FavoriteInstrumentsConfiguration: favoriteInstrumentsConfiguration,

		QuotesGridConfiguration: quotesGridConfiguration,
		EconomicCalendarConfiguration: economicCalendarConfiguration,
		SignalsConfiguration: signalsConfiguration,
		MarketInfoConfiguration: marketInfoConfiguration,
		GTMConfiguration: gtmConfiguration,
		TradingSignalsConfig: tradingSignalsConfig,
		ContractRolloverConfiguration: contractRolloverConfiguration,

		AdvinionChartConfiguration: advinionChartConfiguration,
		AccountCardRecordsConfiguration: accountCardRecordsConfiguration,

		DefaultChartConfiguration: defaultChartConfiguration,
		DealTabsConfiguration: dealTabsConfiguration,

		UploadDocumentsConfiguration: uploadDocumentsConfiguration,
		AmlConfiguration: amlConfiguration,
		ThankYouConfiguration: thankYouConfiguration,
		MarketInfoSectionsConfiguration: {},
		DepositConfirmationConfiguration: depositConfirmationConfiguration,

		AutoCompleteConfiguration: autoCompleteConfiguration,

		PersonalGuideConfiguration: personalGuideConfiguration,
		DynamicTitleConfiguration: dynamicTitleConfiguration,
	};
};

define("configuration/initconfiguration", ["enums/enums", "customEnums/ViewsEnums", "global/UrlResolver"], function () {
	return InitConfiguration();
});

/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var
		History = window.History = window.History||{},
		jQuery = window.jQuery;

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		return;
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		return;
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.isHashEqual(newHash, oldHash)
		 * Checks to see if two hashes are functionally equal
		 * @param {string} newHash
		 * @param {string} oldHash
		 * @return {boolean} true
		 */
		History.isHashEqual = function(newHash, oldHash){
			newHash = encodeURIComponent(newHash).replace(/%25/g, "%");
			oldHash = encodeURIComponent(oldHash).replace(/%25/g, "%");
			return newHash === oldHash;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardedState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning,
					startedWithHash = Boolean(History.getHash());

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					// IE 6 requires iframe to have a src on HTTPS pages, otherwise it will throw a
					// "This page contains both secure and nonsecure items" warning.
					iframe.setAttribute('id', iframeId);
					iframe.setAttribute('src', '#');
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var
							documentHash = History.getHash(),
							iframeHash = History.getHash(iframe.contentWindow.document);

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;
							
							// If there is no iframe hash that means we're at the original
							// iframe state.
							// And if there was a hash on the original request, the original
							// iframe state was replaced instantly, so skip this state and take
							// the user back to where they came from.
							if (startedWithHash && iframeHash === '') {
								History.back();
							}
							else {
								// Update the Hash
								History.setHash(iframeHash,false);
							}
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash()||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || History.getLocationHref()),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||History.getLocationHref()),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,encodeURI(currentState.url),false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash(),
					wasExpected = History.expectedStateId == newState.id;

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				if(!wasExpected)
					History.Adapter.trigger(window,'statechange');

				// Update HTML4 Hash
				if ( !History.isHashEqual(newStateHash, html4Hash) && !History.isHashEqual(newStateHash, History.getShortUrl(History.getLocationHref())) ) {
					History.setHash(newStateHash,false);
				}
				
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// We assume that the URL passed in is URI-encoded, but this makes
				// sure that it's fully URI encoded; any '%'s that are encoded are
				// converted back into '%'s
				url = encodeURI(url).replace(/%25/g, "%");

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragment-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState        = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// If the url hasn't changed, just store and save the state
				// and fire a statechange event to be consistent with the
				// html 5 api
				if ( newStateHash === oldStateHash ) {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;
	
					// Recycle the State
					History.recycleState(newState);
	
					// Force update of the title
					History.setTitle(newState);
					
					// Update HTML5 State
					History.saveState(newState);

					// Fire HTML5 Event
					//History.debug('History.pushState: trigger popstate');
					History.Adapter.trigger(window,'statechange');
					History.busy(false);
				}
				else {
					// Alias to PushState
					History.pushState(newState.data,newState.title,newState.url,false);
				}

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try to Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	try {
		sessionStorage = window.sessionStorage; // This will throw an exception in some browsers when cookies/localStorage are explicitly disabled (i.e. Chrome)
		sessionStorage.setItem('TEST', '1');
		sessionStorage.removeItem('TEST');
	} catch(e) {
		sessionStorage = false;
	}

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		return;
	}

	// Initialise History
	History.init = function(options){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(options){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.disableSuid
		 * Force History not to append suid
		 */
		History.options.disableSuid = History.options.disableSuid || false;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;

		/**
		 * History.options.html4Mode
		 * If true, will force HTMl4 mode (hashtags)
		 */
		History.options.html4Mode = History.options.html4Mode || false;

		/**
		 * History.options.delayInit
		 * Want to override default options and call init manually.
		 */
		History.options.delayInit = History.options.delayInit || false;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */

		if (History.options.html4Mode) {
			History.emulated = {
				pushState : true,
				hashChange: true
			};
		}

		else {

			History.emulated = {
				pushState: !Boolean(
					window.history && window.history.pushState && window.history.replaceState
					&& !(
						(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
						|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
					)
				),
				hashChange: Boolean(
					!(('onhashchange' in window) || ('onhashchange' in document))
					||
					(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
				)
			};
		}

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				if ( obj.hasOwnProperty(name) ) {
					return false;
				}
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||History.getLocationHref(),
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = (History.getLocationHref()).replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};

		/**
		 * History.getLocationHref(document)
		 * Returns a normalized version of document.location.href
		 * accounting for browser inconsistencies, etc.
		 *
		 * This URL will be URI-encoded and will include the hash
		 *
		 * @param {object} document
		 * @return {string} url
		 */
		History.getLocationHref = function(doc) {
			doc = doc || document;

			// most of the time, this will be true
			if (doc.URL === doc.location.href)
				return doc.location.href;

			// some versions of webkit URI-decode document.location.href
			// but they leave document.URL in an encoded state
			if (doc.location.href === decodeURIComponent(doc.URL))
				return doc.URL;

			// FF 3.6 only updates document.URL when a page is reloaded
			// document.location.href is updated correctly
			if (doc.location.hash && decodeURIComponent(doc.location.href.replace(/^[^#]+/, "")) === doc.location.hash)
				return doc.location.href;

			if (doc.URL.indexOf('#') == -1 && doc.location.href.indexOf('#') != -1)
				return doc.location.href;
			
			return doc.URL || doc.location.href;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(oldState.url?oldState.url:(History.getLocationHref()));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( (newState.title || dataNotEmpty) && History.options.disableSuid !== true ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url, tmp;

			// Extract
			
			// If the URL has a #, use the id from before the #
			if (url_or_hash.indexOf('#') != -1)
			{
				tmp = url_or_hash.split("#")[0];
			}
			else
			{
				tmp = url_or_hash;
			}
			
			parts = /(.*)\&_suid=([0-9]+)$/.exec(tmp);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};
		
		/**
		 * History.getCurrentIndex()
		 * Gets the current index
		 * @return (integer)
		*/
		History.getCurrentIndex = function(){
			// Prepare
			var index = null;
			
			// No states saved
			if(History.savedStates.length < 1) {
				index = 0;
			}
			else {
				index = History.savedStates.length-1;
			}
			return index;
		};

		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * @param {Location=} location
		 * Gets the current document hash
		 * Note: unlike location.hash, this is guaranteed to return the escaped hash in all browsers
		 * @return {string}
		 */
		History.getHash = function(doc){
			var url = History.getLocationHref(doc),
				hash;
			hash = History.getHashByUrl(url);
			return hash;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = decodeURIComponent(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( History.getHash() !== hash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+hash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = hash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.encodeURIComponent(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(History.getLocationHref()),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
                // fix Please check: https://github.com/browserstate/history.js/pull/455

				// var stateId = false, newState = false, currentHash, currentState;
			    var stateId = false, newState = false, currentHash, currentState, isNavigationButtons = false;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash = History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||History.getLocationHref(),true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
				    newState = History.getStateById(stateId);
                    // fix Please check: https://github.com/browserstate/history.js/pull/455
 
				    isNavigationButtons = true;
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(History.getLocationHref());
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,History.getLocationHref());
				}
			    // fix Please check: https://github.com/browserstate/history.js/pull/455

				
                // Store back / forward button boolean
				newState.navigation = isNavigationButtons;

			    ///

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(History.getLocationHref(),true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item, currentStoreString;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// In Safari, going into Private Browsing mode causes the
				// Session Storage object to still exist but if you try and use
				// or set any property/function of it it throws the exception
				// "QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to
				// add something to storage that exceeded the quota." infinitely
				// every second.
				currentStoreString = JSON.stringify(currentStore);
				try {
					// Store
					sessionStorage.setItem('History.store', currentStoreString);
				}
				catch (e) {
					if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
						if (sessionStorage.length) {
							// Workaround for a bug seen on iPads. Sometimes the quota exceeded error comes up and simply
							// removing/resetting the storage can work.
							sessionStorage.removeItem('History.store');
							sessionStorage.setItem('History.store', currentStoreString);
						} else {
							// Otherwise, we're probably private browsing in Safari, so we'll ignore the exception.
						}
					} else {
						throw e;
					}
				}
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try to Initialise History
	if (!History.options || !History.options.delayInit) {
		History.init();
	}

})(window);


define("vendor/jquery.history",[],function(){ return History })

;
define(
    'managers/historymanager',
    [
        "require",
        "jquery",
        'handlers/general',
        "vendor/jquery.history"
    ],
    function (require) {
        var $ = require("jquery"),
            general = require('handlers/general'),
            history = require("vendor/jquery.history");

        // -----------------------------------------

        function State() {
            this.type = '';
        }

        // -----------------------------------------

        function InvalidState() {
            this.type = eHistoryStateType.Invalid;
        }

        InvalidState.prototype = Object.create(State.prototype);
        InvalidState.prototype.constructor = InvalidState;

        // -----------------------------------------

        function PopupState(popupType, popupId) {
            this.type = popupType;
            this.popupType = popupType;
            this.popupId = popupId;
        }

        PopupState.prototype = Object.create(State.prototype);
        PopupState.prototype.constructor = PopupState;

        PopupState.prototype.toString = function () {
            return "?popup=" + this.popupId;
        };

        // -----------------------------------------
        function WizardState(view, stepNumber) {
            this.type = eHistoryStateType.Wizard;
            this.step = stepNumber;
            this.view = view;
        }

        WizardState.prototype = Object.create(State.prototype);
        WizardState.prototype.constructor = WizardState;

        WizardState.prototype.toString = function () {
            return "?view=" + this.view + "&step=" + (!general.isEmptyValue(this.step) ? this.step : 1);
        };

        // -----------------------------------------

        function QuestionnaireState(pageNumber) {
            this.type = eHistoryStateType.Questionnaire;
            this.pageNumber = pageNumber;
            this.view = eForms.ClientQuestionnaire;
        }

        QuestionnaireState.prototype = Object.create(State.prototype);
        QuestionnaireState.prototype.constructor = QuestionnaireState;

        QuestionnaireState.prototype.toString = function () {
            return "?view=" + this.view + "&questionnaire=" + this.pageNumber;
        };

        // -----------------------------------------
        function ViewState(viewId, viewArgs) {
            this.type = eHistoryStateType.View;
            this.view = viewId;
            this.viewArgs = viewArgs;
        }

        ViewState.prototype = Object.create(State.prototype);
        ViewState.prototype.constructor = ViewState;

        ViewState.prototype.toString = function () {
            return "?view=" + this.view;
        };

        // -----------------------------------------

        function StartUpState(viewId, viewArgs) {
            this.type = 'startup';
            this.view = viewId;
            this.viewArgs = viewArgs;
        }

        StartUpState.prototype = Object.create(ViewState.prototype);
        StartUpState.prototype.constructor = StartUpState;

        // -----------------------------------------

        function HistoryManager() {
            var onStateChanged = new TDelegate();
            var skipStartup = true;

            //-------------- History Binding -----------------------------
            var init = function () {
                if (!history.enabled) {
                    // History.js is disabled for this browser.
                    // This is because we can optionally choose to support HTML4 browsers or not.
                    return false;
                }

                history.clearQueue();

                trackHistory();

                return true;
            };

            var isValidState = function (state) {
                return general.isDefinedType(state.data.type);
            };

            var isViewState = function (state) {
                return isValidState(state) && general.isDefinedType(state.data.view);
            };

            var isPopupState = function (state) {
                return isValidState(state) && !general.isEmptyType(state.data.popupType);
            };

            var isQuestionnaireState = function (state) {
                return isValidState(state) && !general.isEmptyType(state.data.pageNumber);
            };

            var isWizardState = function (state) {
                return isValidState(state) && !general.isEmptyType(state.data.step);
            };

            var isAlertState = function (state) {
                return isPopupState(state) && state.data.popupType === ePopupType.Alert;
            };

            var isDialogState = function (state) {
                return isPopupState(state) && state.data.popupType === ePopupType.Dialog;
            };

            function isExitingFullScreen(currentState, previousState) {
                var toggleControls = eFullScreenTogleControls;

                for (var name in toggleControls) {
                    if (!toggleControls.hasOwnProperty(name)) {
                        continue;
                    }

                    var toggleControl = toggleControls[name];

                    if (toggleControl.full === previousState.data.popupId &&
                        toggleControl.default === currentState.data.popupId) {
                        return true;
                    }
                }

                return false;
            }

            function isEnteringFullScreen(currentState, previousState) {
                var toggleControls = eFullScreenTogleControls;

                for (var name in toggleControls) {
                    if (!toggleControls.hasOwnProperty(name)) {
                        continue;
                    }

                    var toggleControl = toggleControls[name];

                    if (toggleControl.full === currentState.data.popupId &&
                        (toggleControl.default === previousState.data.popupId || toggleControl.default === previousState.data.view)) {
                        return true;
                    }
                }

                return false;
            }

            var isStartUpState = function (state) {
                return isViewState(state) && state.data.type === 'startup';
            };

            var getPreviousState = function () {
                return history.getStateByIndex(history.getCurrentIndex() - 1);
            };

            function trackHistory() {
                // Bind to StateChange Event
                $(window).on('statechange', function () { // Note: We are using statechange instead of popstate
                    var currentState = history.getState();
                    var previousState = getPreviousState();

                    if (isStartUpState(currentState) && skipStartup) {
                        skipStartup = false;
                        return;
                    }

                    if (isWizardState(currentState)) {
                        onStateChanged.Invoke(new WizardState(currentState.data.view, currentState.data.step));
                    }

                    // questionnaire, and it could be inside a popup
                    if (isQuestionnaireState(currentState) || isPopupState(currentState)) {
                        onStateChanged.Invoke(new QuestionnaireState(currentState.data.pageNumber));
                    }

                    if (isExitingFullScreen(currentState, previousState)) {
                        onStateChanged.Invoke(new PopupState(eHistoryStateType.ExitFullscren, previousState.data.popupId));
                    }

                    if (isEnteringFullScreen(currentState, previousState)) {
                        onStateChanged.Invoke(new PopupState(eHistoryStateType.EnterFullscren, previousState.data.popupId));
                    }


                    if (isPopupState(currentState)) { // alerts and dialogs
                        return;
                    }

                    if (isAlertState(previousState) && currentState.navigation) {
                        onStateChanged.Invoke(new PopupState(eHistoryStateType.CloseAlert, previousState.data.popupId));
                        return;
                    }

                    if (isDialogState(previousState) && currentState.navigation) {
                        onStateChanged.Invoke(new PopupState(eHistoryStateType.CloseDialog, previousState.data.popupId));
                        return;
                    }

                    if (isViewState(currentState)) {
                        onStateChanged.Invoke(new ViewState(currentState.data.view, currentState.data.viewArgs));
                        return;
                    }

                    if (isValidState(currentState)) {
                        onStateChanged.Invoke(currentState.data);
                    } else {
                        onStateChanged.Invoke(new InvalidState());
                    }
                });
            }

            var pushViewState = function (form, args, stateChangedCallback) {
                pushState(new ViewState(form, args), stateChangedCallback);
            };

            var replaceViewState = function (form, args) {
                replaceState(new ViewState(form, args));
            };

            var pushQuestonnaireState = function (pageNumber) {
                if (pageNumber === 1) {
                    replaceState(new QuestionnaireState(pageNumber));
                } else {
                    pushState(new QuestionnaireState(pageNumber));
                }
            };

            var pushStartUpState = function (form, args, stateChangedCallback) {
                pushState(new StartUpState(form, args), stateChangedCallback);
            };

            var pushPopupState = function (type, popupId, stateChangedCallback) {
                if (type !== ePopupType.Dialog && type !== ePopupType.Alert) {
                    throw new Error("Not implemented Type: " + type);
                }

                // push state for back option
                pushState(new PopupState(type, popupId), stateChangedCallback);
            };

            var pushSubState = function (serializedState, stateChangeCallback) {
                var currentState = history.getState(),
                    subState;

                if (isQuestionnaireState(currentState)) {
                    subState = new QuestionnaireState(currentState.data.pageNumber);
                } else if (isPopupState(currentState)) {
                    subState = new PopupState(currentState.data.popupType, currentState.data.popupId);
                } else if (isViewState(currentState)) {
                    subState = new ViewState(currentState.data.view, currentState.data.viewArgs);
                }

                if (subState) {
                    subState.toString = function () {
                        return Object.getPrototypeOf(subState).toString.apply(subState, arguments) + "&" + serializedState;
                    };

                    pushState(subState, stateChangeCallback);
                }
            };

            var pushNavWizardState = function (view, step, stateChangedCallback) {
                pushState(new WizardState(view, step), stateChangedCallback);
            };

            function pushState(state, stateChangedCallback) {
                var currentState = history.getState();

                if (general.isFunctionType(stateChangedCallback)) {
                    if (general.equals(currentState.data, state)) {
                        setTimeout(stateChangedCallback);
                    } else {
                        $(window).one('statechange', stateChangedCallback);
                    }
                }

                history.pushState(state, window.document.title, state.toString());
            }

            function replaceState(state) {
                history.replaceState(state, window.document.title, state.toString());
            }

            var start = function (view, args, startCallback) {
                // jquery.history is using hashtag and not search on ie
                // refresh detection
                var state = history.getState();

                if (isViewState(state) && !isStartUpState(state) && (state.url.containsNotEmpty(window.location.search) || window.location.hash.containsNotEmpty(history.getHash()))) {
                    history.Adapter.trigger(window, 'statechange'); // when page is refresh we need to force statechange

                    if (general.isFunctionType(startCallback)) {
                        startCallback();
                    }
                } else {
                    pushViewState(view, args, startCallback);
                }
            };

            var hasAlert = function (alertType) {
                var state = history.getState();
                return isAlertState(state) && state.data.popupId === alertType;
            };

            var hasDialog = function (dialogName) {
                var state = history.getState();
                return isDialogState(state) && state.data.popupId === dialogName;
            };

            var historyGo = function (direction, callback) {
                if (general.isFunctionType(callback)) {
                    $(window).one('statechange', function () {
                        callback();
                    });
                }

                history.go(direction);
            };

            var goBack = function (callback) {
                historyGo(-1, callback);
            };

            var goForward = function (callback) {
                historyGo(1, callback);
            };

            return {
                Start: start,
                Init: init,

                Back: goBack,
                Forward: goForward,
                GetCurrentState: history.getState,

                PushSubState: pushSubState,

                PushViewState: pushViewState,
                ReplaceViewState: replaceViewState,
                PushPopupState: pushPopupState,
                PushStartUpState: pushStartUpState,
                PushQuestionnaireState: pushQuestonnaireState,
                PushWizardState: pushNavWizardState,

                HasAlert: hasAlert,
                HasDialog: hasDialog,

                OnStateChanged: onStateChanged
            };
        }

        var module = window.HistoryManager = new HistoryManager();

        return module;
    }
);

define(
    'managers/PopUpManager',
    [
        'require',
        'handlers/general',
        'viewmodels/dialogs/DialogViewModel'
    ],
    function PopUpManagerDef(require) {
        var general = require('handlers/general'),
            DialogViewModel = require('viewmodels/dialogs/DialogViewModel');

        var PopUpManager = function PopUpManagerClass() {
            function openAsPopup(viewType, args) {
                if (viewType != eViewTypes.vClientQuestionnaire) {
                    return;
                }

                var options = {
                    title: args.title,
                    modal: true,
                    draggable: true,
                    resizable: false,
                    width: 950,
                    persistent: false,
                    dialogClass: 'fx-dialog'
                };

                general.extendType(options, args);

                if (general.isDefinedType(DialogViewModel)) {
                    DialogViewModel.openAsync(eAppEvents.cddStatusLoadedEvent, eDialog.ClientQuestionnaire, options, eViewTypes.vClientQuestionnaire);
                }
                else {
                    AlertsManager.UpdateAlert(AlertTypes.PopupClientQuestionnaire, null, null, null);
                    AlertsManager.PopAlert(AlertTypes.PopupClientQuestionnaire);
                }
            }

            function closePopup() {
                if (general.isDefinedType(window.DialogViewModel)) {
                    window.DialogViewModel.close();
                    return;
                }

                if (AlertsManager.GetAlert(AlertTypes.PopupClientQuestionnaire).visible()) {
                    AlertsManager.GetAlert(AlertTypes.PopupClientQuestionnaire).visible(false);
                    return;
                }
            }

            function isPopupOpen() {
                if (general.isDefinedType(DialogViewModel)) {
                    return DialogViewModel.isOpen();
                } else {
                    return (AlertsManager.HasAlert());
                }
            }

            return {
                OpenAsPopup: openAsPopup,
                ClosePopup: closePopup,
                IsPopupOpen: isPopupOpen
            };
        };

        var module = window.PopUpManager = new PopUpManager();
        return module;
    }
);
/* global General */
var AmlPopupManager = (function (amlPopupManager) {
    function showAmlPopup() {
        var option = {
            title: Dictionary.GetItem('AMLStatus','dialogsTitles',' '),
            closeOnEscape: false,
            dialogClass: 'fx-dialog amlPopup',
            width: 620
        };

        if (General.isDefinedType(DialogViewModel)) {
            DialogViewModel.openAsync(eAppEvents.amlStatusLoadedEvent, eDialog.AmlStatus, option, eViewTypes.vAmlStatus, null);
        }
    }

    function showAmlView() {
        $viewModelsManager.VManager.SwitchViewVisible(eForms.Aml, {});
    }
        
    function showAmlWindow() {
        (new PopupInSameWindowForSC()).Navigate({
            ActionUrl: '/webpl3/Compliance/AmlStatusWrapper'
        });

        window.external.ResizeHostForm(651, 588);
    }

    amlPopupManager.show = function () {
        switch(InitConfiguration.ApplicationConfiguration.applicationType) {
            case window.eApplicationTypes.Web:
                showAmlPopup();
                break;

            case window.eApplicationTypes.Mobile:
                showAmlView();
                break;

            default:
                showAmlWindow();
                break;
        }
    };

    return amlPopupManager;
}(window.AmlPopupManager || {}));
define("managers/AmlPopupManager", function(){});

define('payments/ComplianceBeforeDeposit', [
    'require',
    'knockout',
    'devicemanagers/StatesManager',
    'managers/PopUpManager',
    'managers/AmlPopupManager',
    'devicemanagers/AlertsManager',
    'dataaccess/dalCompliance',
    'Dictionary',
], function ComplianceBeforeDeposit(require) {
    var ko = require('knockout'),
        StatesManager = require('devicemanagers/StatesManager'),
        PopUpManager = require('managers/PopUpManager'),
        AlertsManager = require('devicemanagers/AlertsManager'),//not loaded yet, use global AlertsManager
        AmlPopupManager = require('managers/AmlPopupManager'),
        dalCompliance = require('dataaccess/dalCompliance'),
        Dictionary = require('Dictionary');

    var title = Dictionary.GetItem('ClientQuestionnaireTitle');

    function isKycStatusFailCannotDeposit() {
        return (
            StatesManager.States.KycStatus() === eKYCStatus.Failed &&
            StatesManager.States.KycReviewStatus() === eKYCReviewStatus.Appropriate
        );
    }

    function showKycWarningAlert() {
        var questionnaireAlertManager = AlertsManager.GetAlert(AlertTypes.ClientQuestionnaire);

        questionnaireAlertManager.popAlert().done();
    }

    function isCddBeforeDeposit() {
        return (
            Dictionary.GetItem('preDepositRequired', 'application_configuration', '0') === '1' &&
            (
                StatesManager.States.IsCddStatusNotComplete() ||
                StatesManager.States.IsKycStatusRequired() ||
                StatesManager.States.IsKycReviewStatusRequired()
            )
        );
    }

    function isMoveToCddFullNoPopupBeforeDeposit() {
        return (
            Dictionary.GetItem('showCompliancePageBeforeDeposit', 'application_configuration', '0') === '1' &&
            (
                StatesManager.States.IsCddStatusNotComplete() ||
                StatesManager.States.IsKycStatusRequired() ||
                StatesManager.States.IsKycReviewStatusRequired()
            )
        );
    }

    function showMifidPopupBeforeDeposit() {
        if (Dictionary.GetItem('showCompliancePageBeforeDeposit', 'application_configuration', '0') !== '1') {
            return false;
        }

        var mifidAlertManager = AlertsManager.GetAlert(AlertTypes.ClientKnowledgeQuestionnaire);

        var knowledgeAlertType;

        switch (StatesManager.States.KycReviewStatus()) {
            case eKYCReviewStatus.Review:
                knowledgeAlertType = KnowledgeAlertTypes.Review;
                break;

            case eKYCReviewStatus.Tested:
                knowledgeAlertType = KnowledgeAlertTypes.Tested;
                break;

            case eKYCReviewStatus.Inappropriate:
                knowledgeAlertType = KnowledgeAlertTypes.Inappropriate;
                break;

            case eKYCReviewStatus.Unsuitable:
                knowledgeAlertType = KnowledgeAlertTypes.Unsuitable;
                break;

            default:
                knowledgeAlertType = null;
                break;
        }

        if (knowledgeAlertType !== null) {
            mifidAlertManager.popAlert(function () {
                return true;
            }, knowledgeAlertType);

            return true;
        }

        return false;
    }

    function openCdd(getRequestData, depositCallback) {
        dalCompliance.logUserShouldCompleteCdd(getRequestData);
        PopUpManager.OpenAsPopup(eViewTypes.vClientQuestionnaire, {
            dialogClass: 'deal-slip PopupClientQuestionnaire',
            title: title,
        });

        var sub = ko.postbox.subscribe('thankyou-continue-clicked', function onThankYouContinueClicked() {
            depositCallback();
            sub.dispose();
        });
    }

    function isAmlRestricted() {
        return StatesManager.States.AmlStatus() === eAMLStatus.Restricted;
    }

    function showAmlPopup() {
        AmlPopupManager.show();
    }

    return {
        isCddBeforeDeposit: isCddBeforeDeposit,
        showMifidPopupBeforeDeposit: showMifidPopupBeforeDeposit,
        isMoveToCddFullNoPopupBeforeDeposit: isMoveToCddFullNoPopupBeforeDeposit,
        openCdd: openCdd,
        isKycStatusFailCannotDeposit: isKycStatusFailCannotDeposit,
        showKycWarningAlert: showKycWarningAlert,
        isAmlRestricted: isAmlRestricted,
        showAmlPopup: showAmlPopup,
    };
});

define(
    'managers/ViewsRouterManager',
    [
        "require",
        'payments/ComplianceBeforeDeposit',
        "initdatamanagers/Customer"
    ],
    function ViewsRouterManager(require) {
        var ComplianceBeforeDeposit = require('payments/ComplianceBeforeDeposit'),
            Customer = require("initdatamanagers/Customer");

        var getFormToRedirect = function (formId, viewArgs) {

            var redirectToFormType = formId;

            switch (formId) {
                case eForms.Deposit:
                    // is regulated 

                    if (ComplianceBeforeDeposit.showMifidPopupBeforeDeposit() ||
                        ComplianceBeforeDeposit.isMoveToCddFullNoPopupBeforeDeposit()) {
                        redirectToFormType = eForms.ClientQuestionnaire;
                        viewArgs = { from: { form: eForms.Deposit, viewArgs: viewArgs } };
                        break;
                    }

                    redirectToFormType = eForms.Deposit;
                    break;

                case eForms.UploadDocuments:
                    if (Customer.prop.isDemo) {
                        redirectToFormType = Customer.prop.mainPage;
                    }
                    break;
            }

            return { viewType: redirectToFormType, viewArgs: viewArgs };
        };

        return {
            GetFormToRedirect: getFormToRedirect
        };
    }
);
define(
    'deepLinks/DeepLinkParameterValidator',
    [
        'require',
        'handlers/general',
        'initdatamanagers/InstrumentsManager',
        'managers/viewsmanager',
        'customEnums/ViewsEnums',
        'enums/enums',
    ],
    function DeepLinkParameterValidator(require) {
        var instrumentsManager = require('initdatamanagers/InstrumentsManager'),
            general = require('handlers/general'),
            validators = [];

        //------------------------------------------
        validators[eDeepLinkParameterType.LoginOption] = function (option) {
            return !general.isEmptyType(option);
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.Instrument] = function (instrumentId) {
            var instrumentIdValue = parseInt(instrumentId);

            return !isNaN(instrumentIdValue) &&
                instrumentsManager.GetInstrument(instrumentIdValue);
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.OrderDir] = function (orderDir) {
            return !general.isEmptyType(eOrderDir[orderDir]);
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.Integer] = function (intValue) {
            return !general.isEmptyType(intValue) && !isNaN(parseInt(intValue));
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.Tab] = function (tabName) {
            var caseInsensitivePattern = new RegExp(tabName, "i");

            for (var key in eNewDealTool) {
                if (!eNewDealTool.hasOwnProperty(key)) {
                    continue;
                }

                if (key.match(caseInsensitivePattern) !== null) {
                    return true;
                }
            }

            return false;
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.Form] = function (requestFormName, mappingParameter) {
            if (general.isEmptyType(requestFormName) || general.isEmptyType(eForms[requestFormName])) {
                return false;
            }

            if (mappingParameter.AllowOnlyFormsContainingView) {
                var requiredView = mappingParameter.AllowOnlyFormsContainingView,
                    mappedFormId = eForms[requestFormName],
                    viewsManager = require('managers/viewsmanager');

                return viewsManager.GetFormProperties(mappedFormId).mappedViews.indexOf(requiredView) > -1;
            }

            return true;
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.SettingsView] = function (viewName) {
            var caseInsensitivePattern = new RegExp(viewName, "i");

            for (var key in eSettingsViews) {
                if (!eSettingsViews.hasOwnProperty(key)) {
                    continue;
                }

                if (key.match(caseInsensitivePattern) !== null) {
                    return true;
                }
            }

            return false;
        };

        //------------------------------------------
        validators[eDeepLinkParameterType.String] = function (stringValue) {
            return general.isStringType(stringValue);
        };

        //------------------------------------------
        function isValid(mappingParameter, requestParameterValue) {
            return validators[mappingParameter.Type](requestParameterValue, mappingParameter);
        }

        return {
            IsValid: isValid
        };
    }
);
define(
    'deepLinks/DeepLinkParameterConverter',
    [
        'customEnums/ViewsEnums',
        'enums/enums',
    ],
    function DeepLinkParameterConverter() {
        var converters = [],
            matchPlusRegex = /\+/g;

        //------------------------------------------
        converters[eDeepLinkParameterType.LoginOption] = function (loginOption) {
            return loginOption;
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.Instrument] = function (instrumentId) {
            return parseInt(instrumentId);
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.OrderDir] = function (orderDir) {
            return eOrderDir[orderDir];
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.Integer] = function (intValue) {
            return parseInt(intValue);
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.Tab] = function (tabName) {
            var caseInsensitivePattern = new RegExp(tabName, "i");

            for (var key in eNewDealTool) {
                if (!eNewDealTool.hasOwnProperty(key)) {
                    continue;
                }

                if (key.match(caseInsensitivePattern) !== null) {
                    return eNewDealTool[key];
                }
            }

            return null;
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.Form] = function (formName) {
            return eForms[formName];
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.SettingsView] = function (viewName) {
            var caseInsensitivePattern = new RegExp(viewName, "i");

            for (var key in eSettingsViews) {
                if (!eSettingsViews.hasOwnProperty(key)) {
                    continue;
                }

                if (key.match(caseInsensitivePattern) !== null) {
                    return eSettingsViews[key];
                }
            }

            return null;
        };

        //------------------------------------------
        converters[eDeepLinkParameterType.String] = function (stringValue) {
            var returnStringValue = stringValue.replace(matchPlusRegex, ' ')
            return returnStringValue;
        }

        //------------------------------------------
        function convert(mappingParameter, parameterValue) {
            return converters[mappingParameter.Type](parameterValue);
        }

        return {
            Convert: convert
        };
    }
);
define(
    'generalmanagers/locationWrapper',
    [],
    function () {
        return {
            GetRootUrl: function GetRootUrl() {
                var rootUrl = document.location.protocol + '//' + (document.location.hostname || document.location.host);

                if (document.location.port || false) {
                    rootUrl += ':' + document.location.port;
                }

                return rootUrl;
            },
            GetAbsoluteLocation: function GetAbsoluteLocation() {
                return window.location.href;
            },
            GetQueryString: function GetQueryString() {
                return window.location.search;
            },
            SetAbsoluteLocation: function SetAbsoluteLocation(url) {
                window.location.href = url;
            }
        }
    }
);

define(
    'customEnums/routes',
    [
        'handlers/general',
        'customEnums/ViewsEnums',
        'enums/enums'
    ],
    function (general) {
        return {
            LoginOptions: {
                Form: {
                    Value: eForms.Deals
                }
            },
            Deals: {
                Form: {
                    Value: eForms.Deals
                }
            },
            OpenDeals: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Deals
                },
                Parameters: {
                    selectedTab: {
                        Value: eViewTypes.vOpenDeals
                    }
                }
            },
            Limits: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Deals
                },
                Parameters: {
                    selectedTab: {
                        Value: eViewTypes.vLimits
                    }
                }
            },
            ClosedDeals: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Deals
                },
                Parameters: {
                    selectedTab: {
                        Value: eViewTypes.vClosedDeals
                    }
                }
            },
            Questionnaire: {
                Form: {
                    Value: eForms.ClientQuestionnaire
                }
            },
            ClientQuestionnaire: {
                Form: {
                    Value: eForms.ClientQuestionnaire
                }
            },
            Wallet: {
                Form: {
                    Value: eForms.Deals
                },
                Actions: ['devicecustomdeeplinks/AccountSummaryAdvancedViewActionHandler']
            },
            NewDeal: {
                Form: {
                    DefaultValue: eForms.Deals,
                    ValueFromRequest: true,
                    AllowOnlyFormsContainingView: eViewTypes.vToolBar,
                    Type: eDeepLinkParameterType.Form
                },
                Actions: ['devicecustomdeeplinks/NewDealActionHandler'],
                Parameters: {
                    instrumentId: {
                        ValueFromRequest: true,
                        DefaultValue: 3631,
                        Type: eDeepLinkParameterType.Instrument
                    },
                    tab: {
                        ValueFromRequest: true,
                        Optional: true,
                        Type: eDeepLinkParameterType.Tab
                    },
                    orderDir: {
                        ValueFromRequest: true,
                        Optional: true,
                        Type: eDeepLinkParameterType.OrderDir
                    }
                }
            },
            NewLimit: {
                Form: {
                    DefaultValue: eForms.Deals,
                    ValueFromRequest: true,
                    AllowOnlyFormsContainingView: eViewTypes.vToolBar,
                    Type: eDeepLinkParameterType.Form
                },
                Actions: ['devicecustomdeeplinks/NewLimitActionHandler'],
                Parameters: {
                    instrumentId: {
                        ValueFromRequest: true,
                        DefaultValue: 3631,
                        Type: eDeepLinkParameterType.Instrument
                    },
                    tab: {
                        ValueFromRequest: true,
                        Optional: true,
                        Type: eDeepLinkParameterType.Tab
                    },
                    orderDir: {
                        ValueFromRequest: true,
                        Optional: true,
                        Type: eDeepLinkParameterType.OrderDir
                    }
                }
            },
            Balance: {
                Form: {
                    Value: eForms.Statement
                }
            },
            NetExposure: {
                Form: {
                    Value: eForms.Deals
                },
                Actions: ['devicecustomdeeplinks/AccountSummaryAdvancedViewActionHandler', 'devicecustomdeeplinks/NetExposureActionHandler']
            },
            Withdrawal: {
                Form: {
                    Value: eForms.Withdrawal
                }
            },
            CustomizeQuotes: {
                Form: {
                    Value: eForms.Deals
                },
                Actions: ['devicecustomdeeplinks/FavoriteInstrumentsActionHandler']
            },
            Deposit: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Deposit
                },
                Actions: ['devicecustomdeeplinks/DepositActionHandler'],
                Parameters: {
                    payment: {
                        ValueFromRequest: true,
                        Optional: true,
                        Type: eDeepLinkParameterType.String
                    },
                }
            },
            ChangePassword: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Settings
                },
                Parameters: {
                    viewArgs: {
                        Value: eViewTypes.vChangePassword,
                        Type: eDeepLinkParameterType.View
                    }
                },
                Actions: ['deepLinks/SettingsActionHandler']
            },
            PendingWithdrawal: {
                Form: {
                    Value: eForms.PendingWithdrawal
                }
            },
            UploadDocuments: {
                Form: {
                    Value: eForms.UploadDocuments
                }
            },
            TradingSignals: {
                Form: {
                    Value: eForms.TradingSignals
                }
            },
            EconomicCalendar: {
                Form: {
                    Value: eForms.Deals
                },
                Actions: ['devicecustomdeeplinks/NewDealActionHandler'],
                Parameters: {
                    tab: {
                        Value: eNewDealTool.EconomicCalendar
                    }
                }
            },
            CashBack: {
                Form: {
                    Value: eForms.Deals
                },
                Actions: ['devicecustomdeeplinks/AccountSummaryAdvancedViewActionHandler', 'devicecustomdeeplinks/CashBackActionHandler']
            },
            Settings: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Settings
                },
                Parameters: {
                    view: {
                        ValueFromRequest: true,
                        Type: eDeepLinkParameterType.SettingsView
                    }
                },
                Actions: ['deepLinks/SettingsActionHandler']
            },
            NotificationsSettings: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Settings
                },
                Parameters: {
                    view: {
                        DefaultValue: eSettingsViews.NotificationsSettings,
                        ValueFromRequest: true,
                        Type: eDeepLinkParameterType.SettingsView
                    }
                },
                Actions: ['deepLinks/SettingsActionHandler']
            },
            PersonalInformation: {
                PassParametersToViews: true,
                Form: {
                    Value: eForms.Settings
                },
                Parameters: {
                    view: {
                        DefaultValue: eSettingsViews.PersonalInformation,
                        ValueFromRequest: true,
                        Type: eDeepLinkParameterType.SettingsView
                    }
                },
                Actions: ['deepLinks/SettingsActionHandler']
            },
            DepositConfirmation: {
                Form: {
                    Value: eForms.UploadDocuments
                },
                Actions: ['devicecustomdeeplinks/DepositConfirmationActionHandler']
            },
            Tutorials: {
                Form: {
                    Value: eForms.Tutorials
                }
            },
            EducationalTutorials: {
                Form: {
                    Value: eForms.EducationalTutorials
                }
            }
        };
    }
);
define("deepLinks/DeepLinkHandler", [
	"require",
	"knockout",
	"Q",
	"handlers/general",
	"deepLinks/DeepLinkParameterValidator",
	"deepLinks/DeepLinkParameterConverter",
	"global/UrlResolver",
	"generalmanagers/ErrorManager",
	"modules/permissionsmodule",
	"fxnet/fxnet",
	"generalmanagers/locationWrapper",
	"customEnums/routes",
], function DeepLinkHandler(require) {
	var urlResolver = require("global/UrlResolver"),
		ko = require("knockout"),
		q = require("Q"),
		general = require("handlers/general"),
		deepLinkParameterValidator = require("deepLinks/DeepLinkParameterValidator"),
		deepLinkParameterConverter = require("deepLinks/DeepLinkParameterConverter"),
		errorManager = require("generalmanagers/ErrorManager"),
		permissionsModule = require("modules/permissionsmodule"),
		locationWrapper = require("generalmanagers/locationWrapper"),
		eFormsDeepLinkMap = require("customEnums/routes"),
		regirectPattern = new RegExp("(.*)/" + urlResolver.getRedirectPath() + "/(.*)", "i");

	return function DeepLinkHandlerImplementation() {
		var isDeepLinkRedirect = false,
			processActionsDefer = q.defer(),
			redirectResult = null,
			params = null,
			actions = null,
			_deepLinkLogName = "";

		//------------------------------------------
		function resetRedirectProperties(startUpForm, args) {
			isDeepLinkRedirect = false;
			redirectResult = { startUpForm: startUpForm, args: args, isDeepLink: false, mode: null };
		}

		//------------------------------------------
		function initializeRedirectProperties() {
			resetRedirectProperties(null, null);
		}

		//------------------------------------------
		function getParameterValue(mappingParameter, requestParameter) {
			if (!mappingParameter.ValueFromRequest) {
				return mappingParameter.Value;
			}

			if (
				!general.isEmptyType(requestParameter) &&
				deepLinkParameterValidator.IsValid(mappingParameter, requestParameter)
			) {
				return deepLinkParameterConverter.Convert(mappingParameter, requestParameter);
			}

			if (mappingParameter.Optional) {
				return null;
			}

			return mappingParameter.DefaultValue;
		}

		//------------------------------------------
		function parseParams(mappingParams, deepLinkParams) {
			params = {};

			if (general.isEmptyType(mappingParams)) {
				return;
			}

			for (var param in mappingParams) {
				if (!mappingParams.hasOwnProperty(param)) {
					continue;
				}

				var paramValue = getParameterValue(mappingParams[param], getValueFromObject(deepLinkParams, param));

				if (general.isEmptyType(paramValue)) {
					continue;
				}

				params[param] = paramValue;
			}
		}

		//------------------------------------------
		function getValueFromObject(obj, propertyName) {
			if (!obj || !propertyName) {
				return null;
			}

			var key = Object.keys(obj).find(function (property) {
				return property.toLowerCase() === propertyName.toLowerCase();
			});

			if (!key) {
				return null;
			}

			return obj[key];
		}

		//------------------------------------------
		function isDeepLinkDataValid(deepLinkData) {
			return (
				!general.isEmptyType(deepLinkData) &&
				!general.isNullOrUndefined(getValueFromObject(eFormsDeepLinkMap, deepLinkData.Name))
			);
		}

		//------------------------------------------
		function setRedirectData(mapping, deepLinkData) {
			isDeepLinkRedirect = true;

			redirectResult.startUpForm = getParameterValue(mapping.Form, getValueFromObject(deepLinkData, "Form"));
			redirectResult.args = mapping.PassParametersToViews === true ? params : {};
			redirectResult.isDeepLink = true;
			redirectResult.mode = deepLinkData.mode;
		}

		//------------------------------------------
		function parseRedirectUrl(url) {
			var redirectMatch = url.match(regirectPattern);

			if (!redirectMatch || redirectMatch.length != 3) {
				return null;
			}

			url = redirectMatch[1] + "?Name=" + redirectMatch[2].replace("?", "&");

			return general.urlDecode(url);
		}

		//------------------------------------------
		function getDeepLinkDataFromUrl(url) {
			var urlProcessors = [general.urlDecode, parseRedirectUrl];

			for (var i = 0; i < urlProcessors.length; i++) {
				var deepLinkData = urlProcessors[i](url);

				if (isDeepLinkDataValid(deepLinkData)) {
					return deepLinkData;
				}
			}

			return null;
		}

		//------------------------------------------
		function processDeepLinkData(url) {
			var deepLinkData = getDeepLinkDataFromUrl(url);

			if (!deepLinkData) {
				return;
			}

			_deepLinkLogName = deepLinkData.Name;
			var mapping = getValueFromObject(eFormsDeepLinkMap, deepLinkData.Name);

			if (!mapping) {
				return;
			}

			if (!permissionsModule.CheckFormPermissions(mapping.Form.Value || mapping.Form.DefaultValue, true)) {
				return;
			}

			actions = mapping.Actions;
			parseParams(mapping.Parameters, deepLinkData);

			setRedirectData(mapping, deepLinkData);
		}

		//------------------------------------------
		function processActions() {
			if (!actions) {
				return;
			}

			var fxNet = require("fxnet/fxnet");

			q.when(fxNet.UiRenderedPromise)
				.then(function () {
					require(actions, function processResolvedActions() {
						var handlers = actions.map(function getHandler(handlerName) {
							var handler = require(handlerName);

							if (handler && handler.HandleDeepLink) {
								return q.fcall(handler.HandleDeepLink, params);
							}

							errorManager.onWarning(
								"DeepLinkHandler:processActions",
								"HandleDeepLink name:" + _deepLinkLogName + " params:" + JSON.stringify(params)
							);
							return null;
						});

						q.all(handlers)
							.then(function resolveProcessActionsPromise() {
								processActionsDefer.resolve();
							})
							.done();
					});
				})
				.done();
		}

		//------------------------------------------
		function shouldRedirect() {
			return isDeepLinkRedirect === true;
		}

		//------------------------------------------
		function init() {
			initializeRedirectProperties();

			var url = locationWrapper.GetAbsoluteLocation();

			processDeepLinkData(url);
			publishEvent(url);
		}

		function publishEvent(url) {
			var deepLinkData = getDeepLinkDataFromUrl(url);

			if (general.isNullOrUndefined(deepLinkData)) {
				return;
			}

			var eventData = {};

			if (!general.isNullOrUndefined(deepLinkData.evt)) {
				eventData.evt = deepLinkData.evt;
			}

			if (!general.isNullOrUndefined(deepLinkData.dcid)) {
				eventData.dcid = deepLinkData.dcid;
			}

			if (!general.isNullOrUndefined(eventData.evt) || !general.isNullOrUndefined(eventData.dcid)) {
				ko.postbox.publish("redirect-link-tracking", eventData);
			}
		}

		//------------------------------------------
		function handle(startUpForm, args) {
			if (!shouldRedirect()) {
				resetRedirectProperties(startUpForm, args);

				return Object.assign(
					{
						processActions: general.emptyFn,
					},
					redirectResult
				);
			}

			isDeepLinkRedirect = false;

			return Object.assign(
				{
					processActions: processActions,
				},
				redirectResult
			);
		}

		//------------------------------------------
		function internalRedirect(url) {
			processDeepLinkData(url);

			if (!shouldRedirect()) {
				resetRedirectProperties(null, null);

				return Object.assign(
					{
						processActions: general.emptyFn,
					},
					redirectResult
				);
			}

			isDeepLinkRedirect = false;

			return Object.assign(
				{
					processActions: processActions,
				},
				redirectResult
			);
		}

		return {
			Init: init,
			InternalRedirect: internalRedirect,
			Handle: handle,
			ProcessActionsCompleted: processActionsDefer.promise,
		};
	};
});

define(
    'managers/viewsmanager',
    [
        "require",
        "jquery",
        "knockout",
        'handlers/general',
        'configuration/Containers',
        'managers/historymanager',
        "initdatamanagers/Customer",
        'managers/CustomerProfileManager',
        'managers/ViewsRouterManager',
        'modules/permissionsmodule',
        'deepLinks/DeepLinkHandler',
        "StateObject!ViewsManager",
        'devicemanagers/AlertsManager'
    ],
    function ViewsManager(require) {
        var ko = require("knockout"),
            general = require('handlers/general'),
            $ = require("jquery"),
            Containers = require('configuration/Containers'),
            HistoryManager = require('managers/historymanager'),
            Customer = require("initdatamanagers/Customer"),
            CustomerProfileManager = require('managers/CustomerProfileManager'),
            ViewsRouterManager = require('managers/ViewsRouterManager'),
            permissionsModule = require('modules/permissionsmodule'),
            DeepLinkHandler = require('deepLinks/DeepLinkHandler'),
            StateObject = require("StateObject!ViewsManager"),
            AlertsManager = require('devicemanagers/AlertsManager');

        var forms = {},
            activeForm = new Form(),
            onActiveFormChanged = new TDelegate(),
            activeFormType = ko.observable(),
            activeFormName = ko.pureComputed(computeActiveFormName),
            deepLinkHandler = new DeepLinkHandler();

        //------------------------------------------------

        function computeActiveFormName() {
            for (var item in eForms) {
                if (!eForms.hasOwnProperty(item)) {
                    continue;
                }

                if (eForms[item] === activeFormType()) {
                    return item.toLowerCase();
                }
            }

            return '';
        }

        //-------------- View Properties -----------------

        function View(viewState) {
            var self = this;

            self.state = ko.observable(viewState);
            self.previousState = ko.observable();

            self.visible = ko.computed(function () {
                if (this.state() === eViewState.Stop)
                    return false;
                else
                    return true;
            }, self);

            this.args = {};
        }

        //-------------- Form Properties -----------------

        function Form() {
            this.viewsList = {};
            this.isReset = ko.observable(false).extend({ notify: 'always' });
            this.args = {};
            this.historicalData = false;
        }

        Form.prototype.SetViews = function setViews(formviews) {
            for (var key in eViewTypes) {
                if (eViewTypes.hasOwnProperty(key)) {
                    if (formviews && formviews.contains(eViewTypes[key])) {
                        //define each form with its dependent view list which is subscribed to the visibility change of the form
                        this.viewsList[eViewTypes[key]] = new View(eViewState.Start);
                    } else {
                        //don't define a subscriber because these views never change
                        this.viewsList[eViewTypes[key]] = new View(eViewState.Stop);
                    }
                }
            }
        };

        Form.prototype.Reset = function reset() {
            this.isReset(true);
        };

        Form.prototype.IsHistoricalData = function isHistoricalData(hData) {
            if (general.isBooleanType(hData)) {
                this.historicalData = hData;
            }

            return this.historicalData;
        };

        //-------------- Init ----------------------------

        var init = function (uiVersion) {
            Containers.Init(uiVersion);

            setFormCollection();

            HistoryManager.Init();
            HistoryManager.OnStateChanged.Add(function (state) {
                switch (state.type) {
                    case eHistoryStateType.View:
                        switchActive(state.view, state.viewArgs);
                        break;

                    case eHistoryStateType.Invalid:
                        switchViewVisible(
                            Customer.prop.startUpForm,
                            {},
                            function showExitAlert() {
                                if (!(permissionsModule.CheckPermissions("commonLogout"))) {
                                    return;
                                }
                                AlertsManager.UpdateAlert(AlertTypes.ExitAlert);
                                AlertsManager.PopAlert(AlertTypes.ExitAlert);
                            }
                        );

                        break;

                    case eHistoryStateType.CloseAlert:
                        var alertToClose = AlertsManager.GetAlert(state.popupId);
                        if (alertToClose && alertToClose.visible()) {
                            alertToClose.hide();
                        }
                        break;
                }
            });

            AlertsManager.OnShowAlert.Add(function (alertType, alertInstance) {
                var subscriber = alertInstance.visible.subscribe(function (isVisible) {
                    if (!isVisible) {
                        subscriber.dispose();

                        if (HistoryManager.HasAlert(alertType)) {
                            HistoryManager.Back(alertInstance.overwriteNavFlow ? alertInstance.properties.okButtonCallback :general.emptyFn);
                        }
                    }
                });

                if (alertInstance.properties.backFormTarget) {
                    HistoryManager.ReplaceViewState(alertInstance.properties.backFormTarget);
                }

                // push state for back option
                HistoryManager.PushPopupState(ePopupType.Alert, alertType);
            });

            activeFormType.subscribe(function (formId) {
                onActiveFormChanged.Invoke(formId);
            });

            deepLinkHandler.Init();
        };

        var setFormCollection = function () {
            for (var key in eForms) {
                if (eForms.hasOwnProperty(key)) {
                    forms[eForms[key]] = new Form();
                    forms[eForms[key]].SetViews(Containers.Forms.Container[eForms[key]].mappedViews);
                }
            }

            activeForm.SetViews();
        };

        var start = function (startUpForm) {
            var args = getForm(startUpForm).args || {};
            var redirectResult = deepLinkHandler.Handle(startUpForm, args);

            if (redirectResult.isDeepLink) {
                if (redirectResult.startUpForm != startUpForm) {
                    HistoryManager.PushStartUpState(startUpForm, args);
                }

                HistoryManager.Start(redirectResult.startUpForm, redirectResult.args, function () {
                    redirectResult.processActions();
                });
            } else {
                HistoryManager.Start(startUpForm, args);
            }

            ko.postbox.publish('main-page-load');
        };

        //-------------- private helper Methods -----------------------------
        var getActiveViews = function () {
            var state,
                activeViews = [];

            for (var view in eViewTypes) {
                if (eViewTypes.hasOwnProperty(view)) {
                    state = getViewState(eViewTypes[view]);

                    if (state !== eViewState.Stop) {
                        activeViews.push(view);
                    }
                }
            }

            return activeViews;
        };

        var switchActive = function (formId, formArgs) {
            if (!(permissionsModule.CheckFormPermissions(formId, true, formArgs))) {
                return;
            }

            saveToCustomerProfile(formId);

            $(document).trigger(eAppEvents.formChangeEvent);
            ko.postbox.publish('active-view', formId);

            activeFormType(formId);
            activeForm.type = formId;
            activeForm.args = formArgs;
            activeForm.IsHistoricalData((Containers.Forms.Container[formId].exportSupport && Containers.Forms.Container[formId].exportSupport.historicalData) || false);

            var viewsList = forms[formId].viewsList;

            for (var key in viewsList) {
                if (viewsList.hasOwnProperty(key)) {
                    if (viewsList[key].state() === eViewState.Start ||
                        activeForm.viewsList[key].state() !== viewsList[key].state() &&
                        (!Containers.IndependentViews || !Containers.IndependentViews.contains(key))) {
                        activeForm.viewsList[key].args = formArgs;
                        activeForm.viewsList[key].previousState(activeForm.viewsList[key].state());
                        activeForm.viewsList[key].state(viewsList[key].state());
                    }
                }
            }

            // refresh 
            activeForm.Reset();

            StateObject.update("ActiveViews", getActiveViews());
        };

        var getForm = function (form) {
            return forms[form];
        };

        //-------------- public Methods -----------------------------

        var getActiveFormView = function (view) {
            return activeForm.viewsList[view];
        };

        var getViewArgs = function (viewType) {
            var view = activeForm.viewsList[viewType];

            if (!view) {
                return;
            }

            var viewArgs = view.args || {};

            return viewArgs;
        };

        var getViewArgsByKeyName = function (viewType, key, defaultValue) {
            if (activeForm.viewsList[viewType].args && !general.isEmptyValue(activeForm.viewsList[viewType].args[key]))
                return activeForm.viewsList[viewType].args[key];
            else
                return defaultValue;
        };

        var refresh = function () {
            //activeForm[eViewTypes.vToolBar] && activeForm[eViewTypes.vToolBar].state(eViewState.Refresh)
            for (var property in activeForm.viewsList) {
                if (activeForm.viewsList.hasOwnProperty(property)) {
                    if (activeForm.viewsList[property].visible()) {
                        activeForm.viewsList[property].state(eViewState.Refresh);
                    }
                }
            }
        };

        var reload = function (formId) {
            if (!general.isDefinedType(formId)) {
                formId = activeForm.type;
            }
            window.location = window.location.pathname + "?view=" + formId;
        };

        var goBack = function (callback) {
            HistoryManager.Back(callback);
        };

        var goForward = function (callback) {
            HistoryManager.Forward(callback);
        };

        var getActiveForm = function () {
            return activeForm;
        };

        var changeState = function (view, state, args) {
            if (view) {
                activeForm.viewsList[view].previousState(activeForm.viewsList[view].state());

                if (state == eViewState.Stop)
                    activeForm.viewsList[view].args = '';
                else
                    activeForm.viewsList[view].args = args;

                if (activeForm.viewsList[view].previousState() === state && activeForm.viewsList[view].state() === eViewState.Update) {
                    activeForm.viewsList[view].state(-1);
                }

                activeForm.viewsList[view].state(state);
            }

            StateObject.set("ActiveViews", getActiveViews());
        };

        var getViewState = function (view) {
            if (view) {
                return activeForm.viewsList[view].state();
            }
        };

        var switchViewVisible = function (formId, viewArgs, switchCompleted) {
            if (!(permissionsModule.CheckFormPermissions(formId, true, viewArgs))) {
                return;
            }
            var redirectObj = ViewsRouterManager.GetFormToRedirect(formId, viewArgs);

            setTimeout(function (historyManager, form, args, callback) {
                historyManager.PushViewState(form, args, callback);
            }, 0, HistoryManager, redirectObj.viewType, redirectObj.viewArgs, switchCompleted);
        };

        var saveToCustomerProfile = function (formId) {
            var defaultForm = formId == eForms.Deals ? formId : Customer.prop.mainPage;
            CustomerProfileManager.DefaultPage(defaultForm);
        };

        var redirectToURL = function (url) {
            var redirectResult = deepLinkHandler.InternalRedirect(url);
            var formId = redirectResult.startUpForm;
            var args = redirectResult.args || {};

            if (redirectResult.isDeepLink) {

                if (isSwitchToRealNeeded(formId, redirectResult.mode) || isSwitchToDemoNeeded(redirectResult.mode)) {
                    window.location.replace(url);
                    return;
                }//else

                redirectToForm(formId, args, function () {
                    redirectResult.processActions();
                });
            } else {
                redirectToForm(Customer.prop.mainPage, {});
            }
        };

        var isSwitchToDemoNeeded = function (targetAccountMode) {
            return Customer.prop.isDemo === false && targetAccountMode === eAccountMode.Demo;
        };

        var isSwitchToRealNeeded = function (formId, targetAccountMode, viewArgs) {
            return Customer.prop.isDemo === true && (
                targetAccountMode === eAccountMode.Real ||
                formId === eForms.Deposit ||
                formId === eForms.Withdrawal ||
                formId === eForms.UploadDocuments ||
                (!general.isNullOrUndefined(eForms.ChangePassword) && formId === eForms.ChangePassword) ||
                formId === eForms.ClientQuestionnaire ||
                formId === eForms.NotificationsSettings ||
                formId === eForms.Settings && (viewArgs === eViewTypes.vChangePassword || viewArgs === eViewTypes.vNotificationsSettings));
        };

        var isWizardView = function (viewArgs) {
            return viewArgs && viewArgs.hasOwnProperty('step') && !general.isEmptyValue(viewArgs.step);
        };

        var switchToWizardView = function (formId, viewArgs, switchCompleted) {
            if (!(permissionsModule.CheckFormPermissions(formId, true, viewArgs))) {
                return;
            }
            var redirectObj = ViewsRouterManager.GetFormToRedirect(formId, viewArgs);

            setTimeout(function (historyManager, form, args, callback) {
                historyManager.PushWizardState(form, args.step, callback);
            }, 0, HistoryManager, redirectObj.viewType, redirectObj.viewArgs, switchCompleted);
        };

        var redirectToForm = function (viewType, viewArgs, callback) {
            // need to switch mode from demo to real
            if (isSwitchToRealNeeded(viewType, null ,viewArgs)) {
                if (!(permissionsModule.CheckFormPermissions(viewType, true, viewArgs))) {
                    return;
                }

                var redirectPageName = Object.keys(eForms).find(function (key) { return eForms[key] === viewType });

                window.location.replace("Account/Redirect/" + redirectPageName);

                return;
            }

            if (isWizardView(viewArgs)) {
                return switchToWizardView(viewType, viewArgs, callback);
            }

            switchViewVisible(viewType, viewArgs, callback);
        };

        var getFormProperties = function (formType) {
            formType = formType || activeFormType();

            return Containers.Forms.GetItem(formType) || {};
        };

        return {
            Init: init,
            Start: start,
            GetFormProperties: getFormProperties,
            GetActiveFormViewProperties: getActiveFormView,
            // todo: replace all and test SwitchViewVisible to RedirectToForm
            // deprecated: use RedirectToForm which include business and application navigation validation  rules
            SwitchViewVisible: switchViewVisible,
            RedirectToForm: redirectToForm,
            RedirectToURL: redirectToURL,
            GetViewArgs: getViewArgs,
            GetViewArgsByKeyName: getViewArgsByKeyName,
            Activeform: getActiveForm,
            ActiveFormType: activeFormType,
            ActiveFormName: activeFormName,
            ChangeViewState: changeState,
            GetViewState: getViewState,
            Refresh: refresh,
            Reload: reload,
            History: {
                GoBack: goBack,
                GoForward: goForward
            },
            OnActiveFormChanged: onActiveFormChanged
        };
    }
);
define(
    'viewmodels/ViewModelBase',
    [
        'require',
        'handlers/general',
    ],
    function (require, general) {

        return {
            setSettings: function (child, customSettings, defaultSettings) {
                customSettings = customSettings || {};

                if (!general.isDefinedType(defaultSettings)) {
                    child.settings = {};
                }
                else {
                    child.settings = defaultSettings;
                }
                Object.assign(child.settings, customSettings);
            },
            getSettings: function (child) {
                return child.settings;
            }
        };
    }
);

/* global UrlResolver */
var TDALInstruments = function (ajaxer, jsonHelper, general, logger) {
    var _ajaxer = ajaxer;

    function getScheduleGroup(instrumentId) {
        var action = "schgrp" + instrumentId;
        var url = UrlResolver.getStaticResourcePath(action);

        return _ajaxer.promises
            .get("TDALInstruments/getScheduleGroup", url, "", null, null, null, null, null, false)
            .then(processResponse)
            .fail(onGetScheduleGroupError);
    }

    function changeUiOrder(uiOrder, onLoadComplete) {
        uiOrder = uiOrder || [];

        _ajaxer.promises
            .jsonPost(
                "dalCommon/ChangeUIOrder",
                "api/customer/ChangeUIOrder",
                JSON.stringify(uiOrder.join("|"))
            )
            .then(onLoadComplete).fail(
                function (error) {
                    ErrorManager.onError("TdalCommon/ChangeUIOrder", error.message, eErrorSeverity.low);
                }
            );
    }

    function getPresets(args) {
        // "fu12-s12-fo67-br3.js";
        var action = "";

        action += "fu" + args.futuresPermission;
        action += "-s" + args.stocksPermission;
        action += "-fo" + args.folderId;
        action += "-br" + args.brokerId;

        var url = UrlResolver.getStaticJSActionPath("Presets", action);

        return _ajaxer.promises
            .get("TDALInstruments/getPresets", url, null, null, null, null, null, null, false) //try 5 times before failing
            .progress(onProgress)
            .then(processResponse)
            .fail(function (error) {
                return onFirstFailReportAndGoToOrigin(error, url);
            });
    }

    function onFirstFailReportAndGoToOrigin(error, url) {
        ErrorManager.onError("TDALInstruments/getPresets", error.message, eErrorSeverity.medium);

        return _ajaxer.promises
            .get("TDALInstruments/getPresets from origin", url)
            .progress(onProgress)
            .then(processResponse)
            .fail(onGetPresetsError);
    }

    function processResponse(responseText) {
        return jsonHelper.STR2JSON("dalInstruments:processResponse", responseText);
    }

    function onGetPresetsError(error) {
        return onError("TDALInstruments/getPresets", error);
    }

    function onGetScheduleGroupError(error) {
        return onError("TDALInstruments/getScheduleGroup", error);
    }

    function onError(methodName, error) {
        ErrorManager.onError(methodName, error.message, eErrorSeverity.medium);

        throw error;
    }

    function onProgress(status) {
        status = status || {};
        status.State = status.State || eAjaxerState.None;

        if (status.State === eAjaxerState.Retry && general.isDefinedType(Logger)) {
            var warningMessage = "Client cache has expired - retried: " + JSON.stringify(status);

            logger.warn("TDALInstruments", warningMessage, general.emptyFn, eErrorSeverity.warning);
        }
    }

    return {
        ChangeUIOrder: changeUiOrder,
        GetPresets: getPresets,
        GetScheduleGroup: getScheduleGroup
    };
};
define("dataaccess/dalInstruments", ["handlers/Ajaxer","JSONHelper","handlers/general","handlers/Logger"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ajaxer, jsonHelper, general, logger) {
				var ajx = new ajaxer();
				return this.TDALInstruments(ajx, jsonHelper, general, logger);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TDALInstruments;
    };
}(this)));

define(
    'modules/FavoriteInstrumentsManager',
    [
        "require",
        'enums/DataMembersPositions',
        'customEnums/ViewsEnums',
        'initdatamanagers/InstrumentsManager',
        'dataaccess/dalInstruments',
        'configuration/initconfiguration',
        'handlers/general',
    ],
    function FavoriteInstrumentsManager(require) {
        var InstrumentsManager = require('initdatamanagers/InstrumentsManager'),
            dalInstruments = require('dataaccess/dalInstruments'),
            general = require('handlers/general'),
            initConfiguration = require('configuration/initconfiguration');

        function getFavoriteInstrumentIds() {
            return InstrumentsManager.GetCustomizedUiOrder().map(function (el) { return el[eQuotesUIOrder.InstrumentID]; });
        }

        //-----------------------------------------------------------
        function addFavoriteInstrument(instrumentId, callback) {
            var customizedInstruments = InstrumentsManager.GetCustomizedUiOrder();

            if (isFavoriteInstrument(instrumentId)) {
                if (general.isFunctionType(callback)) {
                    callback("{\"status\": 1 }");
                }

                return;
            }

            var favoriteInstrumentIds = getFavoriteInstrumentIds();

            if (favoriteInstrumentIds.length >= initConfiguration.FavoriteInstrumentsConfiguration.favoriteInstrumentsLimit) {
                var message = String.format(Dictionary.GetItem("FavoritesList_MaximumLimitReached"), initConfiguration.FavoriteInstrumentsConfiguration.favoriteInstrumentsLimit);

                AlertsManager.UpdateAlert(AlertTypes.SimpleClientAlert, null, message, '');
                AlertsManager.PopAlert(AlertTypes.SimpleClientAlert);

                if (general.isFunctionType(callback)) {
                    callback("{\"status\": 0 }");
                }

                return;
            }

            favoriteInstrumentIds.unshift(instrumentId);

            var instrument = InstrumentsManager.GetInstrument(instrumentId);

            if (!instrument) {
                if (general.isFunctionType(callback)) {
                    callback("{\"status\": 0 }");
                }

                return;
            }

            var instrumentData = [[instrumentId, instrument.defaultDealSize]];
            customizedInstruments = instrumentData.concat(customizedInstruments);

            updateCustomizedUIOrderData(customizedInstruments);
            saveUIOrder(favoriteInstrumentIds, callback);
        }

        //-----------------------------------------------------------
        function removeFavoriteInstrument(instrumentId, callback) {
            if (!isFavoriteInstrument(instrumentId)) {
                if (general.isFunctionType(callback)) {
                    callback("{\"status\": 1 }");
                }

                return;
            }

            var favoriteInstrumentIds = getFavoriteInstrumentIds().filter(function (el) { return el !== instrumentId; });
            var customizedInstruments = InstrumentsManager.GetCustomizedUiOrder().filter(function (el) { return el[eQuotesUIOrder.InstrumentID] != instrumentId });

            updateCustomizedUIOrderData(customizedInstruments);
            saveUIOrder(favoriteInstrumentIds, callback);
        }

        //-----------------------------------------------------------
        function isFavoriteInstrument(instrumentId) {
            return getFavoriteInstrumentIds().indexOf(instrumentId) >= 0;
        }

        //-----------------------------------------------------------
        function saveUIOrder(favoriteInstrumentList, callback) {
            dalInstruments.ChangeUIOrder(favoriteInstrumentList, callback);
        }

        //-----------------------------------------------------------
        function changeUIOrder(favoriteInstrumentList, skipUpdate, callback) {
            if (!favoriteInstrumentList) {
                if (general.isFunctionType(callback)) {
                    callback("{\"status\": 1 }");
                }

                return;
            }

            var customizedInstruments = [];

            for (var i = 0; i < favoriteInstrumentList.length; i++) {
                var instrumentId = favoriteInstrumentList[i];
                var instrument = InstrumentsManager.GetInstrument(instrumentId);

                customizedInstruments.push([instrumentId, instrument.defaultDealSize]);
            }

            updateCustomizedUIOrderData(customizedInstruments, skipUpdate);
            saveUIOrder(favoriteInstrumentList, callback);
        }

        //-----------------------------------------------------------
        function updateCustomizedUIOrderData(uiOrder, skipUpdate) {
            uiOrder = uiOrder || [];
            InstrumentsManager.SetCustomizedUiOrder(uiOrder, skipUpdate);
        }

        return {
            GetFavoriteInstrumentIds: getFavoriteInstrumentIds,
            AddFavoriteInstrument: addFavoriteInstrument,
            RemoveFavoriteInstrument: removeFavoriteInstrument,
            IsFavoriteInstrument: isFavoriteInstrument,
            ChangeUIOrder: changeUIOrder
        };
    }
);
define(
    'handlers/languageHelper',
    [
        'require',
        'handlers/Cookie'
    ],
    function LanguageHelper(require) {
        var cookieHandler = require('handlers/Cookie');
        //eslint-disable-next-line
        var language = undefined;

        function getLanguage() {
            //eslint-disable-next-line
            if (language !== undefined) {
                return language;
            } else {
                language = cookieHandler.ReadCookie("Language");
                return language;
            }
        }

        function isRtlLanguage() {
            return ['hebrew', 'arabic'].indexOf(getLanguage().toLowerCase()) !== -1;
        }

        function getDirection() {
            return isRtlLanguage() ? 'rtl' : 'ltr';
        }

        window.LanguageHelper = {
            GetDirection: getDirection,
            GetLanguage: getLanguage,
            IsRtlLanguage: isRtlLanguage
        }

        return window.LanguageHelper;
    }
);
define("managers/instrumentTranslationsManager", [
	"require",
	"generalmanagers/ErrorManager",
	"initdatamanagers/InstrumentsManager",
	"handlers/languageHelper",
	"Dictionary",
	"vendor/latinize",
], function (require) {
	var ErrorManager = require("generalmanagers/ErrorManager"),
		InstrumentsManager = require("initdatamanagers/InstrumentsManager"),
		LanguageHelper = require("handlers/languageHelper"),
		Dictionary = require("Dictionary"),
		latinize = require("vendor/latinize");

	function TInstrumentTranslation(instrumentId) {
		this.ccyPairLong = Dictionary.GetGlobalItem("instr_" + instrumentId, "*");
		this.ccyPairShort = Dictionary.GetGlobalItem("instr_basic_" + instrumentId, "*");
		this.ccyPairOriginal = Dictionary.GetGlobalItem("instr_raw_" + instrumentId, "*");

		this.baseSymbolName = this.ccyPairOriginal.split(/\//g)[0];
		this.otherSymbolName = this.ccyPairOriginal.split(/\//g)[1];
	}

	function InstrumentTranslationsManager() {
		function getTranslatedInstrument(instrumentId) {
			return new TInstrumentTranslation(instrumentId);
		}

		function getTooltipByInstrumentId(instrumentId) {
			var prefix = "symboltooltip_",
				inst = InstrumentsManager.GetInstrument(instrumentId),
				contractMonthAndYear = inst.contractMonthAndYear || "",
				baseSymbolName = inst.baseSymbolName ? inst.baseSymbolName.toLowerCase() : "",
				otherSymbolName = inst.otherSymbolName ? inst.otherSymbolName.toLowerCase() : "";

			if (Dictionary.ValueIsEmpty(prefix + baseSymbolName + otherSymbolName)) {
				return inst.baseSymbolName + "/" + inst.otherSymbolName;
			}

			return (
				Dictionary.GetGlobalItem(prefix + baseSymbolName + otherSymbolName) +
				buildContractMonth(contractMonthAndYear, instrumentId)
			);
		}

		function buildContractMonth(contractMonthAndYear, instrumentId) {
			if (!contractMonthAndYear) {
				return "";
			}

			var year = contractMonthAndYear.substr(-2),
				yearDigit = contractMonthAndYear.substr(-1),
				month = contractMonthAndYear.split(" ")[0];

			month = month ? month.slice(0, 3).toUpperCase() : month;

			var monthCodes = {
					JAN: "F",
					FEB: "G",
					MAR: "H",
					APR: "J",
					MAY: "K",
					JUN: "M",
					JUL: "N",
					AUG: "Q",
					SEP: "U",
					OCT: "V",
					NOV: "X",
					DEC: "Z",
				},
				monthCode = monthCodes[month];

			if (!monthCode) {
				month = "-";
				monthCode = "-";

				ErrorManager.onWarning(
					"InstrumentTranslationsManager/buildContractMonth",
					String.format(
						"Instrument {0} does not have a valid contract month: [{1}].",
						instrumentId,
						contractMonthAndYear
					)
				);
			}

			return String.format(" {0}{1} {4}({2}{3}){4}", month, year, monthCode, yearDigit, cTextMarks.Ltr);
		}

		function short(instId) {
			var translation = getTranslatedInstrument(instId).ccyPairShort;

			return addLTRMarksToNonArabicTextInRTLLanguages(translation);
		}

		function long(instId) {
			var translation = getTranslatedInstrument(instId).ccyPairLong;

			return addLTRMarksToNonArabicTextInRTLLanguages(translation);
		}

		function addLTRMarksToNonArabicTextInRTLLanguages(translation) {
			if (!LanguageHelper.IsRtlLanguage() || (translation && translation.isRtlText())) {
				return translation;
			}

			translation = String.format("{1}{0}{1}", translation, cTextMarks.Ltr);
			return translation;
		}

		function original(instId) {
			return getTranslatedInstrument(instId).ccyPairOriginal;
		}

		function getFullTextLatinized(instId) {
			var instr = getTranslatedInstrument(instId),
				noSlashName = instr.baseSymbolName + instr.otherSymbolName,
				instrumentTooltip = getTooltipByInstrumentId(instId),
				instrument = InstrumentsManager.GetInstrument(instId);

			return latinize(
				instr.ccyPairShort +
					" " +
					instr.ccyPairLong +
					" " +
					noSlashName +
					" " +
					instrumentTooltip +
					(instrument ? " " + instrument.instrumentEnglishName : "")
			);
		}

		return {
			GetTooltipByInstrumentId: getTooltipByInstrumentId,
			GetTranslatedInstrumentById: getTranslatedInstrument,
			Long: long,
			Short: short,
			Original: original,
			GetFullTextLatinized: getFullTextLatinized,
		};
	}

	var module = (window.$instrumentTranslationsManager = new InstrumentTranslationsManager());

	return module;
});

/*! jQuery UI - v1.11.4 - 2015-04-14
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, menu.js, progressbar.js, slider.js, spinner.js, tabs.js, tooltip.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function (factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/jquery-ui',["jquery"], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    /*!
     * jQuery UI Core 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/category/ui-core/
     */


    // $.ui might exist from components with no dependencies, e.g., $.ui.position
    $.ui = $.ui || {};

    $.extend($.ui, {
        version: "1.11.4",

        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });

    // plugins
    $.fn.extend({
        scrollParent: function (includeHidden) {
            var position = this.css("position"),
                excludeStaticParent = position === "absolute",
                overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
                scrollParent = this.parents().filter(function () {
                    var parent = $(this);
                    if (excludeStaticParent && parent.css("position") === "static") {
                        return false;
                    }
                    return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
                }).eq(0);

            return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        },

        uniqueId: (function () {
            var uuid = 0;

            return function () {
                return this.each(function () {
                    if (!this.id) {
                        this.id = "ui-id-" + (++uuid);
                    }
                });
            };
        })(),

        removeUniqueId: function () {
            return this.each(function () {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });

    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img,
            nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap='#" + mapName + "']")[0];
            return !!img && visible(img);
        }
        return (/^(input|select|textarea|button|object)$/.test(nodeName) ?
            !element.disabled :
            "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN) &&
            // the element and all of its ancestors must be visible
            visible(element);
    }

    function visible(element) {
        return $.expr.filters.visible(element) &&
            !$(element).parents().addBack().filter(function () {
                return $.css(this, "visibility") === "hidden";
            }).length;
    }

    $.extend($.expr[":"], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function (dataName) {
                return function (elem) {
                    return !!$.data(elem, dataName);
                };
            }) :
            // support: jQuery <1.8
            function (elem, i, match) {
                return !!$.data(elem, match[3]);
            },

        focusable: function (element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },

        tabbable: function (element) {
            var tabIndex = $.attr(element, "tabindex"),
                isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });

    // support: jQuery <1.8
    if (!$("<a>").outerWidth(1).jquery) {
        $.each(["Width", "Height"], function (i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce(elem, size, border, margin) {
                $.each(side, function () {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }

            $.fn["inner" + name] = function (size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };

            $.fn["outer" + name] = function (size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }

    // support: jQuery <1.8
    if (!$.fn.addBack) {
        $.fn.addBack = function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        };
    }

    // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = (function (removeData) {
            return function (key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        })($.fn.removeData);
    }

    // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

    $.fn.extend({
        focus: (function (orig) {
            return function (delay, fn) {
                return typeof delay === "number" ?
                    this.each(function () {
                        var elem = this;
                        setTimeout(function () {
                            $(elem).focus();
                            if (fn) {
                                fn.call(elem);
                            }
                        }, delay);
                    }) :
                    orig.apply(this, arguments);
            };
        })($.fn.focus),

        disableSelection: (function () {
            var eventType = "onselectstart" in document.createElement("div") ?
                "selectstart" :
                "mousedown";

            return function () {
                return this.bind(eventType + ".ui-disableSelection", function (event) {
                    event.preventDefault();
                });
            };
        })(),

        enableSelection: function () {
            return this.unbind(".ui-disableSelection");
        },

        zIndex: function (zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }

            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        }
    });

    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    $.ui.plugin = {
        add: function (module, option, set) {
            var i,
                proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([option, set[i]]);
            }
        },
        call: function (instance, name, args, allowDisconnected) {
            var i,
                set = instance.plugins[name];

            if (!set) {
                return;
            }

            if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                return;
            }

            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };


    /*!
     * jQuery UI Widget 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/jQuery.widget/
     */


    var widget_uuid = 0,
        widget_slice = Array.prototype.slice;

    $.cleanData = (function (orig) {
        return function (elems) {
            var events, elem, i;
            for (i = 0; (elem = elems[i]) != null; i++) {
                try {

                    // Only trigger remove when necessary to save time
                    events = $._data(elem, "events");
                    if (events && events.remove) {
                        $(elem).triggerHandler("remove");
                    }

                    // http://bugs.jquery.com/ticket/8235
                } catch (e) { }
            }
            orig(elems);
        };
    })($.cleanData);

    $.widget = function (name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
            namespace = name.split(".")[0];

        name = name.split(".")[1];
        fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function (options, element) {
            // allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function (prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function () {
                var _super = function () {
                    return base.prototype[prop].apply(this, arguments);
                },
                    _superApply = function (args) {
                        return base.prototype[prop].apply(this, args);
                    };
                return function () {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);

        return constructor;
    };

    $.widget.extend = function (target) {
        var input = widget_slice.call(arguments, 1),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
                            $.widget.extend({}, target[key], value) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = typeof options === "string",
                args = widget_slice.call(arguments, 1),
                returnValue = this;

            if (isMethodCall) {
                this.each(function () {
                    var methodValue,
                        instance = $.data(this, fullName);
                    if (options === "instance") {
                        returnValue = instance;
                        return false;
                    }
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " +
                            "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ?
                            returnValue.pushStack(methodValue.get()) :
                            methodValue;
                        return false;
                    }
                });
            } else {

                // Allow multiple hashes to be passed on init
                if (args.length) {
                    options = $.widget.extend.apply(null, [options].concat(args));
                }

                this.each(function () {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function ( /* options, element */) { };
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widget_uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function (event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this.options = $.widget.extend({},
                this.options,
                this._getCreateOptions(),
                options);

            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function () {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .unbind(this.eventNamespace)
                .removeData(this.widgetFullName)
                // support: jquery <1.6.3
                // http://bugs.jquery.com/ticket/9413
                .removeData($.camelCase(this.widgetFullName));
            this.widget()
                .unbind(this.eventNamespace)
                .removeAttr("aria-disabled")
                .removeClass(
                    this.widgetFullName + "-disabled " +
                    "ui-state-disabled");

            // clean up events and states
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,

        widget: function () {
            return this.element;
        },

        option: function (key, value) {
            var options = key,
                parts,
                curOption,
                i;

            if (arguments.length === 0) {
                // don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },
        _setOptions: function (options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },
        _setOption: function (key, value) {
            this.options[key] = value;

            if (key === "disabled") {
                this.widget()
                    .toggleClass(this.widgetFullName + "-disabled", !!value);

                // If the widget is becoming disabled, then nothing is interactive
                if (value) {
                    this.hoverable.removeClass("ui-state-hover");
                    this.focusable.removeClass("ui-state-focus");
                }
            }

            return this;
        },

        enable: function () {
            return this._setOptions({ disabled: false });
        },
        disable: function () {
            return this._setOptions({ disabled: true });
        },

        _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement,
                instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
                        (instance.options.disabled === true ||
                            $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }

                // copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^([\w:-]*)\s*(.*)$/),
                    eventName = match[1] + instance.eventNamespace,
                    selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },

        _off: function (element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") +
                this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);

            // Clear the stack to avoid memory leaks (#10056)
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get());
        },

        _delay: function (handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
                    .apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function (event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function (event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },

        _focusable: function (element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function (event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function (event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },

        _trigger: function (type, event, data) {
            var prop, orig,
                callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
                callback.apply(this.element[0], [event].concat(data)) === false ||
                event.isDefaultPrevented());
        }
    };

    $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
        $.Widget.prototype["_" + method] = function (element, options, callback) {
            if (typeof options === "string") {
                options = { effect: options };
            }
            var hasOptions,
                effectName = !options ?
                    method :
                    options === true || typeof options === "number" ?
                        defaultEffect :
                        options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = { duration: options };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function (next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

    var widget = $.widget;


    /*!
     * jQuery UI Mouse 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/mouse/
     */


    var mouseHandled = false;
    $(document).mouseup(function () {
        mouseHandled = false;
    });

    var mouse = $.widget("ui.mouse", {
        version: "1.11.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function () {
            var that = this;

            this.element
                .bind("mousedown." + this.widgetName, function (event) {
                    return that._mouseDown(event);
                })
                .bind("click." + this.widgetName, function (event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function () {
            this.element.unbind("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                this.document
                    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function (event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) {
                return;
            }

            this._mouseMoved = false;

            // we may have missed mouseup (out of window)
            (this._mouseStarted && this._mouseUp(event));

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = (event.which === 1),
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function () {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = (this._mouseStart(event) !== false);
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }

            // these delegates are required to keep context
            this._mouseMoveDelegate = function (event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function (event) {
                return that._mouseUp(event);
            };

            this.document
                .bind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .bind("mouseup." + this.widgetName, this._mouseUpDelegate);

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function (event) {
            // Only check for mouseups outside the document if you've moved inside the document
            // at least once. This prevents the firing of mouseup in the case of IE<9, which will
            // fire a mousemove event if content is placed under the cursor. See #7778
            // Support: IE <9
            if (this._mouseMoved) {
                // IE mouseup check - mouseup happened when mouse was out of window
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                    return this._mouseUp(event);

                    // Iframe mouseup check - mouseup occurred in another document
                } else if (!event.which) {
                    return this._mouseUp(event);
                }
            }

            if (event.which || event.button) {
                this._mouseMoved = true;
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    (this._mouseStart(this._mouseDownEvent, event) !== false);
                (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
            }

            return !this._mouseStarted;
        },

        _mouseUp: function (event) {
            this.document
                .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }

                this._mouseStop(event);
            }

            mouseHandled = false;
            return false;
        },

        _mouseDistanceMet: function (event) {
            return (Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
            ) >= this.options.distance
            );
        },

        _mouseDelayMet: function (/* event */) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function (/* event */) { },
        _mouseDrag: function (/* event */) { },
        _mouseStop: function (/* event */) { },
        _mouseCapture: function (/* event */) { return true; }
    });


    /*!
     * jQuery UI Position 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/position/
     */

    (function () {

        $.ui = $.ui || {};

        var cachedScrollbarWidth, supportsOffsetFractions,
            max = Math.max,
            abs = Math.abs,
            round = Math.round,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;

        function getOffsets(offsets, width, height) {
            return [
                parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
                parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
            ];
        }

        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }

        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: 0, left: 0 }
                };
            }
            if ($.isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: { top: raw.pageY, left: raw.pageX }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }

        $.position = {
            scrollbarWidth: function () {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1, w2,
                    div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                    innerDiv = div.children()[0];

                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");

                w2 = innerDiv.offsetWidth;

                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }

                div.remove();

                return (cachedScrollbarWidth = w1 - w2);
            },
            getScrollInfo: function (within) {
                var overflowX = within.isWindow || within.isDocument ? "" :
                    within.element.css("overflow-x"),
                    overflowY = within.isWindow || within.isDocument ? "" :
                        within.element.css("overflow-y"),
                    hasOverflowX = overflowX === "scroll" ||
                        (overflowX === "auto" && within.width < within.element[0].scrollWidth),
                    hasOverflowY = overflowY === "scroll" ||
                        (overflowY === "auto" && within.height < within.element[0].scrollHeight);
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function (element) {
                var withinElement = $(element || window),
                    isWindow = $.isWindow(withinElement[0]),
                    isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: withinElement.offset() || { left: 0, top: 0 },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),

                    // support: jQuery 1.6.x
                    // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
                    width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
                    height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
                };
            }
        };

        $.fn.position = function (options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }

            // make a copy, we don't want to modify arguments
            options = $.extend({}, options);

            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
                target = $(options.of),
                within = $.position.getWithinInfo(options.within),
                scrollInfo = $.position.getScrollInfo(within),
                collision = (options.collision || "flip").split(" "),
                offsets = {};

            dimensions = getDimensions(target);
            if (target[0].preventDefault) {
                // force left top to allow flipping
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;
            // clone to reuse original targetOffset later
            basePosition = $.extend({}, targetOffset);

            // force my and at to have valid horizontal and vertical positions
            // if a value is missing or invalid, it will be converted to center
            $.each(["my", "at"], function () {
                var pos = (options[this] || "").split(" "),
                    horizontalOffset,
                    verticalOffset;

                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0]) ?
                        pos.concat(["center"]) :
                        rvertical.test(pos[0]) ?
                            ["center"].concat(pos) :
                            ["center", "center"];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";

                // calculate offsets
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [
                    horizontalOffset ? horizontalOffset[0] : 0,
                    verticalOffset ? verticalOffset[0] : 0
                ];

                // reduce to just the positions without the offsets
                options[this] = [
                    rposition.exec(pos[0])[0],
                    rposition.exec(pos[1])[0]
                ];
            });

            // normalize collision option
            if (collision.length === 1) {
                collision[1] = collision[0];
            }

            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }

            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }

            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];

            return this.each(function () {
                var collisionPosition, using,
                    elem = $(this),
                    elemWidth = elem.outerWidth(),
                    elemHeight = elem.outerHeight(),
                    marginLeft = parseCss(this, "marginLeft"),
                    marginTop = parseCss(this, "marginTop"),
                    collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
                    collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
                    position = $.extend({}, basePosition),
                    myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }

                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }

                position.left += myOffset[0];
                position.top += myOffset[1];

                // if the browser doesn't support fractions, then round for consistent results
                if (!supportsOffsetFractions) {
                    position.left = round(position.left);
                    position.top = round(position.top);
                }

                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };

                $.each(["left", "top"], function (i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        });
                    }
                });

                if (options.using) {
                    // adds feedback as second argument to using callback, if present
                    using = function (props) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                            feedback.horizontal = "center";
                        }
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                            feedback.vertical = "middle";
                        }
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }

                elem.offset($.extend(position, { using: using }));
            });
        };

        $.ui.position = {
            fit: {
                left: function (position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                        outerWidth = within.width,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = withinOffset - collisionPosLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                        newOverRight;

                    // element is wider than within
                    if (data.collisionWidth > outerWidth) {
                        // element is initially over the left side of within
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight;
                            // element is initially over right side of within
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;
                            // element is initially over both left and right sides of within
                        } else {
                            if (overLeft > overRight) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }
                        // too far left -> align with left edge
                    } else if (overLeft > 0) {
                        position.left += overLeft;
                        // too far right -> align with right edge
                    } else if (overRight > 0) {
                        position.left -= overRight;
                        // adjust based on position and margin
                    } else {
                        position.left = max(position.left - collisionPosLeft, position.left);
                    }
                },
                top: function (position, data) {
                    var within = data.within,
                        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                        outerHeight = data.within.height,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = withinOffset - collisionPosTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                        newOverBottom;

                    // element is taller than within
                    if (data.collisionHeight > outerHeight) {
                        // element is initially over the top of within
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom;
                            // element is initially over bottom of within
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;
                            // element is initially over both top and bottom of within
                        } else {
                            if (overTop > overBottom) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }
                        // too far up -> align with top
                    } else if (overTop > 0) {
                        position.top += overTop;
                        // too far down -> align with bottom edge
                    } else if (overBottom > 0) {
                        position.top -= overBottom;
                        // adjust based on position and margin
                    } else {
                        position.top = max(position.top - collisionPosTop, position.top);
                    }
                }
            },
            flip: {
                left: function (position, data) {
                    var within = data.within,
                        withinOffset = within.offset.left + within.scrollLeft,
                        outerWidth = within.width,
                        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                        overLeft = collisionPosLeft - offsetLeft,
                        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                        myOffset = data.my[0] === "left" ?
                            -data.elemWidth :
                            data.my[0] === "right" ?
                                data.elemWidth :
                                0,
                        atOffset = data.at[0] === "left" ?
                            data.targetWidth :
                            data.at[0] === "right" ?
                                -data.targetWidth :
                                0,
                        offset = -2 * data.offset[0],
                        newOverRight,
                        newOverLeft;

                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function (position, data) {
                    var within = data.within,
                        withinOffset = within.offset.top + within.scrollTop,
                        outerHeight = within.height,
                        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                        collisionPosTop = position.top - data.collisionPosition.marginTop,
                        overTop = collisionPosTop - offsetTop,
                        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                        top = data.my[1] === "top",
                        myOffset = top ?
                            -data.elemHeight :
                            data.my[1] === "bottom" ?
                                data.elemHeight :
                                0,
                        atOffset = data.at[1] === "top" ?
                            data.targetHeight :
                            data.at[1] === "bottom" ?
                                -data.targetHeight :
                                0,
                        offset = -2 * data.offset[1],
                        newOverTop,
                        newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function () {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function () {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                }
            }
        };

        // fraction support test
        (function () {
            var testElement, testElementParent, testElementStyle, offsetLeft, i,
                body = document.getElementsByTagName("body")[0],
                div = document.createElement("div");

            //Create a "fake body" for testing based on method used in jQuery.support
            testElement = document.createElement(body ? "div" : "body");
            testElementStyle = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            };
            if (body) {
                $.extend(testElementStyle, {
                    position: "absolute",
                    left: "-1000px",
                    top: "-1000px"
                });
            }
            for (i in testElementStyle) {
                testElement.style[i] = testElementStyle[i];
            }
            testElement.appendChild(div);
            testElementParent = body || document.documentElement;
            testElementParent.insertBefore(testElement, testElementParent.firstChild);

            div.style.cssText = "position: absolute; left: 10.7432222px;";

            offsetLeft = $(div).offset().left;
            supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

            testElement.innerHTML = "";
            testElementParent.removeChild(testElement);
        })();

    })();

    var position = $.ui.position;


    /*!
     * jQuery UI Draggable 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/draggable/
     */


    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,

            // callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function () {

            if (this.options.helper === "original") {
                this._setPositionRelative();
            }
            if (this.options.addClasses) {
                this.element.addClass("ui-draggable");
            }
            if (this.options.disabled) {
                this.element.addClass("ui-draggable-disabled");
            }
            this._setHandleClassName();

            this._mouseInit();
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },

        _destroy: function () {
            if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                this.destroyOnClear = true;
                return;
            }
            this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
            this._removeHandleClassName();
            this._mouseDestroy();
        },

        _mouseCapture: function (event) {
            var o = this.options;

            this._blurActiveElement(event);

            // among others, prevent a drag on a resizable-handle
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }

            //Quit if we're not on a valid handle
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }

            this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);

            return true;

        },

        _blockFrames: function (selector) {
            this.iframeBlocks = this.document.find(selector).map(function () {
                var iframe = $(this);

                return $("<div>")
                    .css("position", "absolute")
                    .appendTo(iframe.parent())
                    .outerWidth(iframe.outerWidth())
                    .outerHeight(iframe.outerHeight())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function () {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _blurActiveElement: function (event) {
            var document = this.document[0];

            // Only need to blur if the event occurred on the draggable itself, see #10527
            if (!this.handleElement.is(event.target)) {
                return;
            }

            // support: IE9
            // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
            try {

                // Support: IE9, IE10
                // If the <body> is blurred, IE will switch windows, see #9520
                if (document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body") {

                    // Blur any element that currently has focus, see #4261
                    $(document.activeElement).blur();
                }
            } catch (error) { }
        },

        _mouseStart: function (event) {

            var o = this.options;

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            this.helper.addClass("ui-draggable-dragging");

            //Cache the helper size
            this._cacheHelperProportions();

            //If ddmanager is used for droppables, set the global draggable
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Store the helper's css position
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent(true);
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter(function () {
                return $(this).css("position") === "fixed";
            }).length > 0;

            //The element's absolute position on the page minus margins
            this.positionAbs = this.element.offset();
            this._refreshOffsets(event);

            //Generate the original position
            this.originalPosition = this.position = this._generatePosition(event, false);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Set a containment if given in the options
            this._setContainment();

            //Trigger event + callbacks
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }

            //Recache the helper size
            this._cacheHelperProportions();

            //Prepare the droppable offsets
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            // Reset helper's right/bottom css if they're set and set explicit width/height instead
            // as this prevents resizing of elements with right/bottom set (see #7772)
            this._normalizeRightBottom();

            this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

            //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }

            return true;
        },

        _refreshOffsets: function (event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };

            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },

        _mouseDrag: function (event, noPropagation) {
            // reset any necessary cached properties (see #5009)
            if (this.hasFixedAncestor) {
                this.offset.parent = this._getParentOffset();
            }

            //Compute the helpers position
            this.position = this._generatePosition(event, true);
            this.positionAbs = this._convertPositionTo("absolute");

            //Call plugins and callbacks and use the resulting position if something is returned
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp({});
                    return false;
                }
                this.position = ui.position;
            }

            this.helper[0].style.left = this.position.left + "px";
            this.helper[0].style.top = this.position.top + "px";

            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            return false;
        },

        _mouseStop: function (event) {

            //If we are using droppables, inform the manager about the drop
            var that = this,
                dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }

            //if a drop comes from outside (a sortable)
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }

            if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
                $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
                    if (that._trigger("stop", event) !== false) {
                        that._clear();
                    }
                });
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }

            return false;
        },

        _mouseUp: function (event) {
            this._unblockFrames();

            //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }

            // Only need to focus if the event occurred on the draggable itself, see #10527
            if (this.handleElement.is(event.target)) {
                // The interaction is over; whether or not the click resulted in a drag, focus the element
                this.element.focus();
            }

            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },

        cancel: function () {

            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp({});
            } else {
                this._clear();
            }

            return this;

        },

        _getHandle: function (event) {
            return this.options.handle ?
                !!$(event.target).closest(this.element.find(this.options.handle)).length :
                true;
        },

        _setHandleClassName: function () {
            this.handleElement = this.options.handle ?
                this.element.find(this.options.handle) : this.element;
            this.handleElement.addClass("ui-draggable-handle");
        },

        _removeHandleClassName: function () {
            this.handleElement.removeClass("ui-draggable-handle");
        },

        _createHelper: function (event) {

            var o = this.options,
                helperIsFunction = $.isFunction(o.helper),
                helper = helperIsFunction ?
                    $(o.helper.apply(this.element[0], [event])) :
                    (o.helper === "clone" ?
                        this.element.clone().removeAttr("id") :
                        this.element);

            if (!helper.parents("body").length) {
                helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
            }

            // http://bugs.jqueryui.com/ticket/9446
            // a helper function can return the original element
            // which wouldn't have been set to relative in _create
            if (helperIsFunction && helper[0] === this.element[0]) {
                this._setPositionRelative();
            }

            if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
                helper.css("position", "absolute");
            }

            return helper;

        },

        _setPositionRelative: function () {
            if (!(/^(?:r|a|f)/).test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if (Array.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _isRootNode: function (element) {
            return (/(html|body)/i).test(element.tagName) || element === this.document[0];
        },

        _getParentOffset: function () {

            //Get the offsetParent and cache its position
            var po = this.offsetParent.offset(),
                document = this.document[0];

            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            if (this._isRootNode(this.offsetParent[0])) {
                po = { top: 0, left: 0 };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function () {
            if (this.cssPosition !== "relative") {
                return { top: 0, left: 0 };
            }

            var p = this.element.position(),
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);

            return {
                top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
            };

        },

        _cacheMargins: function () {
            this.margins = {
                left: (parseInt(this.element.css("marginLeft"), 10) || 0),
                top: (parseInt(this.element.css("marginTop"), 10) || 0),
                right: (parseInt(this.element.css("marginRight"), 10) || 0),
                bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function () {

            var isUserScrollable, c, ce,
                o = this.options,
                document = this.document[0];

            this.relativeContainer = null;

            if (!o.containment) {
                this.containment = null;
                return;
            }

            if (o.containment === "window") {
                this.containment = [
                    $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
                    $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
                    $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left,
                    $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                ];
                return;
            }

            if (o.containment === "document") {
                this.containment = [
                    0,
                    0,
                    $(document).width() - this.helperProportions.width - this.margins.left,
                    ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                ];
                return;
            }

            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return;
            }

            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }

            c = $(o.containment);
            ce = c[0];

            if (!ce) {
                return;
            }

            isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));

            this.containment = [
                (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0),
                (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0),
                (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) -
                (parseInt(c.css("borderRightWidth"), 10) || 0) -
                (parseInt(c.css("paddingRight"), 10) || 0) -
                this.helperProportions.width -
                this.margins.left -
                this.margins.right,
                (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) -
                (parseInt(c.css("borderBottomWidth"), 10) || 0) -
                (parseInt(c.css("paddingBottom"), 10) || 0) -
                this.helperProportions.height -
                this.margins.top -
                this.margins.bottom
            ];
            this.relativeContainer = c;
        },

        _convertPositionTo: function (d, pos) {

            if (!pos) {
                pos = this.position;
            }

            var mod = d === "absolute" ? 1 : -1,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]);

            return {
                top: (
                    pos.top +																// The absolute mouse position
                    this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.offset.scroll.top : (scrollIsRootNode ? 0 : this.offset.scroll.top)) * mod)
                ),
                left: (
                    pos.left +																// The absolute mouse position
                    this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod -										// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.offset.scroll.left : (scrollIsRootNode ? 0 : this.offset.scroll.left)) * mod)
                )
            };

        },

        _generatePosition: function (event, constrainPosition) {

            var containment, co, top, left,
                o = this.options,
                scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
                pageX = event.pageX,
                pageY = event.pageY;

            // Cache the scroll
            if (!scrollIsRootNode || !this.offset.scroll) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft()
                };
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            // If we are not dragging yet, we won't check for options
            if (constrainPosition) {
                if (this.containment) {
                    if (this.relativeContainer) {
                        co = this.relativeContainer.offset();
                        containment = [
                            this.containment[0] + co.left,
                            this.containment[1] + co.top,
                            this.containment[2] + co.left,
                            this.containment[3] + co.top
                        ];
                    } else {
                        containment = this.containment;
                    }

                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                }

                if (o.axis === "y") {
                    pageX = this.originalPageX;
                }

                if (o.axis === "x") {
                    pageY = this.originalPageY;
                }
            }

            return {
                top: (
                    pageY -																	// The absolute mouse position
                    this.offset.click.top -												// Click offset (relative to the element)
                    this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                    (this.cssPosition === "fixed" ? -this.offset.scroll.top : (scrollIsRootNode ? 0 : this.offset.scroll.top))
                ),
                left: (
                    pageX -																	// The absolute mouse position
                    this.offset.click.left -												// Click offset (relative to the element)
                    this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                    (this.cssPosition === "fixed" ? -this.offset.scroll.left : (scrollIsRootNode ? 0 : this.offset.scroll.left))
                )
            };

        },

        _clear: function () {
            this.helper.removeClass("ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if (this.destroyOnClear) {
                this.destroy();
            }
        },

        _normalizeRightBottom: function () {
            if (this.options.axis !== "y" && this.helper.css("right") !== "auto") {
                this.helper.width(this.helper.width());
                this.helper.css("right", "auto");
            }
            if (this.options.axis !== "x" && this.helper.css("bottom") !== "auto") {
                this.helper.height(this.helper.height());
                this.helper.css("bottom", "auto");
            }
        },

        // From now on bulk stuff - mainly helpers

        _trigger: function (type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [event, ui, this], true);

            // Absolute position and offset (see #6884 ) have to be recalculated after plugins
            if (/^(drag|start|stop)/.test(type)) {
                this.positionAbs = this._convertPositionTo("absolute");
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },

        plugins: {},

        _uiHash: function () {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }

    });

    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });

            draggable.sortables = [];
            $(draggable.options.connectToSortable).each(function () {
                var sortable = $(this).sortable("instance");

                if (sortable && !sortable.options.disabled) {
                    draggable.sortables.push(sortable);

                    // refreshPositions is called at drag start to refresh the containerCache
                    // which is used in drag. This ensures it's initialized and synchronized
                    // with any changes that might have happened on the page since initialization.
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function (event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });

            draggable.cancelHelperRemoval = false;

            $.each(draggable.sortables, function () {
                var sortable = this;

                if (sortable.isOver) {
                    sortable.isOver = 0;

                    // Allow this sortable to handle removing the helper
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;

                    // Use _storedCSS To restore properties in the sortable,
                    // as this also handles revert (#9675) since the draggable
                    // may have modified them in unexpected ways (#8809)
                    sortable._storedCSS = {
                        position: sortable.placeholder.css("position"),
                        top: sortable.placeholder.css("top"),
                        left: sortable.placeholder.css("left")
                    };

                    sortable._mouseStop(event);

                    // Once drag has ended, the sortable should return to using
                    // its original helper, not the shared helper from draggable
                    sortable.options.helper = sortable.options._helper;
                } else {
                    // Prevent this Sortable from removing the helper.
                    // However, don't set the draggable to remove the helper
                    // either as another connected Sortable may yet handle the removal.
                    sortable.cancelHelperRemoval = true;

                    sortable._trigger("deactivate", event, uiSortable);
                }
            });
        },
        drag: function (event, ui, draggable) {
            $.each(draggable.sortables, function () {
                var innermostIntersecting = false,
                    sortable = this;

                // Copy over variables that sortable's _intersectsWith uses
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;

                if (sortable._intersectsWith(sortable.containerCache)) {
                    innermostIntersecting = true;

                    $.each(draggable.sortables, function () {
                        // Copy over variables that sortable's _intersectsWith uses
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;

                        if (this !== sortable &&
                            this._intersectsWith(this.containerCache) &&
                            $.contains(sortable.element[0], this.element[0])) {
                            innermostIntersecting = false;
                        }

                        return innermostIntersecting;
                    });
                }

                if (innermostIntersecting) {
                    // If it intersects, we use a little isOver variable and set it once,
                    // so that the move-in stuff gets fired only once.
                    if (!sortable.isOver) {
                        sortable.isOver = 1;

                        // Store draggable's parent in case we need to reappend to it later.
                        draggable._parent = ui.helper.parent();

                        sortable.currentItem = ui.helper
                            .appendTo(sortable.element)
                            .data("ui-sortable-item", true);

                        // Store helper option to later restore it
                        sortable.options._helper = sortable.options.helper;

                        sortable.options.helper = function () {
                            return ui.helper[0];
                        };

                        // Fire the start events of the sortable with our passed browser event,
                        // and our own helper (so it doesn't create a new one)
                        event.target = sortable.currentItem[0];
                        sortable._mouseCapture(event, true);
                        sortable._mouseStart(event, true, true);

                        // Because the browser event is way off the new appended portlet,
                        // modify necessary variables to reflect the changes
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left -
                            sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top -
                            sortable.offset.parent.top;

                        draggable._trigger("toSortable", event);

                        // Inform draggable that the helper is in a valid drop zone,
                        // used solely in the revert option to handle "valid/invalid".
                        draggable.dropped = sortable.element;

                        // Need to refreshPositions of all sortables in the case that
                        // adding to one sortable changes the location of the other sortables (#9675)
                        $.each(draggable.sortables, function () {
                            this.refreshPositions();
                        });

                        // hack so receive/update callbacks work (mostly)
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }

                    if (sortable.currentItem) {
                        sortable._mouseDrag(event);
                        // Copy the sortable's position because the draggable's can potentially reflect
                        // a relative position, while sortable is always absolute, which the dragged
                        // element has now become. (#8809)
                        ui.position = sortable.position;
                    }
                } else {
                    // If it doesn't intersect with the sortable, and it intersected before,
                    // we fake the drag stop of the sortable, but make sure it doesn't remove
                    // the helper by using cancelHelperRemoval.
                    if (sortable.isOver) {

                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;

                        // Calling sortable's mouseStop would trigger a revert,
                        // so revert must be temporarily false until after mouseStop is called.
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;

                        sortable._trigger("out", event, sortable._uiHash(sortable));
                        sortable._mouseStop(event, true);

                        // restore sortable behaviors that were modfied
                        // when the draggable entered the sortable area (#9481)
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;

                        if (sortable.placeholder) {
                            sortable.placeholder.remove();
                        }

                        // Restore and recalculate the draggable's offset considering the sortable
                        // may have modified them in unexpected ways. (#8809, #10669)
                        ui.helper.appendTo(draggable._parent);
                        draggable._refreshOffsets(event);
                        ui.position = draggable._generatePosition(event, true);

                        draggable._trigger("fromSortable", event);

                        // Inform draggable that the helper is no longer in a valid drop zone
                        draggable.dropped = false;

                        // Need to refreshPositions of all sortables just in case removing
                        // from one sortable changes the location of other sortables (#9675)
                        $.each(draggable.sortables, function () {
                            this.refreshPositions();
                        });
                    }
                }
            });
        }
    });

    $.ui.plugin.add("draggable", "cursor", {
        start: function (event, ui, instance) {
            var t = $("body"),
                o = instance.options;

            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function (event, ui, instance) {
            var o = instance.options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });

    $.ui.plugin.add("draggable", "opacity", {
        start: function (event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function (event, ui, instance) {
            var o = instance.options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });

    $.ui.plugin.add("draggable", "scroll", {
        start: function (event, ui, i) {
            if (!i.scrollParentNotHidden) {
                i.scrollParentNotHidden = i.helper.scrollParent(false);
            }

            if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function (event, ui, i) {

            var o = i.options,
                scrolled = false,
                scrollParent = i.scrollParentNotHidden[0],
                document = i.document[0];

            if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                if (!o.axis || o.axis !== "x") {
                    if ((i.overflowOffset.top + scrollParent.offsetHeight) - event.pageY < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                    } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if ((i.overflowOffset.left + scrollParent.offsetWidth) - event.pageX < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }

            } else {

                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }

                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }

            }

            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }

        }
    });

    $.ui.plugin.add("draggable", "snap", {
        start: function (event, ui, i) {

            var o = i.options;

            i.snapElements = [];

            $(o.snap.constructor !== String ? (o.snap.items || ":data(ui-draggable)") : o.snap).each(function () {
                var $t = $(this),
                    $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(), height: $t.outerHeight(),
                        top: $o.top, left: $o.left
                    });
                }
            });

        },
        drag: function (event, ui, inst) {

            var ts, bs, ls, rs, l, r, t, b, i, first,
                o = inst.options,
                d = o.snapTolerance,
                x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
                y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

            for (i = inst.snapElements.length - 1; i >= 0; i--) {

                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;

                if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                    if (inst.snapElements[i].snapping) {
                        (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }

                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
                    }
                }

                first = (ts || bs || ls || rs);

                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
                    }
                }

                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
                }
                inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

            }

        }
    });

    $.ui.plugin.add("draggable", "stack", {
        start: function (event, ui, instance) {
            var min,
                o = instance.options,
                group = $.makeArray($(o.stack)).sort(function (a, b) {
                    return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
                });

            if (!group.length) { return; }

            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function (i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", (min + group.length));
        }
    });

    $.ui.plugin.add("draggable", "zIndex", {
        start: function (event, ui, instance) {
            var t = $(ui.helper),
                o = instance.options;

            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function (event, ui, instance) {
            var o = instance.options;

            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });

    var draggable = $.ui.draggable;


    /*!
     * jQuery UI Droppable 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/droppable/
     */


    $.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: false,
            addClasses: true,
            greedy: false,
            hoverClass: false,
            scope: "default",
            tolerance: "intersect",

            // callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function () {

            var proportions,
                o = this.options,
                accept = o.accept;

            this.isover = false;
            this.isout = true;

            this.accept = $.isFunction(accept) ? accept : function (d) {
                return d.is(accept);
            };

            this.proportions = function ( /* valueToWrite */) {
                if (arguments.length) {
                    // Store the droppable's proportions
                    proportions = arguments[0];
                } else {
                    // Retrieve or derive the droppable's proportions
                    return proportions ?
                        proportions :
                        proportions = {
                            width: this.element[0].offsetWidth,
                            height: this.element[0].offsetHeight
                        };
                }
            };

            this._addToManager(o.scope);

            o.addClasses && this.element.addClass("ui-droppable");

        },

        _addToManager: function (scope) {
            // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
            $.ui.ddmanager.droppables[scope].push(this);
        },

        _splice: function (drop) {
            var i = 0;
            for (; i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }
        },

        _destroy: function () {
            var drop = $.ui.ddmanager.droppables[this.options.scope];

            this._splice(drop);

            this.element.removeClass("ui-droppable ui-droppable-disabled");
        },

        _setOption: function (key, value) {

            if (key === "accept") {
                this.accept = $.isFunction(value) ? value : function (d) {
                    return d.is(value);
                };
            } else if (key === "scope") {
                var drop = $.ui.ddmanager.droppables[this.options.scope];

                this._splice(drop);
                this._addToManager(value);
            }

            this._super(key, value);
        },

        _activate: function (event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.addClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },

        _deactivate: function (event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.removeClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },

        _over: function (event) {

            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
                this._trigger("over", event, this.ui(draggable));
            }

        },

        _out: function (event) {

            var draggable = $.ui.ddmanager.current;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("out", event, this.ui(draggable));
            }

        },

        _drop: function (event, custom) {

            var draggable = custom || $.ui.ddmanager.current,
                childrenIntersection = false;

            // Bail if draggable and droppable are same element
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return false;
            }

            this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
                var inst = $(this).droppable("instance");
                if (
                    inst.options.greedy &&
                    !inst.options.disabled &&
                    inst.options.scope === draggable.options.scope &&
                    inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&
                    $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance, event)
                ) { childrenIntersection = true; return false; }
            });
            if (childrenIntersection) {
                return false;
            }

            if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }

            return false;

        },

        ui: function (c) {
            return {
                draggable: (c.currentItem || c.element),
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        }

    });

    $.ui.intersect = (function () {
        function isOverAxis(x, reference, size) {
            return (x >= reference) && (x < (reference + size));
        }

        return function (draggable, droppable, toleranceMode, event) {

            if (!droppable.offset) {
                return false;
            }

            var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left,
                y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top,
                x2 = x1 + draggable.helperProportions.width,
                y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left,
                t = droppable.offset.top,
                r = l + droppable.proportions().width,
                b = t + droppable.proportions().height;

            switch (toleranceMode) {
                case "fit":
                    return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
                case "intersect":
                    return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half
                        x2 - (draggable.helperProportions.width / 2) < r && // Left Half
                        t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half
                        y2 - (draggable.helperProportions.height / 2) < b); // Top Half
                case "pointer":
                    return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);
                case "touch":
                    return (
                        (y1 >= t && y1 <= b) || // Top edge touching
                        (y2 >= t && y2 <= b) || // Bottom edge touching
                        (y1 < t && y2 > b) // Surrounded vertically
                    ) && (
                            (x1 >= l && x1 <= r) || // Left edge touching
                            (x2 >= l && x2 <= r) || // Right edge touching
                            (x1 < l && x2 > r) // Surrounded horizontally
                        );
                default:
                    return false;
            }
        };
    })();

    /*
        This manager tracks offsets of draggables and droppables
    */
    $.ui.ddmanager = {
        current: null,
        droppables: { "default": [] },
        prepareOffsets: function (t, event) {

            var i, j,
                m = $.ui.ddmanager.droppables[t.options.scope] || [],
                type = event ? event.type : null, // workaround for #2317
                list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();

            droppablesLoop: for (i = 0; i < m.length; i++) {

                // No disabled and non-accepted
                if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], (t.currentItem || t.element)))) {
                    continue;
                }

                // Filter out elements in the current dragged item
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions().height = 0;
                        continue droppablesLoop;
                    }
                }

                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }

                // Activate the droppable if used directly from draggables
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }

                m[i].offset = m[i].element.offset();
                m[i].proportions({ width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight });

            }

        },
        drop: function (draggable, event) {

            var dropped = false;
            // Create a copy of the droppables in case the list changes during the drop (#9116)
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {

                if (!this.options) {
                    return;
                }
                if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {
                    dropped = this._drop.call(this, event) || dropped;
                }

                if (!this.options.disabled && this.visible && this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event);
                }

            });
            return dropped;

        },
        dragStart: function (draggable, event) {
            // Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
            draggable.element.parentsUntil("body").bind("scroll.droppable", function () {
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            });
        },
        drag: function (draggable, event) {

            // If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }

            // Run through all droppables and check their positions based on specific tolerance options
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {

                if (this.options.disabled || this.greedyChild || !this.visible) {
                    return;
                }

                var parentInstance, scope, parent,
                    intersects = $.ui.intersect(draggable, this, this.options.tolerance, event),
                    c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
                if (!c) {
                    return;
                }

                if (this.options.greedy) {
                    // find droppable parents with same scope
                    scope = this.options.scope;
                    parent = this.element.parents(":data(ui-droppable)").filter(function () {
                        return $(this).droppable("instance").options.scope === scope;
                    });

                    if (parent.length) {
                        parentInstance = $(parent[0]).droppable("instance");
                        parentInstance.greedyChild = (c === "isover");
                    }
                }

                // we just moved into a greedy child
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event);
                }

                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);

                // we just moved out of a greedy child
                if (parentInstance && c === "isout") {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event);
                }
            });

        },
        dragStop: function (draggable, event) {
            draggable.element.parentsUntil("body").unbind("scroll.droppable");
            // Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        }
    };

    var droppable = $.ui.droppable;


    /*!
     * jQuery UI Resizable 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/resizable/
     */


    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            // See #7960
            zIndex: 90,

            // callbacks
            resize: null,
            start: null,
            stop: null
        },

        _num: function (value) {
            return parseInt(value, 10) || 0;
        },

        _isNumber: function (value) {
            return !isNaN(parseInt(value, 10));
        },

        _hasScroll: function (el, a) {

            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
                has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[scroll] = 1;
            has = (el[scroll] > 0);
            el[scroll] = 0;
            return has;
        },

        _create: function () {

            var n, i, handle, axis, hname,
                that = this,
                o = this.options;
            this.element.addClass("ui-resizable");

            $.extend(this, {
                _aspectRatio: !!(o.aspectRatio),
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });

            // Wrap the element if it cannot hold child nodes
            if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {

                this.element.wrap(
                    $("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                        position: this.element.css("position"),
                        width: this.element.outerWidth(),
                        height: this.element.outerHeight(),
                        top: this.element.css("top"),
                        left: this.element.css("left")
                    })
                );

                this.element = this.element.parent().data(
                    "ui-resizable", this.element.resizable("instance")
                );

                this.elementIsWrapper = true;

                this.element.css({
                    marginLeft: this.originalElement.css("marginLeft"),
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom")
                });
                this.originalElement.css({
                    marginLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                });
                // support: Safari
                // Prevent Safari textarea resize
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");

                this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }));

                // support: IE9
                // avoid IE jump (hard set the margin)
                this.originalElement.css({ margin: this.originalElement.css("margin") });

                this._proportionallyResize();
            }

            this.handles = o.handles ||
                (!$(".ui-resizable-handle", this.element).length ?
                    "e,s,se" : {
                        n: ".ui-resizable-n",
                        e: ".ui-resizable-e",
                        s: ".ui-resizable-s",
                        w: ".ui-resizable-w",
                        se: ".ui-resizable-se",
                        sw: ".ui-resizable-sw",
                        ne: ".ui-resizable-ne",
                        nw: ".ui-resizable-nw"
                    });

            this._handles = $();
            if (this.handles.constructor === String) {

                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }

                n = this.handles.split(",");
                this.handles = {};

                for (i = 0; i < n.length; i++) {

                    handle = n[i].trim();
                    hname = "ui-resizable-" + handle;
                    axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

                    axis.css({ zIndex: o.zIndex });

                    // TODO : What's going on here?
                    if ("se" === handle) {
                        axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                    }

                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }

            }

            this._renderAxis = function (target) {

                var i, axis, padPos, padWrapper;

                target = target || this.element;

                for (i in this.handles) {

                    if (this.handles[i].constructor === String) {
                        this.handles[i] = this.element.children(this.handles[i]).first().show();
                    } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                        this.handles[i] = $(this.handles[i]);
                        this._on(this.handles[i], { "mousedown": that._mouseDown });
                    }

                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {

                        axis = $(this.handles[i], this.element);

                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

                        padPos = ["padding",
                            /ne|nw|n/.test(i) ? "Top" :
                                /se|sw|s/.test(i) ? "Bottom" :
                                    /^e$/.test(i) ? "Right" : "Left"].join("");

                        target.css(padPos, padWrapper);

                        this._proportionallyResize();
                    }

                    this._handles = this._handles.add(this.handles[i]);
                }
            };

            // TODO: make renderAxis a prototype function
            this._renderAxis(this.element);

            this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
            this._handles.disableSelection();

            this._handles.mouseover(function () {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });

            if (o.autoHide) {
                this._handles.hide();
                $(this.element)
                    .addClass("ui-resizable-autohide")
                    .mouseenter(function () {
                        if (o.disabled) {
                            return;
                        }
                        $(this).removeClass("ui-resizable-autohide");
                        that._handles.show();
                    })
                    .mouseleave(function () {
                        if (o.disabled) {
                            return;
                        }
                        if (!that.resizing) {
                            $(this).addClass("ui-resizable-autohide");
                            that._handles.hide();
                        }
                    });
            }

            this._mouseInit();
        },

        _destroy: function () {

            this._mouseDestroy();

            var wrapper,
                _destroy = function (exp) {
                    $(exp)
                        .removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
                        .removeData("resizable")
                        .removeData("ui-resizable")
                        .unbind(".resizable")
                        .find(".ui-resizable-handle")
                        .remove();
                };

            // TODO: Unwrap at same DOM position
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove();
            }

            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);

            return this;
        },

        _mouseCapture: function (event) {
            var i, handle,
                capture = false;

            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }

            return !this.options.disabled && capture;
        },

        _mouseStart: function (event) {

            var curleft, curtop, cursor,
                o = this.options,
                el = this.element;

            this.resizing = true;

            this._renderProxy();

            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));

            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }

            this.offset = this.helper.offset();
            this.position = { left: curleft, top: curtop };

            this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                    width: el.width(),
                    height: el.height()
                };

            this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                    width: el.width(),
                    height: el.height()
                };

            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };

            this.originalPosition = { left: curleft, top: curtop };
            this.originalMousePosition = { left: event.pageX, top: event.pageY };

            this.aspectRatio = (typeof o.aspectRatio === "number") ?
                o.aspectRatio :
                ((this.originalSize.width / this.originalSize.height) || 1);

            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

            el.addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },

        _mouseDrag: function (event) {

            var data, props,
                smp = this.originalMousePosition,
                a = this.axis,
                dx = (event.pageX - smp.left) || 0,
                dy = (event.pageY - smp.top) || 0,
                trigger = this._change[a];

            this._updatePrevProperties();

            if (!trigger) {
                return false;
            }

            data = trigger.apply(this, [event, dx, dy]);

            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }

            data = this._respectSize(data, event);

            this._updateCache(data);

            this._propagate("resize", event);

            props = this._applyChanges();

            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }

            if (!$.isEmptyObject(props)) {
                this._updatePrevProperties();
                this._trigger("resize", event, this.ui());
                this._applyChanges();
            }

            return false;
        },

        _mouseStop: function (event) {

            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top,
                o = this.options, that = this;

            if (this._helper) {

                pr = this._proportionallyResizeElements;
                ista = pr.length && (/textarea/i).test(pr[0].nodeName);
                soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;

                s = {
                    width: (that.helper.width() - soffsetw),
                    height: (that.helper.height() - soffseth)
                };
                left = (parseInt(that.element.css("left"), 10) +
                    (that.position.left - that.originalPosition.left)) || null;
                top = (parseInt(that.element.css("top"), 10) +
                    (that.position.top - that.originalPosition.top)) || null;

                if (!o.animate) {
                    this.element.css($.extend(s, { top: top, left: left }));
                }

                that.helper.height(that.size.height);
                that.helper.width(that.size.width);

                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }

            $("body").css("cursor", "auto");

            this.element.removeClass("ui-resizable-resizing");

            this._propagate("stop", event);

            if (this._helper) {
                this.helper.remove();
            }

            return false;

        },

        _updatePrevProperties: function () {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },

        _applyChanges: function () {
            var props = {};

            if (this.position.top !== this.prevPosition.top) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== this.prevPosition.left) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== this.prevSize.width) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== this.prevSize.height) {
                props.height = this.size.height + "px";
            }

            this.helper.css(props);

            return props;
        },

        _updateVirtualBoundaries: function (forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
                o = this.options;

            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };

            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;

                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },

        _updateCache: function (data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (this._isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (this._isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (this._isNumber(data.width)) {
                this.size.width = data.width;
            }
        },

        _updateRatio: function (data) {

            var cpos = this.position,
                csize = this.size,
                a = this.axis;

            if (this._isNumber(data.height)) {
                data.width = (data.height * this.aspectRatio);
            } else if (this._isNumber(data.width)) {
                data.height = (data.width / this.aspectRatio);
            }

            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }

            return data;
        },

        _respectSize: function (data) {

            var o = this._vBoundaries,
                a = this.axis,
                ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
                ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
                isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
                isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
                dw = this.originalPosition.left + this.originalSize.width,
                dh = this.position.top + this.size.height,
                cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }

            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }

            // Fixing jump error on top/left - bug #2330
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }

            return data;
        },

        _getPaddingPlusBorderDimensions: function (element) {
            var i = 0,
                widths = [],
                borders = [
                    element.css("borderTopWidth"),
                    element.css("borderRightWidth"),
                    element.css("borderBottomWidth"),
                    element.css("borderLeftWidth")
                ],
                paddings = [
                    element.css("paddingTop"),
                    element.css("paddingRight"),
                    element.css("paddingBottom"),
                    element.css("paddingLeft")
                ];

            for (; i < 4; i++) {
                widths[i] = (parseInt(borders[i], 10) || 0);
                widths[i] += (parseInt(paddings[i], 10) || 0);
            }

            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3]
            };
        },

        _proportionallyResize: function () {

            if (!this._proportionallyResizeElements.length) {
                return;
            }

            var prel,
                i = 0,
                element = this.helper || this.element;

            for (; i < this._proportionallyResizeElements.length; i++) {

                prel = this._proportionallyResizeElements[i];

                // TODO: Seems like a bug to cache this.outerDimensions
                // considering that we are in a loop.
                if (!this.outerDimensions) {
                    this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
                }

                prel.css({
                    height: (element.height() - this.outerDimensions.height) || 0,
                    width: (element.width() - this.outerDimensions.width) || 0
                });

            }

        },

        _renderProxy: function () {

            var el = this.element, o = this.options;
            this.elementOffset = el.offset();

            if (this._helper) {

                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

                this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() - 1,
                    height: this.element.outerHeight() - 1,
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex //TODO: Don't modify option
                });

                this.helper
                    .appendTo("body")
                    .disableSelection();

            } else {
                this.helper = this.element;
            }

        },

        _change: {
            e: function (event, dx) {
                return { width: this.originalSize.width + dx };
            },
            w: function (event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { left: sp.left + dx, width: cs.width - dx };
            },
            n: function (event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return { top: sp.top + dy, height: cs.height - dy };
            },
            s: function (event, dx, dy) {
                return { height: this.originalSize.height + dy };
            },
            se: function (event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments),
                    this._change.e.apply(this, [event, dx, dy]));
            },
            sw: function (event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments),
                    this._change.w.apply(this, [event, dx, dy]));
            },
            ne: function (event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments),
                    this._change.e.apply(this, [event, dx, dy]));
            },
            nw: function (event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments),
                    this._change.w.apply(this, [event, dx, dy]));
            }
        },

        _propagate: function (n, event) {
            $.ui.plugin.call(this, n, [event, this.ui()]);
            (n !== "resize" && this._trigger(n, event, this.ui()));
        },

        plugins: {},

        ui: function () {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }

    });

    /*
     * Resizable Extensions
     */

    $.ui.plugin.add("resizable", "animate", {

        stop: function (event) {
            var that = $(this).resizable("instance"),
                o = that.options,
                pr = that._proportionallyResizeElements,
                ista = pr.length && (/textarea/i).test(pr[0].nodeName),
                soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
                soffsetw = ista ? 0 : that.sizeDiff.width,
                style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
                left = (parseInt(that.element.css("left"), 10) +
                    (that.position.left - that.originalPosition.left)) || null,
                top = (parseInt(that.element.css("top"), 10) +
                    (that.position.top - that.originalPosition.top)) || null;

            that.element.animate(
                $.extend(style, top && left ? { top: top, left: left } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function () {

                    var data = {
                        width: parseInt(that.element.css("width"), 10),
                        height: parseInt(that.element.css("height"), 10),
                        top: parseInt(that.element.css("top"), 10),
                        left: parseInt(that.element.css("left"), 10)
                    };

                    if (pr && pr.length) {
                        $(pr[0]).css({ width: data.width, height: data.height });
                    }

                    // propagating resize, and updating values for each animation step
                    that._updateCache(data);
                    that._propagate("resize", event);

                }
            }
            );
        }

    });

    $.ui.plugin.add("resizable", "containment", {

        start: function () {
            var element, p, co, ch, cw, width, height,
                that = $(this).resizable("instance"),
                o = that.options,
                el = that.element,
                oc = o.containment,
                ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

            if (!ce) {
                return;
            }

            that.containerElement = $(ce);

            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };

                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $(ce);
                p = [];
                $(["Top", "Right", "Left", "Bottom"]).each(function (i, name) {
                    p[i] = that._num(element.css("padding" + name));
                });

                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: (element.innerHeight() - p[3]),
                    width: (element.innerWidth() - p[1])
                };

                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = (that._hasScroll(ce, "left") ? ce.scrollWidth : cw);
                height = (that._hasScroll(ce) ? ce.scrollHeight : ch);

                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },

        resize: function (event) {
            var woset, hoset, isParent, isOffsetRelative,
                that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cp = that.position,
                pRatio = that._aspectRatio || event.shiftKey,
                cop = {
                    top: 0,
                    left: 0
                },
                ce = that.containerElement,
                continueResize = true;

            if (ce[0] !== document && (/static/).test(ce.css("position"))) {
                cop = co;
            }

            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width +
                    (that._helper ?
                        (that.position.left - co.left) :
                        (that.position.left - cop.left));

                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }

            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height +
                    (that._helper ?
                        (that.position.top - co.top) :
                        that.position.top);

                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }

            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

            if (isParent && isOffsetRelative) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }

            woset = Math.abs(that.sizeDiff.width +
                (that._helper ?
                    that.offset.left - cop.left :
                    (that.offset.left - co.left)));

            hoset = Math.abs(that.sizeDiff.height +
                (that._helper ?
                    that.offset.top - cop.top :
                    (that.offset.top - co.top)));

            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }

            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }

            if (!continueResize) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },

        stop: function () {
            var that = $(this).resizable("instance"),
                o = that.options,
                co = that.containerOffset,
                cop = that.containerPosition,
                ce = that.containerElement,
                helper = $(that.helper),
                ho = helper.offset(),
                w = helper.outerWidth() - that.sizeDiff.width,
                h = helper.outerHeight() - that.sizeDiff.height;

            if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }

            if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
        }
    });

    $.ui.plugin.add("resizable", "alsoResize", {

        start: function () {
            var that = $(this).resizable("instance"),
                o = that.options;

            $(o.alsoResize).each(function () {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
                    left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
                });
            });
        },

        resize: function (event, ui) {
            var that = $(this).resizable("instance"),
                o = that.options,
                os = that.originalSize,
                op = that.originalPosition,
                delta = {
                    height: (that.size.height - os.height) || 0,
                    width: (that.size.width - os.width) || 0,
                    top: (that.position.top - op.top) || 0,
                    left: (that.position.left - op.left) || 0
                };

            $(o.alsoResize).each(function () {
                var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
                    css = el.parents(ui.originalElement[0]).length ?
                        ["width", "height"] :
                        ["width", "height", "top", "left"];

                $.each(css, function (i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) {
                        style[prop] = sum || null;
                    }
                });

                el.css(style);
            });
        },

        stop: function () {
            $(this).removeData("resizable-alsoresize");
        }
    });

    $.ui.plugin.add("resizable", "ghost", {

        start: function () {

            var that = $(this).resizable("instance"), o = that.options, cs = that.size;

            that.ghost = that.originalElement.clone();
            that.ghost
                .css({
                    opacity: 0.25,
                    display: "block",
                    position: "relative",
                    height: cs.height,
                    width: cs.width,
                    margin: 0,
                    left: 0,
                    top: 0
                })
                .addClass("ui-resizable-ghost")
                .addClass(typeof o.ghost === "string" ? o.ghost : "");

            that.ghost.appendTo(that.helper);

        },

        resize: function () {
            var that = $(this).resizable("instance");
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                });
            }
        },

        stop: function () {
            var that = $(this).resizable("instance");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }

    });

    $.ui.plugin.add("resizable", "grid", {

        resize: function () {
            var outerDimensions,
                that = $(this).resizable("instance"),
                o = that.options,
                cs = that.size,
                os = that.originalSize,
                op = that.originalPosition,
                a = that.axis,
                grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
                gridX = (grid[0] || 1),
                gridY = (grid[1] || 1),
                ox = Math.round((cs.width - os.width) / gridX) * gridX,
                oy = Math.round((cs.height - os.height) / gridY) * gridY,
                newWidth = os.width + ox,
                newHeight = os.height + oy,
                isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
                isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
                isMinWidth = o.minWidth && (o.minWidth > newWidth),
                isMinHeight = o.minHeight && (o.minHeight > newHeight);

            o.grid = grid;

            if (isMinWidth) {
                newWidth += gridX;
            }
            if (isMinHeight) {
                newHeight += gridY;
            }
            if (isMaxWidth) {
                newWidth -= gridX;
            }
            if (isMaxHeight) {
                newHeight -= gridY;
            }

            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                    outerDimensions = that._getPaddingPlusBorderDimensions(this);
                }

                if (newHeight - gridY > 0) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if (newWidth - gridX > 0) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        }

    });

    var resizable = $.ui.resizable;


    /*!
     * jQuery UI Selectable 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/selectable/
     */


    var selectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",

            // callbacks
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function () {
            var selectees,
                that = this;

            this.element.addClass("ui-selectable");

            this.dragged = false;

            // cache selectee children based on filter
            this.refresh = function () {
                selectees = $(that.options.filter, that.element[0]);
                selectees.addClass("ui-selectee");
                selectees.each(function () {
                    var $this = $(this),
                        pos = $this.offset();
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            };
            this.refresh();

            this.selectees = selectees.addClass("ui-selectee");

            this._mouseInit();

            this.helper = $("<div class='ui-selectable-helper'></div>");
        },

        _destroy: function () {
            this.selectees
                .removeClass("ui-selectee")
                .removeData("selectable-item");
            this.element
                .removeClass("ui-selectable ui-selectable-disabled");
            this._mouseDestroy();
        },

        _mouseStart: function (event) {
            var that = this,
                options = this.options;

            this.opos = [event.pageX, event.pageY];

            if (this.options.disabled) {
                return;
            }

            this.selectees = $(options.filter, this.element[0]);

            this._trigger("start", event);

            $(options.appendTo).append(this.helper);
            // position helper (lasso)
            this.helper.css({
                "left": event.pageX,
                "top": event.pageY,
                "width": 0,
                "height": 0
            });

            if (options.autoRefresh) {
                this.refresh();
            }

            this.selectees.filter(".ui-selected").each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    selectee.$element.removeClass("ui-selected");
                    selectee.selected = false;
                    selectee.$element.addClass("ui-unselecting");
                    selectee.unselecting = true;
                    // selectable UNSELECTING callback
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
            });

            $(event.target).parents().addBack().each(function () {
                var doSelect,
                    selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
                    selectee.$element
                        .removeClass(doSelect ? "ui-unselecting" : "ui-selected")
                        .addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
                    // selectable (UN)SELECTING callback
                    if (doSelect) {
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    } else {
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                    return false;
                }
            });

        },

        _mouseDrag: function (event) {

            this.dragged = true;

            if (this.options.disabled) {
                return;
            }

            var tmp,
                that = this,
                options = this.options,
                x1 = this.opos[0],
                y1 = this.opos[1],
                x2 = event.pageX,
                y2 = event.pageY;

            if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
            if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
            this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

            this.selectees.each(function () {
                var selectee = $.data(this, "selectable-item"),
                    hit = false;

                //prevent helper from being selected if appendTo: selectable
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }

                if (options.tolerance === "touch") {
                    hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1));
                } else if (options.tolerance === "fit") {
                    hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
                }

                if (hit) {
                    // SELECT
                    if (selectee.selected) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        selectee.$element.removeClass("ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        selectee.$element.addClass("ui-selecting");
                        selectee.selecting = true;
                        // selectable SELECTING callback
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    }
                } else {
                    // UNSELECT
                    if (selectee.selecting) {
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            selectee.$element.addClass("ui-selected");
                            selectee.selected = true;
                        } else {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                selectee.$element.addClass("ui-unselecting");
                                selectee.unselecting = true;
                            }
                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;

                            selectee.$element.addClass("ui-unselecting");
                            selectee.unselecting = true;
                            // selectable UNSELECTING callback
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                }
            });

            return false;
        },

        _mouseStop: function (event) {
            var that = this;

            this.dragged = false;

            $(".ui-unselecting", this.element[0]).each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            });
            $(".ui-selecting", this.element[0]).each(function () {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                });
            });
            this._trigger("stop", event);

            this.helper.remove();

            return false;
        }

    });


    /*!
     * jQuery UI Sortable 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/sortable/
     */


    var sortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1000,

            // callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },

        _isOverAxis: function (x, reference, size) {
            return (x >= reference) && (x < (reference + size));
        },

        _isFloating: function (item) {
            return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
        },

        _create: function () {
            this.containerCache = {};
            this.element.addClass("ui-sortable");

            //Get the items
            this.refresh();

            //Let's determine the parent's offset
            this.offset = this.element.offset();

            //Initialize mouse events for interaction
            this._mouseInit();

            this._setHandleClassName();

            //We're ready to go
            this.ready = true;

        },

        _setOption: function (key, value) {
            this._super(key, value);

            if (key === "handle") {
                this._setHandleClassName();
            }
        },

        _setHandleClassName: function () {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle");
            $.each(this.items, function () {
                (this.instance.options.handle ?
                    this.item.find(this.instance.options.handle) : this.item)
                    .addClass("ui-sortable-handle");
            });
        },

        _destroy: function () {
            this.element
                .removeClass("ui-sortable ui-sortable-disabled")
                .find(".ui-sortable-handle")
                .removeClass("ui-sortable-handle");
            this._mouseDestroy();

            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }

            return this;
        },

        _mouseCapture: function (event, overrideHandle) {
            var currentItem = null,
                validHandle = false,
                that = this;

            if (this.reverting) {
                return false;
            }

            if (this.options.disabled || this.options.type === "static") {
                return false;
            }

            //We have to refresh the items data once first
            this._refreshItems(event);

            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            $(event.target).parents().each(function () {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }

            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function () {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }

            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;

        },

        _mouseStart: function (event, overrideHandle, noActivation) {

            var i, body,
                o = this.options;

            this.currentContainer = this;

            //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
            this.refreshPositions();

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            //Cache the helper size
            this._cacheHelperProportions();

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Get the next scrolling parent
            this.scrollParent = this.helper.scrollParent();

            //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };

            $.extend(this.offset, {
                click: { //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
            });

            // Only after we got the offset, we can change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");

            //Generate the original position
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Cache the former DOM position
            this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

            //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }

            //Create the placeholder
            this._createPlaceholder();

            //Set a containment if given in the options
            if (o.containment) {
                this._setContainment();
            }

            if (o.cursor && o.cursor !== "auto") { // cursor option
                body = this.document.find("body");

                // support: IE
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);

                this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
            }

            if (o.opacity) { // opacity option
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }

            if (o.zIndex) { // zIndex option
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }

            //Prepare scrolling
            if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }

            //Call callbacks
            this._trigger("start", event, this._uiHash());

            //Recache the helper size
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }


            //Post "activate" events to possible containers
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }

            //Prepare possible droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            this.dragging = true;

            this.helper.addClass("ui-sortable-helper");
            this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
            return true;

        },

        _mouseDrag: function (event) {
            var i, item, itemElement, intersection,
                o = this.options,
                scrolled = false;

            //Compute the helpers position
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");

            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }

            //Do scrolling
            if (this.options.scroll) {
                if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {

                    if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }

                    if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }

                } else {

                    if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
                    } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
                    }

                    if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
                    } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
                    }

                }

                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }

            //Regenerate the absolute position used for position checks
            this.positionAbs = this._convertPositionTo("absolute");

            //Set the helper position
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }

            //Rearrange
            for (i = this.items.length - 1; i >= 0; i--) {

                //Cache variables and intersection, continue if no intersection
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }

                // Only put the placeholder inside the current Container, skip all
                // items from other containers. This works because when moving
                // an item from one container to another the
                // currentContainer is switched before the placeholder is moved.
                //
                // Without this, moving items in "sub-sortables" can cause
                // the placeholder to jitter between the outer and inner container.
                if (item.instance !== this.currentContainer) {
                    continue;
                }

                // cannot intersect with itself
                // no useless actions that have been done before
                // no action if the item moved is the parent of the item checked
                if (itemElement !== this.currentItem[0] &&
                    this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                    !$.contains(this.placeholder[0], itemElement) &&
                    (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
                ) {

                    this.direction = intersection === 1 ? "down" : "up";

                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }

                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }

            //Post events to containers
            this._contactContainers(event);

            //Interconnect with droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            //Call callbacks
            this._trigger("sort", event, this._uiHash());

            this.lastPositionAbs = this.positionAbs;
            return false;

        },

        _mouseStop: function (event, noPropagation) {

            if (!event) {
                return;
            }

            //If we are using droppables, inform the manager about the drop
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }

            if (this.options.revert) {
                var that = this,
                    cur = this.placeholder.offset(),
                    axis = this.options.axis,
                    animation = {};

                if (!axis || axis === "x") {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
                }
                if (!axis || axis === "y") {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
                }
                this.reverting = true;
                $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
                    that._clear(event);
                });
            } else {
                this._clear(event, noPropagation);
            }

            return false;

        },

        cancel: function () {

            if (this.dragging) {

                this._mouseUp({ target: null });

                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }

                //Post deactivating events to containers
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            if (this.placeholder) {
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                    this.helper.remove();
                }

                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });

                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }

            return this;

        },

        serialize: function (o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            o = o || {};

            $(items).each(function () {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
                if (res) {
                    str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });

            if (!str.length && o.key) {
                str.push(o.key + "=");
            }

            return str.join("&");

        },

        toArray: function (o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];

            o = o || {};

            items.each(function () { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
            return ret;

        },

        /* Be careful with the following core functions */
        _intersectsWith: function (item) {

            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElementHeight = (this.options.axis === "x") || ((y1 + dyClick) > t && (y1 + dyClick) < b),
                isOverElementWidth = (this.options.axis === "y") || ((x1 + dxClick) > l && (x1 + dxClick) < r),
                isOverElement = isOverElementHeight && isOverElementWidth;

            if (this.options.tolerance === "pointer" ||
                this.options.forcePointerForContainers ||
                (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
            ) {
                return isOverElement;
            } else {

                return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                    x2 - (this.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                    y2 - (this.helperProportions.height / 2) < b); // Top Half

            }
        },

        _intersectsWithPointer: function (item) {

            var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                isOverElement = isOverElementHeight && isOverElementWidth,
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (!isOverElement) {
                return false;
            }

            return this.floating ?
                (((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1)
                : (verticalDirection && (verticalDirection === "down" ? 2 : 1));

        },

        _intersectsWithSides: function (item) {

            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
                isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (this.floating && horizontalDirection) {
                return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
            } else {
                return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
            }

        },

        _getDragVerticalDirection: function () {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },

        _getDragHorizontalDirection: function () {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },

        refresh: function (event) {
            this._refreshItems(event);
            this._setHandleClassName();
            this.refreshPositions();
            return this;
        },

        _connectWith: function () {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
        },

        _getItemsAsjQuery: function (connected) {

            var i, j, cur, inst,
                items = [],
                queries = [],
                connectWith = this._connectWith();

            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                        }
                    }
                }
            }

            queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

            function addItems() {
                items.push(this);
            }
            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(addItems);
            }

            return $(items);

        },

        _removeCurrentsFromItems: function () {

            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

            this.items = $.grep(this.items, function (item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });

        },

        _refreshItems: function (event) {

            this.items = [];
            this.containers = [this];

            var i, j, cur, inst, targetData, _queries, item, queriesLength,
                items = this.items,
                queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
                connectWith = this._connectWith();

            if (connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
                            this.containers.push(inst);
                        }
                    }
                }
            }

            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];

                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);

                    item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0, height: 0,
                        left: 0, top: 0
                    });
                }
            }

        },

        refreshPositions: function (fast) {

            // Determine whether items are being displayed horizontally
            this.floating = this.items.length ?
                this.options.axis === "x" || this._isFloating(this.items[0].item) :
                false;

            //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }

            var i, item, t, p;

            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];

                //We ignore calculating positions of all connected containers when we're not over them
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                    continue;
                }

                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }

                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }

            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                }
            }

            return this;
        },

        _createPlaceholder: function (that) {
            that = that || this;
            var className,
                o = that.options;

            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function () {

                        var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                            element = $("<" + nodeName + ">", that.document[0])
                                .addClass(className || that.currentItem[0].className + " ui-sortable-placeholder")
                                .removeClass("ui-sortable-helper");

                        if (nodeName === "tbody") {
                            that._createTrPlaceholder(
                                that.currentItem.find("tr").eq(0),
                                $("<tr>", that.document[0]).appendTo(element)
                            );
                        } else if (nodeName === "tr") {
                            that._createTrPlaceholder(that.currentItem, element);
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }

                        if (!className) {
                            element.css("visibility", "hidden");
                        }

                        return element;
                    },
                    update: function (container, p) {

                        // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                        // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }

                        //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                        if (!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)); }
                        if (!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)); }
                    }
                };
            }

            //Create the placeholder
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

            //Append it after the actual current item
            that.currentItem.after(that.placeholder);

            //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update(that, that.placeholder);

        },

        _createTrPlaceholder: function (sourceTr, targetTr) {
            var that = this;

            sourceTr.children().each(function () {
                $("<td>&#160;</td>", that.document[0])
                    .attr("colspan", $(this).attr("colspan") || 1)
                    .appendTo(targetTr);
            });
        },

        _contactContainers: function (event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
                innermostContainer = null,
                innermostIndex = null;

            // get innermost container that intersects with item
            for (i = this.containers.length - 1; i >= 0; i--) {

                // never consider a container that's located within the item itself
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }

                if (this._intersectsWith(this.containers[i].containerCache)) {

                    // if we've already found a container and it's more "inner" than this, then continue
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                        continue;
                    }

                    innermostContainer = this.containers[i];
                    innermostIndex = i;

                } else {
                    // container doesn't intersect. trigger "out" event if necessary
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            // if no intersecting containers found, return
            if (!innermostContainer) {
                return;
            }

            // move the item into the container if it's not there already
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {

                //When entering a new container, we will find the item with the least distance and append our item near it
                dist = 10000;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || this._isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "clientX" : "clientY";

                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }

                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                        nearBottom = true;
                    }

                    if (Math.abs(event[axis] - cur) < dist) {
                        dist = Math.abs(event[axis] - cur);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }

                //Check if dropOnEmpty is enabled
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }

                if (this.currentContainer === this.containers[innermostIndex]) {
                    if (!this.currentContainer.containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                        this.currentContainer.containerCache.over = 1;
                    }
                    return;
                }

                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];

                //Update the placeholder
                this.options.placeholder.update(this.currentContainer, this.placeholder);

                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }


        },

        _createHelper: function (event) {

            var o = this.options,
                helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

            //Add the helper to the DOM if that didn't happen already
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }

            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
            }

            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }

            return helper;

        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if (Array.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _getParentOffset: function () {


            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();

            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            // This needs to be actually done for all browsers, since pageX/pageY includes this information
            // with an ugly IE fix
            if (this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                po = { top: 0, left: 0 };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function () {

            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return { top: 0, left: 0 };
            }

        },

        _cacheMargins: function () {
            this.margins = {
                left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
                top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function () {

            var ce, co, over,
                o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [
                    0 - this.offset.relative.left - this.offset.parent.left,
                    0 - this.offset.relative.top - this.offset.parent.top,
                    o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
                    (o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                ];
            }

            if (!(/^(document|window|parent)$/).test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = ($(ce).css("overflow") !== "hidden");

                this.containment = [
                    co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left,
                    co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top,
                    co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left,
                    co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top
                ];
            }

        },

        _convertPositionTo: function (d, pos) {

            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            return {
                top: (
                    pos.top +																// The absolute mouse position
                    this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)
                ),
                left: (
                    pos.left +																// The absolute mouse position
                    this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod -										// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)
                )
            };

        },

        _generatePosition: function (event) {

            var top, left,
                o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            if (this.originalPosition) { //If we are not dragging yet, we won't check for options

                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? ((top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                    left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? ((left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                }

            }

            return {
                top: (
                    pageY -																// The absolute mouse position
                    this.offset.click.top -													// Click offset (relative to the element)
                    this.offset.relative.top -											// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))
                ),
                left: (
                    pageX -																// The absolute mouse position
                    this.offset.click.left -												// Click offset (relative to the element)
                    this.offset.relative.left -											// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))
                )
            };

        },

        _rearrange: function (event, i, a, hardRefresh) {

            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;

            this._delay(function () {
                if (counter === this.counter) {
                    this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
                }
            });

        },

        _clear: function (event, noPropagation) {

            this.reverting = false;
            // We delay all events that have to be triggered to after the point where the placeholder has been removed and
            // everything else normalized again
            var i,
                delayedTriggers = [];

            // We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;

            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
                this.currentItem.show();
            }

            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function (event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
            }
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                delayedTriggers.push(function (event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
            }

            // Check if the items Container has Changed and trigger appropriate
            // events.
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function (event) { this._trigger("remove", event, this._uiHash()); });
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("receive", event, this._uiHash(this)); }; }).call(this, this.currentContainer));
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("update", event, this._uiHash(this)); }; }).call(this, this.currentContainer));
                }
            }


            //Post events to containers
            function delayEvent(type, instance, container) {
                return function (event) {
                    container._trigger(type, event, instance._uiHash(instance));
                };
            }
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(delayEvent("out", this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }

            //Do what was originally in plugins
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }

            this.dragging = false;

            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }

            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

            if (!this.cancelHelperRemoval) {
                if (this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
            }

            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                } //Trigger all delayed events
                this._trigger("stop", event, this._uiHash());
            }

            this.fromOutside = false;
            return !this.cancelHelperRemoval;

        },

        _trigger: function () {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },

        _uiHash: function (_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }

    });


    /*!
     * jQuery UI Accordion 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/accordion/
     */


    var accordion = $.widget("ui.accordion", {
        version: "1.11.4",
        options: {
            active: 0,
            animate: {},
            collapsible: false,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },

            // callbacks
            activate: null,
            beforeActivate: null
        },

        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },

        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },

        _create: function () {
            var options = this.options;
            this.prevShow = this.prevHide = $();
            this.element.addClass("ui-accordion ui-widget ui-helper-reset")
                // ARIA
                .attr("role", "tablist");

            // don't allow collapsible: false and active: false / null
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }

            this._processPanels();
            // handle negative values
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },

        _getCreateEventData: function () {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next()
            };
        },

        _createIcons: function () {
            var icons = this.options.icons;
            if (icons) {
                $("<span>")
                    .addClass("ui-accordion-header-icon ui-icon " + icons.header)
                    .prependTo(this.headers);
                this.active.children(".ui-accordion-header-icon")
                    .removeClass(icons.header)
                    .addClass(icons.activeHeader);
                this.headers.addClass("ui-accordion-icons");
            }
        },

        _destroyIcons: function () {
            this.headers
                .removeClass("ui-accordion-icons")
                .children(".ui-accordion-header-icon")
                .remove();
        },

        _destroy: function () {
            var contents;

            // clean up main element
            this.element
                .removeClass("ui-accordion ui-widget ui-helper-reset")
                .removeAttr("role");

            // clean up headers
            this.headers
                .removeClass("ui-accordion-header ui-accordion-header-active ui-state-default " +
                    "ui-corner-all ui-state-active ui-state-disabled ui-corner-top")
                .removeAttr("role")
                .removeAttr("aria-expanded")
                .removeAttr("aria-selected")
                .removeAttr("aria-controls")
                .removeAttr("tabIndex")
                .removeUniqueId();

            this._destroyIcons();

            // clean up content panels
            contents = this.headers.next()
                .removeClass("ui-helper-reset ui-widget-content ui-corner-bottom " +
                    "ui-accordion-content ui-accordion-content-active ui-state-disabled")
                .css("display", "")
                .removeAttr("role")
                .removeAttr("aria-hidden")
                .removeAttr("aria-labelledby")
                .removeUniqueId();

            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },

        _setOption: function (key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }

            this._super(key, value);

            // setting collapsible: false while collapsed; open first panel
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }

            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }

            // #5332 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            if (key === "disabled") {
                this.element
                    .toggleClass("ui-state-disabled", !!value)
                    .attr("aria-disabled", value);
                this.headers.add(this.headers.next())
                    .toggleClass("ui-state-disabled", !!value);
            }
        },

        _keydown: function (event) {
            if (event.altKey || event.ctrlKey) {
                return;
            }

            var keyCode = $.ui.keyCode,
                length = this.headers.length,
                currentIndex = this.headers.index(event.target),
                toFocus = false;

            switch (event.keyCode) {
                case keyCode.RIGHT:
                case keyCode.DOWN:
                    toFocus = this.headers[(currentIndex + 1) % length];
                    break;
                case keyCode.LEFT:
                case keyCode.UP:
                    toFocus = this.headers[(currentIndex - 1 + length) % length];
                    break;
                case keyCode.SPACE:
                case keyCode.ENTER:
                    this._eventHandler(event);
                    break;
                case keyCode.HOME:
                    toFocus = this.headers[0];
                    break;
                case keyCode.END:
                    toFocus = this.headers[length - 1];
                    break;
            }

            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                toFocus.focus();
                event.preventDefault();
            }
        },

        _panelKeyDown: function (event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().focus();
            }
        },

        refresh: function () {
            var options = this.options;
            this._processPanels();

            // was collapsed or no panel
            if ((options.active === false && options.collapsible === true) || !this.headers.length) {
                options.active = false;
                this.active = $();
                // active false only when collapsible is true
            } else if (options.active === false) {
                this._activate(0);
                // was active, but active panel is gone
            } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                // all remaining panel are disabled
                if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                    options.active = false;
                    this.active = $();
                    // activate previous panel
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }
                // was active, active panel still exists
            } else {
                // make sure active index is correct
                options.active = this.headers.index(this.active);
            }

            this._destroyIcons();

            this._refresh();
        },

        _processPanels: function () {
            var prevHeaders = this.headers,
                prevPanels = this.panels;

            this.headers = this.element.find(this.options.header)
                .addClass("ui-accordion-header ui-state-default ui-corner-all");

            this.panels = this.headers.next()
                .addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom")
                .filter(":not(.ui-accordion-content-active)")
                .hide();

            // Avoid memory leaks (#10056)
            if (prevPanels) {
                this._off(prevHeaders.not(this.headers));
                this._off(prevPanels.not(this.panels));
            }
        },

        _refresh: function () {
            var maxHeight,
                options = this.options,
                heightStyle = options.heightStyle,
                parent = this.element.parent();

            this.active = this._findActive(options.active)
                .addClass("ui-accordion-header-active ui-state-active ui-corner-top")
                .removeClass("ui-corner-all");
            this.active.next()
                .addClass("ui-accordion-content-active")
                .show();

            this.headers
                .attr("role", "tab")
                .each(function () {
                    var header = $(this),
                        headerId = header.uniqueId().attr("id"),
                        panel = header.next(),
                        panelId = panel.uniqueId().attr("id");
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                })
                .next()
                .attr("role", "tabpanel");

            this.headers
                .not(this.active)
                .attr({
                    "aria-selected": "false",
                    "aria-expanded": "false",
                    tabIndex: -1
                })
                .next()
                .attr({
                    "aria-hidden": "true"
                })
                .hide();

            // make sure at least one header is in the tab order
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                })
                    .next()
                    .attr({
                        "aria-hidden": "false"
                    });
            }

            this._createIcons();

            this._setupEvents(options.event);

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.headers.each(function () {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.headers.next()
                    .each(function () {
                        $(this).height(Math.max(0, maxHeight -
                            $(this).innerHeight() + $(this).height()));
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next()
                    .each(function () {
                        maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                    })
                    .height(maxHeight);
            }
        },

        _activate: function (index) {
            var active = this._findActive(index)[0];

            // trying to activate the already active panel
            if (active === this.active[0]) {
                return;
            }

            // trying to collapse, simulate a click on the currently active header
            active = active || this.active[0];

            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },

        _findActive: function (selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },

        _setupEvents: function (event) {
            var events = {
                keydown: "_keydown"
            };
            if (event) {
                $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), { keydown: "_panelKeyDown" });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },

        _eventHandler: function (event) {
            var options = this.options,
                active = this.active,
                clicked = $(event.currentTarget),
                clickedIsActive = clicked[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : clicked.next(),
                toHide = active.next(),
                eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };

            event.preventDefault();

            if (
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.headers.index(clicked);

            // when the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);

            // switch classes
            // corner classes on the previously active header stay after the animation
            active.removeClass("ui-accordion-header-active ui-state-active");
            if (options.icons) {
                active.children(".ui-accordion-header-icon")
                    .removeClass(options.icons.activeHeader)
                    .addClass(options.icons.header);
            }

            if (!clickedIsActive) {
                clicked
                    .removeClass("ui-corner-all")
                    .addClass("ui-accordion-header-active ui-state-active ui-corner-top");
                if (options.icons) {
                    clicked.children(".ui-accordion-header-icon")
                        .removeClass(options.icons.header)
                        .addClass(options.icons.activeHeader);
                }

                clicked
                    .next()
                    .addClass("ui-accordion-content-active");
            }
        },

        _toggle: function (data) {
            var toShow = data.newPanel,
                toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

            // handle activating a panel during the animation for another activation
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;

            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }

            toHide.attr({
                "aria-hidden": "true"
            });
            toHide.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });
            // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            if (toShow.length && toHide.length) {
                toHide.prev().attr({
                    "tabIndex": -1,
                    "aria-expanded": "false"
                });
            } else if (toShow.length) {
                this.headers.filter(function () {
                    return parseInt($(this).attr("tabIndex"), 10) === 0;
                })
                    .attr("tabIndex", -1);
            }

            toShow
                .attr("aria-hidden", "false")
                .prev()
                .attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                });
        },

        _animate: function (toShow, toHide, data) {
            var total, easing, duration,
                that = this,
                adjust = 0,
                boxSizing = toShow.css("box-sizing"),
                down = toShow.length &&
                    (!toHide.length || (toShow.index() < toHide.index())),
                animate = this.options.animate || {},
                options = down && animate.down || animate,
                complete = function () {
                    that._toggleComplete(data);
                };

            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }
            // fall back from options to animation in case of partial down settings
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;

            if (!toHide.length) {
                return toShow.animate(this.showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(this.hideProps, duration, easing, complete);
            }

            total = toShow.show().outerHeight();
            toHide.animate(this.hideProps, {
                duration: duration,
                easing: easing,
                step: function (now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow
                .hide()
                .animate(this.showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function (now, fx) {
                        fx.now = Math.round(now);
                        if (fx.prop !== "height") {
                            if (boxSizing === "content-box") {
                                adjust += fx.now;
                            }
                        } else if (that.options.heightStyle !== "content") {
                            fx.now = Math.round(total - toHide.outerHeight() - adjust);
                            adjust = 0;
                        }
                    }
                });
        },

        _toggleComplete: function (data) {
            var toHide = data.oldPanel;

            toHide
                .removeClass("ui-accordion-content-active")
                .prev()
                .removeClass("ui-corner-top")
                .addClass("ui-corner-all");

            // Work around for rendering bug in IE (#5421)
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }
            this._trigger("activate", null, data);
        }
    });


    /*!
     * jQuery UI Menu 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/menu/
     */


    var menu = $.widget("ui.menu", {
        version: "1.11.4",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left-1 top",
                at: "right top"
            },
            role: "menu",

            // callbacks
            blur: null,
            focus: null,
            select: null
        },

        _create: function () {
            this.activeMenu = this.element;

            // Flag used to prevent firing of the click handler
            // as the event bubbles up through nested menus
            this.mouseHandled = false;
            this.element
                .uniqueId()
                .addClass("ui-menu ui-widget ui-widget-content")
                .toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length)
                .attr({
                    role: this.options.role,
                    tabIndex: 0
                });

            if (this.options.disabled) {
                this.element
                    .addClass("ui-state-disabled")
                    .attr("aria-disabled", "true");
            }

            this._on({
                // Prevent focus from sticking to links inside menu after clicking
                // them (focus should always stay on UL during navigation).
                "mousedown .ui-menu-item": function (event) {
                    event.preventDefault();
                },
                "click .ui-menu-item": function (event) {
                    var target = $(event.target);
                    if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                        this.select(event);

                        // Only set the mouseHandled flag if the event will bubble, see #9469.
                        if (!event.isPropagationStopped()) {
                            this.mouseHandled = true;
                        }

                        // Open submenu on click
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus") && $(this.document[0].activeElement).closest(".ui-menu").length) {

                            // Redirect focus to the menu
                            this.element.trigger("focus", [true]);

                            // If the active item is on the top level, let it stay active.
                            // Otherwise, blur the active item since it is no longer visible.
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function (event) {
                    // Ignore mouse events while typeahead is active, see #10458.
                    // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
                    // is over an item in the menu
                    if (this.previousFilter) {
                        return;
                    }
                    var target = $(event.currentTarget);
                    // Remove ui-state-active class from siblings of the newly focused menu item
                    // to avoid a jump caused by adjacent elements both having a class with a border
                    target.siblings(".ui-state-active").removeClass("ui-state-active");
                    this.focus(event, target);
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function (event, keepActiveItem) {
                    // If there's already an active item, keep it active
                    // If not, activate the first item
                    var item = this.active || this.element.find(this.options.items).eq(0);

                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function (event) {
                    this._delay(function () {
                        if (!$.contains(this.element[0], this.document[0].activeElement)) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });

            this.refresh();

            // Clicks outside of a menu collapse any open menus
            this._on(this.document, {
                click: function (event) {
                    if (this._closeOnDocumentClick(event)) {
                        this.collapseAll(event);
                    }

                    // Reset the mouseHandled flag
                    this.mouseHandled = false;
                }
            });
        },

        _destroy: function () {
            // Destroy (sub)menus
            this.element
                .removeAttr("aria-activedescendant")
                .find(".ui-menu").addBack()
                .removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front")
                .removeAttr("role")
                .removeAttr("tabIndex")
                .removeAttr("aria-labelledby")
                .removeAttr("aria-expanded")
                .removeAttr("aria-hidden")
                .removeAttr("aria-disabled")
                .removeUniqueId()
                .show();

            // Destroy menu items
            this.element.find(".ui-menu-item")
                .removeClass("ui-menu-item")
                .removeAttr("role")
                .removeAttr("aria-disabled")
                .removeUniqueId()
                .removeClass("ui-state-hover")
                .removeAttr("tabIndex")
                .removeAttr("role")
                .removeAttr("aria-haspopup")
                .children().each(function () {
                    var elem = $(this);
                    if (elem.data("ui-menu-submenu-carat")) {
                        elem.remove();
                    }
                });

            // Destroy menu dividers
            this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },

        _keydown: function (event) {
            var match, prev, character, skip,
                preventDefault = true;

            switch (event.keyCode) {
                case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;
                case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;
                case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;
                case $.ui.keyCode.UP:
                    this.previous(event);
                    break;
                case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;
                case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;
                case $.ui.keyCode.RIGHT:
                    if (this.active && !this.active.is(".ui-state-disabled")) {
                        this.expand(event);
                    }
                    break;
                case $.ui.keyCode.ENTER:
                case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;
                case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;
                default:
                    preventDefault = false;
                    prev = this.previousFilter || "";
                    character = String.fromCharCode(event.keyCode);
                    skip = false;

                    clearTimeout(this.filterTimer);

                    if (character === prev) {
                        skip = true;
                    } else {
                        character = prev + character;
                    }

                    match = this._filterMenuItems(character);
                    match = skip && match.index(this.active.next()) !== -1 ?
                        this.active.nextAll(".ui-menu-item") :
                        match;

                    // If no matches on the current filter, reset to the last character pressed
                    // to move down the menu to the first item that starts with that character
                    if (!match.length) {
                        character = String.fromCharCode(event.keyCode);
                        match = this._filterMenuItems(character);
                    }

                    if (match.length) {
                        this.focus(event, match);
                        this.previousFilter = character;
                        this.filterTimer = this._delay(function () {
                            delete this.previousFilter;
                        }, 1000);
                    } else {
                        delete this.previousFilter;
                    }
            }

            if (preventDefault) {
                event.preventDefault();
            }
        },

        _activate: function (event) {
            if (!this.active.is(".ui-state-disabled")) {
                if (this.active.is("[aria-haspopup='true']")) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },

        refresh: function () {
            var menus, items,
                that = this,
                icon = this.options.icons.submenu,
                submenus = this.element.find(this.options.menus);

            this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length);

            // Initialize nested menus
            submenus.filter(":not(.ui-menu)")
                .addClass("ui-menu ui-widget ui-widget-content ui-front")
                .hide()
                .attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                })
                .each(function () {
                    var menu = $(this),
                        item = menu.parent(),
                        submenuCarat = $("<span>")
                            .addClass("ui-menu-icon ui-icon " + icon)
                            .data("ui-menu-submenu-carat", true);

                    item
                        .attr("aria-haspopup", "true")
                        .prepend(submenuCarat);
                    menu.attr("aria-labelledby", item.attr("id"));
                });

            menus = submenus.add(this.element);
            items = menus.find(this.options.items);

            // Initialize menu-items containing spaces and/or dashes only as dividers
            items.not(".ui-menu-item").each(function () {
                var item = $(this);
                if (that._isDivider(item)) {
                    item.addClass("ui-widget-content ui-menu-divider");
                }
            });

            // Don't refresh list items that are already adapted
            items.not(".ui-menu-item, .ui-menu-divider")
                .addClass("ui-menu-item")
                .uniqueId()
                .attr({
                    tabIndex: -1,
                    role: this._itemRole()
                });

            // Add aria-disabled attribute to any disabled menu item
            items.filter(".ui-state-disabled").attr("aria-disabled", "true");

            // If the active item has been removed, blur the menu
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },

        _itemRole: function () {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },

        _setOption: function (key, value) {
            if (key === "icons") {
                this.element.find(".ui-menu-icon")
                    .removeClass(this.options.icons.submenu)
                    .addClass(value.submenu);
            }
            if (key === "disabled") {
                this.element
                    .toggleClass("ui-state-disabled", !!value)
                    .attr("aria-disabled", value);
            }
            this._super(key, value);
        },

        focus: function (event, item) {
            var nested, focused;
            this.blur(event, event && event.type === "focus");

            this._scrollIntoView(item);

            this.active = item.first();
            focused = this.active.addClass("ui-state-focus").removeClass("ui-state-active");
            // Only update aria-activedescendant if there's a role
            // otherwise we assume focus is managed elsewhere
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }

            // Highlight active parent menu item, if any
            this.active
                .parent()
                .closest(".ui-menu-item")
                .addClass("ui-state-active");

            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function () {
                    this._close();
                }, this.delay);
            }

            nested = item.children(".ui-menu");
            if (nested.length && event && (/^mouse/.test(event.type))) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();

            this._trigger("focus", event, { item: item });
        },

        _scrollIntoView: function (item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.outerHeight();

                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },

        blur: function (event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }

            if (!this.active) {
                return;
            }

            this.active.removeClass("ui-state-focus");
            this.active = null;

            this._trigger("blur", event, { item: this.active });
        },

        _startOpening: function (submenu) {
            clearTimeout(this.timer);

            // Don't open if already open fixes a Firefox bug that caused a .5 pixel
            // shift in the submenu position when mousing over the carat icon
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }

            this.timer = this._delay(function () {
                this._close();
                this._open(submenu);
            }, this.delay);
        },

        _open: function (submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);

            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
                .hide()
                .attr("aria-hidden", "true");

            submenu
                .show()
                .removeAttr("aria-hidden")
                .attr("aria-expanded", "true")
                .position(position);
        },

        collapseAll: function (event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function () {
                // If we were passed an event, look for the submenu that contains the event
                var currentMenu = all ? this.element :
                    $(event && event.target).closest(this.element.find(".ui-menu"));

                // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }

                this._close(currentMenu);

                this.blur(event);
                this.activeMenu = currentMenu;
            }, this.delay);
        },

        // With no arguments, closes the currently active menu - if nothing is active
        // it closes all menus.  If passed an argument, it will search for menus BELOW
        _close: function (startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }

            startMenu
                .find(".ui-menu")
                .hide()
                .attr("aria-hidden", "true")
                .attr("aria-expanded", "false")
                .end()
                .find(".ui-state-active").not(".ui-state-focus")
                .removeClass("ui-state-active");
        },

        _closeOnDocumentClick: function (event) {
            return !$(event.target).closest(".ui-menu").length;
        },

        _isDivider: function (item) {

            // Match hyphen, em dash, en dash
            return !/[^\-\u2014\u2013\s]/.test(item.text());
        },

        collapse: function (event) {
            var newItem = this.active &&
                this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },

        expand: function (event) {
            var newItem = this.active &&
                this.active
                    .children(".ui-menu ")
                    .find(this.options.items)
                    .first();

            if (newItem && newItem.length) {
                this._open(newItem.parent());

                // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
                this._delay(function () {
                    this.focus(event, newItem);
                });
            }
        },

        next: function (event) {
            this._move("next", "first", event);
        },

        previous: function (event) {
            this._move("prev", "last", event);
        },

        isFirstItem: function () {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },

        isLastItem: function () {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },

        _move: function (direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active
                    [direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item")
                        .eq(-1);
                } else {
                    next = this.active
                    [direction + "All"](".ui-menu-item")
                        .eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.find(this.options.items)[filter]();
            }

            this.focus(event, next);
        },

        nextPage: function (event) {
            var item, base, height;

            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items)
                [!this.active ? "first" : "last"]());
            }
        },

        previousPage: function (event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function () {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });

                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items).first());
            }
        },

        _hasScroll: function () {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },

        select: function (event) {
            // TODO: It should never be possible to not have an active item at this
            // point, but the tests don't trigger mouseenter before click.
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = { item: this.active };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        },

        _filterMenuItems: function (character) {
            var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
                regex = new RegExp("^" + escapedCharacter, "i");

            return this.activeMenu
                .find(this.options.items)

                // Only match on items, not dividers or other content (#10571)
                .filter(".ui-menu-item")
                .filter(function () {
                    return regex.test($(this).text().trim());
                });
        }
    });


    /*!
     * jQuery UI Autocomplete 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/autocomplete/
     */


    $.widget("ui.autocomplete", {
        version: "1.11.4",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,

            // callbacks
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },

        requestIndex: 0,
        pending: 0,

        _create: function () {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                nodeName = this.element[0].nodeName.toLowerCase(),
                isTextarea = nodeName === "textarea",
                isInput = nodeName === "input";

            this.isMultiLine =
                // Textareas are always multi-line
                isTextarea ? true :
                    // Inputs are always single-line, even if inside a contentEditable element
                    // IE also treats inputs as contentEditable
                    isInput ? false :
                        // All other element types are determined by whether or not they're contentEditable
                        this.element.prop("isContentEditable");

            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;

            this.element
                .addClass("ui-autocomplete-input")
                .attr("autocomplete", "off");

            this._on(this.element, {
                keydown: function (event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }

                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:
                            // when menu is open and has focus
                            if (this.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                if (!this.isMultiLine) {
                                    this._value(this.term);
                                }
                                this.close(event);
                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;
                        default:
                            suppressKeyPressRepeat = true;
                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                    }
                },
                keypress: function (event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (!this.isMultiLine || this.menu.element.is(":visible")) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }

                    // replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                    }
                },
                input: function (event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function () {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function (event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }

                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });

            this._initSource();
            this.menu = $("<ul>")
                .addClass("ui-autocomplete ui-front")
                .appendTo(this._appendTo())
                .menu({
                    // disable ARIA support, the live region takes care of that
                    role: null
                })
                .hide()
                .menu("instance");

            this._on(this.menu.element, {
                mousedown: function (event) {
                    // prevent moving focus out of the text field
                    event.preventDefault();

                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = true;
                    this._delay(function () {
                        delete this.cancelBlur;
                    });

                    // clicking on the scrollbar causes focus to shift to the body
                    // but we can't detect a mouseup or a click immediately afterward
                    // so we have to track the next mousedown and close the menu if
                    // the user clicks somewhere outside of the autocomplete
                    var menuElement = this.menu.element[0];
                    if (!$(event.target).closest(".ui-menu-item").length) {
                        this._delay(function () {
                            var that = this;
                            this.document.one("mousedown", function (event) {
                                if (event.target !== that.element[0] &&
                                    event.target !== menuElement &&
                                    !$.contains(menuElement, event.target)) {
                                    that.close();
                                }
                            });
                        });
                    }
                },
                menufocus: function (event, ui) {
                    var label, item;
                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();

                            this.document.one("mousemove", function () {
                                $(event.target).trigger(event.originalEvent);
                            });

                            return;
                        }
                    }

                    item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, { item: item })) {
                        // use value to match what will end up in the input, if it was a key event
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    }

                    // Announce the value in the liveRegion
                    label = ui.item.attr("aria-label") || item.value;
                    if (label && label.trim().length) {
                        this.liveRegion.children().hide();
                        $("<div>").text(label).appendTo(this.liveRegion);
                    }
                },
                menuselect: function (event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"),
                        previous = this.previous;

                    // only trigger when focus was lost (click on menu)
                    if (this.element[0] !== this.document[0].activeElement) {
                        this.element.focus();
                        this.previous = previous;
                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay(function () {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }

                    if (false !== this._trigger("select", event, { item: item })) {
                        this._value(item.value);
                    }
                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();

                    this.close(event);
                    this.selectedItem = item;
                }
            });

            this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            })
                .addClass("ui-helper-hidden-accessible")
                .appendTo(this.document[0].body);

            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _destroy: function () {
            clearTimeout(this.searching);
            this.element
                .removeClass("ui-autocomplete-input")
                .removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _appendTo: function () {
            var element = this.options.appendTo;

            if (element) {
                element = element.jquery || element.nodeType ?
                    $(element) :
                    this.document.find(element).eq(0);
            }

            if (!element || !element[0]) {
                element = this.element.closest(".ui-front");
            }

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        _initSource: function () {
            var array, url,
                that = this;
            if (Array.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function (request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function (request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function (data) {
                            response(data);
                        },
                        error: function () {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },

        _searchTimeout: function (event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function () {

                // Search if the value has changed, or if the user retypes the same value (see #7434)
                var equalValues = this.term === this._value(),
                    menuVisible = this.menu.element.is(":visible"),
                    modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

                if (!equalValues || (equalValues && !menuVisible && !modifierKey)) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },

        search: function (value, event) {
            value = value != null ? value : this._value();

            // always save the actual value, not the one passed as an argument
            this.term = this._value();

            if (value.length < this.options.minLength) {
                return this.close(event);
            }

            if (this._trigger("search", event) === false) {
                return;
            }

            return this._search(value);
        },

        _search: function (value) {
            this.pending++;
            this.element.addClass("ui-autocomplete-loading");
            this.cancelSearch = false;

            this.source({ term: value }, this._response());
        },

        _response: function () {
            var index = ++this.requestIndex;

            return $.proxy(function (content) {
                if (index === this.requestIndex) {
                    this.__response(content);
                }

                this.pending--;
                if (!this.pending) {
                    this.element.removeClass("ui-autocomplete-loading");
                }
            }, this);
        },

        __response: function (content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, { content: content });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },

        close: function (event) {
            this.cancelSearch = true;
            this._close(event);
        },

        _close: function (event) {
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },

        _change: function (event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, { item: this.selectedItem });
            }
        },

        _normalize: function (items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function (item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label
                });
            });
        },

        _suggest: function (items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();

            // size and position menu
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));

            if (this.options.autoFocus) {
                this.menu.next();
            }
        },

        _resizeMenu: function () {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(
                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width("").outerWidth() + 1,
                this.element.outerWidth()
            ));
        },

        _renderMenu: function (ul, items) {
            var that = this;
            $.each(items, function (index, item) {
                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function (ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },

        _renderItem: function (ul, item) {
            return $("<li>").text(item.label).appendTo(ul);
        },

        _move: function (direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) ||
                this.menu.isLastItem() && /^next/.test(direction)) {

                if (!this.isMultiLine) {
                    this._value(this.term);
                }

                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },

        widget: function () {
            return this.menu.element;
        },

        _value: function () {
            return this.valueMethod.apply(this.element, arguments);
        },

        _keyEvent: function (keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);

                // prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        }
    });

    $.extend($.ui.autocomplete, {
        escapeRegex: function (value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function (array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function (value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });

    // live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function (amount) {
                    return amount + (amount > 1 ? " results are" : " result is") +
                        " available, use up and down arrow keys to navigate.";
                }
            }
        },

        __response: function (content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.children().hide();
            $("<div>").text(message).appendTo(this.liveRegion);
        }
    });

    var autocomplete = $.ui.autocomplete;


    /*!
     * jQuery UI Button 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/button/
     */


    var lastActive,
        baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
        typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
        formResetHandler = function () {
            var form = $(this);
            setTimeout(function () {
                form.find(":ui-button").button("refresh");
            }, 1);
        },
        radioGroup = function (radio) {
            var name = radio.name,
                form = radio.form,
                radios = $([]);
            if (name) {
                name = name.replace(/'/g, "\\'");
                if (form) {
                    radios = $(form).find("[name='" + name + "'][type=radio]");
                } else {
                    radios = $("[name='" + name + "'][type=radio]", radio.ownerDocument)
                        .filter(function () {
                            return !this.form;
                        });
                }
            }
            return radios;
        };

    $.widget("ui.button", {
        version: "1.11.4",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: true,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create: function () {
            this.element.closest("form")
                .unbind("reset" + this.eventNamespace)
                .bind("reset" + this.eventNamespace, formResetHandler);

            if (typeof this.options.disabled !== "boolean") {
                this.options.disabled = !!this.element.prop("disabled");
            } else {
                this.element.prop("disabled", this.options.disabled);
            }

            this._determineButtonType();
            this.hasTitle = !!this.buttonElement.attr("title");

            var that = this,
                options = this.options,
                toggleButton = this.type === "checkbox" || this.type === "radio",
                activeClass = !toggleButton ? "ui-state-active" : "";

            if (options.label === null) {
                options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
            }

            this._hoverable(this.buttonElement);

            this.buttonElement
                .addClass(baseClasses)
                .attr("role", "button")
                .bind("mouseenter" + this.eventNamespace, function () {
                    if (options.disabled) {
                        return;
                    }
                    if (this === lastActive) {
                        $(this).addClass("ui-state-active");
                    }
                })
                .bind("mouseleave" + this.eventNamespace, function () {
                    if (options.disabled) {
                        return;
                    }
                    $(this).removeClass(activeClass);
                })
                .bind("click" + this.eventNamespace, function (event) {
                    if (options.disabled) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                    }
                });

            // Can't use _focusable() because the element that receives focus
            // and the element that gets the ui-state-focus class are different
            this._on({
                focus: function () {
                    this.buttonElement.addClass("ui-state-focus");
                },
                blur: function () {
                    this.buttonElement.removeClass("ui-state-focus");
                }
            });

            if (toggleButton) {
                this.element.bind("change" + this.eventNamespace, function () {
                    that.refresh();
                });
            }

            if (this.type === "checkbox") {
                this.buttonElement.bind("click" + this.eventNamespace, function () {
                    if (options.disabled) {
                        return false;
                    }
                });
            } else if (this.type === "radio") {
                this.buttonElement.bind("click" + this.eventNamespace, function () {
                    if (options.disabled) {
                        return false;
                    }
                    $(this).addClass("ui-state-active");
                    that.buttonElement.attr("aria-pressed", "true");

                    var radio = that.element[0];
                    radioGroup(radio)
                        .not(radio)
                        .map(function () {
                            return $(this).button("widget")[0];
                        })
                        .removeClass("ui-state-active")
                        .attr("aria-pressed", "false");
                });
            } else {
                this.buttonElement
                    .bind("mousedown" + this.eventNamespace, function () {
                        if (options.disabled) {
                            return false;
                        }
                        $(this).addClass("ui-state-active");
                        lastActive = this;
                        that.document.one("mouseup", function () {
                            lastActive = null;
                        });
                    })
                    .bind("mouseup" + this.eventNamespace, function () {
                        if (options.disabled) {
                            return false;
                        }
                        $(this).removeClass("ui-state-active");
                    })
                    .bind("keydown" + this.eventNamespace, function (event) {
                        if (options.disabled) {
                            return false;
                        }
                        if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                            $(this).addClass("ui-state-active");
                        }
                    })
                    // see #8559, we bind to blur here in case the button element loses
                    // focus between keydown and keyup, it would be left in an "active" state
                    .bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function () {
                        $(this).removeClass("ui-state-active");
                    });

                if (this.buttonElement.is("a")) {
                    this.buttonElement.keyup(function (event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            // TODO pass through original event correctly (just as 2nd argument doesn't work)
                            $(this).click();
                        }
                    });
                }
            }

            this._setOption("disabled", options.disabled);
            this._resetButton();
        },

        _determineButtonType: function () {
            var ancestor, labelSelector, checked;

            if (this.element.is("[type=checkbox]")) {
                this.type = "checkbox";
            } else if (this.element.is("[type=radio]")) {
                this.type = "radio";
            } else if (this.element.is("input")) {
                this.type = "input";
            } else {
                this.type = "button";
            }

            if (this.type === "checkbox" || this.type === "radio") {
                // we don't search against the document in case the element
                // is disconnected from the DOM
                ancestor = this.element.parents().last();
                labelSelector = "label[for='" + this.element.attr("id") + "']";
                this.buttonElement = ancestor.find(labelSelector);
                if (!this.buttonElement.length) {
                    ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                    this.buttonElement = ancestor.filter(labelSelector);
                    if (!this.buttonElement.length) {
                        this.buttonElement = ancestor.find(labelSelector);
                    }
                }
                this.element.addClass("ui-helper-hidden-accessible");

                checked = this.element.is(":checked");
                if (checked) {
                    this.buttonElement.addClass("ui-state-active");
                }
                this.buttonElement.prop("aria-pressed", checked);
            } else {
                this.buttonElement = this.element;
            }
        },

        widget: function () {
            return this.buttonElement;
        },

        _destroy: function () {
            this.element
                .removeClass("ui-helper-hidden-accessible");
            this.buttonElement
                .removeClass(baseClasses + " ui-state-active " + typeClasses)
                .removeAttr("role")
                .removeAttr("aria-pressed")
                .html(this.buttonElement.find(".ui-button-text").html());

            if (!this.hasTitle) {
                this.buttonElement.removeAttr("title");
            }
        },

        _setOption: function (key, value) {
            this._super(key, value);
            if (key === "disabled") {
                this.widget().toggleClass("ui-state-disabled", !!value);
                this.element.prop("disabled", !!value);
                if (value) {
                    if (this.type === "checkbox" || this.type === "radio") {
                        this.buttonElement.removeClass("ui-state-focus");
                    } else {
                        this.buttonElement.removeClass("ui-state-focus ui-state-active");
                    }
                }
                return;
            }
            this._resetButton();
        },

        refresh: function () {
            //See #8237 & #8828
            var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");

            if (isDisabled !== this.options.disabled) {
                this._setOption("disabled", isDisabled);
            }
            if (this.type === "radio") {
                radioGroup(this.element[0]).each(function () {
                    if ($(this).is(":checked")) {
                        $(this).button("widget")
                            .addClass("ui-state-active")
                            .attr("aria-pressed", "true");
                    } else {
                        $(this).button("widget")
                            .removeClass("ui-state-active")
                            .attr("aria-pressed", "false");
                    }
                });
            } else if (this.type === "checkbox") {
                if (this.element.is(":checked")) {
                    this.buttonElement
                        .addClass("ui-state-active")
                        .attr("aria-pressed", "true");
                } else {
                    this.buttonElement
                        .removeClass("ui-state-active")
                        .attr("aria-pressed", "false");
                }
            }
        },

        _resetButton: function () {
            if (this.type === "input") {
                if (this.options.label) {
                    this.element.val(this.options.label);
                }
                return;
            }
            var buttonElement = this.buttonElement.removeClass(typeClasses),
                buttonText = $("<span></span>", this.document[0])
                    .addClass("ui-button-text")
                    .html(this.options.label)
                    .appendTo(buttonElement.empty())
                    .text(),
                icons = this.options.icons,
                multipleIcons = icons.primary && icons.secondary,
                buttonClasses = [];

            if (icons.primary || icons.secondary) {
                if (this.options.text) {
                    buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : (icons.primary ? "-primary" : "-secondary")));
                }

                if (icons.primary) {
                    buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
                }

                if (icons.secondary) {
                    buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
                }

                if (!this.options.text) {
                    buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");

                    if (!this.hasTitle) {
                        buttonElement.attr("title", buttonText.trim());
                    }
                }
            } else {
                buttonClasses.push("ui-button-text-only");
            }
            buttonElement.addClass(buttonClasses.join(" "));
        }
    });

    $.widget("ui.buttonset", {
        version: "1.11.4",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },

        _create: function () {
            this.element.addClass("ui-buttonset");
        },

        _init: function () {
            this.refresh();
        },

        _setOption: function (key, value) {
            if (key === "disabled") {
                this.buttons.button("option", key, value);
            }

            this._super(key, value);
        },

        refresh: function () {
            var rtl = this.element.css("direction") === "rtl",
                allButtons = this.element.find(this.options.items),
                existingButtons = allButtons.filter(":ui-button");

            // Initialize new buttons
            allButtons.not(":ui-button").button();

            // Refresh existing buttons
            existingButtons.button("refresh");

            this.buttons = allButtons
                .map(function () {
                    return $(this).button("widget")[0];
                })
                .removeClass("ui-corner-all ui-corner-left ui-corner-right")
                .filter(":first")
                .addClass(rtl ? "ui-corner-right" : "ui-corner-left")
                .end()
                .filter(":last")
                .addClass(rtl ? "ui-corner-left" : "ui-corner-right")
                .end()
                .end();
        },

        _destroy: function () {
            this.element.removeClass("ui-buttonset");
            this.buttons
                .map(function () {
                    return $(this).button("widget")[0];
                })
                .removeClass("ui-corner-left ui-corner-right")
                .end()
                .button("destroy");
        }
    });

    var button = $.ui.button;


    /*!
     * jQuery UI Datepicker 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/datepicker/
     */


    $.extend($.ui, { datepicker: { version: "1.11.4" } });

    var datepicker_instActive;

    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {
                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }

        return 0;
    }
    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */

    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[""] = { // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"], // Names of months for drop-down and formatting
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "" // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
            // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
            // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false // The initial disabled state
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }

    $.extend(Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",

        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,

        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function () {
            return this.dpDiv;
        },

        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function (settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function (target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = (nodeName === "div" || nodeName === "span");
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },

        /* Create a new instance object. */
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
            return {
                id: id, input: target, // associated target
                selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
                drawMonth: 0, drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: (!inline ? this.dpDiv : // presentation div
                    datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
            };
        },

        /* Attach the date picker to an input field. */
        _connectDatepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).
                keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);
            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },

        /* Make attachments based on settings. */
        _attachments: function (input, inst) {
            var showOn, buttonText, buttonImage,
                appendText = this._get(inst, "appendText"),
                isRTL = this._get(inst, "isRTL");

            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }

            input.unbind("focus", this._showDatepicker);

            if (inst.trigger) {
                inst.trigger.remove();
            }

            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                input.focus(this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                    $("<img/>").addClass(this._triggerClass).
                        attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
                    $("<button type='button'></button>").addClass(this._triggerClass).
                        html(!buttonImage ? buttonText : $("<img/>").attr(
                            { src: buttonImage, alt: buttonText, title: buttonText })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.click(function () {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },

        /* Apply the maximum length for the date format. */
        _autoSize: function (inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i,
                    date = new Date(2009, 12 - 1, 20), // Ensure double digits
                    dateFormat = this._get(inst, "dateFormat");

                if (dateFormat.match(/[DM]/)) {
                    findMax = function (names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                        "monthNames" : "monthNamesShort"))));
                    date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                        "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },

        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function (target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css("display", "block");
        },

        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date	string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *					event - with x/y coordinates or
         *					leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function (input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY,
                inst = this._dialogInst; // internal instance

            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id +
                    "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
            this._dialogInput.val(date);

            this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
            }

            // move input on screen for focus, but hidden behind dialog
            this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },

        /* Detach a datepicker from its control.
         * @param  target	element - the target input field or division or span
         */
        _destroyDatepicker: function (target) {
            var nodeName,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).
                    unbind("focus", this._showDatepicker).
                    unbind("keydown", this._doKeyDown).
                    unbind("keypress", this._doKeyPress).
                    unbind("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }

            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
            }
        },

        /* Enable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _enableDatepicker: function (target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").
                    each(function () { this.disabled = false; }).end().
                    filter("img").css({ opacity: "1.0", cursor: "" });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                    prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function (value) { return (value === target ? null : value); }); // delete entry
        },

        /* Disable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _disableDatepicker: function (target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").
                    each(function () { this.disabled = true; }).end().
                    filter("img").css({ opacity: "0.5", cursor: "default" });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                    prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function (value) { return (value === target ? null : value); }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = target;
        },

        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target	element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function (target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },

        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function (target) {
            try {
                return $.data(target, "datepicker");
            }
            catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },

        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name	object - the new settings to update or
         *				string - the name of the setting to change or retrieve,
         *				when retrieving also "all" for all instance settings or
         *				"defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *				(omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function (target, name, value) {
            var settings, date, minDate, maxDate,
                inst = this._getInst(target);

            if (arguments.length === 2 && typeof name === "string") {
                return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                    (inst ? (name === "all" ? $.extend({}, inst.settings) :
                        this._get(inst, name)) : null));
            }

            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }

            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }

                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },

        // change method deprecated
        _changeDatepicker: function (target, name, value) {
            this._optionDatepicker(target, name, value);
        },

        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function (target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },

        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date	Date - the new date
         */
        _setDateDatepicker: function (target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },

        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function (target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return (inst ? this._getDate(inst) : null);
        },

        /* Handle keystrokes. */
        _doKeyDown: function (event) {
            var onSelect, dateStr, sel,
                inst = $.datepicker._getInst(event.target),
                handled = true,
                isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                    case 9: $.datepicker._hideDatepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                        $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }

                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);

                            // trigger custom callback
                            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }

                        return false; // don't submit the form
                    case 27: $.datepicker._hideDatepicker();
                        break; // hide on escape
                    case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                        -$.datepicker._get(inst, "stepBigMonths") :
                        -$.datepicker._get(inst, "stepMonths")), "M");
                        break; // previous month/year on page up/+ ctrl
                    case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                        +$.datepicker._get(inst, "stepBigMonths") :
                        +$.datepicker._get(inst, "stepMonths")), "M");
                        break; // next month/year on page down/+ ctrl
                    case 35: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // clear on ctrl or command +end
                    case 36: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // current on ctrl or command +home
                    case 37: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                -$.datepicker._get(inst, "stepBigMonths") :
                                -$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +left on Mac
                        break;
                    case 38: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // -1 week on ctrl or command +up
                    case 39: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                +$.datepicker._get(inst, "stepBigMonths") :
                                +$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +right
                        break;
                    case 40: if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, "D");
                    }
                        handled = event.ctrlKey || event.metaKey;
                        break; // +1 week on ctrl or command +down
                    default: handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Filter entered characters - based on date format. */
        _doKeyPress: function (event) {
            var chars, chr,
                inst = $.datepicker._getInst(event.target);

            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },

        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function (event) {
            var date,
                inst = $.datepicker._getInst(event.target);

            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                        (inst.input ? inst.input.val() : null),
                        $.datepicker._getFormatConfig(inst));

                    if (date) { // only if valid
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                }
                catch (err) {
                }
            }
            return true;
        },

        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *					event - if triggered by focus
         */
        _showDatepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                input = $("input", input.parentNode)[0];
            }

            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                return;
            }

            var inst, beforeShow, beforeShowSettings, isFixed,
                offset, showAnim, duration;

            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }

            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);

            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);

            if ($.datepicker._inDialog) { // hide cursor
                input.value = "";
            }
            if (!$.datepicker._pos) { // position below input
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight; // add the height
            }

            isFixed = false;
            $(input).parents().each(function () {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });

            offset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] };
            $.datepicker._pos = null;
            //to avoid flashes on Firefox
            inst.dpDiv.empty();
            // determine sizing offscreen
            inst.dpDiv.css({ position: "absolute", display: "block", top: "-1000px" });
            $.datepicker._updateDatepicker(inst);
            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: ($.datepicker._inDialog && $.blockUI ?
                    "static" : (isFixed ? "fixed" : "absolute")), display: "none",
                left: offset.left + "px", top: offset.top + "px"
            });

            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;

                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }

                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }

                $.datepicker._curInst = inst;
            }
        },

        /* Generate the date picker content. */
        _updateDatepicker: function (inst) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            datepicker_instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);

            var origyearshtml,
                numMonths = this._getNumberOfMonths(inst),
                cols = numMonths[1],
                width = 17,
                activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");

            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }

            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                "Class"]("ui-datepicker-rtl");

            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }

            // deffered render of the years select (to avoid flashes on Firefox)
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function () {
                    //assure that inst.yearshtml didn't change.
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },

        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function (inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function (inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

            offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                Math.abs(dpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function (obj) {
            var position,
                inst = this._getInst(obj),
                isRTL = this._get(inst, "isRTL");

            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }

            position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function (input) {
            var showAnim, duration, postProcess, onClose,
                inst = this._curInst;

            if (!inst || (input && inst !== $.data(input, "datepicker"))) {
                return;
            }

            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function () {
                    $.datepicker._tidyDialog(inst);
                };

                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                        (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                }

                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;

                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                }

                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },

        /* Tidy up after a dialog display. */
        _tidyDialog: function (inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },

        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function (event) {
            if (!$.datepicker._curInst) {
                return;
            }

            var $target = $(event.target),
                inst = $.datepicker._getInst($target[0]);

            if ((($target[0].id !== $.datepicker._mainDivId &&
                $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                !$target.hasClass($.datepicker.markerClassName) &&
                !$target.closest("." + $.datepicker._triggerClass).length &&
                $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) ||
                ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
                $.datepicker._hideDatepicker();
            }
        },

        /* Adjust one of the date sub-fields. */
        _adjustDate: function (id, offset, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset +
                (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                period);
            this._updateDatepicker(inst);
        },

        /* Action for current link. */
        _gotoToday: function (id) {
            var date,
                target = $(id),
                inst = this._getInst(target[0]);

            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a new month/year. */
        _selectMonthYear: function (id, select, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            inst["selected" + (period === "M" ? "Month" : "Year")] =
                inst["draw" + (period === "M" ? "Month" : "Year")] =
                parseInt(select.options[select.selectedIndex].value, 10);

            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a day. */
        _selectDay: function (id, month, year, td) {
            var inst,
                target = $(id);

            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }

            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst,
                inst.currentDay, inst.currentMonth, inst.currentYear));
        },

        /* Erase the input field and hide the date picker. */
        _clearDate: function (id) {
            var target = $(id);
            this._selectDate(target, "");
        },

        /* Update the input field with the selected date. */
        _selectDate: function (id, dateStr) {
            var onSelect,
                target = $(id),
                inst = this._getInst(target[0]);

            dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);

            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
            } else if (inst.input) {
                inst.input.trigger("change"); // fire the change event
            }

            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof (inst.input[0]) !== "object") {
                    inst.input.focus(); // restore focus
                }
                this._lastInput = null;
            }
        },

        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function (inst) {
            var altFormat, date, dateStr,
                altField = this._get(inst, "altField");

            if (altField) { // update alternate field too
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function () { $(this).val(dateStr); });
            }
        },

        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function (date) {
            var day = date.getDay();
            return [(day > 0 && day < 6), ""];
        },

        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function (date) {
            var time,
                checkDate = new Date(date.getTime());

            // Find Thursday of this week starting on Monday
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

            time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },

        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *					shortYearCutoff  number - the cutoff year for determining the century (optional)
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function (format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }

            value = (typeof value === "object" ? value.toString() : value + "");
            if (value === "") {
                return null;
            }

            var iFormat, dim, extra,
                iValue = 0,
                shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Extract a number from the string value
                getNumber = function (match) {
                    var isDoubled = lookAhead(match),
                        size = (match === "@" ? 14 : (match === "!" ? 20 :
                            (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                        minSize = (match === "y" ? size : 1),
                        digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
                        num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                },
                // Extract a name from the string value and convert to an index
                getName = function (match, shortNames, longNames) {
                    var index = -1,
                        names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                            return [[k, v]];
                        }).sort(function (a, b) {
                            return -(a[1].length - b[1].length);
                        });

                    $.each(names, function (i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },
                // Confirm that a literal character matches the string value
                checkLiteral = function () {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            day = getNumber("d");
                            break;
                        case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;
                        case "o":
                            doy = getNumber("o");
                            break;
                        case "m":
                            month = getNumber("m");
                            break;
                        case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;
                        case "y":
                            year = getNumber("y");
                            break;
                        case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }

            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }

            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    (year <= shortYearCutoff ? 0 : -100);
            }

            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }

            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },

        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601

        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function (format, date, settings) {
            if (!date) {
                return "";
            }

            var iFormat,
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Format a number, with leading zero if necessary
                formatNumber = function (match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },
                // Format a name, short or long as requested
                formatName = function (match, value, shortNames, longNames) {
                    return (lookAhead(match) ? longNames[value] : shortNames[value]);
                },
                output = "",
                literal = false;

            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;
                            case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;
                            case "o":
                                output += formatNumber("o",
                                    Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                break;
                            case "m":
                                output += formatNumber("m", date.getMonth() + 1, 2);
                                break;
                            case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;
                            case "y":
                                output += (lookAhead("y") ? date.getFullYear() :
                                    (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },

        /* Extract all possible characters from the date format. */
        _possibleChars: function (format) {
            var iFormat,
                chars = "",
                literal = false,
                // Check whether a format character is doubled
                lookAhead = function (match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d": case "m": case "y": case "@":
                            chars += "0123456789";
                            break;
                        case "D": case "M":
                            return null; // Accept anything
                        case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function (inst, name) {
            return inst.settings[name] !== undefined ?
                inst.settings[name] : this._defaults[name];
        },

        /* Parse existing date and initialise date picker. */
        _setDateFromField: function (inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }

            var dateFormat = this._get(inst, "dateFormat"),
                dates = inst.lastVal = inst.input ? inst.input.val() : null,
                defaultDate = this._getDefaultDate(inst),
                date = defaultDate,
                settings = this._getFormatConfig(inst);

            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = (noDefault ? "" : dates);
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = (dates ? date.getDate() : 0);
            inst.currentMonth = (dates ? date.getMonth() : 0);
            inst.currentYear = (dates ? date.getFullYear() : 0);
            this._adjustInstDate(inst);
        },

        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function (inst) {
            return this._restrictMinMax(inst,
                this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },

        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function (inst, date, defaultDate) {
            var offsetNumeric = function (offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            },
                offsetString = function (offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                            offset, $.datepicker._getFormatConfig(inst));
                    }
                    catch (e) {
                        // Ignore
                    }

                    var date = (offset.toLowerCase().match(/^c/) ?
                        $.datepicker._getDate(inst) : null) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec(offset);

                    while (matches) {
                        switch (matches[2] || "d") {
                            case "d": case "D":
                                day += parseInt(matches[1], 10); break;
                            case "w": case "W":
                                day += parseInt(matches[1], 10) * 7; break;
                            case "m": case "M":
                                month += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                            case "y": case "Y":
                                year += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                },
                newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                    (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

            newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },

        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function (date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },

        /* Set the date(s) directly. */
        _setDate: function (inst, date, noChange) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },

        /* Retrieve the date(s) directly. */
        _getDate: function (inst) {
            var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                this._daylightSavingAdjust(new Date(
                    inst.currentYear, inst.currentMonth, inst.currentDay)));
            return startDate;
        },

        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function (inst) {
            var stepMonths = this._get(inst, "stepMonths"),
                id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function () {
                var handler = {
                    prev: function () {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function () {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function () {
                        $.datepicker._hideDatepicker();
                    },
                    today: function () {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function () {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function () {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function () {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },

        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function (inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                isRTL = this._get(inst, "isRTL"),
                showButtonPanel = this._get(inst, "showButtonPanel"),
                hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                numMonths = this._getNumberOfMonths(inst),
                showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                stepMonths = this._get(inst, "stepMonths"),
                isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                    new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;

            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                    maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;

            prevText = this._get(inst, "prevText");
            prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                this._getFormatConfig(inst)));

            prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

            nextText = this._get(inst, "nextText");
            nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                this._getFormatConfig(inst)));

            next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

            currentText = this._get(inst, "currentText");
            gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
            currentText = (!navigationAsDateFormat ? currentText :
                this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

            controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get(inst, "closeText") + "</button>" : "");

            buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                    ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = (isNaN(firstDay) ? 0 : firstDay);

            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                                case 0: calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
                                case numMonths[1] - 1: calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
                                default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                        (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                        (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                        this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                            row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                    for (dow = 0; dow < 7; dow++) { // days of the week
                        day = (dow + firstDay) % 7;
                        thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                            "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                    numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                        calender += "<tr>";
                        tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get(inst, "calculateWeek")(printDate) + "</td>");
                        for (dow = 0; dow < 7; dow++) { // create date picker days
                            daySettings = (beforeShowDay ?
                                beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                            otherMonth = (printDate.getMonth() !== drawMonth);
                            unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                            tbody += "<td class='" +
                                ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                                (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                                ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                                    (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                                    // or defaultDate is current printedDate and defaultDate is selectedDate
                                    " " + this._dayOverClass : "") + // highlight selected day
                                (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") +  // highlight unselectable days
                                (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                    (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                                    (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                                ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                                (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                                (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                    (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                        (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                                        (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                                        (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                        "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                        ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },

        /* Generate the month and year header. */
        _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate,
            secondary, monthNames, monthNamesShort) {

            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                changeMonth = this._get(inst, "changeMonth"),
                changeYear = this._get(inst, "changeYear"),
                showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";

            // month selection
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = (minDate && minDate.getFullYear() === drawYear);
                inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" +
                            (month === drawMonth ? " selected='selected'" : "") +
                            ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }

            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }

            // year selection
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    // determine range of years to display
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function (value) {
                        var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                            (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                                parseInt(value, 10)));
                        return (isNaN(year) ? thisYear : year);
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                    endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (; year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" +
                            (year === drawYear ? " selected='selected'" : "") +
                            ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";

                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }

            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },

        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function (inst, offset, period) {
            var year = inst.drawYear + (period === "Y" ? offset : 0),
                month = inst.drawMonth + (period === "M" ? offset : 0),
                day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },

        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function (inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                newDate = (minDate && date < minDate ? minDate : date);
            return (maxDate && newDate > maxDate ? maxDate : newDate);
        },

        /* Notify change of month/year. */
        _notifyChange: function (inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply((inst.input ? inst.input[0] : null),
                    [inst.selectedYear, inst.selectedMonth + 1, inst]);
            }
        },

        /* Determine the number of months to show. */
        _getNumberOfMonths: function (inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
        },

        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function (inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },

        /* Find the number of days in a given month. */
        _getDaysInMonth: function (year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },

        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function (year, month) {
            return new Date(year, month, 1).getDay();
        },

        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function (inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst),
                date = this._daylightSavingAdjust(new Date(curYear,
                    curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },

        /* Is the given date in the accepted range? */
        _isInRange: function (inst, date) {
            var yearSplit, currentYear,
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                minYear = null,
                maxYear = null,
                years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }

            return ((!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()) &&
                (!minYear || date.getFullYear() >= minYear) &&
                (!maxYear || date.getFullYear() <= maxYear));
        },

        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function (inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")
            };
        },

        /* Format the given date for display. */
        _formatDate: function (inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = (day ? (typeof day === "object" ? day :
                this._daylightSavingAdjust(new Date(year, month, day))) :
                this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });

    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function () {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        })
            .delegate(selector, "mouseover", datepicker_handleMouseover);
    }

    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
            $(this).addClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).addClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).addClass("ui-datepicker-next-hover");
            }
        }
    }

    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }

    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
                        Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function (options) {

        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if (!this.length) {
            return this;
        }

        /* Initialise the date picker. */
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }

        /* Append datepicker main container to body if not exist. */
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].
                apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].
                apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function () {
            typeof options === "string" ?
                $.datepicker["_" + options + "Datepicker"].
                    apply($.datepicker, [this].concat(otherArgs)) :
                $.datepicker._attachDatepicker(this, options);
        });
    };

    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.11.4";

    var datepicker = $.datepicker;


    /*!
     * jQuery UI Dialog 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/dialog/
     */


    var dialog = $.widget("ui.dialog", {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            closeOnEscape: true,
            closeText: "Close",
            dialogClass: "",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                // Ensure the titlebar is always visible
                using: function (pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,

            // callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },

        sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        },

        resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        },

        _create: function () {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            };
            this.originalTitle = this.element.attr("title");
            this.options.title = this.options.title || this.originalTitle;

            this._createWrapper();

            this.element
                .show()
                .removeAttr("title")
                .addClass("ui-dialog-content ui-widget-content")
                .appendTo(this.uiDialog);

            this._createTitlebar();
            this._createButtonPane();

            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }

            this._isOpen = false;

            this._trackFocus();
        },

        _init: function () {
            if (this.options.autoOpen) {
                this.open();
            }
        },

        _appendTo: function () {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },

        _destroy: function () {
            var next,
                originalPosition = this.originalPosition;

            this._untrackInstance();
            this._destroyOverlay();

            this.element
                .removeUniqueId()
                .removeClass("ui-dialog-content ui-widget-content")
                .css(this.originalCss)
                // Without detaching first, the following becomes really slow
                .detach();

            this.uiDialog.stop(true, true).remove();

            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }

            next = originalPosition.parent.children().eq(originalPosition.index);
            // Don't try to place the dialog next to itself (#8613)
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },

        widget: function () {
            return this.uiDialog;
        },

        disable: $.noop,
        enable: $.noop,

        close: function (event) {
            var activeElement,
                that = this;

            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }

            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();

            if (!this.opener.filter(":focusable").focus().length) {

                // support: IE9
                // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
                try {
                    activeElement = this.document[0].activeElement;

                    // Support: IE9, IE10
                    // If the <body> is blurred, IE will switch windows, see #4520
                    if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {

                        // Hiding a focused element doesn't trigger blur in WebKit
                        // so in case we have nothing to focus on, explicitly blur the active element
                        // https://bugs.webkit.org/show_bug.cgi?id=47182
                        $(activeElement).blur();
                    }
                } catch (error) { }
            }

            this._hide(this.uiDialog, this.options.hide, function () {
                that._trigger("close", event);
            });
        },

        isOpen: function () {
            return this._isOpen;
        },

        moveToTop: function () {
            this._moveToTop();
        },

        _moveToTop: function (event, silent) {
            var moved = false,
                zIndices = this.uiDialog.siblings(".ui-front:visible").map(function () {
                    return +$(this).css("z-index");
                }).get(),
                zIndexMax = Math.max.apply(null, zIndices);

            if (zIndexMax >= +this.uiDialog.css("z-index")) {
                this.uiDialog.css("z-index", zIndexMax + 1);
                moved = true;
            }

            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },

        open: function () {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }

            this._isOpen = true;
            this.opener = $(this.document[0].activeElement);

            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);

            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if (this.overlay) {
                this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
            }

            this._show(this.uiDialog, this.options.show, function () {
                that._focusTabbable();
                that._trigger("focus");
            });

            // Track the dialog immediately upon openening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget();

            this._trigger("open");
        },

        _focusTabbable: function () {
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement;
            if (!hasFocus) {
                hasFocus = this.element.find("[autofocus]");
            }
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).focus();
        },

        _keepFocus: function (event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement,
                    isActive = this.uiDialog[0] === activeElement ||
                        $.contains(this.uiDialog[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call(this);
            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(checkFocus);
        },

        _createWrapper: function () {
            this.uiDialog = $("<div>")
                .addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
                    this.options.dialogClass)
                .hide()
                .attr({
                    // Setting tabIndex makes the div focusable
                    tabIndex: -1,
                    role: "dialog"
                })
                .appendTo(this._appendTo());

            this._on(this.uiDialog, {
                keydown: function (event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                        event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }

                    // prevent tabbing out of dialogs
                    if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"),
                        first = tabbables.filter(":first"),
                        last = tabbables.filter(":last");

                    if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                        this._delay(function () {
                            first.focus();
                        });
                        event.preventDefault();
                    } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                        this._delay(function () {
                            last.focus();
                        });
                        event.preventDefault();
                    }
                },
                mousedown: function (event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });

            // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                });
            }
        },

        _createTitlebar: function () {
            var uiDialogTitle;

            this.uiDialogTitlebar = $("<div>")
                .addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix")
                .prependTo(this.uiDialog);
            this._on(this.uiDialogTitlebar, {
                mousedown: function (event) {
                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                        // Dialog isn't getting focus when dragging (#8063)
                        this.uiDialog.focus();
                    }
                }
            });

            // support: IE
            // Use type="button" to prevent enter keypresses in textboxes from closing the
            // dialog in IE (#9312)
            this.uiDialogTitlebarClose = $("<button type='button'></button>")
                .button({
                    label: this.options.closeText,
                    icons: {
                        primary: "ui-icon-closethick"
                    },
                    text: false
                })
                .addClass("ui-dialog-titlebar-close")
                .appendTo(this.uiDialogTitlebar);
            this._on(this.uiDialogTitlebarClose, {
                click: function (event) {
                    event.preventDefault();
                    this.close(event);
                }
            });

            uiDialogTitle = $("<span>")
                .uniqueId()
                .addClass("ui-dialog-title")
                .prependTo(this.uiDialogTitlebar);
            this._title(uiDialogTitle);

            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },

        _title: function (title) {
            if (!this.options.title) {
                title.html("&#160;");
            }
            title.text(this.options.title);
        },

        _createButtonPane: function () {
            this.uiDialogButtonPane = $("<div>")
                .addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");

            this.uiButtonSet = $("<div>")
                .addClass("ui-dialog-buttonset")
                .appendTo(this.uiDialogButtonPane);

            this._createButtons();
        },

        _createButtons: function () {
            var that = this,
                buttons = this.options.buttons;

            // if we already have a button pane, remove it
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();

            if ($.isEmptyObject(buttons) || (Array.isArray(buttons) && !buttons.length)) {
                this.uiDialog.removeClass("ui-dialog-buttons");
                return;
            }

            $.each(buttons, function (name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ?
                    { click: props, text: name } :
                    props;
                // Default to a non-submitting button
                props = $.extend({ type: "button" }, props);
                // Change the context for the click callback to be the main element
                click = props.click;
                props.click = function () {
                    click.apply(that.element[0], arguments);
                };
                buttonOptions = {
                    icons: props.icons,
                    text: props.showText
                };
                delete props.icons;
                delete props.showText;
                $("<button></button>", props)
                    .button(buttonOptions)
                    .appendTo(that.uiButtonSet);
            });
            this.uiDialog.addClass("ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },

        _makeDraggable: function () {
            var that = this,
                options = this.options;

            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }

            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function (event, ui) {
                    $(this).addClass("ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function (event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(),
                        top = ui.offset.top - that.document.scrollTop();

                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " +
                            "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    $(this).removeClass("ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },

        _makeResizable: function () {
            var that = this,
                options = this.options,
                handles = options.resizable,
                // .ui-resizable has position: relative defined in the stylesheet
                // but dialogs have to use absolute or fixed positioning
                position = this.uiDialog.css("position"),
                resizeHandles = typeof handles === "string" ?
                    handles :
                    "n,e,s,w,se,sw,ne,nw";

            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }

            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function (event, ui) {
                    $(this).addClass("ui-dialog-resizing");
                    that._blockFrames();
                    that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function (event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    var offset = that.uiDialog.offset(),
                        left = offset.left - that.document.scrollLeft(),
                        top = offset.top - that.document.scrollTop();

                    options.height = that.uiDialog.height();
                    options.width = that.uiDialog.width();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " +
                            "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    $(this).removeClass("ui-dialog-resizing");
                    that._unblockFrames();
                    that._trigger("resizeStop", event, filteredUi(ui));
                }
            })
                .css("position", position);
        },

        _trackFocus: function () {
            this._on(this.widget(), {
                focusin: function (event) {
                    this._makeFocusTarget();
                    this._focusedElement = $(event.target);
                }
            });
        },

        _makeFocusTarget: function () {
            this._untrackInstance();
            this._trackingInstances().unshift(this);
        },

        _untrackInstance: function () {
            var instances = this._trackingInstances(),
                exists = $.inArray(this, instances);
            if (exists !== -1) {
                instances.splice(exists, 1);
            }
        },

        _trackingInstances: function () {
            var instances = this.document.data("ui-dialog-instances");
            if (!instances) {
                instances = [];
                this.document.data("ui-dialog-instances", instances);
            }
            return instances;
        },

        _minHeight: function () {
            var options = this.options;

            return options.height === "auto" ?
                options.minHeight :
                Math.min(options.minHeight, options.height);
        },

        _position: function () {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },

        _setOptions: function (options) {
            var that = this,
                resize = false,
                resizableOptions = {};

            $.each(options, function (key, value) {
                that._setOption(key, value);

                if (key in that.sizeRelatedOptions) {
                    resize = true;
                }
                if (key in that.resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });

            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },

        _setOption: function (key, value) {
            var isDraggable, isResizable,
                uiDialog = this.uiDialog;

            if (key === "dialogClass") {
                uiDialog
                    .removeClass(this.options.dialogClass)
                    .addClass(value);
            }

            if (key === "disabled") {
                return;
            }

            this._super(key, value);

            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }

            if (key === "buttons") {
                this._createButtons();
            }

            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({
                    // Ensure that we always pass a string
                    label: "" + value
                });
            }

            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }

                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }

            if (key === "position") {
                this._position();
            }

            if (key === "resizable") {
                // currently resizable, becoming non-resizable
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }

                // currently resizable, changing handles
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }

                // currently non-resizable, becoming resizable
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }

            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },

        _size: function () {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight, minContentHeight, maxContentHeight,
                options = this.options;

            // Reset content sizing
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            });

            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }

            // reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            })
                .outerHeight();
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
            maxContentHeight = typeof options.maxHeight === "number" ?
                Math.max(0, options.maxHeight - nonContentHeight) :
                "none";

            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                });
            } else {
                this.element.height(Math.max(0, options.height - nonContentHeight));
            }

            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", "minHeight", this._minHeight());
            }
        },

        _blockFrames: function () {
            this.iframeBlocks = this.document.find("iframe").map(function () {
                var iframe = $(this);

                return $("<div>")
                    .css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    })
                    .appendTo(iframe.parent())
                    .offset(iframe.offset())[0];
            });
        },

        _unblockFrames: function () {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },

        _allowInteraction: function (event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }

            // TODO: Remove hack when datepicker implements
            // the .ui-front logic (#8989)
            return !!$(event.target).closest(".ui-datepicker").length;
        },

        _createOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true;
            this._delay(function () {
                isOpening = false;
            });

            if (!this.document.data("ui-dialog-overlays")) {

                // Prevent use of anchors and inputs
                // Using _on() for an event handler shared across many instances is
                // safe because the dialogs stack and must be closed in reverse order
                this._on(this.document, {
                    focusin: function (event) {
                        if (isOpening) {
                            return;
                        }

                        if (!this._allowInteraction(event)) {
                            event.preventDefault();
                            this._trackingInstances()[0]._focusTabbable();
                        }
                    }
                });
            }

            this.overlay = $("<div>")
                .addClass("ui-widget-overlay ui-front")
                .appendTo(this._appendTo());
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });
            this.document.data("ui-dialog-overlays",
                (this.document.data("ui-dialog-overlays") || 0) + 1);
        },

        _destroyOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            if (this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;

                if (!overlays) {
                    this.document
                        .unbind("focusin")
                        .removeData("ui-dialog-overlays");
                } else {
                    this.document.data("ui-dialog-overlays", overlays);
                }

                this.overlay.remove();
                this.overlay = null;
            }
        }
    });


    /*!
     * jQuery UI Progressbar 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/progressbar/
     */


    var progressbar = $.widget("ui.progressbar", {
        version: "1.11.4",
        options: {
            max: 100,
            value: 0,

            change: null,
            complete: null
        },

        min: 0,

        _create: function () {
            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue();

            this.element
                .addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
                .attr({
                    // Only set static values, aria-valuenow and aria-valuemax are
                    // set inside _refreshValue()
                    role: "progressbar",
                    "aria-valuemin": this.min
                });

            this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>")
                .appendTo(this.element);

            this._refreshValue();
        },

        _destroy: function () {
            this.element
                .removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all")
                .removeAttr("role")
                .removeAttr("aria-valuemin")
                .removeAttr("aria-valuemax")
                .removeAttr("aria-valuenow");

            this.valueDiv.remove();
        },

        value: function (newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }

            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },

        _constrainedValue: function (newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }

            this.indeterminate = newValue === false;

            // sanitize value
            if (typeof newValue !== "number") {
                newValue = 0;
            }

            return this.indeterminate ? false :
                Math.min(this.options.max, Math.max(this.min, newValue));
        },

        _setOptions: function (options) {
            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value;

            this._super(options);

            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },

        _setOption: function (key, value) {
            if (key === "max") {
                // Don't allow a max less than min
                value = Math.max(this.min, value);
            }
            if (key === "disabled") {
                this.element
                    .toggleClass("ui-state-disabled", !!value)
                    .attr("aria-disabled", value);
            }
            this._super(key, value);
        },

        _percentage: function () {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },

        _refreshValue: function () {
            var value = this.options.value,
                percentage = this._percentage();

            this.valueDiv
                .toggle(this.indeterminate || value > this.min)
                .toggleClass("ui-corner-right", value === this.options.max)
                .width(percentage.toFixed(0) + "%");

            this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);

            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        }
    });


    /*!
     * jQuery UI Slider 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/slider/
     */


    var slider = $.widget("ui.slider", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "slide",

        options: {
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,

            // callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },

        // number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,

        _create: function () {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();

            this.element
                .addClass("ui-slider" +
                    " ui-slider-" + this.orientation +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all");

            this._refresh();
            this._setOption("disabled", this.options.disabled);

            this._animateOff = false;
        },

        _refresh: function () {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function () {
            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
                handles = [];

            handleCount = (options.values && options.values.length) || 1;

            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

            this.handle = this.handles.eq(0);

            this.handles.each(function (i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },

        _createRange: function () {
            var options = this.options,
                classes = "";

            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [this._valueMin(), this._valueMin()];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [options.values[0], options.values[0]];
                    } else if (Array.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }

                if (!this.range || !this.range.length) {
                    this.range = $("<div></div>")
                        .appendTo(this.element);

                    classes = "ui-slider-range" +
                        // note: this isn't the most fittingly semantic framework class for this element,
                        // but worked best visually with a variety of themes
                        " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass("ui-slider-range-min ui-slider-range-max")
                        // Handle range switching from true to min/max
                        .css({
                            "left": "",
                            "bottom": ""
                        });
                }

                this.range.addClass(classes +
                    ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },

        _setupEvents: function () {
            this._off(this.handles);
            this._on(this.handles, this._handleEvents);
            this._hoverable(this.handles);
            this._focusable(this.handles);
        },

        _destroy: function () {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }

            this.element
                .removeClass("ui-slider" +
                    " ui-slider-horizontal" +
                    " ui-slider-vertical" +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all");

            this._mouseDestroy();
        },

        _mouseCapture: function (event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = { x: event.pageX, y: event.pageY };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function (i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if ((distance > thisDistance) ||
                    (distance === thisDistance &&
                        (i === that._lastChangedValue || that.values(i) === o.min))) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            closestHandle
                .addClass("ui-state-active")
                .focus();

            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                left: event.pageX - offset.left - (closestHandle.width() / 2),
                top: event.pageY - offset.top -
                    (closestHandle.height() / 2) -
                    (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
                    (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
                    (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function () {
            return true;
        },

        _mouseDrag: function (event) {
            var position = { x: event.pageX, y: event.pageY },
                normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function (event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function () {
            this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
        },

        _normValueFromMouse: function (position) {
            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;

            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }

            percentMouse = (pixelMouse / pixelTotal);
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _start: function (event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },

        _slide: function (event, index, newVal) {
            var otherVal,
                newValues,
                allowed;

            if (this.options.values && this.options.values.length) {
                otherVal = this.values(index ? 0 : 1);

                if ((this.options.values.length === 2 && this.options.range === true) &&
                    ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
                ) {
                    newVal = otherVal;
                }

                if (newVal !== this.values(index)) {
                    newValues = this.values();
                    newValues[index] = newVal;
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal,
                        values: newValues
                    });
                    otherVal = this.values(index ? 0 : 1);
                    if (allowed !== false) {
                        this.values(index, newVal);
                    }
                }
            } else {
                if (newVal !== this.value()) {
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal
                    });
                    if (allowed !== false) {
                        this.value(newVal);
                    }
                }
            }
        },

        _stop: function (event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }

            this._trigger("stop", event, uiHash);
        },

        _change: function (event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }

                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;

                this._trigger("change", event, uiHash);
            }
        },

        value: function (newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },

        values: function (index, newValue) {
            var vals,
                newValues,
                i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if (Array.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function (key, value) {
            var i,
                valsLength = 0;

            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }

            if (Array.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            if (key === "disabled") {
                this.element.toggleClass("ui-state-disabled", !!value);
            }

            this._super(key, value);

            switch (key) {
                case "orientation":
                    this._detectOrientation();
                    this.element
                        .removeClass("ui-slider-horizontal ui-slider-vertical")
                        .addClass("ui-slider-" + this.orientation);
                    this._refreshValue();

                    // Reset positioning from previous orientation
                    this.handles.css(value === "horizontal" ? "bottom" : "left", "");
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = 0; i < valsLength; i += 1) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "step":
                case "min":
                case "max":
                    this._animateOff = true;
                    this._calculateNewMax();
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function () {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function (index) {
            var val,
                vals,
                i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else if (this.options.values && this.options.values.length) {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            } else {
                return [];
            }
        },

        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function (val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = (this.options.step > 0) ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += (valModStep > 0) ? step : (-step);
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _calculateNewMax: function () {
            var max = this.options.max,
                min = this._valueMin(),
                step = this.options.step,
                aboveMin = Math.floor((+(max - min).toFixed(this._precision())) / step) * step;
            max = aboveMin + min;
            this.max = parseFloat(max.toFixed(this._precision()));
        },

        _precision: function () {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },

        _precisionOf: function (num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _valueMin: function () {
            return this.options.min;
        },

        _valueMax: function () {
            return this.max;
        },

        _refreshValue: function () {
            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = (!this._animateOff) ? o.animate : false,
                _set = {};

            if (this.options.values && this.options.values.length) {
                this.handles.each(function (i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({ left: valPercent + "%" }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({ width: (valPercent - lastValPercent) + "%" }, { queue: false, duration: o.animate });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({ bottom: (valPercent) + "%" }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({ height: (valPercent - lastValPercent) + "%" }, { queue: false, duration: o.animate });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = (valueMax !== valueMin) ?
                    (value - valueMin) / (valueMax - valueMin) * 100 :
                    0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({ width: valPercent + "%" }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range[animate ? "animate" : "css"]({ width: (100 - valPercent) + "%" }, { queue: false, duration: o.animate });
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({ height: valPercent + "%" }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range[animate ? "animate" : "css"]({ height: (100 - valPercent) + "%" }, { queue: false, duration: o.animate });
                }
            }
        },

        _handleEvents: {
            keydown: function (event) {
                var allowed, curVal, newVal, step,
                    index = $(event.target).data("ui-slider-handle-index");

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            $(event.target).addClass("ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if (this.options.values && this.options.values.length) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(
                            curVal + ((this._valueMax() - this._valueMin()) / this.numPages)
                        );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(
                            curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                }

                this._slide(event, index, newVal);
            },
            keyup: function (event) {
                var index = $(event.target).data("ui-slider-handle-index");

                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    $(event.target).removeClass("ui-state-active");
                }
            }
        }
    });


    /*!
     * jQuery UI Spinner 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/spinner/
     */


    function spinner_modifier(fn) {
        return function () {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }

    var spinner = $.widget("ui.spinner", {
        version: "1.11.4",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,

            change: null,
            spin: null,
            start: null,
            stop: null
        },

        _create: function () {
            // handle string values that need to be parsed
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);

            // Only format if there is a value, prevents the field from being marked
            // as invalid in Firefox, see #9573.
            if (this.value() !== "") {
                // Format the value, but don't constrain.
                this._value(this.element.val(), true);
            }

            this._draw();
            this._on(this._events);
            this._refresh();

            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function () {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _getCreateOptions: function () {
            var options = {},
                element = this.element;

            $.each(["min", "max", "step"], function (i, option) {
                var value = element.attr(option);
                if (value !== undefined && value.length) {
                    options[option] = value;
                }
            });

            return options;
        },

        _events: {
            keydown: function (event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function () {
                this.previous = this.element.val();
            },
            blur: function (event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }

                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function (event, delta) {
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }

                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function () {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function (event) {
                var previous;

                // We never want the buttons to have focus; whenever the user is
                // interacting with the spinner, the focus should be on the input.
                // If the input is focused then this.previous is properly set from
                // when the input first received focus. If the input is not focused
                // then we need to set this.previous based on the value before spinning.
                previous = this.element[0] === this.document[0].activeElement ?
                    this.previous : this.element.val();
                function checkFocus() {
                    var isActive = this.element[0] === this.document[0].activeElement;
                    if (!isActive) {
                        this.element.focus();
                        this.previous = previous;
                        // support: IE
                        // IE sets focus asynchronously, so we need to check if focus
                        // moved off of the input because the user clicked on the button.
                        this._delay(function () {
                            this.previous = previous;
                        });
                    }
                }

                // ensure focus is on (or stays on) the text field
                event.preventDefault();
                checkFocus.call(this);

                // support: IE
                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                // and check (again) if focus moved off of the input.
                this.cancelBlur = true;
                this._delay(function () {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });

                if (this._start(event) === false) {
                    return;
                }

                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function (event) {
                // button will add ui-state-active if mouse was down while mouseleave and kept down
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }

                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .ui-spinner-button": "_stop"
        },

        _draw: function () {
            var uiSpinner = this.uiSpinner = this.element
                .addClass("ui-spinner-input")
                .attr("autocomplete", "off")
                .wrap(this._uiSpinnerHtml())
                .parent()
                // add buttons
                .append(this._buttonHtml());

            this.element.attr("role", "spinbutton");

            // button bindings
            this.buttons = uiSpinner.find(".ui-spinner-button")
                .attr("tabIndex", -1)
                .button()
                .removeClass("ui-corner-all");

            // IE 6 doesn't understand height: 50% for the buttons
            // unless the wrapper has an explicit height
            if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) &&
                uiSpinner.height() > 0) {
                uiSpinner.height(uiSpinner.height());
            }

            // disable spinner if element was already disabled
            if (this.options.disabled) {
                this.disable();
            }
        },

        _keydown: function (event) {
            var options = this.options,
                keyCode = $.ui.keyCode;

            switch (event.keyCode) {
                case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;
                case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;
                case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;
                case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
            }

            return false;
        },

        _uiSpinnerHtml: function () {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
        },

        _buttonHtml: function () {
            return "" +
                "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
                "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
                "</a>" +
                "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
                "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
                "</a>";
        },

        _start: function (event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }

            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },

        _repeat: function (i, steps, event) {
            i = i || 500;

            clearTimeout(this.timer);
            this.timer = this._delay(function () {
                this._repeat(40, steps, event);
            }, i);

            this._spin(steps * this.options.step, event);
        },

        _spin: function (step, event) {
            var value = this.value() || 0;

            if (!this.counter) {
                this.counter = 1;
            }

            value = this._adjustValue(value + step * this._increment(this.counter));

            if (!this.spinning || this._trigger("spin", event, { value: value }) !== false) {
                this._value(value);
                this.counter++;
            }
        },

        _increment: function (i) {
            var incremental = this.options.incremental;

            if (incremental) {
                return $.isFunction(incremental) ?
                    incremental(i) :
                    Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
            }

            return 1;
        },

        _precision: function () {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },

        _precisionOf: function (num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _adjustValue: function (value) {
            var base, aboveMin,
                options = this.options;

            // make sure we're at a valid step
            // - find out where we are relative to the base (min or 0)
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            // - round to the nearest step
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            // - rounding is based on 0, so adjust back to our base
            value = base + aboveMin;

            // fix precision from bad JS floating point math
            value = parseFloat(value.toFixed(this._precision()));

            // clamp the value
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }

            return value;
        },

        _stop: function (event) {
            if (!this.spinning) {
                return;
            }

            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },

        _setOption: function (key, value) {
            if (key === "culture" || key === "numberFormat") {
                var prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }

            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                this.buttons.first().find(".ui-icon")
                    .removeClass(this.options.icons.up)
                    .addClass(value.up);
                this.buttons.last().find(".ui-icon")
                    .removeClass(this.options.icons.down)
                    .addClass(value.down);
            }

            this._super(key, value);

            if (key === "disabled") {
                this.widget().toggleClass("ui-state-disabled", !!value);
                this.element.prop("disabled", !!value);
                this.buttons.button(value ? "disable" : "enable");
            }
        },

        _setOptions: spinner_modifier(function (options) {
            this._super(options);
        }),

        _parse: function (val) {
            if (typeof val === "string" && val !== "") {
                val = window.Globalize && this.options.numberFormat ?
                    Globalize.parseFloat(val, 10, this.options.culture) : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },

        _format: function (value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat ?
                Globalize.format(value, this.options.numberFormat, this.options.culture) :
                value;
        },

        _refresh: function () {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse(this.element.val())
            });
        },

        isValid: function () {
            var value = this.value();

            // null is invalid
            if (value === null) {
                return false;
            }

            // if value gets adjusted, it's invalid
            return value === this._adjustValue(value);
        },

        // update the value without triggering change
        _value: function (value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },

        _destroy: function () {
            this.element
                .removeClass("ui-spinner-input")
                .prop("disabled", false)
                .removeAttr("autocomplete")
                .removeAttr("role")
                .removeAttr("aria-valuemin")
                .removeAttr("aria-valuemax")
                .removeAttr("aria-valuenow");
            this.uiSpinner.replaceWith(this.element);
        },

        stepUp: spinner_modifier(function (steps) {
            this._stepUp(steps);
        }),
        _stepUp: function (steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },

        stepDown: spinner_modifier(function (steps) {
            this._stepDown(steps);
        }),
        _stepDown: function (steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },

        pageUp: spinner_modifier(function (pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),

        pageDown: spinner_modifier(function (pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),

        value: function (newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            spinner_modifier(this._value).call(this, newVal);
        },

        widget: function () {
            return this.uiSpinner;
        }
    });


    /*!
     * jQuery UI Tabs 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/tabs/
     */


    var tabs = $.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,

            // callbacks
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },

        _isLocal: (function () {
            var rhash = /#.*$/;

            return function (anchor) {
                var anchorUrl, locationUrl;

                // support: IE7
                // IE7 doesn't normalize the href property when set via script (#9317)
                anchor = anchor.cloneNode(false);

                anchorUrl = anchor.href.replace(rhash, "");
                locationUrl = location.href.replace(rhash, "");

                // decoding may throw an error if the URL isn't UTF-8 (#9518)
                try {
                    anchorUrl = decodeURIComponent(anchorUrl);
                } catch (error) { }
                try {
                    locationUrl = decodeURIComponent(locationUrl);
                } catch (error) { }

                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        })(),

        _create: function () {
            var that = this,
                options = this.options;

            this.running = false;

            this.element
                .addClass("ui-tabs ui-widget ui-widget-content ui-corner-all")
                .toggleClass("ui-tabs-collapsible", options.collapsible);

            this._processTabs();
            options.active = this._initialActive();

            // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            if (Array.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat(
                    $.map(this.tabs.filter(".ui-state-disabled"), function (li) {
                        return that.tabs.index(li);
                    })
                )).sort();
            }

            // check for length avoids error when initializing empty list
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }

            this._refresh();

            if (this.active.length) {
                this.load(options.active);
            }
        },

        _initialActive: function () {
            var active = this.options.active,
                collapsible = this.options.collapsible,
                locationHash = location.hash.substring(1);

            if (active === null) {
                // check the fragment identifier in the URL
                if (locationHash) {
                    this.tabs.each(function (i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }

                // check for a tab marked active via a class
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }

                // no active tab, set to false
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }

            // handle numbers: negative, out of range
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }

            // don't allow collapsible: false and active: false
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }

            return active;
        },

        _getCreateEventData: function () {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },

        _tabKeydown: function (event) {
            var focusedTab = $(this.document[0].activeElement).closest("li"),
                selectedIndex = this.tabs.index(focusedTab),
                goingForward = true;

            if (this._handlePageNav(event)) {
                return;
            }

            switch (event.keyCode) {
                case $.ui.keyCode.RIGHT:
                case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;
                case $.ui.keyCode.UP:
                case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;
                case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;
                case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;
                case $.ui.keyCode.SPACE:
                    // Activate only, no collapsing
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;
                case $.ui.keyCode.ENTER:
                    // Toggle (cancel delayed activation, allow collapsing)
                    event.preventDefault();
                    clearTimeout(this.activating);
                    // Determine if we should collapse or activate
                    this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                    return;
                default:
                    return;
            }

            // Focus the appropriate tab, based on which key was pressed
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);

            // Navigating with control/command key will prevent automatic activation
            if (!event.ctrlKey && !event.metaKey) {

                // Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");

                this.activating = this._delay(function () {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },

        _panelKeydown: function (event) {
            if (this._handlePageNav(event)) {
                return;
            }

            // Ctrl+up moves focus to the current tab
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.focus();
            }
        },

        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function (event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },

        _findNextTab: function (index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;

            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }

            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }

            return index;
        },

        _focusNextTab: function (index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).focus();
            return index;
        },

        _setOption: function (key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "disabled") {
                // don't use the widget factory's disabled handling
                this._setupDisabled(value);
                return;
            }

            this._super(key, value);

            if (key === "collapsible") {
                this.element.toggleClass("ui-tabs-collapsible", value);
                // Setting collapsible: false while collapsed; open first panel
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }

            if (key === "event") {
                this._setupEvents(value);
            }

            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },

        _sanitizeSelector: function (hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },

        refresh: function () {
            var options = this.options,
                lis = this.tablist.children(":has(a[href])");

            // get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function (tab) {
                return lis.index(tab);
            });

            this._processTabs();

            // was collapsed or no tabs
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();
                // was active, but active tab is gone
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                // all remaining tabs are disabled
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();
                    // activate previous tab
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }
                // was active, active tab still exists
            } else {
                // make sure active index is correct
                options.active = this.tabs.index(this.active);
            }

            this._refresh();
        },

        _refresh: function () {
            this._setupDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);

            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active))
                .hide()
                .attr({
                    "aria-hidden": "true"
                });

            // Make sure one tab is in the tab order
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active
                    .addClass("ui-tabs-active ui-state-active")
                    .attr({
                        "aria-selected": "true",
                        "aria-expanded": "true",
                        tabIndex: 0
                    });
                this._getPanelForTab(this.active)
                    .show()
                    .attr({
                        "aria-hidden": "false"
                    });
            }
        },

        _processTabs: function () {
            var that = this,
                prevTabs = this.tabs,
                prevAnchors = this.anchors,
                prevPanels = this.panels;

            this.tablist = this._getList()
                .addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all")
                .attr("role", "tablist")

                // Prevent users from focusing disabled tabs via click
                .delegate("> li", "mousedown" + this.eventNamespace, function (event) {
                    if ($(this).is(".ui-state-disabled")) {
                        event.preventDefault();
                    }
                })

                // support: IE <9
                // Preventing the default action in mousedown doesn't prevent IE
                // from focusing the element, so if the anchor gets focused, blur.
                // We don't have to worry about focusing the previously focused
                // element since clicking on a non-focusable element should focus
                // the body anyway.
                .delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function () {
                    if ($(this).closest("li").is(".ui-state-disabled")) {
                        this.blur();
                    }
                });

            this.tabs = this.tablist.find("> li:has(a[href])")
                .addClass("ui-state-default ui-corner-top")
                .attr({
                    role: "tab",
                    tabIndex: -1
                });

            this.anchors = this.tabs.map(function () {
                return $("a", this)[0];
            })
                .addClass("ui-tabs-anchor")
                .attr({
                    role: "presentation",
                    tabIndex: -1
                });

            this.panels = $();

            this.anchors.each(function (i, anchor) {
                var selector, panel, panelId,
                    anchorId = $(anchor).uniqueId().attr("id"),
                    tab = $(anchor).closest("li"),
                    originalAriaControls = tab.attr("aria-controls");

                // inline tab
                if (that._isLocal(anchor)) {
                    selector = anchor.hash;
                    panelId = selector.substring(1);
                    panel = that.element.find(that._sanitizeSelector(selector));
                    // remote tab
                } else {
                    // If the tab doesn't already have aria-controls,
                    // generate an id by using a throw-away element
                    panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }

                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });

            this.panels
                .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
                .attr("role", "tabpanel");

            // Avoid memory leaks (#10056)
            if (prevTabs) {
                this._off(prevTabs.not(this.tabs));
                this._off(prevAnchors.not(this.anchors));
                this._off(prevPanels.not(this.panels));
            }
        },

        // allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function () {
            return this.tablist || this.element.find("ol,ul").eq(0);
        },

        _createPanel: function (id) {
            return $("<div>")
                .attr("id", id)
                .addClass("ui-tabs-panel ui-widget-content ui-corner-bottom")
                .data("ui-tabs-destroy", true);
        },

        _setupDisabled: function (disabled) {
            if (Array.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }

            // disable tabs
            for (var i = 0, li; (li = this.tabs[i]); i++) {
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    $(li)
                        .addClass("ui-state-disabled")
                        .attr("aria-disabled", "true");
                } else {
                    $(li)
                        .removeClass("ui-state-disabled")
                        .removeAttr("aria-disabled");
                }
            }

            this.options.disabled = disabled;
        },

        _setupEvents: function (event) {
            var events = {};
            if (event) {
                $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.anchors.add(this.tabs).add(this.panels));
            // Always prevent the default action, even when disabled
            this._on(true, this.anchors, {
                click: function (event) {
                    event.preventDefault();
                }
            });
            this._on(this.anchors, events);
            this._on(this.tabs, { keydown: "_tabKeydown" });
            this._on(this.panels, { keydown: "_panelKeydown" });

            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },

        _setupHeightStyle: function (heightStyle) {
            var maxHeight,
                parent = this.element.parent();

            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();

                this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });

                this.element.children().not(this.panels).each(function () {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.panels.each(function () {
                    $(this).height(Math.max(0, maxHeight -
                        $(this).innerHeight() + $(this).height()));
                })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function () {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },

        _eventHandler: function (event) {
            var options = this.options,
                active = this.active,
                anchor = $(event.currentTarget),
                tab = anchor.closest("li"),
                clickedIsActive = tab[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : this._getPanelForTab(tab),
                toHide = !active.length ? $() : this._getPanelForTab(active),
                eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };

            event.preventDefault();

            if (tab.hasClass("ui-state-disabled") ||
                // tab is already loading
                tab.hasClass("ui-tabs-loading") ||
                // can't switch durning an animation
                this.running ||
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.tabs.index(tab);

            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }

            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }

            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },

        // handles show/hide for selecting tabs
        _toggle: function (event, eventData) {
            var that = this,
                toShow = eventData.newPanel,
                toHide = eventData.oldPanel;

            this.running = true;

            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }

            function show() {
                eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");

                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }

            // start out by hiding, then showing, then completing
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function () {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                    show();
                });
            } else {
                eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                toHide.hide();
                show();
            }

            toHide.attr("aria-hidden", "true");
            eventData.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });
            // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function () {
                    return $(this).attr("tabIndex") === 0;
                })
                    .attr("tabIndex", -1);
            }

            toShow.attr("aria-hidden", "false");
            eventData.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },

        _activate: function (index) {
            var anchor,
                active = this._findActive(index);

            // trying to activate the already active panel
            if (active[0] === this.active[0]) {
                return;
            }

            // trying to collapse, simulate a click on the current active header
            if (!active.length) {
                active = this.active;
            }

            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });
        },

        _findActive: function (index) {
            return index === false ? $() : this.tabs.eq(index);
        },

        _getIndex: function (index) {
            // meta-function to give users option to provide a href string instead of a numerical index.
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
            }

            return index;
        },

        _destroy: function () {
            if (this.xhr) {
                this.xhr.abort();
            }

            this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");

            this.tablist
                .removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all")
                .removeAttr("role");

            this.anchors
                .removeClass("ui-tabs-anchor")
                .removeAttr("role")
                .removeAttr("tabIndex")
                .removeUniqueId();

            this.tablist.unbind(this.eventNamespace);

            this.tabs.add(this.panels).each(function () {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this)
                        .removeClass("ui-state-default ui-state-active ui-state-disabled " +
                            "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel")
                        .removeAttr("tabIndex")
                        .removeAttr("aria-live")
                        .removeAttr("aria-busy")
                        .removeAttr("aria-selected")
                        .removeAttr("aria-labelledby")
                        .removeAttr("aria-hidden")
                        .removeAttr("aria-expanded")
                        .removeAttr("role");
                }
            });

            this.tabs.each(function () {
                var li = $(this),
                    prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li
                        .attr("aria-controls", prev)
                        .removeData("ui-tabs-aria-controls");
                } else {
                    li.removeAttr("aria-controls");
                }
            });

            this.panels.show();

            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },

        enable: function (index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }

            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if (Array.isArray(disabled)) {
                    disabled = $.map(disabled, function (num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function (li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setupDisabled(disabled);
        },

        disable: function (index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }

            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if (Array.isArray(disabled)) {
                    disabled = $.merge([index], disabled).sort();
                } else {
                    disabled = [index];
                }
            }
            this._setupDisabled(disabled);
        },

        load: function (index, event) {
            index = this._getIndex(index);
            var that = this,
                tab = this.tabs.eq(index),
                anchor = tab.find(".ui-tabs-anchor"),
                panel = this._getPanelForTab(tab),
                eventData = {
                    tab: tab,
                    panel: panel
                },
                complete = function (jqXHR, status) {
                    if (status === "abort") {
                        that.panels.stop(false, true);
                    }

                    tab.removeClass("ui-tabs-loading");
                    panel.removeAttr("aria-busy");

                    if (jqXHR === that.xhr) {
                        delete that.xhr;
                    }
                };

            // not remote
            if (this._isLocal(anchor[0])) {
                return;
            }

            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));

            // support: jQuery <1.8
            // jQuery <1.8 returns false if the request is canceled in beforeSend,
            // but as of 1.8, $.ajax() always returns a jqXHR object.
            if (this.xhr && this.xhr.statusText !== "canceled") {
                tab.addClass("ui-tabs-loading");
                panel.attr("aria-busy", "true");

                this.xhr
                    .done(function (response, status, jqXHR) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function () {
                            panel.html(response);
                            that._trigger("load", event, eventData);

                            complete(jqXHR, status);
                        }, 1);
                    })
                    .fail(function (jqXHR, status) {
                        // support: jQuery <1.8
                        // http://bugs.jquery.com/ticket/11778
                        setTimeout(function () {
                            complete(jqXHR, status);
                        }, 1);
                    });
            }
        },

        _ajaxSettings: function (anchor, event, eventData) {
            var that = this;
            return {
                url: anchor.attr("href"),
                beforeSend: function (jqXHR, settings) {
                    return that._trigger("beforeLoad", event,
                        $.extend({ jqXHR: jqXHR, ajaxSettings: settings }, eventData));
                }
            };
        },

        _getPanelForTab: function (tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    });


    /*!
     * jQuery UI Tooltip 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/tooltip/
     */


    var tooltip = $.widget("ui.tooltip", {
        version: "1.11.4",
        options: {
            content: function () {
                // support: IE<9, Opera in jQuery <1.7
                // .text() can't accept undefined, so coerce to a string
                var title = $(this).attr("title") || "";
                // Escape title, since we're going from an attribute to raw HTML
                return $("<a>").text(title).html();
            },
            hide: true,
            // Disabled elements have inconsistent behavior across browsers (#8661)
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            tooltipClass: null,
            track: false,

            // callbacks
            close: null,
            open: null
        },

        _addDescribedBy: function (elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id);
            elem
                .data("ui-tooltip-id", id)
                .attr("aria-describedby", describedby.join(" ").trim());
        },

        _removeDescribedBy: function (elem) {
            var id = elem.data("ui-tooltip-id"),
                describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
                index = $.inArray(id, describedby);

            if (index !== -1) {
                describedby.splice(index, 1);
            }

            elem.removeData("ui-tooltip-id");
            describedby = describedby.join(" ").trim();
            if (describedby) {
                elem.attr("aria-describedby", describedby);
            } else {
                elem.removeAttr("aria-describedby");
            }
        },

        _create: function () {
            this._on({
                mouseover: "open",
                focusin: "open"
            });

            // IDs of generated tooltips, needed for destroy
            this.tooltips = {};

            // IDs of parent tooltips where we removed the title attribute
            this.parents = {};

            if (this.options.disabled) {
                this._disable();
            }

            // Append the aria-live region so tooltips announce correctly
            this.liveRegion = $("<div>")
                .attr({
                    role: "log",
                    "aria-live": "assertive",
                    "aria-relevant": "additions"
                })
                .addClass("ui-helper-hidden-accessible")
                .appendTo(this.document[0].body);
        },

        _setOption: function (key, value) {
            var that = this;

            if (key === "disabled") {
                this[value ? "_disable" : "_enable"]();
                this.options[key] = value;
                // disable element style changes
                return;
            }

            this._super(key, value);

            if (key === "content") {
                $.each(this.tooltips, function (id, tooltipData) {
                    that._updateContent(tooltipData.element);
                });
            }
        },

        _disable: function () {
            var that = this;

            // close open tooltips
            $.each(this.tooltips, function (id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0];
                that.close(event, true);
            });

            // remove title attributes to prevent native tooltips
            this.element.find(this.options.items).addBack().each(function () {
                var element = $(this);
                if (element.is("[title]")) {
                    element
                        .data("ui-tooltip-title", element.attr("title"))
                        .removeAttr("title");
                }
            });
        },

        _enable: function () {
            // restore title attributes
            this.element.find(this.options.items).addBack().each(function () {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
        },

        open: function (event) {
            var that = this,
                target = $(event ? event.target : this.element)
                    // we need closest here due to mouseover bubbling,
                    // but always pointing at the same event target
                    .closest(this.options.items);

            // No element to show a tooltip for or the tooltip is already open
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }

            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }

            target.data("ui-tooltip-open", true);

            // kill parent tooltips, custom or native, for hover
            if (event && event.type === "mouseover") {
                target.parents().each(function () {
                    var parent = $(this),
                        blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title")
                        };
                        parent.attr("title", "");
                    }
                });
            }

            this._registerCloseHandlers(event, target);
            this._updateContent(target, event);
        },

        _updateContent: function (target, event) {
            var content,
                contentOption = this.options.content,
                that = this,
                eventType = event ? event.type : null;

            if (typeof contentOption === "string") {
                return this._open(event, target, contentOption);
            }

            content = contentOption.call(target[0], function (response) {

                // IE may instantly serve a cached response for ajax requests
                // delay this call to _open so the other call to _open runs first
                that._delay(function () {

                    // Ignore async response if tooltip was closed already
                    if (!target.data("ui-tooltip-open")) {
                        return;
                    }

                    // jQuery creates a special event for focusin when it doesn't
                    // exist natively. To improve performance, the native event
                    // object is reused and the type is changed. Therefore, we can't
                    // rely on the type being correct after the event finished
                    // bubbling, so we set it back to the previous value. (#8740)
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },

        _open: function (event, target, content) {
            var tooltipData, tooltip, delayedShow, a11yContent,
                positionOption = $.extend({}, this.options.position);

            if (!content) {
                return;
            }

            // Content can be updated multiple times. If the tooltip already
            // exists, then just update the content and bail.
            tooltipData = this._find(target);
            if (tooltipData) {
                tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                return;
            }

            // if we have a title, clear it to prevent the native tooltip
            // we have to check first to avoid defining a title if none exists
            // (we don't want to cause an element to start matching [title])
            //
            // We use removeAttr only for key events, to allow IE to export the correct
            // accessible attributes. For mouse events, set to empty string to avoid
            // native tooltip showing up (happens only when removing inside mouseover).
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }

            tooltipData = this._tooltip(target);
            tooltip = tooltipData.tooltip;
            this._addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);

            // Support: Voiceover on OS X, JAWS on IE <= 9
            // JAWS announces deletions even when aria-relevant="additions"
            // Voiceover will sometimes re-read the entire log region's contents from the beginning
            this.liveRegion.children().hide();
            if (content.clone) {
                a11yContent = content.clone();
                a11yContent.removeAttr("id").find("[id]").removeAttr("id");
            } else {
                a11yContent = content;
            }
            $("<div>").html(a11yContent).appendTo(this.liveRegion);

            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });
                // trigger once to override element-relative positioning
                position(event);
            } else {
                tooltip.position($.extend({
                    of: target
                }, this.options.position));
            }

            tooltip.hide();

            this._show(tooltip, this.options.show);
            // Handle tracking tooltips that are shown with a delay (#8644). As soon
            // as the tooltip is visible, position the tooltip using the most recent
            // event.
            if (this.options.show && this.options.show.delay) {
                delayedShow = this.delayedShow = setInterval(function () {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, $.fx.interval);
            }

            this._trigger("open", event, { tooltip: tooltip });
        },

        _registerCloseHandlers: function (event, target) {
            var events = {
                keyup: function (event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                }
            };

            // Only bind remove handler for delegated targets. Non-delegated
            // tooltips will handle this in destroy.
            if (target[0] !== this.element[0]) {
                events.remove = function () {
                    this._removeTooltip(this._find(target).tooltip);
                };
            }

            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },

        close: function (event) {
            var tooltip,
                that = this,
                target = $(event ? event.currentTarget : this.element),
                tooltipData = this._find(target);

            // The tooltip may already be closed
            if (!tooltipData) {

                // We set ui-tooltip-open immediately upon open (in open()), but only set the
                // additional data once there's actually content to show (in _open()). So even if the
                // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
                // the period between open() and _open().
                target.removeData("ui-tooltip-open");
                return;
            }

            tooltip = tooltipData.tooltip;

            // disabling closes the tooltip, so we need to track when we're closing
            // to avoid an infinite loop in case the tooltip becomes disabled on close
            if (tooltipData.closing) {
                return;
            }

            // Clear the interval for delayed tracking tooltips
            clearInterval(this.delayedShow);

            // only set title if we had one before (see comment in _open())
            // If the title attribute has changed since open(), don't restore
            if (target.data("ui-tooltip-title") && !target.attr("title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }

            this._removeDescribedBy(target);

            tooltipData.hiding = true;
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function () {
                that._removeTooltip($(this));
            });

            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");

            // Remove 'remove' binding only on delegated targets
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");

            if (event && event.type === "mouseleave") {
                $.each(this.parents, function (id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }

            tooltipData.closing = true;
            this._trigger("close", event, { tooltip: tooltip });
            if (!tooltipData.hiding) {
                tooltipData.closing = false;
            }
        },

        _tooltip: function (element) {
            var tooltip = $("<div>")
                .attr("role", "tooltip")
                .addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " +
                    (this.options.tooltipClass || "")),
                id = tooltip.uniqueId().attr("id");

            $("<div>")
                .addClass("ui-tooltip-content")
                .appendTo(tooltip);

            tooltip.appendTo(this.document[0].body);

            return this.tooltips[id] = {
                element: element,
                tooltip: tooltip
            };
        },

        _find: function (target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null;
        },

        _removeTooltip: function (tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },

        _destroy: function () {
            var that = this;

            // close open tooltips
            $.each(this.tooltips, function (id, tooltipData) {
                // Delegate to close method to handle common cleanup
                var event = $.Event("blur"),
                    element = tooltipData.element;
                event.target = event.currentTarget = element[0];
                that.close(event, true);

                // Remove immediately; destroying an open tooltip doesn't use the
                // hide animation
                $("#" + id).remove();

                // Restore the title
                if (element.data("ui-tooltip-title")) {
                    // If the title attribute has changed since open(), don't restore
                    if (!element.attr("title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                    element.removeData("ui-tooltip-title");
                }
            });
            this.liveRegion.remove();
        }
    });


    /*!
     * jQuery UI Effects 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/category/effects-core/
     */


    var dataSpace = "ui-effects-",

        // Create a local jQuery because jQuery Color relies on it and the
        // global may not exist with AMD and a custom build (#10199)
        jQuery = $;

    $.effects = {
        effect: {}
    };

    /*!
     * jQuery Color Animations v2.1.2
     * https://github.com/jquery/jquery-color
     *
     * Copyright 2014 jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * Date: Wed Jan 16 08:47:09 2013 -0600
     */
    (function (jQuery, undefined) {

        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

            // plusequals test for += 100 -= 100
            rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
            // a set of RE's that can match strings and generate color tuples.
            stringParsers = [{
                re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2],
                        execResult[3],
                        execResult[4]
                    ];
                }
            }, {
                re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                parse: function (execResult) {
                    return [
                        execResult[1] * 2.55,
                        execResult[2] * 2.55,
                        execResult[3] * 2.55,
                        execResult[4]
                    ];
                }
            }, {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1], 16),
                        parseInt(execResult[2], 16),
                        parseInt(execResult[3], 16)
                    ];
                }
            }, {
                // this regex ignores A-F because it's compared against an already lowercased string
                re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                parse: function (execResult) {
                    return [
                        parseInt(execResult[1] + execResult[1], 16),
                        parseInt(execResult[2] + execResult[2], 16),
                        parseInt(execResult[3] + execResult[3], 16)
                    ];
                }
            }, {
                re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                space: "hsla",
                parse: function (execResult) {
                    return [
                        execResult[1],
                        execResult[2] / 100,
                        execResult[3] / 100,
                        execResult[4]
                    ];
                }
            }],

            // jQuery.Color( )
            color = jQuery.Color = function (color, green, blue, alpha) {
                return new jQuery.Color.fn.parse(color, green, blue, alpha);
            },
            spaces = {
                rgba: {
                    props: {
                        red: {
                            idx: 0,
                            type: "byte"
                        },
                        green: {
                            idx: 1,
                            type: "byte"
                        },
                        blue: {
                            idx: 2,
                            type: "byte"
                        }
                    }
                },

                hsla: {
                    props: {
                        hue: {
                            idx: 0,
                            type: "degrees"
                        },
                        saturation: {
                            idx: 1,
                            type: "percent"
                        },
                        lightness: {
                            idx: 2,
                            type: "percent"
                        }
                    }
                }
            },
            propTypes = {
                "byte": {
                    floor: true,
                    max: 255
                },
                "percent": {
                    max: 1
                },
                "degrees": {
                    mod: 360,
                    floor: true
                }
            },
            support = color.support = {},

            // element for support tests
            supportElem = jQuery("<p>")[0],

            // colors = jQuery.Color.names
            colors,

            // local aliases of functions called often
            each = jQuery.each;

        // determine rgba support immediately
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;

        // define cache name and alpha properties
        // for rgba and hsla spaces
        each(spaces, function (spaceName, space) {
            space.cache = "_" + spaceName;
            space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        });

        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};

            if (value == null) {
                return (allowEmpty || !prop.def) ? null : prop.def;
            }

            // ~~ is an short way of doing floor for positive numbers
            value = type.floor ? ~~value : parseFloat(value);

            // IE will pass in empty strings as value for alpha,
            // which will hit this case
            if (isNaN(value)) {
                return prop.def;
            }

            if (type.mod) {
                // we add mod before modding to make sure that negatives values
                // get converted properly: -10 -> 350
                return (value + type.mod) % type.mod;
            }

            // for now all property types without mod have min and max
            return 0 > value ? 0 : type.max < value ? type.max : value;
        }

        function stringParse(string) {
            var inst = color(),
                rgba = inst._rgba = [];

            string = string.toLowerCase();

            each(stringParsers, function (i, parser) {
                var parsed,
                    match = parser.re.exec(string),
                    values = match && parser.parse(match),
                    spaceName = parser.space || "rgba";

                if (values) {
                    parsed = inst[spaceName](values);

                    // if this was an rgba parse the assignment might happen twice
                    // oh well....
                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                    rgba = inst._rgba = parsed._rgba;

                    // exit each( stringParsers ) here because we matched
                    return false;
                }
            });

            // Found a stringParser that handled it
            if (rgba.length) {

                // if this came from a parsed string, force "transparent" when alpha is 0
                // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
                if (rgba.join() === "0,0,0,0") {
                    jQuery.extend(rgba, colors.transparent);
                }
                return inst;
            }

            // named colors
            return colors[string];
        }

        color.fn = jQuery.extend(color.prototype, {
            parse: function (red, green, blue, alpha) {
                if (red === undefined) {
                    this._rgba = [null, null, null, null];
                    return this;
                }
                if (red.jquery || red.nodeType) {
                    red = jQuery(red).css(green);
                    green = undefined;
                }

                var inst = this,
                    type = jQuery.type(red),
                    rgba = this._rgba = [];

                // more than 1 argument specified - assume ( red, green, blue, alpha )
                if (green !== undefined) {
                    red = [red, green, blue, alpha];
                    type = "array";
                }

                if (type === "string") {
                    return this.parse(stringParse(red) || colors._default);
                }

                if (type === "array") {
                    each(spaces.rgba.props, function (key, prop) {
                        rgba[prop.idx] = clamp(red[prop.idx], prop);
                    });
                    return this;
                }

                if (type === "object") {
                    if (red instanceof color) {
                        each(spaces, function (spaceName, space) {
                            if (red[space.cache]) {
                                inst[space.cache] = red[space.cache].slice();
                            }
                        });
                    } else {
                        each(spaces, function (spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function (key, prop) {

                                // if the cache doesn't exist, and we know how to convert
                                if (!inst[cache] && space.to) {

                                    // if the value was null, we don't need to copy it
                                    // if the key was alpha, we don't need to copy it either
                                    if (key === "alpha" || red[key] == null) {
                                        return;
                                    }
                                    inst[cache] = space.to(inst._rgba);
                                }

                                // this is the only case where we allow nulls for ALL properties.
                                // call clamp with alwaysAllowEmpty
                                inst[cache][prop.idx] = clamp(red[key], prop, true);
                            });

                            // everything defined but alpha?
                            if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                // use the default of 1
                                inst[cache][3] = 1;
                                if (space.from) {
                                    inst._rgba = space.from(inst[cache]);
                                }
                            }
                        });
                    }
                    return this;
                }
            },
            is: function (compare) {
                var is = color(compare),
                    same = true,
                    inst = this;

                each(spaces, function (_, space) {
                    var localCache,
                        isCache = is[space.cache];
                    if (isCache) {
                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                        each(space.props, function (_, prop) {
                            if (isCache[prop.idx] != null) {
                                same = (isCache[prop.idx] === localCache[prop.idx]);
                                return same;
                            }
                        });
                    }
                    return same;
                });
                return same;
            },
            _space: function () {
                var used = [],
                    inst = this;
                each(spaces, function (spaceName, space) {
                    if (inst[space.cache]) {
                        used.push(spaceName);
                    }
                });
                return used.pop();
            },
            transition: function (other, distance) {
                var end = color(other),
                    spaceName = end._space(),
                    space = spaces[spaceName],
                    startColor = this.alpha() === 0 ? color("transparent") : this,
                    start = startColor[space.cache] || space.to(startColor._rgba),
                    result = start.slice();

                end = end[space.cache];
                each(space.props, function (key, prop) {
                    var index = prop.idx,
                        startValue = start[index],
                        endValue = end[index],
                        type = propTypes[prop.type] || {};

                    // if null, don't override start value
                    if (endValue === null) {
                        return;
                    }
                    // if null - use end
                    if (startValue === null) {
                        result[index] = endValue;
                    } else {
                        if (type.mod) {
                            if (endValue - startValue > type.mod / 2) {
                                startValue += type.mod;
                            } else if (startValue - endValue > type.mod / 2) {
                                startValue -= type.mod;
                            }
                        }
                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                    }
                });
                return this[spaceName](result);
            },
            blend: function (opaque) {
                // if we are already opaque - return ourself
                if (this._rgba[3] === 1) {
                    return this;
                }

                var rgb = this._rgba.slice(),
                    a = rgb.pop(),
                    blend = color(opaque)._rgba;

                return color(jQuery.map(rgb, function (v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function () {
                var prefix = "rgba(",
                    rgba = jQuery.map(this._rgba, function (v, i) {
                        return v == null ? (i > 2 ? 1 : 0) : v;
                    });

                if (rgba[3] === 1) {
                    rgba.pop();
                    prefix = "rgb(";
                }

                return prefix + rgba.join() + ")";
            },
            toHslaString: function () {
                var prefix = "hsla(",
                    hsla = jQuery.map(this.hsla(), function (v, i) {
                        if (v == null) {
                            v = i > 2 ? 1 : 0;
                        }

                        // catch 1 and 2
                        if (i && i < 3) {
                            v = Math.round(v * 100) + "%";
                        }
                        return v;
                    });

                if (hsla[3] === 1) {
                    hsla.pop();
                    prefix = "hsl(";
                }
                return prefix + hsla.join() + ")";
            },
            toHexString: function (includeAlpha) {
                var rgba = this._rgba.slice(),
                    alpha = rgba.pop();

                if (includeAlpha) {
                    rgba.push(~~(alpha * 255));
                }

                return "#" + jQuery.map(rgba, function (v) {

                    // default to 0 when nulls exist
                    v = (v || 0).toString(16);
                    return v.length === 1 ? "0" + v : v;
                }).join("");
            },
            toString: function () {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
            }
        });
        color.fn.parse.prototype = color.fn;

        // hsla conversions adapted from:
        // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

        function hue2rgb(p, q, h) {
            h = (h + 1) % 1;
            if (h * 6 < 1) {
                return p + (q - p) * h * 6;
            }
            if (h * 2 < 1) {
                return q;
            }
            if (h * 3 < 2) {
                return p + (q - p) * ((2 / 3) - h) * 6;
            }
            return p;
        }

        spaces.hsla.to = function (rgba) {
            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                return [null, null, null, rgba[3]];
            }
            var r = rgba[0] / 255,
                g = rgba[1] / 255,
                b = rgba[2] / 255,
                a = rgba[3],
                max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                diff = max - min,
                add = max + min,
                l = add * 0.5,
                h, s;

            if (min === max) {
                h = 0;
            } else if (r === max) {
                h = (60 * (g - b) / diff) + 360;
            } else if (g === max) {
                h = (60 * (b - r) / diff) + 120;
            } else {
                h = (60 * (r - g) / diff) + 240;
            }

            // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
            // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
            if (diff === 0) {
                s = 0;
            } else if (l <= 0.5) {
                s = diff / add;
            } else {
                s = diff / (2 - add);
            }
            return [Math.round(h) % 360, s, l, a == null ? 1 : a];
        };

        spaces.hsla.from = function (hsla) {
            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                return [null, null, null, hsla[3]];
            }
            var h = hsla[0] / 360,
                s = hsla[1],
                l = hsla[2],
                a = hsla[3],
                q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
                p = 2 * l - q;

            return [
                Math.round(hue2rgb(p, q, h + (1 / 3)) * 255),
                Math.round(hue2rgb(p, q, h) * 255),
                Math.round(hue2rgb(p, q, h - (1 / 3)) * 255),
                a
            ];
        };

        each(spaces, function (spaceName, space) {
            var props = space.props,
                cache = space.cache,
                to = space.to,
                from = space.from;

            // makes rgba() and hsla()
            color.fn[spaceName] = function (value) {

                // generate a cache for this space if it doesn't exist
                if (to && !this[cache]) {
                    this[cache] = to(this._rgba);
                }
                if (value === undefined) {
                    return this[cache].slice();
                }

                var ret,
                    type = jQuery.type(value),
                    arr = (type === "array" || type === "object") ? value : arguments,
                    local = this[cache].slice();

                each(props, function (key, prop) {
                    var val = arr[type === "object" ? key : prop.idx];
                    if (val == null) {
                        val = local[prop.idx];
                    }
                    local[prop.idx] = clamp(val, prop);
                });

                if (from) {
                    ret = color(from(local));
                    ret[cache] = local;
                    return ret;
                } else {
                    return color(local);
                }
            };

            // makes red() green() blue() alpha() hue() saturation() lightness()
            each(props, function (key, prop) {
                // alpha is included in more than one space
                if (color.fn[key]) {
                    return;
                }
                color.fn[key] = function (value) {
                    var vtype = jQuery.type(value),
                        fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
                        local = this[fn](),
                        cur = local[prop.idx],
                        match;

                    if (vtype === "undefined") {
                        return cur;
                    }

                    if (vtype === "function") {
                        value = value.call(this, cur);
                        vtype = jQuery.type(value);
                    }
                    if (value == null && prop.empty) {
                        return this;
                    }
                    if (vtype === "string") {
                        match = rplusequals.exec(value);
                        if (match) {
                            value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                        }
                    }
                    local[prop.idx] = value;
                    return this[fn](local);
                };
            });
        });

        // add cssHook and .fx.step function for each named hook.
        // accept a space separated string of properties
        color.hook = function (hook) {
            var hooks = hook.split(" ");
            each(hooks, function (i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function (elem, value) {
                        var parsed, curElem,
                            backgroundColor = "";

                        if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                            value = color(parsed || value);
                            if (!support.rgba && value._rgba[3] !== 1) {
                                curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                while (
                                    (backgroundColor === "" || backgroundColor === "transparent") &&
                                    curElem && curElem.style
                                ) {
                                    try {
                                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                                        curElem = curElem.parentNode;
                                    } catch (e) {
                                    }
                                }

                                value = value.blend(backgroundColor && backgroundColor !== "transparent" ?
                                    backgroundColor :
                                    "_default");
                            }

                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {
                            // wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
                        }
                    }
                };
                jQuery.fx.step[hook] = function (fx) {
                    if (!fx.colorInit) {
                        fx.start = color(fx.elem, hook);
                        fx.end = color(fx.end);
                        fx.colorInit = true;
                    }
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });

        };

        color.hook(stepHooks);

        jQuery.cssHooks.borderColor = {
            expand: function (value) {
                var expanded = {};

                each(["Top", "Right", "Bottom", "Left"], function (i, part) {
                    expanded["border" + part + "Color"] = value;
                });
                return expanded;
            }
        };

        // Basic color names only.
        // Usage of any of the other color names requires adding yourself or including
        // jquery.color.svg-names.js.
        colors = jQuery.Color.names = {
            // 4.1. Basic color keywords
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",

            // 4.2.3. "transparent" color keyword
            transparent: [null, null, null, 0],

            _default: "#ffffff"
        };

    })(jQuery);

    /******************************************************************************/
    /****************************** CLASS ANIMATIONS ******************************/
    /******************************************************************************/
    (function () {

        var classAnimationActions = ["add", "remove", "toggle"],
            shorthandStyles = {
                border: 1,
                borderBottom: 1,
                borderColor: 1,
                borderLeft: 1,
                borderRight: 1,
                borderTop: 1,
                borderWidth: 1,
                margin: 1,
                padding: 1
            };

        $.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (_, prop) {
            $.fx.step[prop] = function (fx) {
                if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                    jQuery.style(fx.elem, prop, fx.end);
                    fx.setAttr = true;
                }
            };
        });

        function getElementStyles(elem) {
            var key, len,
                style = elem.ownerDocument.defaultView ?
                    elem.ownerDocument.defaultView.getComputedStyle(elem, null) :
                    elem.currentStyle,
                styles = {};

            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[$.camelCase(key)] = style[key];
                    }
                }
                // support: Opera, IE <9
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }

            return styles;
        }

        function styleDifference(oldStyle, newStyle) {
            var diff = {},
                name, value;

            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }

            return diff;
        }

        // support: jQuery <1.8
        if (!$.fn.addBack) {
            $.fn.addBack = function (selector) {
                return this.add(selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                );
            };
        }

        $.effects.animateClass = function (value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);

            return this.queue(function () {
                var animated = $(this),
                    baseClass = animated.attr("class") || "",
                    applyClassChange,
                    allAnimations = o.children ? animated.find("*").addBack() : animated;

                // map the animated objects to store the original styles.
                allAnimations = allAnimations.map(function () {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                });

                // apply class change
                applyClassChange = function () {
                    $.each(classAnimationActions, function (i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();

                // map all animated objects again - calculate new styles and diff
                allAnimations = allAnimations.map(function () {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });

                // apply original class
                animated.attr("class", baseClass);

                // map all animated objects again - this time collecting a promise
                allAnimations = allAnimations.map(function () {
                    var styleInfo = this,
                        dfd = $.Deferred(),
                        opts = $.extend({}, o, {
                            queue: false,
                            complete: function () {
                                dfd.resolve(styleInfo);
                            }
                        });

                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });

                // once all animations have completed:
                $.when.apply($, allAnimations.get()).done(function () {

                    // set the final class
                    applyClassChange();

                    // for each animated element,
                    // clear all css properties that were animated
                    $.each(arguments, function () {
                        var el = this.el;
                        $.each(this.diff, function (key) {
                            el.css(key, "");
                        });
                    });

                    // this is guarnteed to be there if you use jQuery.speed()
                    // it also handles dequeuing the next anim...
                    o.complete.call(animated[0]);
                });
            });
        };

        $.fn.extend({
            addClass: (function (orig) {
                return function (classNames, speed, easing, callback) {
                    return speed ?
                        $.effects.animateClass.call(this,
                            { add: classNames }, speed, easing, callback) :
                        orig.apply(this, arguments);
                };
            })($.fn.addClass),

            removeClass: (function (orig) {
                return function (classNames, speed, easing, callback) {
                    return arguments.length > 1 ?
                        $.effects.animateClass.call(this,
                            { remove: classNames }, speed, easing, callback) :
                        orig.apply(this, arguments);
                };
            })($.fn.removeClass),

            toggleClass: (function (orig) {
                return function (classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {
                            // without speed parameter
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(this,
                                (force ? { add: classNames } : { remove: classNames }),
                                speed, easing, callback);
                        }
                    } else {
                        // without force parameter
                        return $.effects.animateClass.call(this,
                            { toggle: classNames }, force, speed, easing);
                    }
                };
            })($.fn.toggleClass),

            switchClass: function (remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });

    })();

    /******************************************************************************/
    /*********************************** EFFECTS **********************************/
    /******************************************************************************/

    (function () {

        $.extend($.effects, {
            version: "1.11.4",

            // Saves a set of properties in a data storage
            save: function (element, set) {
                for (var i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        element.data(dataSpace + set[i], element[0].style[set[i]]);
                    }
                }
            },

            // Restores a set of previously saved properties from a data storage
            restore: function (element, set) {
                var val, i;
                for (i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        val = element.data(dataSpace + set[i]);
                        // support: jQuery 1.6.2
                        // http://bugs.jquery.com/ticket/9917
                        // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
                        // We can't differentiate between "" and 0 here, so we just assume
                        // empty string since it's likely to be a more common value...
                        if (val === undefined) {
                            val = "";
                        }
                        element.css(set[i], val);
                    }
                }
            },

            setMode: function (el, mode) {
                if (mode === "toggle") {
                    mode = el.is(":hidden") ? "show" : "hide";
                }
                return mode;
            },

            // Translates a [top,left] array into a baseline value
            // this should be a little more flexible in the future to handle a string & hash
            getBaseline: function (origin, original) {
                var y, x;
                switch (origin[0]) {
                    case "top": y = 0; break;
                    case "middle": y = 0.5; break;
                    case "bottom": y = 1; break;
                    default: y = origin[0] / original.height;
                }
                switch (origin[1]) {
                    case "left": x = 0; break;
                    case "center": x = 0.5; break;
                    case "right": x = 1; break;
                    default: x = origin[1] / original.width;
                }
                return {
                    x: x,
                    y: y
                };
            },

            // Wraps the element around a wrapper that copies position properties
            createWrapper: function (element) {

                // if the element is already wrapped, return it
                if (element.parent().is(".ui-effects-wrapper")) {
                    return element.parent();
                }

                // wrap the element
                var props = {
                    width: element.outerWidth(true),
                    height: element.outerHeight(true),
                    "float": element.css("float")
                },
                    wrapper = $("<div></div>")
                        .addClass("ui-effects-wrapper")
                        .css({
                            fontSize: "100%",
                            background: "transparent",
                            border: "none",
                            margin: 0,
                            padding: 0
                        }),
                    // Store the size in case width/height are defined in % - Fixes #5245
                    size = {
                        width: element.width(),
                        height: element.height()
                    },
                    active = document.activeElement;

                // support: Firefox
                // Firefox incorrectly exposes anonymous content
                // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
                try {
                    active.id;
                } catch (e) {
                    active = document.body;
                }

                element.wrap(wrapper);

                // Fixes #7595 - Elements lose focus when wrapped.
                if (element[0] === active || $.contains(element[0], active)) {
                    $(active).focus();
                }

                wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

                // transfer positioning properties to the wrapper
                if (element.css("position") === "static") {
                    wrapper.css({ position: "relative" });
                    element.css({ position: "relative" });
                } else {
                    $.extend(props, {
                        position: element.css("position"),
                        zIndex: element.css("z-index")
                    });
                    $.each(["top", "left", "bottom", "right"], function (i, pos) {
                        props[pos] = element.css(pos);
                        if (isNaN(parseInt(props[pos], 10))) {
                            props[pos] = "auto";
                        }
                    });
                    element.css({
                        position: "relative",
                        top: 0,
                        left: 0,
                        right: "auto",
                        bottom: "auto"
                    });
                }
                element.css(size);

                return wrapper.css(props).show();
            },

            removeWrapper: function (element) {
                var active = document.activeElement;

                if (element.parent().is(".ui-effects-wrapper")) {
                    element.parent().replaceWith(element);

                    // Fixes #7595 - Elements lose focus when wrapped.
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).focus();
                    }
                }

                return element;
            },

            setTransition: function (element, list, factor, value) {
                value = value || {};
                $.each(list, function (i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            }
        });

        // return an effect options object for the given parameters:
        function _normalizeArguments(effect, options, speed, callback) {

            // allow passing all options as the first parameter
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }

            // convert to an object
            effect = { effect: effect };

            // catch (effect, null, ...)
            if (options == null) {
                options = {};
            }

            // catch (effect, callback)
            if ($.isFunction(options)) {
                callback = options;
                speed = null;
                options = {};
            }

            // catch (effect, speed, ?)
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }

            // catch (effect, options, callback)
            if ($.isFunction(speed)) {
                callback = speed;
                speed = null;
            }

            // add options to effect
            if (options) {
                $.extend(effect, options);
            }

            speed = speed || options.duration;
            effect.duration = $.fx.off ? 0 :
                typeof speed === "number" ? speed :
                    speed in $.fx.speeds ? $.fx.speeds[speed] :
                        $.fx.speeds._default;

            effect.complete = callback || options.complete;

            return effect;
        }

        function standardAnimationOption(option) {
            // Valid standard speeds (nothing, number, named speed)
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }

            // Invalid strings - treat as "normal" speed
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }

            // Complete callback
            if ($.isFunction(option)) {
                return true;
            }

            // Options hash (but not naming an effect)
            if (typeof option === "object" && !option.effect) {
                return true;
            }

            // Didn't match any standard API
            return false;
        }

        $.fn.extend({
            effect: function ( /* effect, options, speed, callback */) {
                var args = _normalizeArguments.apply(this, arguments),
                    mode = args.mode,
                    queue = args.queue,
                    effectMethod = $.effects.effect[args.effect];

                if ($.fx.off || !effectMethod) {
                    // delegate to the original method (e.g., .show()) if possible
                    if (mode) {
                        return this[mode](args.duration, args.complete);
                    } else {
                        return this.each(function () {
                            if (args.complete) {
                                args.complete.call(this);
                            }
                        });
                    }
                }

                function run(next) {
                    var elem = $(this),
                        complete = args.complete,
                        mode = args.mode;

                    function done() {
                        if ($.isFunction(complete)) {
                            complete.call(elem[0]);
                        }
                        if ($.isFunction(next)) {
                            next();
                        }
                    }

                    // If the element already has the correct final state, delegate to
                    // the core methods so the internal tracking of "olddisplay" works.
                    if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                        elem[mode]();
                        done();
                    } else {
                        effectMethod.call(elem[0], args, done);
                    }
                }

                return queue === false ? this.each(run) : this.queue(queue || "fx", run);
            },

            show: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.show),

            hide: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.hide),

            toggle: (function (orig) {
                return function (option) {
                    if (standardAnimationOption(option) || typeof option === "boolean") {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            })($.fn.toggle),

            // helper functions
            cssUnit: function (key) {
                var style = this.css(key),
                    val = [];

                $.each(["em", "px", "%", "pt"], function (i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [parseFloat(style), unit];
                    }
                });
                return val;
            }
        });

    })();

    /******************************************************************************/
    /*********************************** EASING ***********************************/
    /******************************************************************************/

    (function () {

        // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

        var baseEasings = {};

        $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (i, name) {
            baseEasings[name] = function (p) {
                return Math.pow(p, i + 2);
            };
        });

        $.extend(baseEasings, {
            Sine: function (p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function (p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function (p) {
                return p === 0 || p === 1 ? p :
                    -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
            },
            Back: function (p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function (p) {
                var pow2,
                    bounce = 4;

                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) { }
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
            }
        });

        $.each(baseEasings, function (name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function (p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function (p) {
                return p < 0.5 ?
                    easeIn(p * 2) / 2 :
                    1 - easeIn(p * -2 + 2) / 2;
            };
        });

    })();

    var effect = $.effects;


    /*!
     * jQuery UI Effects Blind 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/blind-effect/
     */


    var effectBlind = $.effects.effect.blind = function (o, done) {
        // Create element
        var el = $(this),
            rvertical = /up|down|vertical/,
            rpositivemotion = /up|left|vertical|horizontal/,
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            direction = o.direction || "up",
            vertical = rvertical.test(direction),
            ref = vertical ? "height" : "width",
            ref2 = vertical ? "top" : "left",
            motion = rpositivemotion.test(direction),
            animation = {},
            show = mode === "show",
            wrapper, distance, margin;

        // if already wrapped, the wrapper's properties are my property. #6245
        if (el.parent().is(".ui-effects-wrapper")) {
            $.effects.save(el.parent(), props);
        } else {
            $.effects.save(el, props);
        }
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });

        distance = wrapper[ref]();
        margin = parseFloat(wrapper.css(ref2)) || 0;

        animation[ref] = show ? distance : 0;
        if (!motion) {
            el
                .css(vertical ? "bottom" : "right", 0)
                .css(vertical ? "top" : "left", "auto")
                .css({ position: "absolute" });

            animation[ref2] = show ? margin : distance + margin;
        }

        // start at 0 if we are showing
        if (show) {
            wrapper.css(ref, 0);
            if (!motion) {
                wrapper.css(ref2, margin + distance);
            }
        }

        // Animate
        wrapper.animate(animation, {
            duration: o.duration,
            easing: o.easing,
            queue: false,
            complete: function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };


    /*!
     * jQuery UI Effects Bounce 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/bounce-effect/
     */


    var effectBounce = $.effects.effect.bounce = function (o, done) {
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],

            // defaults:
            mode = $.effects.setMode(el, o.mode || "effect"),
            hide = mode === "hide",
            show = mode === "show",
            direction = o.direction || "up",
            distance = o.distance,
            times = o.times || 5,

            // number of internal animations
            anims = times * 2 + (show || hide ? 1 : 0),
            speed = o.duration / anims,
            easing = o.easing,

            // utility:
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left"),
            i,
            upAnim,
            downAnim,

            // we will need to re-assemble the queue to stack our animations in place
            queue = el.queue(),
            queuelen = queue.length;

        // Avoid touching opacity to prevent clearType and PNG issues in IE
        if (show || hide) {
            props.push("opacity");
        }

        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el); // Create Wrapper

        // default distance for the BIGGEST bounce is the outer Distance / 3
        if (!distance) {
            distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }

        if (show) {
            downAnim = { opacity: 1 };
            downAnim[ref] = 0;

            // if we are showing, force opacity 0 and set the initial position
            // then do the "first" animation
            el.css("opacity", 0)
                .css(ref, motion ? -distance * 2 : distance * 2)
                .animate(downAnim, speed, easing);
        }

        // start at the smallest distance if we are hiding
        if (hide) {
            distance = distance / Math.pow(2, times - 1);
        }

        downAnim = {};
        downAnim[ref] = 0;
        // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
        for (i = 0; i < times; i++) {
            upAnim = {};
            upAnim[ref] = (motion ? "-=" : "+=") + distance;

            el.animate(upAnim, speed, easing)
                .animate(downAnim, speed, easing);

            distance = hide ? distance * 2 : distance / 2;
        }

        // Last Bounce when Hiding
        if (hide) {
            upAnim = { opacity: 0 };
            upAnim[ref] = (motion ? "-=" : "+=") + distance;

            el.animate(upAnim, speed, easing);
        }

        el.queue(function () {
            if (hide) {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });

        // inject all the animations we just queued to be first in line (after "inprogress")
        if (queuelen > 1) {
            queue.splice.apply(queue,
                [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();

    };


    /*!
     * jQuery UI Effects Clip 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/clip-effect/
     */


    var effectClip = $.effects.effect.clip = function (o, done) {
        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            direction = o.direction || "vertical",
            vert = direction === "vertical",
            size = vert ? "height" : "width",
            position = vert ? "top" : "left",
            animation = {},
            wrapper, animate, distance;

        // Save & Show
        $.effects.save(el, props);
        el.show();

        // Create Wrapper
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        animate = (el[0].tagName === "IMG") ? wrapper : el;
        distance = animate[size]();

        // Shift
        if (show) {
            animate.css(size, 0);
            animate.css(position, distance / 2);
        }

        // Create Animation Object:
        animation[size] = show ? distance : 0;
        animation[position] = show ? 0 : distance / 2;

        // Animate
        animate.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (!show) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });

    };


    /*!
     * jQuery UI Effects Drop 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/drop-effect/
     */


    var effectDrop = $.effects.effect.drop = function (o, done) {

        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            direction = o.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            motion = (direction === "up" || direction === "left") ? "pos" : "neg",
            animation = {
                opacity: show ? 1 : 0
            },
            distance;

        // Adjust
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);

        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;

        if (show) {
            el
                .css("opacity", 0)
                .css(ref, motion === "pos" ? -distance : distance);
        }

        // Animation
        animation[ref] = (show ?
            (motion === "pos" ? "+=" : "-=") :
            (motion === "pos" ? "-=" : "+=")) +
            distance;

        // Animate
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };


    /*!
     * jQuery UI Effects Explode 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/explode-effect/
     */


    var effectExplode = $.effects.effect.explode = function (o, done) {

        var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
            cells = rows,
            el = $(this),
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",

            // show and then visibility:hidden the element before calculating offset
            offset = el.show().css("visibility", "hidden").offset(),

            // width and height of a piece
            width = Math.ceil(el.outerWidth() / cells),
            height = Math.ceil(el.outerHeight() / rows),
            pieces = [],

            // loop
            i, j, left, top, mx, my;

        // children animate complete:
        function childComplete() {
            pieces.push(this);
            if (pieces.length === rows * cells) {
                animComplete();
            }
        }

        // clone the element for each row and cell.
        for (i = 0; i < rows; i++) { // ===>
            top = offset.top + i * height;
            my = i - (rows - 1) / 2;

            for (j = 0; j < cells; j++) { // |||
                left = offset.left + j * width;
                mx = j - (cells - 1) / 2;

                // Create a clone of the now hidden main element that will be absolute positioned
                // within a wrapper div off the -left and -top equal to size of our pieces
                el
                    .clone()
                    .appendTo("body")
                    .wrap("<div></div>")
                    .css({
                        position: "absolute",
                        visibility: "visible",
                        left: -j * width,
                        top: -i * height
                    })

                    // select the wrapper - make it overflow: hidden and absolute positioned based on
                    // where the original was located +left and +top equal to the size of pieces
                    .parent()
                    .addClass("ui-effects-explode")
                    .css({
                        position: "absolute",
                        overflow: "hidden",
                        width: width,
                        height: height,
                        left: left + (show ? mx * width : 0),
                        top: top + (show ? my * height : 0),
                        opacity: show ? 0 : 1
                    }).animate({
                        left: left + (show ? 0 : mx * width),
                        top: top + (show ? 0 : my * height),
                        opacity: show ? 1 : 0
                    }, o.duration || 500, o.easing, childComplete);
            }
        }

        function animComplete() {
            el.css({
                visibility: "visible"
            });
            $(pieces).remove();
            if (!show) {
                el.hide();
            }
            done();
        }
    };


    /*!
     * jQuery UI Effects Fade 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/fade-effect/
     */


    var effectFade = $.effects.effect.fade = function (o, done) {
        var el = $(this),
            mode = $.effects.setMode(el, o.mode || "toggle");

        el.animate({
            opacity: mode
        }, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: done
        });
    };


    /*!
     * jQuery UI Effects Fold 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/fold-effect/
     */


    var effectFold = $.effects.effect.fold = function (o, done) {

        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "hide"),
            show = mode === "show",
            hide = mode === "hide",
            size = o.size || 15,
            percent = /([0-9]+)%/.exec(size),
            horizFirst = !!o.horizFirst,
            widthFirst = show !== horizFirst,
            ref = widthFirst ? ["width", "height"] : ["height", "width"],
            duration = o.duration / 2,
            wrapper, distance,
            animation1 = {},
            animation2 = {};

        $.effects.save(el, props);
        el.show();

        // Create Wrapper
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        distance = widthFirst ?
            [wrapper.width(), wrapper.height()] :
            [wrapper.height(), wrapper.width()];

        if (percent) {
            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        if (show) {
            wrapper.css(horizFirst ? {
                height: 0,
                width: size
            } : {
                    height: size,
                    width: 0
                });
        }

        // Animation
        animation1[ref[0]] = show ? distance[0] : size;
        animation2[ref[1]] = show ? distance[1] : 0;

        // Animate
        wrapper
            .animate(animation1, duration, o.easing)
            .animate(animation2, duration, o.easing, function () {
                if (hide) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });

    };


    /*!
     * jQuery UI Effects Highlight 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/highlight-effect/
     */


    var effectHighlight = $.effects.effect.highlight = function (o, done) {
        var elem = $(this),
            props = ["backgroundImage", "backgroundColor", "opacity"],
            mode = $.effects.setMode(elem, o.mode || "show"),
            animation = {
                backgroundColor: elem.css("backgroundColor")
            };

        if (mode === "hide") {
            animation.opacity = 0;
        }

        $.effects.save(elem, props);

        elem
            .show()
            .css({
                backgroundImage: "none",
                backgroundColor: o.color || "#ffff99"
            })
            .animate(animation, {
                queue: false,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    if (mode === "hide") {
                        elem.hide();
                    }
                    $.effects.restore(elem, props);
                    done();
                }
            });
    };


    /*!
     * jQuery UI Effects Size 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/size-effect/
     */


    var effectSize = $.effects.effect.size = function (o, done) {

        // Create element
        var original, baseline, factor,
            el = $(this),
            props0 = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],

            // Always restore
            props1 = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],

            // Copy for children
            props2 = ["width", "height", "overflow"],
            cProps = ["fontSize"],
            vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
            hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],

            // Set options
            mode = $.effects.setMode(el, o.mode || "effect"),
            restore = o.restore || mode !== "effect",
            scale = o.scale || "both",
            origin = o.origin || ["middle", "center"],
            position = el.css("position"),
            props = restore ? props0 : props1,
            zero = {
                height: 0,
                width: 0,
                outerHeight: 0,
                outerWidth: 0
            };

        if (mode === "show") {
            el.show();
        }
        original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        };

        if (o.mode === "toggle" && mode === "show") {
            el.from = o.to || zero;
            el.to = o.from || original;
        } else {
            el.from = o.from || (mode === "show" ? zero : original);
            el.to = o.to || (mode === "hide" ? zero : original);
        }

        // Set scaling factor
        factor = {
            from: {
                y: el.from.height / original.height,
                x: el.from.width / original.width
            },
            to: {
                y: el.to.height / original.height,
                x: el.to.width / original.width
            }
        };

        // Scale the css box
        if (scale === "box" || scale === "both") {

            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                props = props.concat(vProps);
                el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
            }

            // Horizontal props scaling
            if (factor.from.x !== factor.to.x) {
                props = props.concat(hProps);
                el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
                el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
            }
        }

        // Scale the content
        if (scale === "content" || scale === "both") {

            // Vertical props scaling
            if (factor.from.y !== factor.to.y) {
                props = props.concat(cProps).concat(props2);
                el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
            }
        }

        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        el.css("overflow", "hidden").css(el.from);

        // Adjust
        if (origin) { // Calculate baseline shifts
            baseline = $.effects.getBaseline(origin, original);
            el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
            el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
            el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
            el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
        }
        el.css(el.from); // set top & left

        // Animate
        if (scale === "content" || scale === "both") { // Scale the children

            // Add margins/font-size
            vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps);
            hProps = hProps.concat(["marginLeft", "marginRight"]);
            props2 = props0.concat(vProps).concat(hProps);

            el.find("*[width]").each(function () {
                var child = $(this),
                    c_original = {
                        height: child.height(),
                        width: child.width(),
                        outerHeight: child.outerHeight(),
                        outerWidth: child.outerWidth()
                    };
                if (restore) {
                    $.effects.save(child, props2);
                }

                child.from = {
                    height: c_original.height * factor.from.y,
                    width: c_original.width * factor.from.x,
                    outerHeight: c_original.outerHeight * factor.from.y,
                    outerWidth: c_original.outerWidth * factor.from.x
                };
                child.to = {
                    height: c_original.height * factor.to.y,
                    width: c_original.width * factor.to.x,
                    outerHeight: c_original.height * factor.to.y,
                    outerWidth: c_original.width * factor.to.x
                };

                // Vertical props scaling
                if (factor.from.y !== factor.to.y) {
                    child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
                    child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
                }

                // Horizontal props scaling
                if (factor.from.x !== factor.to.x) {
                    child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
                    child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
                }

                // Animate children
                child.css(child.from);
                child.animate(child.to, o.duration, o.easing, function () {

                    // Restore children
                    if (restore) {
                        $.effects.restore(child, props2);
                    }
                });
            });
        }

        // Animate
        el.animate(el.to, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (el.to.opacity === 0) {
                    el.css("opacity", el.from.opacity);
                }
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                if (!restore) {

                    // we need to calculate our new positioning based on the scaling
                    if (position === "static") {
                        el.css({
                            position: "relative",
                            top: el.to.top,
                            left: el.to.left
                        });
                    } else {
                        $.each(["top", "left"], function (idx, pos) {
                            el.css(pos, function (_, str) {
                                var val = parseInt(str, 10),
                                    toRef = idx ? el.to.left : el.to.top;

                                // if original was "auto", recalculate the new value from wrapper
                                if (str === "auto") {
                                    return toRef + "px";
                                }

                                return val + toRef + "px";
                            });
                        });
                    }
                }

                $.effects.removeWrapper(el);
                done();
            }
        });

    };


    /*!
     * jQuery UI Effects Scale 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/scale-effect/
     */


    var effectScale = $.effects.effect.scale = function (o, done) {

        // Create element
        var el = $(this),
            options = $.extend(true, {}, o),
            mode = $.effects.setMode(el, o.mode || "effect"),
            percent = parseInt(o.percent, 10) ||
                (parseInt(o.percent, 10) === 0 ? 0 : (mode === "hide" ? 0 : 100)),
            direction = o.direction || "both",
            origin = o.origin,
            original = {
                height: el.height(),
                width: el.width(),
                outerHeight: el.outerHeight(),
                outerWidth: el.outerWidth()
            },
            factor = {
                y: direction !== "horizontal" ? (percent / 100) : 1,
                x: direction !== "vertical" ? (percent / 100) : 1
            };

        // We are going to pass this effect to the size effect:
        options.effect = "size";
        options.queue = false;
        options.complete = done;

        // Set default origin and restore for show/hide
        if (mode !== "effect") {
            options.origin = origin || ["middle", "center"];
            options.restore = true;
        }

        options.from = o.from || (mode === "show" ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : original);
        options.to = {
            height: original.height * factor.y,
            width: original.width * factor.x,
            outerHeight: original.outerHeight * factor.y,
            outerWidth: original.outerWidth * factor.x
        };

        // Fade option to support puff
        if (options.fade) {
            if (mode === "show") {
                options.from.opacity = 0;
                options.to.opacity = 1;
            }
            if (mode === "hide") {
                options.from.opacity = 1;
                options.to.opacity = 0;
            }
        }

        // Animate
        el.effect(options);

    };


    /*!
     * jQuery UI Effects Puff 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/puff-effect/
     */


    var effectPuff = $.effects.effect.puff = function (o, done) {
        var elem = $(this),
            mode = $.effects.setMode(elem, o.mode || "hide"),
            hide = mode === "hide",
            percent = parseInt(o.percent, 10) || 150,
            factor = percent / 100,
            original = {
                height: elem.height(),
                width: elem.width(),
                outerHeight: elem.outerHeight(),
                outerWidth: elem.outerWidth()
            };

        $.extend(o, {
            effect: "scale",
            queue: false,
            fade: true,
            mode: mode,
            complete: done,
            percent: hide ? percent : 100,
            from: hide ?
                original :
                {
                    height: original.height * factor,
                    width: original.width * factor,
                    outerHeight: original.outerHeight * factor,
                    outerWidth: original.outerWidth * factor
                }
        });

        elem.effect(o);
    };


    /*!
     * jQuery UI Effects Pulsate 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/pulsate-effect/
     */


    var effectPulsate = $.effects.effect.pulsate = function (o, done) {
        var elem = $(this),
            mode = $.effects.setMode(elem, o.mode || "show"),
            show = mode === "show",
            hide = mode === "hide",
            showhide = (show || mode === "hide"),

            // showing or hiding leaves of the "last" animation
            anims = ((o.times || 5) * 2) + (showhide ? 1 : 0),
            duration = o.duration / anims,
            animateTo = 0,
            queue = elem.queue(),
            queuelen = queue.length,
            i;

        if (show || !elem.is(":visible")) {
            elem.css("opacity", 0).show();
            animateTo = 1;
        }

        // anims - 1 opacity "toggles"
        for (i = 1; i < anims; i++) {
            elem.animate({
                opacity: animateTo
            }, duration, o.easing);
            animateTo = 1 - animateTo;
        }

        elem.animate({
            opacity: animateTo
        }, duration, o.easing);

        elem.queue(function () {
            if (hide) {
                elem.hide();
            }
            done();
        });

        // We just queued up "anims" animations, we need to put them next in the queue
        if (queuelen > 1) {
            queue.splice.apply(queue,
                [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        elem.dequeue();
    };


    /*!
     * jQuery UI Effects Shake 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/shake-effect/
     */


    var effectShake = $.effects.effect.shake = function (o, done) {

        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "height", "width"],
            mode = $.effects.setMode(el, o.mode || "effect"),
            direction = o.direction || "left",
            distance = o.distance || 20,
            times = o.times || 3,
            anims = times * 2 + 1,
            speed = Math.round(o.duration / anims),
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            animation = {},
            animation1 = {},
            animation2 = {},
            i,

            // we will need to re-assemble the queue to stack our animations in place
            queue = el.queue(),
            queuelen = queue.length;

        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);

        // Animation
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;

        // Animate
        el.animate(animation, speed, o.easing);

        // Shakes
        for (i = 1; i < times; i++) {
            el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
        }
        el
            .animate(animation1, speed, o.easing)
            .animate(animation, speed / 2, o.easing)
            .queue(function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            });

        // inject all the animations we just queued to be first in line (after "inprogress")
        if (queuelen > 1) {
            queue.splice.apply(queue,
                [1, 0].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();

    };


    /*!
     * jQuery UI Effects Slide 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/slide-effect/
     */


    var effectSlide = $.effects.effect.slide = function (o, done) {

        // Create element
        var el = $(this),
            props = ["position", "top", "bottom", "left", "right", "width", "height"],
            mode = $.effects.setMode(el, o.mode || "show"),
            show = mode === "show",
            direction = o.direction || "left",
            ref = (direction === "up" || direction === "down") ? "top" : "left",
            positiveMotion = (direction === "up" || direction === "left"),
            distance,
            animation = {};

        // Adjust
        $.effects.save(el, props);
        el.show();
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);

        $.effects.createWrapper(el).css({
            overflow: "hidden"
        });

        if (show) {
            el.css(ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance);
        }

        // Animation
        animation[ref] = (show ?
            (positiveMotion ? "+=" : "-=") :
            (positiveMotion ? "-=" : "+=")) +
            distance;

        // Animate
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function () {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };


    /*!
     * jQuery UI Effects Transfer 1.11.4
     * http://jqueryui.com
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license.
     * http://jquery.org/license
     *
     * http://api.jqueryui.com/transfer-effect/
     */


    var effectTransfer = $.effects.effect.transfer = function (o, done) {
        var elem = $(this),
            target = $(o.to),
            targetFixed = target.css("position") === "fixed",
            body = $("body"),
            fixTop = targetFixed ? body.scrollTop() : 0,
            fixLeft = targetFixed ? body.scrollLeft() : 0,
            endPosition = target.offset(),
            animation = {
                top: endPosition.top - fixTop,
                left: endPosition.left - fixLeft,
                height: target.innerHeight(),
                width: target.innerWidth()
            },
            startPosition = elem.offset(),
            transfer = $("<div class='ui-effects-transfer'></div>")
                .appendTo(document.body)
                .addClass(o.className)
                .css({
                    top: startPosition.top - fixTop,
                    left: startPosition.left - fixLeft,
                    height: elem.innerHeight(),
                    width: elem.innerWidth(),
                    position: targetFixed ? "fixed" : "absolute"
                })
                .animate(animation, o.duration, o.easing, function () {
                    transfer.remove();
                    done();
                });
    };



}));
/*!
 * jQuery UI Touch Punch 0.2.3
 *
 * Copyright 20112014, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
define('vendor/jquery.ui.touch-punc',
    ['jquery'],
    function ($) {
        // Detect touch support
        $.support.touch = 'ontouchend' in document;

        // Ignore browsers without touch support
        if (!$.support.touch) {
            return;
        }

        var mouseProto = $.ui.mouse.prototype,
            _mouseInit = mouseProto._mouseInit,
            _mouseDestroy = mouseProto._mouseDestroy,
            touchHandled;

        /**
         * Simulate a mouse event based on a corresponding touch event
         * @param {Object} event A touch event
         * @param {String} simulatedType The corresponding mouse event
         */
        function simulateMouseEvent(event, simulatedType) {

            // Ignore multi-touch events
            if (event.originalEvent.touches.length > 1) {
                return;
            }

            event.preventDefault();

            var touch = event.originalEvent.changedTouches[0],
                simulatedEvent = document.createEvent('MouseEvents');

            // Initialize the simulated mouse event using the touch event's coordinates
            simulatedEvent.initMouseEvent(
                simulatedType,    // type
                true,             // bubbles                    
                true,             // cancelable                 
                window,           // view                       
                1,                // detail                     
                touch.screenX,    // screenX                    
                touch.screenY,    // screenY                    
                touch.clientX,    // clientX                    
                touch.clientY,    // clientY                    
                false,            // ctrlKey                    
                false,            // altKey                     
                false,            // shiftKey                   
                false,            // metaKey                    
                0,                // button                     
                null              // relatedTarget              
            );

            // Dispatch the simulated event to the target element
            event.target.dispatchEvent(simulatedEvent);
        }

        /**
         * Handle the jQuery UI widget's touchstart events
         * @param {Object} event The widget element's touchstart event
         */
        mouseProto._touchStart = function (event) {

            var self = this;

            // Ignore the event if another widget is already being handled
            if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
                return;
            }

            // Set the flag to prevent other widgets from inheriting the touch event
            touchHandled = true;

            // Track movement to determine if interaction was a click
            self._touchMoved = false;

            // Simulate the mouseover event
            simulateMouseEvent(event, 'mouseover');

            // Simulate the mousemove event
            simulateMouseEvent(event, 'mousemove');

            // Simulate the mousedown event
            simulateMouseEvent(event, 'mousedown');
        };

        /**
         * Handle the jQuery UI widget's touchmove events
         * @param {Object} event The document's touchmove event
         */
        mouseProto._touchMove = function (event) {

            // Ignore event if not handled
            if (!touchHandled) {
                return;
            }

            // Interaction was not a click
            this._touchMoved = true;

            // Simulate the mousemove event
            simulateMouseEvent(event, 'mousemove');
        };

        /**
         * Handle the jQuery UI widget's touchend events
         * @param {Object} event The document's touchend event
         */
        mouseProto._touchEnd = function (event) {

            // Ignore event if not handled
            if (!touchHandled) {
                return;
            }

            // Simulate the mouseup event
            simulateMouseEvent(event, 'mouseup');

            // Simulate the mouseout event
            simulateMouseEvent(event, 'mouseout');

            // If the touch interaction did not move, it should trigger a click
            if (!this._touchMoved) {

                // Simulate the click event
                simulateMouseEvent(event, 'click');
            }

            // Unset the flag to allow other widgets to inherit the touch event
            touchHandled = false;
        };

        /**
         * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
         * This method extends the widget with bound touch event handlers that
         * translate touch events to mouse events and pass them to the widget's
         * original mouse event handling methods.
         */
        mouseProto._mouseInit = function () {

            var self = this;

            // Delegate the touch handlers to the widget's element
            self.element.bind({
                touchstart: $.proxy(self, '_touchStart'),
                touchmove: $.proxy(self, '_touchMove'),
                touchend: $.proxy(self, '_touchEnd')
            });

            // Call the original $.ui.mouse init method
            _mouseInit.call(self);
        };

        /**
         * Remove the touch event handlers
         */
        mouseProto._mouseDestroy = function () {

            var self = this;

            // Delegate the touch handlers to the widget's element
            self.element.unbind({
                touchstart: $.proxy(self, '_touchStart'),
                touchmove: $.proxy(self, '_touchMove'),
                touchend: $.proxy(self, '_touchEnd')
            });

            // Call the original $.ui.mouse destroy method
            _mouseDestroy.call(self);
        };

    });
; (function (factory) {
    if (typeof define === "function" && define.amd) {
        // AMD anonymous module
        define('vendor/knockout-sortable',["knockout", "jquery", 'vendor/jquery-ui', 'vendor/jquery.ui.touch-punc'], factory);
    } else if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // CommonJS module
        var ko = require("knockout"),
            jQuery = require("jquery");
        require('vendor/jquery-ui');
        require('vendor/jquery.ui.touch-punc');

        factory(ko, jQuery);
    } else {
        // No module loader (plain <script> tag) - put directly in global namespace
        factory(window.ko, window.jQuery);
    }
})(function (ko, $) {
    var ITEMKEY = "ko_sortItem",
        INDEXKEY = "ko_sourceIndex",
        LISTKEY = "ko_sortList",
        PARENTKEY = "ko_parentList",
        DRAGKEY = "ko_dragItem",
        unwrap = ko.utils.unwrapObservable,
        dataGet = ko.utils.domData.get,
        dataSet = ko.utils.domData.set,
        version = $.ui && $.ui.version,
        //1.8.24 included a fix for how events were triggered in nested sortables. indexOf checks will fail if version starts with that value (0 vs. -1)
        hasNestedSortableFix = version && version.indexOf("1.6.") && version.indexOf("1.7.") && (version.indexOf("1.8.") || version === "1.8.24");

    //internal afterRender that adds meta-data to children
    var addMetaDataAfterRender = function (elements, data) {
        ko.utils.arrayForEach(elements, function (element) {
            if (element.nodeType === 1) {
                dataSet(element, ITEMKEY, data);
                dataSet(element, PARENTKEY, dataGet(element.parentNode, LISTKEY));
            }
        });
    };

    //prepare the proper options for the template binding
    var prepareTemplateOptions = function (valueAccessor, dataName) {
        var result = {},
            options = {},
            actualAfterRender;

        //build our options to pass to the template engine
        if (ko.utils.peekObservable(valueAccessor()).data) {
            options = unwrap(valueAccessor() || {});
            result[dataName] = options.data;
            if (options.hasOwnProperty("template")) {
                result.name = options.template;
            }
        } else {
            result[dataName] = valueAccessor();
        }

        ko.utils.arrayForEach(["afterAdd", "afterRender", "as", "beforeRemove", "includeDestroyed", "templateEngine", "templateOptions", "nodes"], function (option) {
            if (options.hasOwnProperty(option)) {
                result[option] = options[option];
            } else if (ko.bindingHandlers.sortable.hasOwnProperty(option)) {
                result[option] = ko.bindingHandlers.sortable[option];
            }
        });

        //use an afterRender function to add meta-data
        if (dataName === "foreach") {
            if (result.afterRender) {
                //wrap the existing function, if it was passed
                actualAfterRender = result.afterRender;
                result.afterRender = function (element, data) {
                    addMetaDataAfterRender.call(data, element, data);
                    actualAfterRender.call(data, element, data);
                };
            } else {
                result.afterRender = addMetaDataAfterRender;
            }
        }

        //return options to pass to the template binding
        return result;
    };

    var updateIndexFromDestroyedItems = function (index, items) {
        var unwrapped = unwrap(items);

        if (unwrapped) {
            for (var i = 0; i <= index; i++) {
                //add one for every destroyed item we find before the targetIndex in the target array
                if (unwrapped[i] && unwrap(unwrapped[i]._destroy)) {
                    index++;
                }
            }
        }

        return index;
    };

    //remove problematic leading/trailing whitespace from templates
    var stripTemplateWhitespace = function (element, name) {
        var templateSource,
            templateElement;

        //process named templates
        if (name) {
            templateElement = document.getElementById(name);
            if (templateElement) {
                templateSource = new ko.templateSources.domElement(templateElement);
                templateSource.text(templateSource.text().trim());
            }
        }
        else {
            //remove leading/trailing non-elements from anonymous templates
            $(element).contents().each(function () {
                if (this && this.nodeType !== 1) {
                    element.removeChild(this);
                }
            });
        }
    };

    //connect items with observableArrays
    ko.bindingHandlers.sortable = {
        init: function (element, valueAccessor, allBindingsAccessor, data, context) {
            var $element = $(element),
                value = unwrap(valueAccessor()) || {},
                templateOptions = prepareTemplateOptions(valueAccessor, "foreach"),
                sortable = {},
                startActual, updateActual;

            stripTemplateWhitespace(element, templateOptions.name);

            //build a new object that has the global options with overrides from the binding
            $.extend(true, sortable, ko.bindingHandlers.sortable);
            if (value.options && sortable.options) {
                ko.utils.extend(sortable.options, value.options);
                delete value.options;
            }
            ko.utils.extend(sortable, value);

            //if allowDrop is an observable or a function, then execute it in a computed observable
            if (sortable.connectClass && (ko.isObservable(sortable.allowDrop) || typeof sortable.allowDrop == "function")) {
                ko.computed({
                    read: function () {
                        var value = unwrap(sortable.allowDrop),
                            shouldAdd = typeof value == "function" ? value.call(this, templateOptions.foreach) : value;
                        ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, shouldAdd);
                    },
                    disposeWhenNodeIsRemoved: element
                }, this);
            } else {
                ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, sortable.allowDrop);
            }

            //wrap the template binding
            ko.bindingHandlers.template.init(element, function () { return templateOptions; }, allBindingsAccessor, data, context);

            //keep a reference to start/update functions that might have been passed in
            startActual = sortable.options.start;
            updateActual = sortable.options.update;

            //ensure draggable table row cells maintain their width while dragging (unless a helper is provided)
            if (!sortable.options.helper) {
                sortable.options.helper = function (e, ui) {
                    if (ui.is("tr")) {
                        ui.children().each(function () {
                            $(this).width($(this).width());
                        });
                    }
                    return ui;
                };
            }

            //initialize sortable binding after template binding has rendered in update function
            var createTimeout = setTimeout(function () {
                var dragItem;
                var originalReceive = sortable.options.receive;

                $element.sortable(ko.utils.extend(sortable.options, {
                    start: function (event, ui) {
                        //track original index
                        var el = ui.item[0];
                        dataSet(el, INDEXKEY, ko.utils.arrayIndexOf(ui.item.parent().children(), el));

                        //make sure that fields have a chance to update model
                        ui.item.find("input:focus").change();
                        if (startActual) {
                            startActual.apply(this, arguments);
                        }
                    },
                    receive: function (event, ui) {
                        //optionally apply an existing receive handler
                        if (typeof originalReceive === "function") {
                            originalReceive.call(this, event, ui);
                        }

                        dragItem = dataGet(ui.item[0], DRAGKEY);
                        if (dragItem) {
                            //copy the model item, if a clone option is provided
                            if (dragItem.clone) {
                                dragItem = dragItem.clone();
                            }

                            //configure a handler to potentially manipulate item before drop
                            if (sortable.dragged) {
                                dragItem = sortable.dragged.call(this, dragItem, event, ui) || dragItem;
                            }
                        }
                    },
                    update: function (event, ui) {
                        var sourceParent, targetParent, sourceIndex, targetIndex, arg,
                            el = ui.item[0],
                            parentEl = ui.item.parent()[0],
                            item = dataGet(el, ITEMKEY) || dragItem;

                        if (!item) {
                            $(el).remove();
                        }
                        dragItem = null;

                        //make sure that moves only run once, as update fires on multiple containers
                        if (item && (this === parentEl) || (!hasNestedSortableFix && $.contains(this, parentEl))) {
                            //identify parents
                            sourceParent = dataGet(el, PARENTKEY);
                            sourceIndex = dataGet(el, INDEXKEY);
                            targetParent = dataGet(el.parentNode, LISTKEY);
                            targetIndex = ko.utils.arrayIndexOf(ui.item.parent().children(), el);

                            //take destroyed items into consideration
                            if (!templateOptions.includeDestroyed) {
                                sourceIndex = updateIndexFromDestroyedItems(sourceIndex, sourceParent);
                                targetIndex = updateIndexFromDestroyedItems(targetIndex, targetParent);
                            }

                            //build up args for the callbacks
                            if (sortable.beforeMove || sortable.afterMove) {
                                arg = {
                                    item: item,
                                    sourceParent: sourceParent,
                                    sourceParentNode: sourceParent && ui.sender || el.parentNode,
                                    sourceIndex: sourceIndex,
                                    targetParent: targetParent,
                                    targetIndex: targetIndex,
                                    cancelDrop: false
                                };

                                //execute the configured callback prior to actually moving items
                                if (sortable.beforeMove) {
                                    sortable.beforeMove.call(this, arg, event, ui);
                                }
                            }

                            //call cancel on the correct list, so KO can take care of DOM manipulation
                            if (sourceParent) {
                                $(sourceParent === targetParent ? this : ui.sender || this).sortable("cancel");
                            }
                            //for a draggable item just remove the element
                            else {
                                $(el).remove();
                            }

                            //if beforeMove told us to cancel, then we are done
                            if (arg && arg.cancelDrop) {
                                return;
                            }

                            //if the strategy option is unset or false, employ the order strategy involving removal and insertion of items
                            if (!sortable.hasOwnProperty("strategyMove") || sortable.strategyMove === false) {
                                //do the actual move
                                if (targetIndex >= 0) {
                                    if (sourceParent) {
                                        sourceParent.splice(sourceIndex, 1);

                                        //if using deferred updates plugin, force updates
                                        if (ko.processAllDeferredBindingUpdates) {
                                            ko.processAllDeferredBindingUpdates();
                                        }

                                        //if using deferred updates on knockout 3.4, force updates
                                        if (ko.options && ko.options.deferUpdates) {
                                            ko.tasks.runEarly();
                                        }
                                    }

                                    targetParent.splice(targetIndex, 0, item);
                                }

                                //rendering is handled by manipulating the observableArray; ignore dropped element
                                dataSet(el, ITEMKEY, null);
                            }
                            else { //employ the strategy of moving items
                                if (targetIndex >= 0) {
                                    if (sourceParent) {
                                        if (sourceParent !== targetParent) {
                                            // moving from one list to another

                                            sourceParent.splice(sourceIndex, 1);
                                            targetParent.splice(targetIndex, 0, item);

                                            //rendering is handled by manipulating the observableArray; ignore dropped element
                                            dataSet(el, ITEMKEY, null);
                                            ui.item.remove();
                                        }
                                        else {
                                            // moving within same list
                                            var underlyingList = unwrap(sourceParent);

                                            // notify 'beforeChange' subscribers
                                            if (sourceParent.valueWillMutate) {
                                                sourceParent.valueWillMutate();
                                            }

                                            // move from source index ...
                                            underlyingList.splice(sourceIndex, 1);
                                            // ... to target index
                                            underlyingList.splice(targetIndex, 0, item);

                                            // notify subscribers
                                            if (sourceParent.valueHasMutated) {
                                                sourceParent.valueHasMutated();
                                            }
                                        }
                                    }
                                    else {
                                        // drop new element from outside
                                        targetParent.splice(targetIndex, 0, item);

                                        //rendering is handled by manipulating the observableArray; ignore dropped element
                                        dataSet(el, ITEMKEY, null);
                                        ui.item.remove();
                                    }
                                }
                            }

                            //if using deferred updates plugin, force updates
                            if (ko.processAllDeferredBindingUpdates) {
                                ko.processAllDeferredBindingUpdates();
                            }

                            //allow binding to accept a function to execute after moving the item
                            if (sortable.afterMove) {
                                sortable.afterMove.call(this, arg, event, ui);
                            }
                        }

                        if (updateActual) {
                            updateActual.apply(this, arguments);
                        }
                    },
                    connectWith: sortable.connectClass ? "." + sortable.connectClass : false
                }));

                //handle enabling/disabling sorting
                if (sortable.isEnabled !== undefined) {
                    ko.computed({
                        read: function () {
                            $element.sortable(unwrap(sortable.isEnabled) ? "enable" : "disable");
                        },
                        disposeWhenNodeIsRemoved: element
                    });
                }
            }, 0);

            //handle disposal
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                //only call destroy if sortable has been created
                if ($element.data("ui-sortable") || $element.data("sortable")) {
                    $element.sortable("destroy");
                }

                ko.utils.toggleDomNodeCssClass(element, sortable.connectClass, false);

                //do not create the sortable if the element has been removed from DOM
                clearTimeout(createTimeout);
            });

            return { 'controlsDescendantBindings': true };
        },
        update: function (element, valueAccessor, allBindingsAccessor, data, context) {
            var templateOptions = prepareTemplateOptions(valueAccessor, "foreach");

            //attach meta-data
            dataSet(element, LISTKEY, templateOptions.foreach);

            //call template binding's update with correct options
            ko.bindingHandlers.template.update(element, function () { return templateOptions; }, allBindingsAccessor, data, context);
        },
        connectClass: 'ko_container',
        allowDrop: true,
        afterMove: null,
        beforeMove: null,
        options: {}
    };

    //create a draggable that is appropriate for dropping into a sortable
    ko.bindingHandlers.draggable = {
        init: function (element, valueAccessor, allBindingsAccessor, data, context) {
            var value = unwrap(valueAccessor()) || {},
                options = value.options || {},
                draggableOptions = ko.utils.extend({}, ko.bindingHandlers.draggable.options),
                templateOptions = prepareTemplateOptions(valueAccessor, "data"),
                connectClass = value.connectClass || ko.bindingHandlers.draggable.connectClass,
                isEnabled = value.isEnabled !== undefined ? value.isEnabled : ko.bindingHandlers.draggable.isEnabled;

            value = "data" in value ? value.data : value;

            //set meta-data
            dataSet(element, DRAGKEY, value);

            //override global options with override options passed in
            ko.utils.extend(draggableOptions, options);

            //setup connection to a sortable
            draggableOptions.connectToSortable = connectClass ? "." + connectClass : false;

            //initialize draggable
            $(element).draggable(draggableOptions);

            //handle enabling/disabling sorting
            if (isEnabled !== undefined) {
                ko.computed({
                    read: function () {
                        $(element).draggable(unwrap(isEnabled) ? "enable" : "disable");
                    },
                    disposeWhenNodeIsRemoved: element
                });
            }

            //handle disposal
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                $(element).draggable("destroy");
            });

            return ko.bindingHandlers.template.init(element, function () { return templateOptions; }, allBindingsAccessor, data, context);
        },
        update: function (element, valueAccessor, allBindingsAccessor, data, context) {
            var templateOptions = prepareTemplateOptions(valueAccessor, "data");

            return ko.bindingHandlers.template.update(element, function () { return templateOptions; }, allBindingsAccessor, data, context);
        },
        connectClass: ko.bindingHandlers.sortable.connectClass,
        options: {
            helper: "clone"
        }
    };

    // Simple Droppable Implementation
    // binding that updates (function or observable)
    ko.bindingHandlers.droppable = {
        init: function (element, valueAccessor, allBindingsAccessor, data, context) {
            var value = unwrap(valueAccessor()) || {},
                options = value.options || {},
                droppableOptions = ko.utils.extend({}, ko.bindingHandlers.droppable.options),
                isEnabled = value.isEnabled !== undefined ? value.isEnabled : ko.bindingHandlers.droppable.isEnabled;

            //override global options with override options passed in
            ko.utils.extend(droppableOptions, options);

            //get reference to drop method
            value = "data" in value ? value.data : valueAccessor();

            //set drop method
            droppableOptions.drop = function (event, ui) {
                var droppedItem = dataGet(ui.draggable[0], DRAGKEY) || dataGet(ui.draggable[0], ITEMKEY);
                value(droppedItem);
            };

            //initialize droppable
            $(element).droppable(droppableOptions);

            //handle enabling/disabling droppable
            if (isEnabled !== undefined) {
                ko.computed({
                    read: function () {
                        $(element).droppable(unwrap(isEnabled) ? "enable" : "disable");
                    },
                    disposeWhenNodeIsRemoved: element
                });
            }

            //handle disposal
            ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                $(element).droppable("destroy");
            });
        },
        options: {
            accept: "*"
        }
    };
});
/* global ePresetsOrder */
var QuotesViewModel = function (ko, ViewModelBase, general, debounce, Dictionary,
    QuotesManager, FavoriteInstrumentsManager,
    InstrumentTranslationsManager, PermissionsModule, delegate,
    AlertsManager, portfolioManager) {
    var self,
        presetViewModel,
        subscriptions = [],
        computedObservables = [],
        viewProperties = {},
        openInDialogDelegate = new delegate(),
        inheritedInstance = general.clone(ViewModelBase);

    //----------------------------------------------------------------

    var init = function (customSettings) {
        self = this;
        presetViewModel = $viewModelsManager.VmQuotesPreset;

        inheritedInstance.setSettings(self, customSettings);

        registerObservableStartUpEvent();
        setDefaultObservables();
    };

    //----------------------------------------------------------------

    var setDefaultObservables = function () {
        viewProperties.selectedPresetId = ko.observable();
        viewProperties.isCashBackIconVisible = ko.observable(general.toNumeric(portfolioManager.Portfolio.pendingBonus) > 0 && portfolioManager.Portfolio.pendingBonusType === ePendingBonusType.cashBack);
        viewProperties.isMarketClosed = $statesManager.States.IsMarketClosed;
        viewProperties.isAmlRestricted = $statesManager.States.IsAmlRestricted;
        viewProperties.alertOfInactiveInstrument = alertOfInactiveInstrument;
    };

    //----------------------------------------------------------------

    var onPresetChanged = function (preset) {
        var uiOrder;

        if (!preset) {
            return;
        }

        viewProperties.selectedPresetId(preset.Id);

        if (preset.Id === ePresetType.PresetCustomized) {
            uiOrder = $instrumentsManager.GetCustomizedUiOrder();
        }
        else {
            uiOrder = $instrumentsManager.GetPresetInstruments(preset.Id);
        }

        if (preset.Order !== ePresetsOrder.None) {
            preset.Clear();
        }

        if (preset.QuotesCollection.Keys.count() < 1) {
            buildQuotesCollection(uiOrder || [], preset).then(function (collection) {
                preset.AddRange(collection);
                preset.TemporaryQuotesCollection.length = 0;
            }).done();
        }
    };

    //----------------------------------------------------------------

    var setSubscribers = function () {
        subscriptions.push(presetViewModel.Data.SelectedPreset.subscribe(onPresetChanged));
    };

    //----------------------------------------------------------------

    var unsetSubscribers = function () {
        if (subscriptions.length > 0) {
            for (var i = 0; i < subscriptions.length; i++) {
                subscriptions[i].dispose();
            }
        }

        subscriptions.length = 0;
    };

    //----------------------------------------------------------------

    var unsetComputedObservables = function () {
        if (computedObservables.length > 0) {
            for (var i = 0; i < computedObservables.length; i++) {
                computedObservables[i].dispose();
            }
        }

        computedObservables.length = 0;
    };

    //----------------------------------------------------------------

    var alertOfInactiveInstrument = function (ccyPair) {
        var body = String.format(Dictionary.GetItem("InstrumentInactiveOnLoad"), ccyPair);
        AlertsManager.UpdateAlert(AlertTypes.ServerResponseAlert, null, body, '');
        AlertsManager.PopAlert(AlertTypes.ServerResponseAlert);
    };

    //----------------------------------------------------------------

    var openNewDealOrNewLimit = function (quoteRow, orderDir, tab) {
        if (window.componentsLoaded()) {
            ko.postbox.publish('instrument-trade', { instrumentName: InstrumentTranslationsManager.Long(quoteRow.id) });

            if ($customer.prop.brokerAllowLimitsOnNoRates && (quoteRow.state() === eQuoteStates.Disabled || viewProperties.isMarketClosed())) {
                openNewLimit(quoteRow.id, orderDir, tab);
            }
            else {
                openNewDeal(quoteRow.id, orderDir, tab);
            }
        }
        else {
            alertOfInactiveInstrument(quoteRow.ccyPair);
        }
    };

    //----------------------------------------------------------------

    var openTransactionSwitcherDialog = function (transactionParameters) {
        openInDialogDelegate.Invoke(eDialog.TransactionSwitcher, {
            title: '',
            customTitle: 'TransactionDropDown',
            width: 700,
            dragStart: function () { ko.postbox.publish('new-deal-dragged', {}); },
            persistent: false,
            dialogClass: 'deal-slip revised-slip'
        }, eViewTypes.vTransactionSwitcher, transactionParameters);
    };

    //----------------------------------------------------------------

    var openNewDeal = function (instrumentId, orderDir, tab) {
        var newDealParameters = {
            'instrumentId': instrumentId,
            'orderDir': orderDir,
            'tab': tab,
            'transactionType': eTransactionSwitcher.NewDeal
        };

        openTransactionSwitcherDialog(newDealParameters);
    };

    //----------------------------------------------------------------

    var openNewLimit = function (instrumentId, orderDir, tab) {
        var newLimitParameters = {
            'instrumentId': instrumentId,
            'orderDir': orderDir,
            'tab': tab,
            'transactionType': eTransactionSwitcher.NewLimit
        };

        openTransactionSwitcherDialog(newLimitParameters);
    };

    //----------------------------------------------------------------

    var openNewPriceAlert = function (instrumentId, orderDir, tab) {
        var newPriceAlertParameters = {
                'instrumentId': instrumentId,
                'orderDir': orderDir,
                'tab': tab,
                'transactionType': eTransactionSwitcher.NewPriceAlert
            };

        openInDialogDelegate.Invoke(eDialog.NewPriceAlert, {
            title: '',
            customTitle: 'TransactionDropDown',
            width: 700,
            dragStart: function () { ko.postbox.publish('new-deal-dragged', {}); },
            persistent: false,
            dialogClass: 'deal-slip revised-slip'
        }, eViewTypes.vNewPriceAlert, newPriceAlertParameters);
    };

    //----------------------------------------------------------------

    var rateDetails = function (quote, orderDir) {
        var args = {
            'instrumentId': !general.isNullOrUndefined(quote) && quote.id,
            'isActiveQuote': !general.isNullOrUndefined(quote) && quote.isActiveQuote(),
            'quoteState': !general.isNullOrUndefined(quote) && quote.state(),
            'orderDir': orderDir === null ? eOrderDir.None : orderDir
        };

        $viewModelsManager.VManager.SwitchViewVisible(eForms.Transaction, args);
    };

    //----------------------------------------------------------------

    var registerObservableStartUpEvent = function () {
        $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vQuotes).state.subscribe(function (state) {
            switch (state) {
                case eViewState.Start:
                    if ($viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vQuotes).previousState() !== eViewState.Update) {
                        start(); // we want the state to be always start but we dont want the start metod to run if we came from update
                    }
                    break;

                case eViewState.Update:
                    update();
                    $viewModelsManager.VManager.ChangeViewState(eViewTypes.vQuotes, eViewState.Start);
                    break;

                case eViewState.Stop:
                    stop();
                    break;
            }
        });
    };

    //----------------------------------------------------------------

    var start = function () {
        setSubscribers();

        var defaultPresetId = viewProperties.selectedPresetId() || $initialDataManager.prop.initialScreen.screenId || ePresetType.PresetCustomized;
        var presetId = $viewModelsManager.VManager.GetViewArgsByKeyName(eViewTypes.vQuotes, "presetToSelect");

        var presetIdToSelect = presetId || defaultPresetId;
        var selectedPreset = presetViewModel.Data.SelectedPreset();

        if (selectedPreset && selectedPreset.Id === presetIdToSelect) {
            onPresetChanged(selectedPreset);
        }
        else {
            presetViewModel.SelectPreset(presetIdToSelect);
        }

        registerToDispatcher();
        onPortofolioChanged();
    };

    //----------------------------------------------------------------

    var stop = function () {
        unRegisterFromDispatcher();

        unsetSubscribers();
        unsetComputedObservables();

        presetViewModel.Reset();
    };

    //----------------------------------------------------------------

    var registerToDispatcher = function () {
        QuotesManager.OnChange.Add(onQuotesChanged);
        $instrumentsManager.OnEnhancedInstrumentsChange.Add(onInstrumentsChanged);
        portfolioManager.OnChange.Add(onPortofolioChanged);
    };

    //----------------------------------------------------------------

    var unRegisterFromDispatcher = function () {
        QuotesManager.OnChange.Remove(onQuotesChanged);
        $instrumentsManager.OnEnhancedInstrumentsChange.Remove(onInstrumentsChanged);
        portfolioManager.OnChange.Remove(onPortofolioChanged);
    };

    //----------------------------------------------------------------

    var update = function () {
        var presetId = $viewModelsManager.VManager.GetViewArgsByKeyName(eViewTypes.vQuotes, "presetToSelect");

        if (typeof presetId === "undefined") {
            return;
        }

        presetViewModel.SelectPreset(presetId);
    };

    //----------------------------------------------------------------

    var addFakeRows = function (collection) {
        var seed = (new Date()).getTime(),
            minRowsToDisplay = inheritedInstance.getSettings(self).minRowsToDisplay,
            fakeRecordsToAdd = Math.max(collection.length, minRowsToDisplay) - collection.length,
            rowCounter = collection.length - 1;

        for (var i = 0; i < fakeRecordsToAdd; i++) {
            var fakeObj = {
                id: String.format("empty{0}", seed++),
                rowId: ++rowCounter,
                isFake: true
            };

            collection.push(fakeObj);
        }

        return collection;
    }

    //----------------------------------------------------------------

    var buildQuotesCollection = function (uiOrderLocal, preset) {
        var i,
            rowCounter = 0,
            maxLength = uiOrderLocal.length,
            collectionToAdd = [],
            instrument,
            quoteRow;

        for (i = 0; i < maxLength; i++) {
            instrument = $instrumentsManager.GetInstrument(uiOrderLocal[i][eQuotesUIOrder.InstrumentID]);

            if (instrument) {
                quoteRow = {
                    isFake: false
                };

                setStaticInfo(++rowCounter, quoteRow, instrument, preset);

                updateQuoteValues(quoteRow);

                collectionToAdd.push(quoteRow);
            }
        }

        // needed to get quotes updates
        preset.TemporaryQuotesCollection = collectionToAdd;

        if (preset.Order !== ePresetsOrder.None) {
            var quotesHasDataPromises = collectionToAdd.map(function (item) {
                if (!item.isFake) {
                    return item.hasData.promise;
                }
                return true;
            });

            return Q.all(quotesHasDataPromises).then(function () {
                return orderByChangeColumn(collectionToAdd, preset.Order);
            }).then(addFakeRows);
        } else {
            return Q(collectionToAdd).then(addFakeRows);
        }
    };

    //----------------------------------------------------------------

    var setStaticInfo = function (rowId, quoteRow, instrument, preset) {
        quoteRow.hasData = Q.defer();
        quoteRow.rowId = rowId;
        quoteRow.instrumentId = instrument.id;

        quoteRow.DecimalDigit = instrument.DecimalDigit;
        quoteRow.PipDigit = instrument.PipDigit;

        quoteRow.id = instrument.id;
        quoteRow.amountGroupId = instrument.amountGroupId;
        quoteRow.factor = instrument.factor;
        quoteRow.isTradable = instrument.isTradable;

        quoteRow.baseSymbolName = instrument.baseSymbolName;
        quoteRow.otherSymbolName = instrument.otherSymbolName;

        quoteRow.baseSymbolId = instrument.baseSymbol;
        quoteRow.otherSymbolId = instrument.otherSymbol;

        quoteRow.signal = instrument.hasSignal;
        quoteRow.alertInactiveQuote = alertInactiveQuote;

        quoteRow.bidPips = ko.observable();
        quoteRow.bid10K = ko.observable();
        quoteRow.bid100K = ko.observable();
        quoteRow.askPips = ko.observable();
        quoteRow.ask10K = ko.observable();
        quoteRow.ask100K = ko.observable();

        quoteRow.state = ko.observable("");
        quoteRow.isActiveQuote = ko.observable("");

        quoteRow.bid = ko.observable("");
        quoteRow.ask = ko.observable("");

        quoteRow.prevBid = ko.observable("");
        quoteRow.prevAsk = ko.observable("");

        quoteRow.open = ko.observable("");
        quoteRow.close = ko.observable("");
        quoteRow.high = ko.observable("");
        quoteRow.low = ko.observable("");
        quoteRow.highLowState = ko.observable("");
        quoteRow.change = ko.observable("");
        quoteRow.changePips = ko.observable("");
        quoteRow.time = ko.observable("");
        quoteRow.orderDir = ko.observable("");
        quoteRow.isSingleInstrument = instrument.isFuture || instrument.isShare || (instrument.instrumentTypeId == eInstrumentType.Commodities && instrument.assetTypeId == eAssetType.Forex);

        quoteRow.isIndiceInstrument = instrument.instrumentTypeId == eInstrumentType.Indices;

        quoteRow.isFavoriteHelper = ko.observable(0).extend({ notify: 'always' });
        quoteRow.isFavorite = ko.pureComputed(function () {
            return this.isFavoriteHelper() > -1 && preset.isSelected() && FavoriteInstrumentsManager.IsFavoriteInstrument(this.id);
        }, quoteRow);

        quoteRow.weightedVolumeFactor = ko.observable(instrument.weightedVolumeFactor);

        quoteRow.onToggleFavoriteClick = debounce(function () {
            if (PermissionsModule.CheckActionAllowed("addFavorite", true)) {
                if (quoteRow.isFavorite()) {
                    FavoriteInstrumentsManager.RemoveFavoriteInstrument(quoteRow.id, notifyQuoteRowIsFavorite);
                    ko.postbox.publish("favorite-instrument-update", { instrumentId: quoteRow.id, isRemoveInstrument: true });
                } else {
                    FavoriteInstrumentsManager.AddFavoriteInstrument(quoteRow.id, notifyQuoteRowIsFavorite);
                    ko.postbox.publish("favorite-instrument-update", { instrumentId: quoteRow.id, isAddInstrument: true });
                }
            }
        });

        var notifyQuoteRowIsFavorite = function (result) {
            var jsonResult = JSON.parse(result);
            if (jsonResult && jsonResult.status === eOperationStatus.Success) {
                quoteRow.isFavoriteHelper(1);
            }
        }

        quoteRow.isCashBackIconVisible = ko.pureComputed(function () {
            return this.weightedVolumeFactor() > 1 && viewProperties.isCashBackIconVisible();
        }, quoteRow);

        quoteRow.isAvailable = ko.pureComputed(function () {
            return (!viewProperties.isMarketClosed() && this.isActiveQuote());
        }, quoteRow);

        quoteRow.isStock = ko.observable(instrument.isStock);

        quoteRow.isUp = ko.pureComputed(function () {
            return this.state() === eQuoteStates.Up;
        }, quoteRow).extend({ notify: "always" });

        quoteRow.isDown = ko.pureComputed(function () {
            return this.state() === eQuoteStates.Down;
        }, quoteRow).extend({ notify: "always" });

        quoteRow.notChanged = ko.pureComputed(function () {
            return this.state() === eQuoteStates.NotChanged;
        }, quoteRow).extend({ notify: "always" });

        quoteRow.formattedChange = ko.pureComputed(function () {
            return Format.toSignedPercent(this.change(), '');
        }, quoteRow);

        quoteRow.onClick = function () {
            rateDetails(quoteRow, eOrderDir.None);
        };

        quoteRow.onBuyClick = function () {
            rateDetails(quoteRow, eOrderDir.Buy);
        };

        quoteRow.onSellClick = function () {
            rateDetails(quoteRow, quoteRow.isStock() ? eOrderDir.None : eOrderDir.Sell);
        };

        quoteRow.choose = function () {
            quoteRow.onChoiceClick();
        };

        // Web
        quoteRow.onChoiceClick = function () {
            openNewDealOrNewLimit(quoteRow, eOrderDir.None);
        };

        // Web
        quoteRow.onAskClick = function () {
            openNewDealOrNewLimit(quoteRow, eOrderDir.Buy);
        };

        // Web
        quoteRow.onBidClick = function () {
            openNewDealOrNewLimit(quoteRow, quoteRow.isStock() ? eOrderDir.None : eOrderDir.Sell);
        };

        quoteRow.onSignalClick = function (quoteRowData) {
            openNewDealOrNewLimit(quoteRowData, eOrderDir.None, quoteRowData.signal ? eNewDealTool.Signals : null);
        };

        quoteRow.hasPriceAlerts = ko.observable(false);

        quoteRow.onPriceAlertClick = function (quoteRowData) {
            openNewPriceAlert(quoteRowData.instrumentId, eOrderDir.None);
        };
    };

    //----------------------------------------------------------------

    var alertInactiveQuote = function (val) {
        var body = String.format("Instrument {0} is currently inactive", val);
        AlertsManager.UpdateAlert(AlertTypes.ServerResponseAlert, null, body, '');
        AlertsManager.PopAlert(AlertTypes.ServerResponseAlert);

        return false;
    };

    //----------------------------------------------------------------

    var onQuotesChanged = function (changedQuotesIds) {
        var preset = presetViewModel.Data.SelectedPreset(),
            quoteId,
            quoteRow;

        if (!preset) {
            return;
        }

        for (var i = 0, ii = changedQuotesIds.length; i < ii; i++) {
            quoteId = changedQuotesIds[i];
            quoteRow = preset.QuotesCollection.Get(quoteId) ||
                preset.TemporaryQuotesCollection.find(function (id, item) { return item.id === id; }.bind(null, quoteId));

            if (quoteRow && !quoteRow.isFake) {
                updateQuoteValues(quoteRow);
            }
        }
    };

    //----------------------------------------------------------------

    var isTopFaller = function (order, change) {
        return order === ePresetsOrder.Ascending && change < 0;
    };

    //----------------------------------------------------------------

    var isTopRiser = function (order, change) {
        return order === ePresetsOrder.Descending && change >= 0;
    };

    //----------------------------------------------------------------

    var sortTopFallers = function (a, b) { return a.change() - b.change(); }

    //----------------------------------------------------------------

    var sortTopRisers = function (a, b) { return b.change() - a.change(); }

    //----------------------------------------------------------------

    var orderByChangeColumn = function (collection, order) {
        collection = collection || [];

        if (!order) {
            return;
        }

        collection = collection.filter(function (quote) {
            return !quote.isFake && (isTopRiser(order, quote.change()) || isTopFaller(order, quote.change()));
        });

        return collection.sort(order === ePresetsOrder.Ascending ? sortTopFallers : sortTopRisers);
    };

    //----------------------------------------------------------------

    var onInstrumentsChanged = debounce(function onInstrumentsChangedHandler() {
        for (var i = 0, length = presetViewModel.Data.Presets().length; i < length; i++) {
            var preset = presetViewModel.Data.Presets()[i];

            if (!preset ||
                preset.QuotesCollection.Keys.count() < 1) {
                continue;
            }

            preset.QuotesCollection.Keys.ForEach(function (key, quoteRow) {
                if (quoteRow.isFake) {
                    return;
                }

                var instrument = $instrumentsManager.GetInstrument(quoteRow.instrumentId);
                quoteRow.weightedVolumeFactor(instrument.weightedVolumeFactor);
            });
        }
    });

    //----------------------------------------------------------------

    var onPortofolioChanged = debounce(function onPortofolioChangedHandler() {
        viewProperties.isCashBackIconVisible(general.toNumeric(portfolioManager.Portfolio.pendingBonus) > 0 && portfolioManager.Portfolio.pendingBonusType === ePendingBonusType.cashBack);
    });

    //----------------------------------------------------------------

    var updateQuoteValues = function (quoteToUpdate) {
        if (!quoteToUpdate) {
            return;
        }

        if (!quoteToUpdate.id || quoteToUpdate.isFake) {
            return;
        }

        var instrumentId = quoteToUpdate.id,
            currentQuote = QuotesManager.Quotes.GetItem(instrumentId);

        if (currentQuote) {
            quoteToUpdate.highLowState(getHighLowState(quoteToUpdate, currentQuote));
            quoteToUpdate.state(currentQuote.state);
            quoteToUpdate.isActiveQuote(currentQuote.isActive());
            quoteToUpdate.prevAsk(quoteToUpdate.ask());
            quoteToUpdate.prevBid(quoteToUpdate.bid());
            quoteToUpdate.bid(currentQuote.bid);
            quoteToUpdate.ask(currentQuote.ask);
            quoteToUpdate.open(currentQuote.open);
            quoteToUpdate.close(currentQuote.close);
            quoteToUpdate.high(currentQuote.highBid);
            quoteToUpdate.low(currentQuote.lowAsk);
            quoteToUpdate.change(currentQuote.change);
            quoteToUpdate.changePips(Format.toRate(currentQuote.changePips, true, instrumentId));
            quoteToUpdate.time(currentQuote.tradeTime);

            quoteToUpdate.hasData.resolve(true);
        }
    };

    function getHighLowState(previousQuote, currentQuote) {
        var state = eHighLowStates.Active;
        var previousState = previousQuote.state();
        var currentState = currentQuote.state;

        if (currentState === eQuoteStates.Disabled && general.objectContainsValue(eQuoteStates, previousState)) {
            state = eHighLowStates.MarketClosed;
        } else if (currentQuote.isActive() && general.objectContainsValue(eQuoteStates, previousState)) {
            state = eHighLowStates.Active;
        } else if ((currentState === eQuoteStates.TimedOut || currentState === eQuoteStates.Locked) && previousState === eQuoteStates.Disabled) {
            state = eHighLowStates.NA;
        }

        return state;
    }

    //----------------------------------------------------------------

    return {
        Init: init,
        Start: start,
        Stop: stop,
        Presets: presetViewModel,
        ViewProperties: viewProperties,
        OpenInDialog: openInDialogDelegate,
        UpdateQuoteValues: updateQuoteValues,
        GetDialogPos: function () {
            return {

                dialogPosition: $viewModelsManager.VmDialog.dialogPosition,
                parentIsCollapsed: $viewModelsManager.VmAccountMarket.IsCollapsed,
                parentTopElement: eRefDomElementsIds.newDealRefParentTopElement,
                topOffset: -3,
                parentLeftElement: '#QuotesTable .ask-column',
                leftOffset: -70,
                RTLoffset: 10
            }
        }
    }
};

define("viewmodels/QuotesViewModel", ["knockout","viewmodels/ViewModelBase","handlers/general","global/debounce","Dictionary","cachemanagers/QuotesManager","modules/FavoriteInstrumentsManager","managers/instrumentTranslationsManager","modules/permissionsmodule","handlers/Delegate","devicemanagers/AlertsManager","cachemanagers/PortfolioStaticManager","vendor/knockout-sortable","enums/enums"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko, vmb, gen, deb, dct, qtm, fim, itm, pm, deg, am, pfm) {
				return this.QuotesViewModel(ko, vmb, gen, deb, dct, qtm, fim, itm, pm, deg, am, pfm);
			};
        ret = fn.apply(global, arguments);
        return ret || global.QuotesViewModel;
    };
}(this)));

var TDALInitialData = function (errorManager) {
    var getData = function(onSuccess) {
        var ajaxer = new TAjaxer();

        return ajaxer.promises.get(
            "TDALInitialData/getData",
            "InitialData/GetData",
            "",
            onSuccess,
            function(error) {
                errorManager.onError("TDALInitialData/getData", errorManager.getFullExceptionMessage(error), eErrorSeverity.high);
            },
            null, null, null, false
        );
    };

    return {
        GetData: getData
    };
};
define("dataaccess/dalInitialData", ["generalmanagers/ErrorManager"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (em) {
				return this.TDALInitialData(em);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TDALInitialData;
    };
}(this)));

var eLoginLogoutReason = {
	userDemand: 7770000,
	doubleLogin: 7770001,
	FxDenied: 7770002,
	appClose: 7770003,
	idleTime: 7770004,
	clientStateError: 7770005,
	serverError: 7770006,
	webTrader_filepathNotAccessible: 7770007,
	webTrader_noViewModeCookie: 7770008,
	webTrader_noVersionCookie: 7770009,
	webTrader_noBrokerCookie: 7770010,
	webTrader_unsupportedError: 7770011,
	mobileTrader_filepathNotAccessible: 7770012,
	mobileTrader_noViewModeCookie: 7770013,
	mobileTrader_noVersionCookie: 7770014,
	mobileTrader_noBrokerCookie: 7770015,
	mobileTrader_unsupportedError: 7770016,
	preloaderError_noVersion: 7770017,
	preloaderError_noBroker: 7770018,
	preloaderError_noLanguage: 7770019,
	preloaderError_noStaticParams: 7770020,
	preloaderError_ajaxHttp: 7770021,
	preloaderError_other: 7770022,
	preloaderError_jsonParse: 7770051,
	errorManager_httpError: 7770023,
	alert_exitApp: 7770024,
	web_exitAlert: 7770025,
	mobile_exitAlert: 7770026,
	web_postLoginAlertController_serverError: 7770027,
	mobile_postLoginAlertController_serverError: 7770028,
	serverResponseAlert_exit: 7770029,
	initialDataManager_dataError: 7770030,
	initialDataManager_symbolsDataError: 7770031,
	dealAddServerResponseAlert_exit: 7770032,
	dealsClosed_serverResponseAlert_exit: 7770033,
	limitsServerResponseAlert_exit: 7770034,
	activitySupervisor_updateAsStay: 7770035,
	activitySupervisor_exit: 7770036,
	activitySupervisor_logout: 7770037,
	sessionSupervisor_keepAliveHttpContextRequired: 7770038,
	sessionSupervisor_keepAliveCompleteError: 7770039,
	web_doubleLogin1: 7770040,
	web_doubleLogin2: 7770041,
	web_doubleLogin3: 7770042,
	mobile_doubleLogin1: 7770043,
	mobile_doubleLogin2: 7770044,
	mobile_doubleLogin3: 7770045,
	web_registrationFailed: 7770046,
	mobile_registrationFailed: 7770047,
	forgotPasswordLogin: 7770048,
	confirmLogin: 7770049,
	mobileTrader_nocontentStyleBrokerCookie: 7770050,
	changePassword_NoToken: 7770108,
};

define('enums/LoginLogoutReasonEnum',[], function () {
	return eLoginLogoutReason;
});

define(
    'generalmanagers/LocalStoreDoubleTabsListener',
    [
        'require',
        'enums/LoginLogoutReasonEnum',
        'handlers/Cookie',
        'dataaccess/dalCommon'
    ],
    function LocalStoreDoubleTabsListenerDef() {
        var cookieHandler = require('handlers/Cookie'),
            dalCommon = require('dataaccess/dalCommon');

        function localStoreDoubleTabsListener(csmg, checkInterval) {
            function doubleTabsFlow(guid) {
                if (guid && guid !== cookieHandler.ReadCookie('csmg')) {
                    return true;
                }

                return false;
            }

            function iedoubleTabsFlow(guid, delay) {
                var isDt = doubleTabsFlow(guid);

                if (isDt) {
                    dalCommon.Exit(eLoginLogoutReason.initialDataManager_dataError);
                } else {
                    setTimeout(iedoubleTabsFlow, (delay * 2), guid, delay);
                }
            }

            if (checkInterval > 0) {
                setTimeout(iedoubleTabsFlow, checkInterval, csmg, checkInterval);
            }

            cookieHandler.CreateCookie('csmg', csmg);
        }

        return localStoreDoubleTabsListener;
    }
);
define('devicemanagers/LocalStoreDoubleTabsListener', ['generalmanagers/LocalStoreDoubleTabsListener'], function LocalStoreDoubleTabsListener(localStoreDoubleTabsListener) {
    return localStoreDoubleTabsListener;
});
/* global eDealerParams Preloader*/
define("initdatamanagers/InitialDataManager", [
	"require",
	"Q",
	"enums/enums",
	"handlers/general",
	"generalmanagers/ErrorManager",
	"handlers/Logger",
	"JSONHelper",
	"dataaccess/dalInitialData",
	"dataaccess/dalCommon",
	"initdatamanagers/Customer",
	"initdatamanagers/SymbolsManager",
	"managers/CustomerProfileManager",
	"initdatamanagers/InstrumentsManager",
	"configuration/initconfiguration",
	"modules/systeminfo",
	"devicemanagers/LocalStoreDoubleTabsListener",
	"StateObject!PerformaceEvents",
	"StateObject!DealerParams",
	"handlers/Delegate",
	"fxnet/preloader",
], function (require) {
	var Q = require("Q"),
		general = require("handlers/general"),
		ErrorManager = require("generalmanagers/ErrorManager"),
		Logger = require("handlers/Logger"),
		dalCommon = require("dataaccess/dalCommon"),
		dalInitialData = require("dataaccess/dalInitialData"),
		JSONHelper = require("JSONHelper"),
		InstrumentsManager = require("initdatamanagers/InstrumentsManager"),
		Customer = require("initdatamanagers/Customer"),
		CustomerProfileManager = require("managers/CustomerProfileManager"),
		SymbolsManager = require("initdatamanagers/SymbolsManager"),
		applicationConfiguration = require("configuration/initconfiguration").ApplicationConfiguration,
		systemInfo = require("modules/systeminfo"),
		localStoreDoubleTabsListener = require("devicemanagers/LocalStoreDoubleTabsListener"),
		stateObject = require("StateObject!PerformaceEvents"),
		stateObjectDealerParams = require("StateObject!DealerParams"),
		Preloader = require("fxnet/preloader"),
		delegate = require("handlers/Delegate");

	function InitialDataManager(timeout) {
		var prop = {
				profileCustomer: null,
				profileInstrument: null,
				defaultFirstPage: -1,
				initialScreen: {
					screenId: -1,
				},
				csmg: "",
				ready: false,
			},
			onTimestamp = new delegate(),
			onInitialScreens = new delegate(),
			InitialDataError = ErrorManager.createErrorType("InitialDataError", function errorHandler() {
				// this keyword refers to the istance of thrown InitialDataError
				Logger.log("TDALClientState", this.getFullExceptionMessage(), function () {
					dalCommon.Logout(eLoginLogoutReason.initialDataManager_dataError);
				});
			});

		function checkInitialData() {
			var defer = Q.defer();

			function checkPreloader() {
				if (Preloader.DataObjects.initialDataReady) {
					defer.resolve(Preloader.DataObjects.initialData);
					return;
				}

				Preloader.SetInitialDataLoadEvent(checkPreloader);
			}

			checkPreloader();

			return defer.promise;
		}

		function loadData() {
			onTimestamp.Invoke(eFxNetEvents.InitialDataStart);

			return checkInitialData().then(setInitialData).then(checkSetInitialDataResult).finally(endInitialData);
		}

		function checkSetInitialDataResult(initialDataSuccess) {
			if (!initialDataSuccess) {
				throw new InitialDataError("ServerError: Initial data could not be loaded");
			}

			prop.ready = true;
		}

		function endInitialData() {
			onTimestamp.Invoke(eFxNetEvents.InitialDataEnd);
		}

		function loadOnlySymbols(onSymbolLoadComplete) {
			dalInitialData
				.GetData()
				.then(parseInitialDataServerResponse)
				.then(function setSymbolsData(data) {
					if (data.status == "ServerError") {
						dalCommon.Logout(eLoginLogoutReason.initialDataManager_symbolsDataError);

						return false;
					} else {
						var newSystemInfo = data.systemInfo || {};
						newSystemInfo.clientApplicationParams = data.clientParams || {};

						systemInfo.save(newSystemInfo);

						return true;
					}
				})
				.then(function checkSymbolData(symbolsDataSuccess) {
					if (symbolsDataSuccess && general.isFunctionType(onSymbolLoadComplete)) {
						onSymbolLoadComplete();
					} else {
						throw new InitialDataError("ServerError: Initial data could not be loaded");
					}
				})
				.done();
		}

		function parseInitialDataServerResponse(response) {
			if (general.isStringType(response)) {
				return JSONHelper.STR2JSON("InitialDataManager/onLoadComplete", response, eErrorSeverity.high);
			}

			return response || {};
		}

		function saveSystemInfo(initialData) {
			var systemInfoValue;
			var countryArray = parseInitialDataServerResponse(initialData.Countries);

			systemInfoValue = initialData.Main.systemInfo || {};
			systemInfoValue.clientApplicationParams = initialData.Main.clientParams || {};
			systemInfoValue.slaTimeout = 1000; // It could be fetched from DB
			systemInfoValue.limitRatePercentage = parseFloat(systemInfoValue.limitRatePercentage || "0.5");
			systemInfoValue.instruments = parseInitialDataServerResponse(initialData.Instruments);
			systemInfoValue.countries = getCountriesAsAnObject(countryArray);
			systemInfoValue.uiExclusionCountries = getCountriesAsAnObject(
				countryArray.filter(function (country) {
					return country[eCountryAttributes.IsActive] === 0;
				})
			);
			systemInfoValue.symbols = parseInitialDataServerResponse(initialData.Symbols);

			systemInfo.save(systemInfoValue);
		}

		function setInitialData(data) {
			var parsedData = parseInitialDataServerResponse(data);

			if (parsedData.Main.status == "ServerError") {
				return false;
			}

			saveSystemInfo(parsedData);

			stateObjectDealerParams.set(eDealerParams.DealerCurrency, window.environmentData.dealerCurrency);
			stateObjectDealerParams.set(
				eDealerParams.DealerAdvancedWalletView,
				window.environmentData.dealerAdvancedWalletView
			);

			setPersonalInfo(parsedData.Main.personalInfo, parsedData.Symbols);

			stateObject.update("InitialDataLoadCompleted", parsedData.Main.initialServerTime);

			return true;
		}

		function getCountriesAsAnObject(countriesArray) {
			var countriesObject = {};

			for (var i = 0, length = countriesArray.length; i < length; i++) {
				countriesObject[countriesArray[i][eCountryAttributes.Id]] = countriesArray[i][eCountryAttributes.Name];
			}

			return countriesObject;
		}

		function setUiVersion(personalInfo) {
			if (applicationConfiguration.applicationType === eApplicationTypes.Web) {
				var prevMainForm = 1;

				personalInfo.profileCustomer.dealSlipVersion = eUIVersion.Default;

				if (personalInfo.profileCustomer.homePage === prevMainForm) {
					personalInfo.profileCustomer.homePage = eForms.Deals;
				}

				if (personalInfo.defaultFirstPage === prevMainForm) {
					personalInfo.defaultFirstPage = eForms.Deals;
				}
			} else {
				personalInfo.profileCustomer.homePage = eForms.Quotes;
			}

			personalInfo.profileCustomer.isAllowedSwitchView = 0;
		}

		function setPersonalInfo(pInfo, symbols) {
			var personalInfo = {
				customer: {},
				defaultFirstPage: 0,
				profileCustomer: {},
				profileInstrument: {},
				customQuotesUIOrder: [],
				initialScreen: [],
				initialQuotesUIOrder: [],
				availableScreens: [],
			};

			Object.assign(personalInfo, pInfo || {});

			setUiVersion(personalInfo);

			prop.profileCustomer = personalInfo.profileCustomer;
			prop.profileInstrument = personalInfo.profileInstrument;
			prop.defaultFirstPage = personalInfo.defaultFirstPage;
			prop.csmg = personalInfo.csmg;
			prop.initialScreen.screenId = personalInfo.initialScreen;
			prop.customQuotesUIOrder = personalInfo.customQuotesUIOrder;

			onInitialScreens.Invoke(personalInfo.availableScreens);

			SymbolsManager.Init(symbols || []);
			Customer.Init(personalInfo.customer, prop.defaultFirstPage, prop.profileCustomer.homePage);

			CustomerProfileManager.Init(
				prop.profileCustomer,
				Customer.prop.startUpForm,
				prop.profileInstrument,
				prop.initialScreen.screenId
			);
			CustomerProfileManager.Events.onStartUpFormChanged.Add(function (value) {
				Customer.prop.startUpForm = value;
				prop.defaultFirstPage = value;
			});
			CustomerProfileManager.Events.onInitialScreenChanged.Add(function (value) {
				prop.initialScreen.screenId = value;
			});

			Customer.prop.selectedCcyId(
				stateObjectDealerParams.get(eDealerParams.DealerCurrency) ||
					CustomerProfileManager.ProfileCustomer().displaySymbol ||
					Customer.prop.selectedCcyId()
			);

			InstrumentsManager.Init({
				customerType: Customer.prop.customerType,
				hasWeightedVolumeFactor: Customer.prop.hasWeightedVolumeFactor,
				isOvernightOnForex: Customer.prop.isOvernightOnForex,
				customUiOrder: personalInfo.customQuotesUIOrder,
				initialUiOrder: personalInfo.initialQuotesUIOrder,
				initialScreenId: prop.initialScreen.screenId,
				initialProfileInstrument: prop.profileInstrument,
			});

			localStoreDoubleTabsListener(prop.csmg, timeout);
		}

		function updateInitialScreen(screenId) {
			prop.initialScreen.screenId = screenId;
		}

		return {
			LoadData: loadData,
			LoadOnlySymbols: loadOnlySymbols,
			UpdateInitialScreen: updateInitialScreen,
			prop: prop,
			OnInitialScreens: onInitialScreens,
			OnTimestamp: onTimestamp,
		};
	}

	window.$initialDataManager = new InitialDataManager(applicationConfiguration.doubleTabListenInterval);

	return window.$initialDataManager;
});


define('managers/PresetBuilder',
    [
        'require',
        'knockout',
        'handlers/general',
        "helpers/ObservableHashTable",
        'initdatamanagers/InitialDataManager',
        'Dictionary'
    ],
    function (require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            dictionary = require('Dictionary'),
            observableHashTable = require("helpers/ObservableHashTable"),
            initialDataManager = require('initdatamanagers/InitialDataManager');

        function setPresetName(params) {
            for (var presetName in ePresetType) {
                if (ePresetType.hasOwnProperty(presetName) &&
                    ePresetType[presetName] === params.presetId) {
                    return presetName;
                }
            }

            return "";
        }

        function setPresetOrder(params) {
            if (params.ascOrderPresetIds && 0 <= params.ascOrderPresetIds.indexOf(params.presetId)) {
                return ePresetsOrder.Ascending;
            }

            if (params.descOrderPresetIds && 0 <= params.descOrderPresetIds.indexOf(params.presetId)) {
                return ePresetsOrder.Descending;
            }

            return ePresetsOrder.None;
        }

        function newPreset(currentCategory, presetType) {
            var data = {};

            var presetId = currentCategory.presets[presetType].id,
                subCategory = currentCategory.presets[presetType].subCategory;

            data = {
                presetId: presetId,
                instrumentType: currentCategory.instrumentType,
                subCategory: subCategory,
                categoryNameKey: currentCategory.categoryName,
                presetOrder: currentCategory.presetOrder,
                isInitial: presetId == initialDataManager.prop.initialScreen.screenId,
                ascOrderPresetIds: currentCategory.ascOrderPresetIds,
                descOrderPresetIds: currentCategory.descOrderPresetIds
            };

            var name = setPresetName(data);

            var quotesCollection = new observableHashTable(ko,general,'id');
            var onOrderUpdate = new TDelegate();

            var isSelected = ko.observable(false);
            var isReady = ko.observable(false);

            function getNonFakeCount() {
                return quotesCollection.Values()
                    .filter(function (item) {
                        return item.isFake === false;
                    })
                    .length;
            }

            var nonFakeCount = ko.pureComputed(getNonFakeCount);

            function updateOrder() {
                var newOrder = quotesCollection.Values()
                                .filter(function (item) { return item.isFake === false; })
                                .map(function (item) { return item.id; });

                onOrderUpdate.Invoke(newOrder);

                ko.postbox.publish("favorite-instruments-reorder-drop");
            }

            function update() {
                clear();

                if (isSelected()) {
                    isSelected(false);
                    isSelected(true);
                }
            }

            function addRange(collection) {
                quotesCollection.AddRange(collection);
                isReady(true);
            }

            function clear() {
                isReady(false);
                quotesCollection.Clear();
            }

            return {
                Id: data.presetId,
                IdString: data.presetId.toString(),
                InstrumentType: parseInt(data.instrumentType),
                CategoryNameKey: data.categoryNameKey,
                IsReady: isReady,
                Order: setPresetOrder(data),
                PresetOrder: data.presetOrder,
                subCategory: data.subCategory,
                Name: name,
                Label: dictionary.GetItem(name, 'PresetsCategories'),
                IsCustomScreen: (data.presetId === ePresetType.PresetCustomized),
                isSelected: isSelected,
                OnOrderUpdate: onOrderUpdate,
                UpdateOrder: updateOrder,
                QuotesCollection: quotesCollection,
                TemporaryQuotesCollection: [],
                Count: nonFakeCount,
                Update: update,
                AddRange: addRange,
                Clear: clear
            };
        }

        return {
            NewPreset: newPreset
        }
    }
);

define('managers/PresetCollectionBuilder',
    [
        'require',
        'managers/PresetBuilder'
    ],
    function (require) {
        var presetBuilder = require('managers/PresetBuilder');

        function newCollection(categories, availableScreens) {
            var presets = [];
            availableScreens = availableScreens || [];

            for (var index = 0, count = categories.length; index < count; index++) {
                var currentCategory = categories[index];

                for (var presetType in currentCategory.presets) {
                    if (currentCategory.presets.hasOwnProperty(presetType)) {
                        if (availableScreens.contains(currentCategory.presets[presetType].id)) {
                            presets.push(presetBuilder.NewPreset(currentCategory, presetType));
                        }
                    }
                }
            }

            return presets;
        }

        return {
            NewCollection: newCollection
        };
    }
);


define('managers/PresetCategoryBuilder',
    [
        'require',
        'knockout',
        'initdatamanagers/InstrumentsManager',
        'Dictionary'
    ],
    function (require) {
        var ko = require('knockout'),
            dictionary = require('Dictionary'),
            instrumentsManager = require('initdatamanagers/InstrumentsManager');

        function newCategory(presetArr, categoryName) {
            var key = presetArr.length ? presetArr[0].CategoryNameKey : categoryName,
                selectedPreset = ko.observable("").extend({ notify: "always" }),
                lastSelectedPreset = null,
                label = dictionary.GetItem(key, 'PresetsCategories'),
                presets = presetArr;
            
            presets.forEach(function (preset) {
                preset.isSelected.subscribe(function (isSelected) {
                    if (isSelected) {
                        lastSelectedPreset = preset;
                    }
                }, preset);
            });

            var categoryIsSelected = ko.pureComputed(function () {
                var selectedItem = presets.find(function (item) {
                    return item.isSelected();
                });

                return !!selectedItem;
            });

            function select() {
                if (!presets.length) {
                    return;
                }

                var firstPresetFromCollection = presets[0];

                //if we are in main tab and after login (don't have lastSelectedPreset) and have at least one instrument in Favorites, switch to Favorites
                //if Favorites is empty, switch to next preset (MostPopular)
                if (presets.length > 0 &&
                    firstPresetFromCollection.Count() === 0 &&
                    firstPresetFromCollection.CategoryNameKey === "PresetMainTab" &&
                    instrumentsManager.GetPresetInstruments(firstPresetFromCollection.Id).length === 0) {
                    firstPresetFromCollection = presets[1];
                }

                selectedPreset(lastSelectedPreset ? lastSelectedPreset.Id : firstPresetFromCollection.Id);
                ko.postbox.publish('main-tab-click');
            }
            
            function compareAlphabetically(a, b) {
                var firstPresetLabel = a.Label,
                    secondPresetLabel = b.Label;

                return firstPresetLabel.localeCompare(secondPresetLabel);
            }

            function compareSubCategoryOrder(a, b) {
                return a.subCategory.order - b.subCategory.order;
            }

            function sortSubCategoryPresets(subCategoryGroup) {
                if (subCategoryGroup.subCategory.sortAlphabetically) {
                    subCategoryGroup.presets.sort(compareAlphabetically);
                }
            }

            function sortColumns(subCategories) {
                return subCategories
                    .sort(compareSubCategoryOrder)
                    .forEach(sortSubCategoryPresets);
            }

            function getGroupedPresetsByColumns() {
                var columns = [],
                    subCategories = {};

                for (var i = 0; i < presets.length; i++) {
                    var preset = presets[i],
                        columnIndex = preset.subCategory.columnId,
                        group = subCategories[preset.subCategory.label];

                    while (columns.length <= columnIndex) {
                        columns.push([]);
                    }

                    if (!group) {
                        group = { subCategory: preset.subCategory, presets: [] };
                        subCategories[preset.subCategory.label] = group;
                        columns[columnIndex].push(group);
                    }

                    group.presets.push(preset);
                }

                columns.forEach(sortColumns);

                return columns;
            }

            return {
                Key: key,
                SelectedPreset: selectedPreset,
                LastSelectedPreset: lastSelectedPreset,
                Label: label,
                GetGroupedPresetsByColumns: getGroupedPresetsByColumns,
                Presets: presets,
                isSelected: categoryIsSelected,
                Select: select
            };

        }

        return {
            NewCategory: newCategory
        };
    }
);

define("modules/PresetsManager", [
	"require",
	"Q",
	"handlers/general",
	"initdatamanagers/Customer",
	"generalmanagers/ErrorManager",
	"handlers/Logger",
	"dataaccess/dalInstruments",
	"global/UrlResolver",
	"devicemanagers/StatesManager",
], function PresetsManager(require) {
	var Q = require("Q"),
		general = require("handlers/general"),
		Customer = require("initdatamanagers/Customer"),
		ErrorManager = require("generalmanagers/ErrorManager"),
		Logger = require("handlers/Logger"),
		dalInstruments = require("dataaccess/dalInstruments"),
		StatesManager = require("devicemanagers/StatesManager"),
		UrlResolver = require("global/UrlResolver");

	var presetsRefreshTimeoutMiliseconds = 5 * 60 * 1000,
		defer = Q.defer(),
		isStarted = false,
		availableScreens = [],
		hasData = defer.promise,
		presetInstrumentsList = [],
		onPresetsUpdated = new TDelegate();

	var QuotesPresetsError = ErrorManager.createErrorType("QuotesPresetsError", function errorHandler() {
		// this keyword refers to the istance of thrown InitialDataError
		Logger.log("TDALClientState", this.getFullExceptionMessage(), function () {});
	});

	function load() {
		loadPresets(Customer.prop).then(processPresets).catch(onError).finally(setPresetsRefreshTimer).done();
	}

	function onError(error) {
		throw new QuotesPresetsError("PresetsManager: Error on load/parse presets: " + error.message);
	}

	function loadPresets(customerProperties) {
		return dalInstruments.GetPresets({
			folderId: getFolderId(),
			brokerId: customerProperties.brokerID,
			futuresPermission: customerProperties.futureStatus,
			stocksPermission: customerProperties.shareStatus,
		});
	}

	function getFolderId() {
		var folder = StatesManager.States.Folder;
		var folderId;

		if (!general.isNullOrUndefined(folder) && !general.isNullOrUndefined(folder()) && folder() !== -1) {
			folderId = folder();
		} else {
			folderId = UrlResolver.getFolderForInstruments();
		}

		return folderId;
	}

	function processPresets(presets) {
		if (!presets) {
			throw new QuotesPresetsError("ServerError: Presets could not be loaded");
		}

		var cfdScreens = [];

		for (var key in presets) {
			if (presets.hasOwnProperty(key)) {
				var presetId = parseInt(key);
				if (isNaN(presetId)) {
					continue;
				}

				cfdScreens.push(presetId);
			}
		}

		setPresetLoaded(presets, cfdScreens);
	}

	function setPresetsRefreshTimer() {
		setTimeout(load, presetsRefreshTimeoutMiliseconds);
	}

	function getDefaultCfdScreenId() {
		var cfdScreens = this.GetAvailableScreens();

		return getCfdDefaultScreenId(cfdScreens);
	}

	function setAvailableScreens(screens) {
		availableScreens = availableScreens.concatUnique(screens);
	}

	function getAvailableScreens() {
		return availableScreens || [];
	}

	function getPresetInstruments() {
		return presetInstrumentsList;
	}

	function setPresetLoaded(presets, cfdScreens) {
		presetInstrumentsList = Object.assign({}, presets);
		setAvailableScreens(cfdScreens);

		onPresetsUpdated.Invoke(presets, cfdScreens);

		defer.resolve(this);
	}

	function start() {
		if (!isStarted) {
			load();
		}

		isStarted = true;
	}

	function getCfdDefaultScreenId(cfdScreens) {
		if (0 <= cfdScreens.indexOf(ePresetType.PresetMostPopular)) {
			return ePresetType.PresetMostPopular;
		}

		if (0 <= cfdScreens.indexOf(ePresetType.PresetMostPopularWithoutShares)) {
			return ePresetType.PresetMostPopularWithoutShares;
		}

		if (0 <= cfdScreens.indexOf(ePresetType.PresetMostPopularWithoutFutures)) {
			return ePresetType.PresetMostPopularWithoutFutures;
		}

		if (0 <= cfdScreens.indexOf(ePresetType.PresetMostPopularWithoutFuturesWithoutShares)) {
			return ePresetType.PresetMostPopularWithoutFuturesWithoutShares;
		}

		if (0 <= cfdScreens.indexOf(ePresetType.PresetMostPopularCurrencies)) {
			return ePresetType.PresetMostPopularCurrencies;
		}

		return -1;
	}

	return {
		HasData: hasData,
		GetDefaultCFDScreenId: getDefaultCfdScreenId,
		SetAvailableScreens: setAvailableScreens,
		GetAvailableScreens: getAvailableScreens,
		Start: start,
		OnPresetsUpdated: onPresetsUpdated,
		GetPresetInstruments: getPresetInstruments,
	};
});

define(
    'FxNet/Common/Constants/Collections/PresetsDefinitions',
    [
        'enums/enums'
    ],
    function () {
        var subCategories = {
            Display: {
                label: "lblDisplay",
                order: 0,
                columnId: 0
            },
            CrossRates: {
                label: "lblCrossRates",
                order: 1,
                columnId: 0
            },
            Group: {
                label: "lblGroup",
                order: 2,
                columnId: 0
            },
            Region: {
                label: "lblRegion",
                order: 3,
                columnId: 0
            },
            Americas: {
                label: "lblAmericas",
                order: 4,
                sortAlphabetically: true,
                columnId: 0
            },
            APAC: {
                label: "lblAPAC",
                order: 5,
                sortAlphabetically: true,
                columnId: 0
            },
            EMEA: {
                label: "lblEMEA",
                order: 6,
                sortAlphabetically: true,
                columnId: 1
            },
            Assets: {
                label: "lblAssets",
                order: 7,
                columnId: 0
            }
        };

        return [
            {
                presets: {
                    PresetCustomized: { id: 0, subCategory: subCategories.Display },
                    PresetMostPopular: { id: 2, subCategory: subCategories.Display },
                    PresetMostPopularWithoutFutures: { id: 1, subCategory: subCategories.Display },
                    PresetMostPopularWithoutShares: { id: 18, subCategory: subCategories.Display },
                    PresetMostPopularWithoutFuturesWithoutShares: { id: 19, subCategory: subCategories.Display },
                    PresetNewReleases: { id: 136, subCategory: subCategories.Display },
                    PresetNewReleasesNoFutures: { id: 137, subCategory: subCategories.Display },
                    PresetNewReleasesNoShares: { id: 138, subCategory: subCategories.Display },
                    PresetNewReleasesNoSharesNoFutures: { id: 139, subCategory: subCategories.Display },
                    MainHot: { id: 80, subCategory: subCategories.Display },
                    MainHot_NoShares: { id: 83, subCategory: subCategories.Display },
                    MainHot_NoSharesNoFutures: { id: 84, subCategory: subCategories.Display },
                    MainTopGainers: { id: 85, subCategory: subCategories.Display },
                    MainTopGainers_NoShares: { id: 88, subCategory: subCategories.Display },
                    MainTopGainers_NoSharesNoFuture: { id: 89, subCategory: subCategories.Display },
                    MainTopLosers: { id: 90, subCategory: subCategories.Display },
                    MainTopLosers_NoShares: { id: 93, subCategory: subCategories.Display },
                    MainTopLosers_NoSharesNoFutures: { id: 94, subCategory: subCategories.Display },
                    MainHot_NoFutures: { id: 101, subCategory: subCategories.Display },
                    MainTopGainers_NoFutures: { id: 102, subCategory: subCategories.Display },
                    MainTopLosers_NoFutures: { id: 103, subCategory: subCategories.Display }
                },
                ascOrderPresetIds: [90, 93, 94, 103],
                descOrderPresetIds: [85, 88, 89, 102],
                categoryName: "PresetMainTab",
                presetOrder: 0,
                sortPresetsAlphabetically: false,
                instrumentType: eInstrumentType.Mixed,
                searchPresetIds: []
            },
            {
                presets: {
                    PresetMostPopularCurrencies: { id: 3, subCategory: subCategories.Display },
                    CurrenciesHot: { id: 81, subCategory: subCategories.Display },
                    CurrenciesTopGainers: { id: 86, subCategory: subCategories.Display },
                    CurrenciesTopLosers: { id: 91, subCategory: subCategories.Display },
                    PresetUsdCurrencies: { id: 4, subCategory: subCategories.CrossRates },
                    PresetEurCurrencies: { id: 5, subCategory: subCategories.CrossRates },
                    PresetGbpCurrencies: { id: 6, subCategory: subCategories.CrossRates },
                    PresetJpyCurrencies: { id: 7, subCategory: subCategories.CrossRates },
                    PresetOtherCurrencies: { id: 8, subCategory: subCategories.CrossRates }
                },
                ascOrderPresetIds: [91],
                descOrderPresetIds: [86],
                categoryName: "PresetCurrenciesTab",
                presetOrder: 1,
                sortPresetsAlphabetically: false,
                instrumentType: eInstrumentType.Currencies,
                searchPresetIds: [4, 5, 6, 7, 8]
            },
            {
                presets: {
                    PresetCommodities: { id: 9, subCategory: subCategories.Display },
                    PresetCommoditiesWithoutFutures: { id: 10, subCategory: subCategories.Display },
                    CommoditiesHot: { id: 95, subCategory: subCategories.Display },
                    CommoditiesTopGainers: { id: 96, subCategory: subCategories.Display },
                    CommoditiesTopLosers: { id: 97, subCategory: subCategories.Display },
                    PresetCommoditiesAgricultural: { id: 24, subCategory: subCategories.Group },
                    PresetCommoditiesEnergy: { id: 25, subCategory: subCategories.Group },
                    PresetCommoditiesMetals: { id: 26, subCategory: subCategories.Group }
                },
                ascOrderPresetIds: [97],
                descOrderPresetIds: [96],
                categoryName: "PresetCommoditiesTab",
                presetOrder: 2,
                sortPresetsAlphabetically: false,
                instrumentType: eInstrumentType.Commodities,
                searchPresetIds: [10, 24, 25, 26]
            },
            {
                presets: {
                    IndiciesMostPopular_NoShares: { id: 11, subCategory: subCategories.Display },
                    IndicesHot_NoShares: { id: 98, subCategory: subCategories.Display },
                    IndicesTopGainers_NoShares: { id: 99, subCategory: subCategories.Display },
                    IndicesTopLosers_NoShares: { id: 100, subCategory: subCategories.Display },
                    IndicesEMEA_NoShares: { id: 27, subCategory: subCategories.Display },
                    IndicesNorthAmericas_NoShares: { id: 28, subCategory: subCategories.Display },
                    IndicesOther_NoShares: { id: 29, subCategory: subCategories.Display },
                    IndicesMostPopular: { id: 113, subCategory: subCategories.Display },
                    IndicesHot: { id: 114, subCategory: subCategories.Display },
                    IndicesTopGainers: { id: 115, subCategory: subCategories.Display },
                    IndicesTopLosers: { id: 116, subCategory: subCategories.Display },
                    IndicesNorthAmericas: { id: 118, subCategory: subCategories.Region },
                    IndicesOther: { id: 119, subCategory: subCategories.Region },
                    IndicesEMEA: { id: 117, subCategory: subCategories.Region }
                },
                ascOrderPresetIds: [100, 116],
                descOrderPresetIds: [99, 115],
                categoryName: "PresetIndicesTab",
                presetOrder: 3,
                sortPresetsAlphabetically: false,
                instrumentType: eInstrumentType.Indices,
                searchPresetIds: [27, 28, 29, 117, 118, 119]
            },
            {
                presets: {
                    PresetShares: { id: 12, subCategory: subCategories.Display },
                    SharesHot: { id: 82, subCategory: subCategories.Display },
                    SharesTopGainers: { id: 87, subCategory: subCategories.Display },
                    SharesTopLosers: { id: 92, subCategory: subCategories.Display },
                    PresetSharesUS: { id: 13, subCategory: subCategories.Americas },
                    PresetSharesUK: { id: 20, subCategory: subCategories.EMEA },
                    PresetSharesJapan: { id: 22, subCategory: subCategories.APAC },
                    PresetSharesHongKong: { id: 125, subCategory: subCategories.APAC },
                    PresetSharesGermany: { id: 15, subCategory: subCategories.EMEA },
                    PresetSharesFrance: { id: 21, subCategory: subCategories.EMEA },
                    PresetSharesIndia: { id: 140, subCategory: subCategories.APAC },
                    PresetSharesItaly: { id: 17, subCategory: subCategories.EMEA },
                    PresetSharesNetherlands: { id: 31, subCategory: subCategories.EMEA },
                    PresetSharesAustralia: { id: 126, subCategory: subCategories.APAC },
                    PresetSharesSouthCorea: { id: 30, subCategory: subCategories.APAC },
                    PresetsSharesSaudiArabia: { id: 135, subCategory: subCategories.EMEA },
                    PresetSharesSpain: { id: 16, subCategory: subCategories.EMEA },
                    PresetSharesRussia: { id: 23, subCategory: subCategories.EMEA },
                    PresetSharesMexico: { id: 127, subCategory: subCategories.Americas },
                    PresetSharesSwitzerland: { id: 32, subCategory: subCategories.EMEA },
                    PresetSharesSweden: { id: 33, subCategory: subCategories.EMEA },
                    PresetSharesPoland: { id: 128, subCategory: subCategories.EMEA },
                    PresetSharesFinland: { id: 132, subCategory: subCategories.EMEA },
                    PresetSharesGreece: { id: 129, subCategory: subCategories.EMEA },
                    PresetSharesCzechRepublic: { id: 130, subCategory: subCategories.EMEA },
                    PresetSharesHungary: { id: 131, subCategory: subCategories.EMEA }
                },
                ascOrderPresetIds: [92],
                descOrderPresetIds: [87],
                categoryName: "PresetSharesTab",
                presetOrder: 4,
                sortPresetsAlphabetically: true,
                instrumentType: eInstrumentType.Shares,
                searchPresetIds: [13, 20, 22, 125, 15, 21, 140, 17, 31, 126, 30, 135, 16, 23, 127, 32, 33, 128, 132, 129, 130, 131]
            },
            {
                presets: {
                    StocksMostPopular: { id: 141, subCategory: subCategories.Display }
                },
                categoryName: "PresetStocksTab",
                presetOrder: 5,
                instrumentType: eInstrumentType.Stocks,
                ascOrderPresetIds: [],
                descOrderPresetIds: [],
                searchPresetIds: [141]
            },
            {
                presets: {
                    ETFMostPopular: { id: 104, subCategory: subCategories.Display },
                    ETFHot: { id: 105, subCategory: subCategories.Display },
                    ETFTopGainers: { id: 106, subCategory: subCategories.Display },
                    ETFTopLosers: { id: 107, subCategory: subCategories.Display },
                    ETFCommodities: { id: 108, subCategory: subCategories.Assets },
                    ETFEquityCountries: { id: 109, subCategory: subCategories.Assets },
                    ETFEquityIndices: { id: 110, subCategory: subCategories.Assets },
                    ETFEquitySectors: { id: 111, subCategory: subCategories.Assets },
                    ETFFixedIncome: { id: 112, subCategory: subCategories.Assets }
                },
                ascOrderPresetIds: [107],
                descOrderPresetIds: [106],
                categoryName: "PresetETFTab",
                presetOrder: 6,
                instrumentType: eInstrumentType.ETF,
                searchPresetIds: [108, 109, 110, 111, 112]
            },
            {
                presets: {
                    CryptoMostPopular: { id: 120, subCategory: subCategories.Display },
                    CryptoHot: { id: 121, subCategory: subCategories.Display },
                    CryptoTopGainers: { id: 122, subCategory: subCategories.Display },
                    CryptoTopLosers: { id: 123, subCategory: subCategories.Display },
                    CryptoCurrencies: { id: 124, subCategory: subCategories.Display }
                },
                ascOrderPresetIds: [123],
                descOrderPresetIds: [122],
                categoryName: "PresetCryptoTab",
                presetOrder: 7,
                instrumentType: eInstrumentType.Crypto,
                searchPresetIds: [124]
            }
        ];
    }
);


define(
    'viewmodels/QuotesPresetViewModel',
    [
        'knockout',
        'viewmodels/ViewModelBase',
        'managers/PresetCollectionBuilder',
        'managers/PresetCategoryBuilder',
        'modules/PresetsManager',
        'modules/FavoriteInstrumentsManager',
        'initdatamanagers/InitialDataManager',
        'managers/CustomerProfileManager',
        'initdatamanagers/InstrumentsManager',
        'managers/instrumentTranslationsManager',
        'managers/viewsmanager',
        'FxNet/Common/Constants/Collections/PresetsDefinitions',
        'handlers/general'
    ],
    function QuotesPresetViewModel() {
        var self = {},
            observableObject = {},
            ko = require('knockout'),
            ViewModelBase = require('viewmodels/ViewModelBase'),
            general = require('handlers/general'),
            inheritedInstance = general.clone(ViewModelBase),
            presetCollectionBuilder = require('managers/PresetCollectionBuilder'),
            presetCategoryBuilder = require('managers/PresetCategoryBuilder'),
            PresetsManager = require('modules/PresetsManager'),
            FavoriteInstrumentsManager = require('modules/FavoriteInstrumentsManager'),
            InitialDataManager = require('initdatamanagers/InitialDataManager'),
            CustomerProfileManager = require('managers/CustomerProfileManager'),
            InstrumentsManager = require('initdatamanagers/InstrumentsManager'),
            InstrumentTranslationsManager = require('managers/instrumentTranslationsManager'),
            ViewsManager = require('managers/viewsmanager'),
            lastPresetIdToSelect = -1,
            maxInitialDataCategories = 2,
            searchInstruments = ko.observable([]),
            singleCharSearch = ko.observable(false),
            presetsDefinitions = require('FxNet/Common/Constants/Collections/PresetsDefinitions'),
            editFavoriteVisible = ko.observable(false);

        function init(customSettings) {
            inheritedInstance.setSettings(self, customSettings);

            setDefaultObservables();
            setComputables();
            setSubscribers();
            setPresetSubscribers();

            buildAndSelect();
        }

        function buildAndSelect() {
            var selectedPresetId = observableObject.SelectedId() || InitialDataManager.prop.initialScreen.screenId;
            var availableCfdScreens = PresetsManager.GetAvailableScreens();

            buildCollections(availableCfdScreens);
            selectPreset(selectedPresetId);

            setSearchInstruments();
        }

        //---------------------------------------------------------
        function isSearchPreset(presetId) {
            var presetIdNum = parseInt(presetId);

            for (var idx = 0; idx < presetsDefinitions.length; idx++) {
                if (0 <= presetsDefinitions[idx].searchPresetIds.indexOf(presetIdNum)) {
                    return true;
                }
            }

            return false;
        }

        //---------------------------------------------------------
        function setSearchInstruments() {
            var instrumentsUiOrder = InstrumentsManager.GetInstrumentIds(),
                presets = InstrumentsManager.GetPresetInstruments();

            var mappedInstruments = instrumentsUiOrder.map(function (instrumentId) {
                //search for preset having instrument
                var presetIdsHavingInstrument = [];

                for (var presetId in presets) {
                    if (!presets.hasOwnProperty(presetId)) {
                        continue;
                    }

                    var presetInstruments = presets[presetId];
                    if (0 <= presetInstruments.findIndex(function (instrument) {
                        return instrument[0] === instrumentId;
                    })) {
                        presetIdsHavingInstrument.push(presetId);
                    }
                }

                if (presetIdsHavingInstrument.length === 0) {
                    return null;
                }

                //search preset for instrument first on searchPresetIds and if not use last one all available presets list
                var instrumentPresetId = presetIdsHavingInstrument.find(isSearchPreset) || presetIdsHavingInstrument[presetIdsHavingInstrument.length - 1];

                var instrumentInfo = InstrumentsManager.GetInstrument(instrumentId),
                    presetInfo = getPreset(instrumentPresetId);

                var instrumentTranslationShort = InstrumentTranslationsManager.Short(instrumentId),
                    instrumentTranslationLong = InstrumentTranslationsManager.Long(instrumentId),
                    fullText = InstrumentTranslationsManager.GetFullTextLatinized(instrumentId),
                    translatedInstrument = InstrumentTranslationsManager.GetTranslatedInstrumentById(instrumentId);

                if (instrumentTranslationLong.length < 2) {
                    singleCharSearch(true);
                }

                return {
                    id: instrumentId,
                    baseSymbolId: instrumentInfo.baseSymbol,
                    otherSymbolId: instrumentInfo.otherSymbol,
                    shortTranslation: instrumentTranslationShort,
                    value: instrumentTranslationLong,
                    fullText: fullText,
                    category: Dictionary.GetItem(presetInfo.CategoryNameKey, 'PresetsCategories') + ' - ' + presetInfo.Label,
                    presetId: presetInfo.Id,

                    instrumentName: instrumentTranslationLong,
                    symbolName: translatedInstrument.baseSymbolName,
                    fullName: InstrumentTranslationsManager.GetTooltipByInstrumentId(instrumentId),
                    ccyOrder: instrumentsUiOrder.indexOf(instrumentId)
                };
            });

            mappedInstruments = mappedInstruments.filter(function (instrument) { return instrument !== null; });

            searchInstruments(mappedInstruments);
        }

        function isDynamicPreset(selectedPresetId) {
            var presetIdNum = parseInt(selectedPresetId);

            for (var idx = 0; idx < presetsDefinitions.length; idx++) {
                if (0 <= presetsDefinitions[idx].ascOrderPresetIds.indexOf(presetIdNum)
                    || 0 <= presetsDefinitions[idx].descOrderPresetIds.indexOf(presetIdNum)
                    || presetIdNum === presetsDefinitions[idx].presets.PresetMostPopularCurrencies
                    || presetIdNum === presetsDefinitions[idx].presets.CurrenciesHot) {
                    return true;
                }
            }

            return false;
        }

        function isFavouritePreset(presetId) {
            var presetIdNum = parseInt(presetId);

            for (var idx = 0; idx < presetsDefinitions.length; idx++) {
                if (presetIdNum === presetsDefinitions[idx].presets.PresetCustomized) {
                    return true;
                }
            }

            return false;
        }

        function equalPresetInstruments(selectedPresetInstruments, newPresetInstruments) {
            if (selectedPresetInstruments.length !== newPresetInstruments.length) {
                return false;
            }

            for (var i = 0; i < newPresetInstruments.length; i++) {
                if (newPresetInstruments[i][0] !== selectedPresetInstruments[i].instrumentId) {
                    return false;
                }
            }
            return true;
        }

        function equalPresets(newPresets, actualPresets) {
            if (general.isNullOrUndefined(newPresets) || general.isNullOrUndefined(actualPresets)) {
                return false;
            }

            actualPresets = actualPresets.filter(function (preset) {
                return isFavouritePreset(preset.Id) === false;
            });

            return Object.keys(newPresets).length === actualPresets.length;
        }

        function buildAndSelectWithDelta(newPresets) {
            var selectedPresetId = observableObject.SelectedId() || InitialDataManager.prop.initialScreen.screenId;
            var actualPresets = observableObject.Presets();

            if (isDynamicPreset(selectedPresetId) || equalPresets(newPresets, actualPresets) === false) {
                buildAndSelect();
            } else {
                var selectedPresetInstruments;
                var selectedPreset = actualPresets.find(function (obsPreset) {
                    return obsPreset.Id === selectedPresetId;
                });

                if (general.isNullOrUndefined(selectedPreset) === false) {
                    selectedPresetInstruments = selectedPreset.QuotesCollection.Values().filter(function (instr) {
                        return !instr.isFake;
                    });
                }

                var newPresetInstruments;

                if (general.isNullOrUndefined(newPresets) === false) {
                    newPresetInstruments = newPresets[selectedPresetId];
                }

                if (general.isNullOrUndefined(newPresetInstruments) === false
                    && general.isNullOrUndefined(selectedPresetInstruments) === false
                    && equalPresetInstruments(selectedPresetInstruments, newPresetInstruments) === false) {
                    buildAndSelect();
                }
            }
        }

        function setPresetSubscribers() {
            PresetsManager.OnPresetsUpdated.Add(buildAndSelectWithDelta);
        }

        function reset() {
            lastPresetIdToSelect = -1;

            // Deactivate presets
            observableObject.Presets().forEach(function (item) {
                item.isSelected(false);
            });
        }

        function setDefaultObservables() {
            observableObject.Presets = ko.observableArray([]);
            observableObject.SelectedId = ko.observable("");
            observableObject.isSearch = ko.observable(false);
        }

        function setComputables() {
            observableObject.SelectedPreset = ko.pureComputed(function () {
                var preset = observableObject.Presets().find(function (item) {
                    return item.isSelected();
                });

                if (preset) {
                    observableObject.SelectedId(preset.Id);
                } else {
                    observableObject.SelectedId("");
                }

                return preset;
            });

            observableObject.Categories = ko.computed(function () {
                // Get all categories IDs (InstrumentType)
                var categorySortingIds = observableObject.Presets().map(function (item) {
                    return { instrumentType: item.InstrumentType, presetOrder: item.PresetOrder };
                });

                var categoryList = buildCategories(categorySortingIds);

                if (categoryList.length > maxInitialDataCategories) {
                    return categoryList;
                }

                return fillCategoryList(categoryList);
            });

            observableObject.SelectedCategory = ko.computed(function () {
                var category = observableObject.Categories().find(function (item) {
                    return item.isSelected();
                });

                return category;
            });
        }

        function buildCategories(categoryIds) {
            var uniqueCategories = categoryIds
                .filter(function (value, index, arr) {
                    var categ = arr.find(function (item) {
                        return item.instrumentType === value.instrumentType;
                    });
                    return arr.indexOf(categ) === index;
                })
                .sort(function (a, b) {
                    return a.presetOrder - b.presetOrder;
                });

            var categoriesList = [],
                category;

            for (var i = 0; i < uniqueCategories.length; i++) {
                // Find the presets that belogs to this category
                var presets = observableObject.Presets().filter(function (categoryType, item) {
                    return item.InstrumentType === categoryType;
                }.bind(null, uniqueCategories[i].instrumentType));

                category = presetCategoryBuilder.NewCategory(presets);

                category.SelectedPreset.subscribe(function (presetId) {
                    selectPreset(presetId);
                });

                categoriesList.push(category);
            }

            return categoriesList;
        }

        function fillCategoryList(initialCategoryList) {
            var categoriesList = [],
                initialCategoryNames = initialCategoryList.map(getCategoryName);

            for (var i = 0; i < presetsDefinitions.length; i++) {
                var categoryName = presetsDefinitions[i].categoryName,
                    category;

                if (initialCategoryNames.contains(categoryName)) {
                    category = initialCategoryList.find(isSpecifiedCategory.bind(null, categoryName));
                } else {
                    category = presetCategoryBuilder.NewCategory([], categoryName);
                }

                categoriesList.push(category);
            }

            return categoriesList;
        }

        function getCategoryName(category) {
            return category.Key;
        }

        function isSpecifiedCategory(categoryName, item) {
            return item.Key === categoryName;
        }

        function setSubscribers() {
            ko.postbox.subscribe('swipePreset', function (direction) {
                var categories = observableObject.Categories();
                var currentPresetPos = categories.indexOf(observableObject.SelectedCategory());

                if (direction === "left-to-right") {
                    if (typeof categories[currentPresetPos - 1] !== "undefined") {
                        categories[currentPresetPos - 1].Select();
                    } else {
                        ko.postbox.publish('search-presets');
                        observableObject.isSearch(true);
                    }
                }

                if (direction === "right-to-left" && typeof categories[currentPresetPos + 1] !== "undefined") {
                    if (observableObject.isSearch()) {
                        categories[0].Select();
                    } else {
                        categories[currentPresetPos + 1].Select();
                    }

                    observableObject.isSearch(false);
                }
            });

            InstrumentsManager.OnFavoritesPresetChanged.Add(function onPresetChanged() {
                var customizedPreset = observableObject.Presets().find(function (item) {
                    return item.Id == ePresetType.PresetCustomized;
                });

                if (customizedPreset) {
                    customizedPreset.Update();
                }
            });
        }

        function buildCollections(availableCfdScreens) {
            var collection = presetCollectionBuilder.NewCollection(presetsDefinitions, availableCfdScreens);

            collection.forEach(function (presteItem) {
                presteItem.Select = selectPreset;
            });

            observableObject.Presets(collection);
        }

        function selectPresetHandler(preset) {
            // Only the last clicked preset should be selected
            if (preset.Id !== lastPresetIdToSelect) {
                return;
            }

            if (preset.isSelected()) {
                // Skip an already selected preset
                return;
            }

            // Deactivate others
            observableObject.Presets().forEach(function (item) {
                if (item.Id !== lastPresetIdToSelect) {
                    item.isSelected(false);
                    // remove any listeners
                    item.OnOrderUpdate.Flush();
                }
            });

            if (inheritedInstance.getSettings(self).areQuotesVisible) {
                updateQuoteUIOrder(preset);
            }

            // Activate
            preset.isSelected(true);

            // listen for order change
            preset.OnOrderUpdate.Add(function (instrumentsIds) {
                FavoriteInstrumentsManager.ChangeUIOrder(instrumentsIds, true);
            });

            ko.postbox.publish('preset-changed', preset.Name);
            CustomerProfileManager.LastSelectedPresetId(preset.Id);
        }

        function selectPreset(presetId) {
            presetId = Number(presetId);

            editFavoriteVisible(presetId === 0);

            var presetToActivate = observableObject.Presets().find(function (item) {
                return item.Id === presetId;
            });

            if (!presetToActivate) {
                return;
            }

            lastPresetIdToSelect = presetId;

            selectPresetHandler(presetToActivate);
        }

        function getPreset(presetId) {
            var preset = observableObject.Presets().find(function (item) {
                return item.Id == presetId;
            });

            return preset;
        }

        function updateQuoteUIOrder(preset) {
            var quotesUIorder;

            if (preset.Id == ePresetType.PresetCustomized) {
                quotesUIorder = InstrumentsManager.GetCustomizedUiOrder();
            } else {
                quotesUIorder = InstrumentsManager.GetPresetInstruments(preset.Id);
            }

            if (quotesUIorder) {
                if (!observableObject.isSearch()) {
                    InstrumentsManager.SetQuotesUIOrder(quotesUIorder);
                }

                if (!inheritedInstance.getSettings(self).areQuotesVisible) {
                    ViewsManager.SwitchViewVisible(eForms.Quotes, { presetToSelect: preset.Id });
                }
            }

            ko.postbox.publish('quotes-ui-order-loaded');
        }

        function getCurrentPresetName() {
            var currentPreset = observableObject.SelectedPreset();

            if (!currentPreset) {
                currentPreset = observableObject.Presets().find(function (item) {
                    return InitialDataManager.prop.initialScreen.screenId === item.Id;
                });
            }

            return currentPreset.Name;
        }

        return {
            Init: init,
            Reset: reset,
            Data: observableObject,
            SearchInstrumentsObservable: searchInstruments,
            SingleCharSearch: singleCharSearch,
            GetCurrentPresetName: getCurrentPresetName,
            GetPreset: getPreset,
            SelectPreset: selectPreset,
            IsSearchPreset: isSearchPreset,
            EditFavoriteVisible: editFavoriteVisible
        };
    });
var ViewAndPrintWithdrawalViewModel = function (ko, ViewModelBase, general) {
    var self = this;

    var inheritedInstance = general.clone(ViewModelBase);
    var accountDetails = {};
    var requestDetails = {};

    var depositsInfo = {};

    var init = function (customSettings) {
        inheritedInstance.setSettings(self, customSettings);

        initAccountDetails();
        initRequestDetails();
        initDepositsInfo();
        registerObservableStartUpEvent();

    };
    var initAccountDetails = function () {
        var customer = $customer.prop;

        accountDetails.accountName = customer.userName;
        accountDetails.accountNumber = customer.accountNumber;
        accountDetails.email = customer.email;
        accountDetails.fullName = customer.firstName + ' ' + customer.lastName;
        accountDetails.telephone = customer.phone;
        accountDetails.accountSymbol = customer.defaultCcy();
        accountDetails.equity = ko.observable(0);
        accountDetails.currency = ko.observable("");
    };

    var initRequestDetails = function () {
        requestDetails.date = ko.observable("");
        requestDetails.amount = ko.observable(0);
        requestDetails.currency = ko.observable("");

        requestDetails.bankName = ko.observable("");
        requestDetails.bankAddress = ko.observable("");
        requestDetails.bankDetails = ko.observable("");
        requestDetails.branch = ko.observable("");
        requestDetails.swiftCode = ko.observable(0);
        requestDetails.bankAccount = ko.observable("");

        requestDetails.ccId = ko.observable();
        requestDetails.last4 = ko.observable("");
        requestDetails.creditCardType = ko.observable("");
        requestDetails.creditCardExpirationDate = ko.observable("");

        requestDetails.isBankWithdrawal = ko.computed(function () {
            return general.isEmptyValue(requestDetails.last4()) && !general.isEmptyValue(requestDetails.date());
        });
        requestDetails.isCreditCardWithdrawal = ko.computed(function () {
            return !general.isEmptyValue(requestDetails.last4()) && !general.isEmptyValue(requestDetails.date());
        });

    };

    var initDepositsInfo = function () {
        depositsInfo.depositsTotal = ko.observableArray();
        depositsInfo.deposits = ko.observableArray();
        depositsInfo.firstDepositDate = ko.observable("");
        depositsInfo.lastDepositDate = ko.observable("");

    };
    var registerObservableStartUpEvent = function () {
        $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vViewAndPrintWithdrawal).state.subscribe(function (state) {
            if (state === eViewState.Start) {
                start();
            }
        });
    };

    var start = function () {
        var args = $viewModelsManager.VManager.GetViewArgs(eViewTypes.vViewAndPrintWithdrawal);
        var id = args.iD;

        dalWithdrawal.getWithdrawalRequestById(id, function (responseText) {
            var response = JSONHelper.STR2JSON("ViewAndPrintWithdrawalViewModel/onLoadWithdrawalsComplete", responseText, eErrorSeverity.medium);
            setRequestDetails(response.WithdrawalRequestById);
        });

        dalWithdrawal.getCCDeposits()
            .then(onLoadCCDepositsComplete)
            .done();
    };

    var setRequestDetails = function (lastWithdrawalRequest) {
        if (lastWithdrawalRequest) {
            requestDetails.date(lastWithdrawalRequest.RequestDate);
            requestDetails.amount(lastWithdrawalRequest.Amount);
            requestDetails.currency($symbolsManager.GetTranslatedSymbolByName(lastWithdrawalRequest.SymbolName));

            requestDetails.bankName(lastWithdrawalRequest.BankName);
            requestDetails.bankAddress(lastWithdrawalRequest.BankAddress);
            requestDetails.bankDetails(lastWithdrawalRequest.Details);
            requestDetails.branch(lastWithdrawalRequest.BankBranch);
            requestDetails.swiftCode(lastWithdrawalRequest.SwiftCode);
            requestDetails.bankAccount(lastWithdrawalRequest.BankAccount);
            requestDetails.ccId(lastWithdrawalRequest.CCId);
            requestDetails.last4(lastWithdrawalRequest.Last4);
            requestDetails.creditCardType(lastWithdrawalRequest.CreditCardType);
            requestDetails.creditCardExpirationDate(lastWithdrawalRequest.CreditCardExpirationDate);

        }
    };
    var onLoadCCDepositsComplete = function (responseText) {
        var ccDepositsResponse = JSONHelper.STR2JSON("ViewAndPrintWithdrawalViewModel/onLoadCCDepositsComplete", responseText, eErrorSeverity.medium);

        depositsInfo.deposits(ccDepositsResponse.Deposits);
        depositsInfo.depositsTotal(ccDepositsResponse.DepositsTotal);

        depositsInfo.firstDepositDate(ccDepositsResponse.FirstDepositDate);
        depositsInfo.lastDepositDate(ccDepositsResponse.LastDepositDate);
    };

    //-------------------------------------------------------
    return {
        AccountDetails: accountDetails,
        RequestDetails: requestDetails,
        DepositsInfo: depositsInfo,
        Init: init
    };
};
define("viewmodels/ViewAndPrintWithdrawalViewModel", ["knockout","viewmodels/ViewModelBase","handlers/general"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko, vmb, gen) {
				return this.ViewAndPrintWithdrawalViewModel(ko, vmb, gen);
			};
        ret = fn.apply(global, arguments);
        return ret || global.ViewAndPrintWithdrawalViewModel;
    };
}(this)));

function TDALAccountingActions(ErrorManager, general) {
    function loadAccountingActions(filter, OnLoadComplete) {
        var ajaxer = new TAjaxer();

        var requestFilter = {
            symbolId: filter.SymbolId,
            actionCategory: filter.ActionCategory,
            from: filter.From,
            to: filter.To,
            page: filter.Page,
            position: filter.Position,
            pageSize: filter.pagesize || filter.PageSize,
            exportdata: filter.exportdata || false,
            showCosts: filter.ShowCosts || false,
            closedDate: filter.ClosedDate
        };

        ajaxer.get(
            "TDALAccountingActions/loadAccountingActions",
            "api/accountingactions/GetData",
            general.urlEncode(requestFilter),
            OnLoadComplete,
            function () {
                ErrorManager.onError("TDALAccountingActions/loadAccountingActions", "", eErrorSeverity.medium);
            }
        );
    }

    function getAccountSymbols(OnLoadSymbolsComplete) {
        var ajaxer = new TAjaxer();

        ajaxer.get(
            "TDALAccountingActions/getAccountSymbols",
            "api/accountingactions/GetAccountSymbols",
            "",
            OnLoadSymbolsComplete,
            function () {
                ErrorManager.onError("TDALAccountingActions/getAccountSymbols", "", eErrorSeverity.medium);
            }
        );
    }

    function getContractRollover(filter, OnLoadComplete) {
        var ajaxer = TAjaxer();

        var requestFilter = {
            page: filter.Page,
            position: filter.Position,
            pageSize: filter.pagesize || filter.PageSize,
            exportdata: filter.exportdata || false
        };

        ajaxer.get(
            "TDALAccountingActions/getContractRollover",
            "api/accountingactions/GetAdditionalPl",
            general.urlEncode(requestFilter),
            OnLoadComplete,
            function () {
                ErrorManager.onError("TDALAccountingActions/getContractRollover", "", eErrorSeverity.medium);
            }
        );
    }

    return {
        LoadAccountingActions: loadAccountingActions,
        GetAccountSymbols: getAccountSymbols,
        GetContractRollover: getContractRollover
    };
}
;
define("dataaccess/dalAccountingActions", ["generalmanagers/ErrorManager","handlers/general","handlers/Ajaxer"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (em, general) {
				return this.TDALAccountingActions(em, general);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TDALAccountingActions;
    };
}(this)));

function ObservableDataSet(ko, general, opts, sortingParams) {
    // Keep reference to THIS
    var self = this;
    // Ensure opts is not null
    opts = opts || {};
    var isLoadingData = ko.observable(false);
    // default options
    var defOptions = {
        columns: [],                                // Columns definition
        idField: "id",                              // id field for each record, required for ObservableHashTable
        statusField: "status",                      // response status
        totalField: "total",                        // total records, the field where total records value is stored
        dataField: "data",                          // the field where records are returned
        pagination: {
            pagesPerPage: 5,                        // pages to display
            pageSizeField: "pagesize",              // field for page size
            pageIndexField: "page"                  // field for page index
        },
        Filter: {},                                 // Filter definition
        DAL: {
            reference: function () { },             // reference to DAL function
            callerName: "ObservableDataSet",        // caller name
            errorSeverity: eErrorSeverity.medium,   // error severity
            onLoad: function () { }                 // on load callback
        }
    };

    var options = general.extendType({}, opts, defOptions);  // Merge default options with options passed

    // Initialize properties
    var dataRows = new ObservableHashTable(ko, general, options.idField, sortingParams),
        currentPage = ko.observable(1),
        pageSize = ko.observable(10),
        pages = ko.observableArray(),
        pagesPerPage = ko.observable(options.pagination.pagesPerPage),
        totalRecords = ko.observable(0),
        hasRecords = ko.observable(false);

    var appendRecords = false;

    var showMore = function () {
        if (currentPage() < totalPages()) {
            appendRecords = true;
            currentPage(parseInt(currentPage() + 1));
        }
    };

    var nextPage = function () {
        if (currentPage() < totalPages()) {
            currentPage(parseInt(currentPage() + 1));
        }
    };

    var prevPage = function () {
        if (currentPage() > 1) {
            currentPage(parseInt(currentPage() - 1));
        }
    };

    var firstPage = function () {
        if (currentPage() > 1) {
            currentPage(1);
        }
    };

    var lastPage = function () {
        if (currentPage() < totalPages()) {
            currentPage(totalPages());
        }
    };

    // Computed value
    var totalPages = ko.computed(function () {
        return Math.ceil(totalRecords() / pageSize());
    });
    var hasNextPage = ko.computed(function () {
        return currentPage() < totalPages();
    });
    var isLastPage = ko.computed(function () {
        return currentPage() == totalPages();
    });
    var isFirstPage = ko.computed(function () {
        return currentPage() == 1;
    });
    var hasPrevPage = ko.computed(function () {
        return currentPage() > 1;
    });
    var showPaging = ko.computed(function() {
        return (hasRecords() && totalPages() > 1);
    });

    // apply pageIndex to filter
    var changePageIndexFilter = function (pageIndex) {
        var pageIndexField = options.pagination.pageIndexField;

        if (ko.isWriteableObservable(options.Filter[pageIndexField])) {
            options.Filter[pageIndexField](pageIndex);
        } else {
            options.Filter[pageIndexField] = pageIndex;
        }
    };

    // Subscribe for changing page
    currentPage.subscribe(function (newPageIndex) {
        changePageIndexFilter(newPageIndex);

        // load data when the page is changed
        loadData();
    });

    // initialize column model
    var initColumnModel = function () {
        // Define column template (default properties)
        var columnTemplate = {
            name: "",
            transform: function (value, rIndex, cIndex, rawRecord, record) {
                return value;
            }
        };

        // Initialize columns
        for (var i = 0; i < options.columns.length; i++) {
            options.columns[i] = options.columns[i] || {};

            if (general.isStringType(options.columns[i])) {
                options.columns[i] = {
                    name: options.columns[i]
                };
            }

            // Merge column definition with column template
            general.extendIfType(options.columns[i], columnTemplate);
        }
    };

    // Initialize the DataSet
    var init = function () {
        initColumnModel();      // initialize columns
        setPaginationFilter();  // set pagination
    };

    var updateColumnModel = function (newOptions) {
        options = general.extendType({}, newOptions, defOptions);
        dataRows.KeyProperty(options.idField);

        init();
    };

    var initFilter = function () {
        var filter = {};

        for (var prop in options.Filter) {
            if (options.Filter.hasOwnProperty(prop)) {
                if (ko.isObservable(options.Filter[prop])) {
                    filter[prop] = options.Filter[prop]();
                } else if (ko.isComputed(options.Filter[prop])) {
                    filter[prop] = options.Filter[prop]();
                } else {
                    filter[prop] = options.Filter[prop];
                }
            }
        }

        return filter;
    };

    var setPaginationFilter = function () {
        // get value for pageSize
        var pageSizeField = options.pagination.pageSizeField,
            pageSizeValue = 10;

        if (pageSizeField in options.Filter && general.isNumber(options.Filter[pageSizeField])) {
            // get pageSize value
            pageSizeValue = options.Filter[pageSizeField];
        } else {
            // set default value for pageSize
            options.Filter[pageSizeField] = pageSizeValue;
        }
        // set the value for pageSize
        pageSize(pageSizeValue);

        // set page index value to 1
        changePageIndexFilter(1);
    };

    var setFilter = function (newFilter) {
        options.Filter = newFilter || {};

        // set pagination
        setPaginationFilter();
    };

    // Get values from observable filter
    var applyFilter = function () {
        isLoadingData(true);
        if (currentPage() != 1) {
            // reset current page to 1
            currentPage(1);
        } else {
            loadData();
        }
    };

    // Clean up the memory
    var clean = function () {
        dataRows.Clear();
        pages.removeAll();

        hasRecords(false);
        currentPage(1);
        totalRecords(0);
    };

    // Add record to rows observable collection
    var addRecord = function (rawRecord, rowIndex) {
        if (!general.isEmptyType(rawRecord)) {
            var record = {};

            if (general.isArrayType(rawRecord)) {
                // Iterate through column definitions
                options.columns.forEach(function (column, colIndex) {
                    var field = column.name;
                    var value = "";

                    if ('dataIndex' in column) {
                        if (general.isDefinedType(rawRecord[column.dataIndex])) {
                            value = rawRecord[column.dataIndex];
                        }
                    }

                    if (general.isFunctionType(column.transform)) {
                        value = column.transform(value, rowIndex, colIndex, rawRecord, record);
                    }

                    // Set value for current field
                    record[field] = value;
                });
            } else if (general.isObjectType(rawRecord)) {
                // TODO
            } else if (general.isStringType(rawRecord)) {
                record.value = rawRecord;
            }

            // Check for idField, if not then set the record index
            if (!(options.idField in record)) {
                record[options.idField] = rowIndex;
            }

            // Add record to dataset
            dataRows.Add(record);
        }
    };

    // Paging
    var buildPages = function () {
        pages.removeAll();

        var mod = currentPage() % pagesPerPage();
        var start;
        if (mod == 0) {
            start = currentPage() - pagesPerPage();
        } else {
            start = currentPage() - mod;
        }

        var end = start + pagesPerPage();
        if (end > totalPages()) {
            end = totalPages();
        }

        for (var i = start; i < end; i++) {
            pages.push((i + 1));
        }
    };

    var onData = function (responseText) {
        appendRecords = false;
        var response = JSONHelper.STR2JSON(options.DAL.callerName, responseText, options.DAL.errorSeverity);

        if (response) {
            var result = {};
            result[options.statusField] = "RequestFailed";
            result[options.totalField] = 0;
            result[options.dataField] = [];

            general.extendType(result, response);

            // Set total records
            totalRecords(result[options.totalField]);

            if (eOperationStatus[result[options.statusField]] == eOperationStatus.Success) {
                hasRecords(result[options.dataField].length > 0);

                for (var rIndex = 0, len = result[options.dataField].length; rIndex < len; rIndex++) {
                    addRecord(result[options.dataField][rIndex], rIndex);
                }

                buildPages(); // build paging
            }

            if (general.isFunctionType(options.DAL.onLoad)) {
                options.DAL.onLoad(result);
            }

            isLoadingData(false);
        }
    };

    // Create a callback function for DAL
    var loadData = function () {
        var filter = initFilter();
        isLoadingData(true);

        // Check if new records should be appended
        if (appendRecords !== true) {
            dataRows.Clear();   // remove old records
            hasRecords(false);  // set the hasRecords flag
        }

        // Call the DAL function reference
        if (general.isFunctionType(options.DAL.reference)) {
            return options.DAL.reference.apply(self, [filter, onData]);
        }
    };

    // Return public members
    return {
        Init: init,
        DataRows: dataRows.Values,
        Load: loadData,
        Clean: clean,
        HasRecords: hasRecords,
        ShowPaging: showPaging,
        ApplyFilter: applyFilter,
        IsLoadingData : isLoadingData,
        SetFilter: setFilter,
        Paging: {
            ShowMore: showMore,
            TotalRecords: totalRecords,
            TotalPages: totalPages,
            PageSize: pageSize,
            Pages: pages,
            CurrentPage: currentPage,
            NextPage: nextPage,
            PrevPage: prevPage,
            FirstPage: firstPage,
            LastPage: lastPage,
            IsFirstPage: isFirstPage,
            HasPrevPage: hasPrevPage,
            HasNextPage: hasNextPage,
            IsLastPage: isLastPage
        },
        UpdateColumnModel: updateColumnModel,
        SetSorting: dataRows.SetSorting,
        SortProperties: dataRows.SortProperties
    };
};
define("helpers/observabledataset", ["knockout","JSONHelper","helpers/ObservableHashTable"], (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
				return this.ObservableDataSet;
			};
        ret = fn.apply(global, arguments);
        return ret || global.ObservableDataSet;
    };
}(this)));

function BalanceViewModel(
	ko,
	dalAccountingActions,
	ViewModelBase,
	DealsManager,
	general,
	ObservableDataSet,
	JSONHelper,
	customer,
	viewsManager,
	symbolsManager
) {
	var self,
		viewInfo = {},
		inheritedInstance = general.clone(ViewModelBase),
		hasDataSubscriber;

	var filter = new (function () {
		var me = this;

		me.SymbolId = ko.observable();
		me.OriginalActionCategory = ko.observable("All");

		me.ActionCategory = ko.computed(function () {
			var actionType = me.OriginalActionCategory() || "All";

			switch (actionType.toLowerCase()) {
				case "all":
					actionType = eAccountingActionsCategory.All;
					break;
				case "deposits":
					actionType = eAccountingActionsCategory.Deposits;
					break;
				case "withdrawals":
					actionType = eAccountingActionsCategory.Withdrawals;
					break;
				case "pl":
					actionType = eAccountingActionsCategory.DealPL;
					break;
				case "overnightfinancing":
					actionType = eAccountingActionsCategory.OvernightFinancing;
					break;
				case "contractrollover":
					actionType = eAccountingActionsCategory.ContractRollover;
					break;
				case "dividend":
					actionType = eAccountingActionsCategory.Dividend;
					break;
				case "general":
					actionType = eAccountingActionsCategory.General;
					break;
			}
			return actionType;
		});

		me.From = ko.observable(new Date().AddWeeks(-1).ExtractDate());
		me.To = ko.observable(new Date().ExtractDate());
		me.Position = ko.observable("");
		me.Page = ko.observable(1);
		me.PageSize = 20;

		me.Currencies = ko.observableArray();
	})();

	var onLoad = function (data) {
		viewInfo.showBalanceColumn(filter.SymbolId() !== 0);
	};

	var dsColumns = {
		idField: "actionNumber",
		columns: [
			{
				name: "rowNumber",
				transform: function (value, rowIndex) {
					return rowIndex;
				},
			},
			{
				name: "actionNumber",
				dataIndex: eAccountingAction.actionID,
			},
			{
				name: "date",
				dataIndex: eAccountingAction.date,
			},
			{
				name: "credit",
				dataIndex: eAccountingAction.credit,
			},
			{
				name: "debit",
				dataIndex: eAccountingAction.debit,
			},
			{
				name: "symbolName",
				transform: function (value, rowIndex, cIndex, rawRecord) {
					return symbolsManager.GetTranslatedSymbolById(rawRecord[eAccountingAction.symbolID]);
				},
			},
			{
				name: "creditNoComma",
				transform: function (value, rowIndex, columnIndex, rawRecord, record) {
					return record.credit.sign();
				},
			},
			{
				name: "debitNoComma",
				transform: function (value, rowIndex, columnIndex, rawRecord, record) {
					return record.debit.sign();
				},
			},
			{
				name: "debitCredit",
				transform: function (value, rowIndex, columnIndex, rawRecord, record) {
					return record.debit.cleanComma() > 0
						? "-" + record.debit.cleanComma()
						: record.credit.cleanComma() > 0
						? record.credit.cleanComma()
						: "0.00";
				},
			},
			{
				name: "type",
				transform: function (value, rowIndex, columnIndex, rawRecord) {
					return Dictionary.GetItem("acctype" + rawRecord[eAccountingAction.actionTypeID]);
				},
			},
			{
				name: "isEditable",
				transform: function (value, rowIndex, columnIndex, rawRecord) {
					var isOpenPosition = false;
					var positionNumber = rawRecord[eAccountingAction.posNum];

					DealsManager.Deals.ForEach(function iterator(orderId, deal) {
						if (deal.positionNumber == positionNumber) {
							isOpenPosition = true;

							return false;
						}
					});

					return !isOpenPosition;
				},
			},
			{
				name: "balance",
				dataIndex: eAccountingAction.balance,
			},
			{
				name: "comment",
				dataIndex: eAccountingAction.comment,
			},
			{
				name: "positionNumber",
				dataIndex: eAccountingAction.posNum,
			},
		],
		pageSizes: 20,
		statusField: "status",
		totalField: "totalItems",
		dataField: "actions",
		pagination: {
			pagesPerPage: 5,
			pageIndexField: "Page",
			pageSizeField: "PageSize",
		},
		Filter: filter,
		DAL: {
			reference: dalAccountingActions.LoadAccountingActions,
			callerName: "StatementControl/onLoadComplete",
			errorSeverity: eErrorSeverity.medium,
			onLoad: onLoad,
		},
	};

	var dataSet = new ObservableDataSet(ko, general, dsColumns);

	var init = function (customSettings) {
		self = this;
		inheritedInstance.setSettings(self, customSettings);

		setDefaultObservables();
		setExtenders();
		registerObservableStartUpEvent();

		setFilterDefaults();
		dataSet.Init();
	};

	var setExtenders = function () {
		filter.Position = filter.Position.extend({
			toNumericLength: {
				ranges: [
					{
						from: 0,
						to: Number.MAX_SAFE_INTEGER,
						decimalDigits: 0,
					},
				],
			},
		});
	};

	var setDefaultObservables = function () {
		viewInfo.showBalanceColumn = ko.observable();
	};

	var registerObservableStartUpEvent = function () {
		viewsManager.GetActiveFormViewProperties(eViewTypes.vBalance).state.subscribe(function (state) {
			switch (state) {
				case eViewState.Start:
					start();
					break;
				case eViewState.Stop:
					stop();
					break;
				case eViewState.Refresh:
					dataSet.Load();
					viewsManager.GetActiveFormViewProperties(eViewTypes.vBalance).state(eViewState.Initial);
					break;
			}
		});
	};

	var start = function () {
		hasDataSubscriber = dataSet.HasRecords.subscribe(function (hasData) {
			ko.postbox.publish("printableDataAvailable", {
				dataAvailable: hasData,
				viewType: viewsManager.ActiveFormType(),
				viewModel: "BalanceViewModel",
			});
		});

		dalAccountingActions.GetAccountSymbols(onLoadCCYComplete);
	};

	var stop = function () {
		dataSet.Clean();
		if (hasDataSubscriber) {
			hasDataSubscriber.dispose();
			hasDataSubscriber = null;
		}
		setFilterDefaults();
	};

	var setFilterDefaults = function () {
		filter.SymbolId(customer.prop.baseCcyId());
		filter.OriginalActionCategory("All");
		filter.From(new Date().AddWeeks(-1).ExtractDate());
		filter.To(new Date().ExtractDate());
		filter.Position("");

		if (inheritedInstance.getSettings(self).pageSize) {
			filter.PageSize = inheritedInstance.getSettings(self).pageSize;
		}
	};

	var onLoadCCYComplete = function (responseText) {
		var userSymbols = JSONHelper.STR2JSON("StatementControl/onLoadCCYComplete", responseText, eErrorSeverity.low);

		if (userSymbols) {
			var options = [];
			options.push({
				name: Dictionary.GetItem("All", "contentdata", " "),
				value: eAccountingActionsCategory.All,
			});

			for (var i = 0, ii = userSymbols.length; i < ii; i++) {
				options.push({ name: $symbolsManager.GetTranslatedSymbolById(userSymbols[i]), value: userSymbols[i] });
			}

			filter.Currencies(options);
		}

		setFilterDefaults();
		dataSet.ApplyFilter();
	};

	var enableApplyButton = ko.computed(function () {
		return !dataSet.IsLoadingData();
	}, self);

	var applyFilter = function () {
		if (enableApplyButton()) dataSet.ApplyFilter();
	};

	//----------------------------------------------------------------
	return {
		Init: init,
		ViewInfo: viewInfo,
		BalanceInfo: dataSet.DataRows,
		GetNextBalance: dataSet.Paging.ShowMore(),
		VisibleShowMore: dataSet.Paging.HasNextPage,
		DataSet: dataSet,
		Filter: filter,
		EnableApplyButton: enableApplyButton,
		ApplyFilter: applyFilter,
		HasRecords: dataSet.HasRecords,
		DsColumns: dsColumns,
	};
}

define('viewmodels/BalanceViewModel',[
	"knockout",
	"dataaccess/dalAccountingActions",
	"viewmodels/ViewModelBase",
	"cachemanagers/dealsmanager",
	"handlers/general",
	"helpers/observabledataset",
	"JSONHelper",
	"initdatamanagers/Customer",
	"initdatamanagers/SymbolsManager",
	"managers/viewsmanager",
	"customEnums/ViewsEnums",
], function (
	ko,
	dalAccountingActions,
	ViewModelBase,
	DealsManager,
	general,
	ObservableDataSet,
	JSONHelper,
	customer,
	symbolsManager,
	viewsManager
) {
	return BalanceViewModel(
		ko,
		dalAccountingActions,
		ViewModelBase,
		DealsManager,
		general,
		ObservableDataSet,
		JSONHelper,
		customer,
		viewsManager,
		symbolsManager
	);
});

define(
    'viewmodels/NetExposureViewModel',
    [
        'require',
        'knockout',
        'handlers/general',
        'helpers/ObservableHashTable',
        'cachemanagers/ClientStateHolderManager',
        'cachemanagers/NetExposureManager',
        'initdatamanagers/SymbolsManager'
    ],
    function NetExposureViewModelDef(require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            observableHashTable = require('helpers/ObservableHashTable'),
            csHolderManager = require('cachemanagers/ClientStateHolderManager'),
            netExposureManager = require('cachemanagers/NetExposureManager'),
            symbolsManager = require('initdatamanagers/SymbolsManager');

        var NetExposureViewModel = function NetExposureViewModelClass() {
            var observableNetExposuresObject = {},
                observableNetExposuresCollection = new observableHashTable(ko, general, 'symbolId');

            function init() {
                setObservableNetExposuresObject();
                registerToDispatcher();
            }

            function registerToDispatcher() {
                netExposureManager.OnChange.Add(onNetExposureChange);
                csHolderManager.OnChange.Add(onCsHolderClientStateChange);
            }

            function toObservable(exposure) {
                return {
                    accountSymbolAmount: ko.observable(exposure.accountSymbolAmount),
                    status: exposure.status,
                    amount: ko.observable(exposure.amount),
                    symbolId: ko.observable(exposure.symbolId),
                    symbolName: ko.observable(symbolsManager.GetTranslatedSymbolById(exposure.symbolId))
                };
            }

            function onNetExposureChange(exposures) {
                for (var i = 0; i < exposures.length; i++) {
                    var exposure = exposures[i];

                    if (exposure.status === eStatus.Removed) {
                        observableNetExposuresCollection.Remove(exposure.symbolId);
                        continue;
                    }

                    var item = observableNetExposuresCollection.Get(exposure.symbolId);
                    if (!item) {
                        observableNetExposuresCollection.Add(toObservable(exposure));
                    }
                    else {
                        var delta = {
                            accountSymbolAmount: exposure.accountSymbolAmount,
                            amount: exposure.amount
                        };

                        observableNetExposuresCollection.Update(exposure.symbolId, delta);
                    }
                }
            }

            function onCsHolderClientStateChange() {
                var csHolder = csHolderManager.CSHolder;

                observableNetExposuresObject.netExposure(general.toNumeric(csHolder.netExposure));
            }

            function setObservableNetExposuresObject() {
                var csHolder = csHolderManager.CSHolder;

                observableNetExposuresObject.netExposure = ko.observable(general.toNumeric(csHolder.netExposure));
                observableNetExposuresObject.displayedInAccountCurrency = ko.observable(false);
            }

            return {
                Init: init,
                NetExposureCollection: observableNetExposuresCollection.Values,
                NetExposureInfo: observableNetExposuresObject
            };
        };

        return new NetExposureViewModel();
    }
);
/*eslint no-unused-vars: 0*/
var AccountMarketViewModel = function (ko) {
    var quotesIsAdvanced = ko.observable(false),
        accountSummaryIsAdvanced = ko.observable(false),
        isCollapsed = ko.observable(false),
        useTransitions = ko.observable(false);

    function init() {
        registerObservableStartUpEvent();
    }

    function accSummarySwitchView(newValue) {
        accountSummaryIsAdvanced(newValue);
    }

    function registerObservableStartUpEvent() {
        // set initial value
        accSummarySwitchView(
            $customerProfileManager.ProfileCustomer().advancedWalletView === 1
        );

        // subscribe to changes
        $customerProfileManager.ProfileCustomer.subscribe(function (pc) {
            var isAdvanced = pc.advancedWalletView === 1;
            accSummarySwitchView(isAdvanced);
        });
    }

    function collapsedToggle() {
        isCollapsed(!isCollapsed());
    }

    return {
        Init: init,
        QuotesIsAdvanced: quotesIsAdvanced,
        AccountSummaryIsAdvanced: accountSummaryIsAdvanced,
        IsCollapsed: isCollapsed,
        UseTransitions: useTransitions,
        CollapsedToggle: collapsedToggle,
    };
};

define("viewmodels/AccountMarketViewModel", ["knockout"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko) {
				return this.AccountMarketViewModel(ko);
			};
        ret = fn.apply(global, arguments);
        return ret || global.AccountMarketViewModel;
    };
}(this)));

/* eslint no-extend-native: 0 */
define("generalmanagers/ErrorManager", [
	"require",
	"handlers/Logger",
	"handlers/general",
	"devicemanagers/StatesManager",
	"initdatamanagers/Customer",
	"modules/permissionsmodule",
	"global/UrlResolver",
	"handlers/RequireError",
	"StateObject!ViewsManager",
], function (require) {
	var Logger = require("handlers/Logger"),
		general = require("handlers/general"),
		StatesManager = require("devicemanagers/StatesManager"),
		Customer = require("initdatamanagers/Customer"),
		permissionsModule = require("modules/permissionsmodule"),
		UrlResolver = require("global/UrlResolver"),
		RequireError = require("handlers/RequireError"),
		StateObject = require("StateObject!ViewsManager");

	function ErrorManager() {
		// Extend Error prototype
		Error.prototype.getFullExceptionMessage = function () {
			var self = this;

			var messageObj = {
				Message: self.message,
				StackTrace: (self.stack || "")
					.replace(self.message, "")
					.replace(/\n|\r\n/g, " ")
					.replace(/\s\s+/g, " "),
				Form: "",
				Views: [],
				AccountNumber: Customer.prop.accountNumber,
				UserAgent: window.navigator.userAgent,
			};

			if (window.trackingData) {
				var errorTrackingData = window.trackingData.getErrorTrackingData();

				for (var trakingProperty in errorTrackingData) {
					if (errorTrackingData.hasOwnProperty(trakingProperty)) {
						messageObj[trakingProperty] = errorTrackingData[trakingProperty];
					}
				}
			}

			try {
				messageObj.Form = general.urlDecode(window.location.search)["view"] || "";

				if (StateObject) {
					messageObj.Views = StateObject.get("ActiveViews");
				}
			} catch (e) {
				// empty
			}

			return JSON.stringify(messageObj);
		};

		function redirectTologin() {
			window.location.replace(
				UrlResolver.combine(
					UrlResolver.getApplicationRelativePath(),
					"account/login?reason=" + eLoginLogoutReason.errorManager_httpError
				)
			);
		}

		function handleHttpError(error) {
			if (error && (error.httpStatus === 403 || error.httpStatus === 401 || error.httpStatus === 420)) {
				if (permissionsModule.IsRestrictedUser()) {
					return true;
				}

				redirectTologin();

				return true;
			}

			return false;
		}

		function onException(msg, url, lineNumber, columnNumber, error) {
			if (general.isNullOrUndefined(error)) {
				return true;
			}

			if (handleHttpError(error)) {
				return true;
			}

			if (error && typeof error.handler === "function") {
				// This is a custom error
				error.handler();

				return true;
			}

			handleUnknownException(msg, error);

			throw error;
		}

		function handleUnknownException(msg, error) {
			if (typeof systemInfo !== "undefined" && typeof Logger !== "undefined") {
				var blackList = systemInfo.clientApplicationParams
					? systemInfo.clientApplicationParams[eClientParams.JsErrorBlacklistRegex] || ""
					: "";

				var blacklistReObj = new RegExp(blackList, "i");

				var shouldIgnoreMessageLog =
					blackList.length > 0 &&
					((msg.length > 0 && blacklistReObj.test(msg)) ||
						(error && error.message.length > 0 && blacklistReObj.test(error.message)));

				// log the UnknownError if the error is not in the blacklist
				if (!shouldIgnoreMessageLog) {
					var loggedMessage = (error && error.getFullExceptionMessage()) || msg;
					Logger.log("UnknownError", loggedMessage);
				}
			}
		}

		function onError(functionName, strError, severityLevel) {
			severityLevel = severityLevel || eErrorSeverity.low;

			/*if (strError === "http403") {
				StatesManager.PushState(
					StatesManager.StatePropertiesEnum.Forbidden,
					eErrorSeverity.medium,
					StatesManager.StatePropertiesEnum["Forbidden"]
				);
			} else {
				switch (severityLevel) {
					case eErrorSeverity.critical:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.critical,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;

					case eErrorSeverity.high:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.high,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;

					case eErrorSeverity.medium:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.medium,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;

					case eErrorSeverity.low:
						StatesManager.PushState(
							StatesManager.StatePropertiesEnum.ServerErrorStatus,
							eErrorSeverity.low,
							StatesManager.StatePropertiesEnum["ServerErrorStatus"]
						);
						break;
				}

				var error = {
					Message: strError,
					AccountNumber: Customer.prop.accountNumber,
					UserAgent: window.navigator.userAgent,
				};

				Logger.error(functionName, JSON.stringify(error), general.emptyFn, severityLevel);
			}*/
		}

		function onWarning(source, warningMessage) {
			var warning = {
				Message: warningMessage,
				AccountNumber: Customer.prop.accountNumber,
				UserAgent: window.navigator.userAgent,
			};

			Logger.warn(source, JSON.stringify(warning));
		}

		function getFullExceptionMessage(ex) {
			return ex.getFullExceptionMessage();
		}

		/*
		 * Utility function to create custom Error types
		 *
		 * To create a custom error type, derived from Error JS object
		 *
		 * @param {string} name an unique name for the newly custom error type
		 * @param {function} handler a function used to handle the created type of error
		 *
		 * var myCustomError = ErrorManager.createErrorType("CustomError", function() {
		 *     // this keyword refers to the current error instance
		 *     console.log(this.message);
		 * });
		 *
		 * throw new myCustomError("This is a custom error");
		 *
		 */
		function createErrorType(name, handler) {
			function BaseError(message) {
				this.name = name;
				this.message = message;

				if (!Error.captureStackTrace) {
					this.stack = new Error().stack;
				} else {
					Error.captureStackTrace(this, this.constructor);
				}
			}

			BaseError.prototype = Object.create(Error.prototype);
			BaseError.prototype.name = name;
			BaseError.prototype.constructor = BaseError;
			BaseError.prototype.handler = typeof handler === "function" ? handler : function () {};

			return BaseError;
		}

		function onRequireError(error) {
			if (error.requireType === "mismatch") {
				throw new RequireError("Mismatched anonymous define() module", error);
			}

			throw error;
		}

		return {
			getFullExceptionMessage: getFullExceptionMessage,
			onRequireError: onRequireError,
			onError: onError,
			onWarning: onWarning,
			onException: onException,
			createErrorType: createErrorType,
		};
	}

	var module = (window.ErrorManager = new ErrorManager());

	return module;
});

define("generalmanagers/errormanager", function(){});

var dalActivityLog = function (ErrorManager, general) {
	//---------------------------------------------------------
	// loadActivityLog
	//---------------------------------------------------------

	// var loadActivityLog = function (FilterTypes, From, To, Page, PageSize, OnLoadComplete) {
	var loadActivityLog = function (params, onLoadComplete) {
		var ajaxer = new TAjaxer();

		params = params || {};

		ajaxer.post(
			"TDALHistoricalData/loadActivityLog",
			"api/activitylog/GetData",
			general.urlEncode(params),
			onLoadComplete,
			function () {
				ErrorManager.onError("TDALHistoricalData/loadActivityLog", "", eErrorSeverity.medium);
			},
			0
		);
	};

	return {
		LoadActivityLog: loadActivityLog,
	};
};

define('dataaccess/dalActivityLog',["generalmanagers/errormanager", "handlers/general"], function (Errormanager, general) {
	return dalActivityLog(Errormanager, general);
});

/*globals clone:false, $viewModelsManager:false, eViewState: false, general.str2Date:false, eViewTypes:false, eActivityLogFilterType:false, eActivityLog:false, dalActivityLog:false, eErrorSeverity:false, ObservableDataSet:faLse, ActivityLogModel: true*/
var ActivityLogViewModel = function (ko, general,dalActivityLog, systemInfo) {
    var self = this;
    var dateFrom = ko.observable("").extend({ dirty: false });
    var dateTo = ko.observable("").extend({ dirty: false });
    var recordsRendered = ko.observable(false).extend({ deferred: true });
    var filterBy = ko.observable("");
    var hasDataSubscriber;
    var isLoadingSubscriber;

    var filterTypes = ko.computed(function () {
        var selectedValue = filterBy();
        var types = [];

        if (selectedValue in eActivityLogFilterType) {
            types.push(eActivityLogFilterType[selectedValue]);
        } else {
            for (var name in eActivityLogFilterType) {
                types.push(eActivityLogFilterType[name]);
            }
        }

        return "[" + types.join(",") + "]";
    }, self);

    var dsColumns = {
        columns: [{
            name: "DateTime",
            dataIndex: eActivityLog.DateTime
        }, {
            name: "Type",
            dataIndex: eActivityLog.MessageType
        }, {
            name: "Source",
            dataIndex: eActivityLog.SourceType
        }, {
            name: "Message",
            dataIndex: eActivityLog.Message
        }],
        pageSizes: 5,
        statusField: "status",
        totalField: "totalItems",
        dataField: "activityLogs",
        pagination: {
            pagesPerPage: 5,
            pageIndexField: "page",
            pageSizeField: "pagesize"
        },
        Filter: {
            page: 1,
            pagesize: 20,
            from: dateFrom,
            to: dateTo,
            filterTypes: filterTypes
        },
        DAL: {
            reference: dalActivityLog.LoadActivityLog,
            callerName: "ActivityLogControl/onLoadComplete",
            errorSeverity: eErrorSeverity.medium
        }
    };

    var dataSet = new ObservableDataSet(ko, general, dsColumns);

    var registerObservableStartUpEvent = function () {
        $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vActivityLog).state.subscribe(function (state) {
            switch (state) {
                case eViewState.Start:
                    start();
                    break;
                case eViewState.Stop:
                    stop();
                    break;
                case eViewState.Refresh:
                    dataSet.Load();
                    $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vActivityLog).state(eViewState.Initial);
                    break;
            }
        });
    };

    var init = function () {
        registerObservableStartUpEvent();
        dataSet.Init();
        setValidation();
    };

    var start = function () {
        hasDataSubscriber = dataSet.HasRecords.subscribe(function (hasData) {
            if (!hasData) {
                recordsRendered(false);
            }

            ko.postbox.publish("printableDataAvailable", {
                dataAvailable: hasData,
                viewType: $viewModelsManager.VManager.ActiveFormType(),
                viewModel: 'ActivityLogModel'
            });
        });

        isLoadingSubscriber = dataSet.IsLoadingData.subscribe(function (isLoading) {
            if (isLoading) {
                recordsRendered(false);
            }
        });

        setFilterToDefault();
        dataSet.ApplyFilter();
    };

    var setFilterToDefault = function () {
        var defaultDaysBack = systemInfo.get('config').ActivityLogFromDateDefaultRange;
        dateFrom(new Date().AddDays(defaultDaysBack).ExtractDateUTC());
        dateTo(new Date().ExtractDateUTC());
        filterBy("All");
    };

    var setValidation = function () {
        dateFrom.extend({ validation: { validator: validateFromDate } });
        dateTo.extend({ validation: { validator: validateToDate } });
    };

    var validateFromDate = function (value) {
        return general.str2Date(value) <= general.str2Date(dateTo());
    };

    var validateToDate = function (value) {
        return general.str2Date(dateFrom()) <= general.str2Date(value);
    };

    var enableApplyButton = ko.computed(function () { return !dataSet.IsLoadingData(); }, self);

    var applyFilter = function () {
        if (dataSet.IsLoadingData()) {
            return;
        }

        dataSet.ApplyFilter();
    };


    var stop = function () {
        if (hasDataSubscriber) {
            hasDataSubscriber.dispose();
            hasDataSubscriber = null;
        }
        if (isLoadingSubscriber) {
            isLoadingSubscriber.dispose();
            isLoadingSubscriber = null;
        }

        dataSet.Clean();
    };

    return {
        Init: init,
        ActivityLogs: dataSet.DataRows,
        RecordsRendered: recordsRendered,
        HasRecords: dataSet.HasRecords,
        DataSet: dataSet,
        EnableApplyButton: enableApplyButton,
        Filter: {
            From: dateFrom,
            To: dateTo,
            Type: filterBy,
            Apply: applyFilter
        },
        DsColumns: dsColumns
    };
};

define("viewmodels/ActivityLogViewModel", ["helpers/ObservableCustomExtender","handlers/general","dataaccess/dalActivityLog","modules/systeminfo","helpers/KOExtensions"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko, general, dag, si) {
				return this.ActivityLogViewModel(ko, general, dag, si);
			};
        ret = fn.apply(global, arguments);
        return ret || global.ActivityLogViewModel;
    };
}(this)));

define(
    'viewmodels/MarginStatusViewModel',
    [
        'require',
        'knockout',
        'helpers/ObservableHashTable',
        'handlers/general',
        'cachemanagers/ClientStateHolderManager',
        'cachemanagers/InstrumentVolumeManager',
        'cachemanagers/PortfolioStaticManager'
    ],
    function MarginStatusViewModelDef(require) {
        var ko = require('knockout'),
            observableHashTable = require('helpers/ObservableHashTable'),
            general = require('handlers/general'),
            csHolderManager = require('cachemanagers/ClientStateHolderManager'),
            instrumentVolumeManager = require('cachemanagers/InstrumentVolumeManager'),
            portfolioManager = require('cachemanagers/PortfolioStaticManager');

        var MarginStatusViewModel = function MarginStatusViewModelClass() {
            var instrumentVolumeCollection = new observableHashTable(ko, general, "InstrumentID"),
                walletInfo = {},
                totals = {};

            function init() {
                setObservableObject();
                registerObservableStartUpEvent();
            }

            function setObservableObject() {
                // WalletInfo
                walletInfo.CustomerCcy = $customer.prop.defaultCcy();

                walletInfo.Equity = ko.observable(0);
                walletInfo.TotalEquity = ko.observable(0);

                walletInfo.Securities = ko.observable(0);
                walletInfo.TradingBonus = ko.observable(0);

                // Totals
                var totalUsedMargin = ko.observable(0),
                    totalMarginUtilization = ko.observable(0);

                totals.TotalUsedMargin = ko.computed({
                    read: function () {
                        var value = 0;

                        ko.utils.arrayForEach(instrumentVolumeCollection.Values(), function processItem(item) {
                            var tmp = general.toNumeric(item.UsedMargin());

                            if (tmp) {
                                value += tmp;
                            }
                        });

                        return value;
                    },
                    write: function (value) {
                        totalUsedMargin(value);
                    }
                });

                totals.TotalMarginUtilization = ko.computed({
                    read: function () {
                        var value = 0;

                        ko.utils.arrayForEach(instrumentVolumeCollection.Values(), function processItem(item) {
                            var tmp = general.toNumeric(item.MarginUtilizationPercentage());
                            if (tmp) {
                                value += tmp;
                            }
                        });

                        return value;
                    },
                    write: function (value) {
                        totalMarginUtilization(value);
                    }
                });
            }

            function setInitialData() {
                instrumentVolumeManager.InstrumentVolumes.ForEach(function processInstrumentVolume(key, element) {
                    instrumentVolumeCollection.Add(toObservable(element));
                });

                totals.TotalUsedMargin(0);
                totals.TotalMarginUtilization(0);

                onClientStateChange();
                onPortfolioStateChange();
            }

            function registerToDispatcher() {
                instrumentVolumeManager.OnChange.Add(onInstrumentVolumeChange);
                csHolderManager.OnChange.Add(onClientStateChange);
                portfolioManager.OnChange.Add(onPortfolioStateChange);
            }

            function unRegisterFromDispatcher() {
                instrumentVolumeManager.OnChange.Remove(onInstrumentVolumeChange);
                csHolderManager.OnChange.Remove(onClientStateChange);
                portfolioManager.OnChange.Remove(onPortfolioStateChange);
            }

            function start() {
                setInitialData();

                registerToDispatcher();
            }

            function stop() {
                unRegisterFromDispatcher();
                instrumentVolumeCollection.Clear();
            }

            function toObservable(item) {
                var obj = {};

                for (var prop in item) {
                    obj[prop] = ko.observable(item[prop]);
                }

                return obj;
            }

            function onInstrumentVolumeChange(items) {
                for (var i = 0; i < items.removedItems.length; i++) {
                    var rid = items.removedItems[i];

                    instrumentVolumeCollection.Remove(rid);
                }

                for (var j = 0, jj = items.editedItems.length; j < jj; j++) {
                    var eid = items.editedItems[j];

                    instrumentVolumeCollection.Update(eid, instrumentVolumeManager.InstrumentVolumes.GetItem(eid));
                }

                for (var k = 0, kk = items.newItems.length; k < kk; k++) {
                    var nid = items.newItems[k];
                    var deal = instrumentVolumeManager.InstrumentVolumes.GetItem(nid);

                    if (deal) {
                        instrumentVolumeCollection.Add(toObservable(deal));
                    }
                }
            }

            function onClientStateChange() {
                walletInfo.Equity(general.toNumeric(csHolderManager.CSHolder.equity));
                walletInfo.TotalEquity(general.toNumeric(csHolderManager.CSHolder.totalEquity));
            }

            function onPortfolioStateChange() {
                walletInfo.Securities(general.toNumeric(portfolioManager.Portfolio.securities));
                walletInfo.TradingBonus(general.toNumeric(portfolioManager.Portfolio.tradingBonus));
            }

            function registerObservableStartUpEvent() {
                $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vMarginStatus).state.subscribe(function (state) {
                    switch (state) {
                        case eViewState.Start:
                            start();
                            break;

                        case eViewState.Stop:
                            stop();
                            break;
                    }
                });
            }

            return {
                Init: init,
                Collection: instrumentVolumeCollection.Values,
                WalletInfo: walletInfo,
                Totals: totals
            };
        };

        return new MarginStatusViewModel();
    }
);
/* tutorials from signals page */
var TradingSignalsTutorialsViewModel = function (ko, ViewModelBase, general) {
    var self,
        tutorial = {},
        inheritedInstance = general.clone(ViewModelBase);

    var init = function (customSettings) {
        self = this;
        inheritedInstance.setSettings(self, customSettings);
        registerObservableStartUpEvent();
        tutorial.url = ko.observable("");
    };

    var registerObservableStartUpEvent = function () {
        $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vTradingSignalsTutorials).state.subscribe(function (state) {
            switch (state) {
                case eViewState.Start:
                    start();
                    break;

                case eViewState.Stop:
                    stop();
                    break;
                default:
            }
        });
    };

    var start = function () {
        var tradingTutorialsParameters = $viewModelsManager.VManager.GetViewArgs(eViewTypes.vTradingSignalsTutorials);
        tutorial.url(tradingTutorialsParameters.url);
    };

    var stop = function () {
        tutorial.url("");
    };

    return {
        Init: init,
        Tutorial: tutorial
    };
}
;
define("viewmodels/TradingSignalsTutorialsViewModel", ["knockout","viewmodels/ViewModelBase","handlers/general"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko, vmb, gen) {
				return this.TradingSignalsTutorialsViewModel(ko, vmb, gen);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TradingSignalsTutorialsViewModel;
    };
}(this)));

define(
    'viewmodels/AccountBalanceViewModel',
    [
        'require',
        'knockout',
        'cachemanagers/ClientStateHolderManager'
    ],
    function AccountBalanceViewModel(require) {
        var ko = require('knockout'),
            csHolder = require('cachemanagers/ClientStateHolderManager');

        var viewProperties = {
            accountBalance: ko.observable(),
        };

        var unsubscribeFromCsHolder;

        var init = function () {
            subscribeToCsHolder();
        };

        var subscribeToCsHolder = function () {
            csHolder.OnChange.Add(updateAccountBalance);
            unsubscribeFromCsHolder = function () {
                csHolder.OnChange.Remove(updateAccountBalance);
            };
        };

        var updateAccountBalance = function (data) {
            viewProperties.accountBalance(data.accountBalance);
        };

        var stop = function () {
            if (unsubscribeFromCsHolder) {
                unsubscribeFromCsHolder();
            }
        };

        return {
            Init: init,
            Stop: stop,
            ViewProperties: viewProperties,
        };
    }
);

define(
    'viewmodels/QuotesSubscriber',
    [
        'require',
        'knockout',
        'handlers/general',
        'cachemanagers/QuotesManager',
        "helpers/ObservableHashTable"
    ],
    function(require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            QuotesManager = require('cachemanagers/QuotesManager'),
            observableHashTable = require("helpers/ObservableHashTable");

        function QuotesSubscriber() {
            var observableQuotesCollection = new observableHashTable(ko,general,'instrumentID'),
                started = false;

            var start = function() {
                if (!started) {
                    registerToDispatcher();

                    started = true;
                }
            };

            var stop = function() {
                if (started) {
                    unRegisterFromDispatcher();
                    observableQuotesCollection.Clear();

                    started = false;
                }
            };

            var registerToDispatcher = function() {
                QuotesManager.OnChange.Add(onQuoteChange);
            };

            var unRegisterFromDispatcher = function() {
                QuotesManager.OnChange.Remove(onQuoteChange);
            };

            var subscribeToQuote = function(instrumentId) {
                var quote = QuotesManager.Quotes.GetItem(instrumentId);
                if (quote) {
                    var observableQuote = createObservableQuote(quote);
                    observableQuotesCollection.Add(observableQuote);
                    return true;
                } else {
                    var emptyQuote = createObservableQuote({
                        id: instrumentId,
                        bid: 0,
                        ask: 0,
                        open: 0,
                        close: 0,
                        high: 0,
                        low: 0,
                        change: 0,
                        tradeTime: '00:00:00',
                        state: eQuoteStates.Disabled,
                        isActive: function () {
                            return false;
                        }
                    });

                    observableQuotesCollection.Add(emptyQuote);
                    return false;
                }
            };

            var createObservableQuote = function (quote) {
                var observableQuote = {
                    instrumentID: quote.id,
                    bid: ko.observable(quote.bid),
                    ask: ko.observable(quote.ask),
                    open: ko.observable(quote.open),
                    close: ko.observable(quote.close),
                    high: ko.observable(quote.high),
                    low: ko.observable(quote.low),
                    change: ko.observable(Format.toPercent(quote.change)),
                    dataTime: ko.observable(quote.tradeTime),
                    state: ko.observable(quote.state),
                    midRate: ko.observable(Format.toMidRate(quote.bid, quote.ask)),
                    time: ko.observable(Format.toTime(quote.tradeTime)),
                    isActiveQuote: ko.observable(quote.isActive()),
                };

                observableQuote.rateDirIsUp = ko.pureComputed(function() { return this.state() == eQuoteStates.Up; }, observableQuote);
                observableQuote.rateDirIsDown = ko.pureComputed(function() { return this.state() == eQuoteStates.Down; }, observableQuote);
                observableQuote.isInactive = ko.pureComputed(function () { return !this.isActiveQuote() }, observableQuote);

                return observableQuote;
            };

            var getOrderRate = function(instrumentId, orderDir) {
                var quote = getQuote(instrumentId);
                return (orderDir == eOrderDir.Buy) ? quote.ask : quote.bid;
            };

            var getQuote = function(instrumentId) {
                var quote = observableQuotesCollection.Get(instrumentId);
                if (!quote) {
                    subscribeToQuote(instrumentId);
                    quote = observableQuotesCollection.Get(instrumentId);
                }
                return quote;
            };

            var removeQuoteSubscription = function (instrumentId) {
                var quote = observableQuotesCollection.Get(instrumentId);

                if (quote) {
                    observableQuotesCollection.Remove(quote)
                }

                return quote;
            };

            var onQuoteChange = function(deltaList) {
                if (deltaList) {
                    for (var i = 0; i < deltaList.length; i++) {
                        var quote = QuotesManager.Quotes.GetItem(deltaList[i]);
                        var delta = {
                            instrumentID: quote.id,
                            bid: quote.bid,
                            ask: quote.ask,
                            open: quote.open,
                            close: quote.close,
                            high: quote.high,
                            low: quote.low,
                            change: Format.toPercent(quote.change),
                            dataTime: quote.tradeTime,
                            state: quote.state,
                            midRate: Format.toMidRate(quote.bid, quote.ask),
                            time: Format.toTime(quote.tradeTime)
                        };
                        observableQuotesCollection.Update(deltaList[i], delta);
                    }
                }
            };

            return {
                Start: start,
                Stop: stop,
                GetOrderRate: getOrderRate,
                GetQuote: getQuote,
                RemoveQuoteSubscription: removeQuoteSubscription,
                Values: observableQuotesCollection.Values
            };
        }

        return QuotesSubscriber;
    }
);

define(
    'viewmodels/relatedPositionViewModel',
    [
        'knockout',
        'handlers/general',
        'cachemanagers/dealsmanager',
        'viewmodels/QuotesSubscriber',
        'helpers/ObservableHashTable'
    ],
    function (ko, general, DealsManager, quotesSubscriber, observableHashTable) {
        var observableOpenDealsCollection = new observableHashTable(ko, general, 'orderID', { enabled: true, sortProperty: 'positionNumber', asc: false }),
            REBUILD_COLLECTION_SIZE = 2,
            positionNumber;

        var init = function () {
            registerObservableStartUpEvent();
        };

        var registerObservableStartUpEvent = function () {
            $viewModelsManager.VManager.GetActiveFormViewProperties(eViewTypes.vRelatedPosition).state.subscribe(function (state) {
                switch (state) {
                    case eViewState.Start:
                        start();
                        break;

                    case eViewState.Stop:
                        stop();
                        break;
                }
            });
        };

        var start = function () {
            positionNumber = $viewModelsManager.VManager.GetViewArgsByKeyName(eViewTypes.vRelatedPosition, 'posNum');

            registerToDispatcher();
            populateObservableCollection();
            quotesSubscriber.Start();
        };

        var stop = function () {
            unRegisterFromDispatcher();
            observableOpenDealsCollection.Clear();
            quotesSubscriber.Stop();
        };

        var registerToDispatcher = function () {
            DealsManager.OnDealsChange.Add(onDealsChange);
            DealsManager.OnDealsPLChange.Add(onDealsPLChange);
        };

        var unRegisterFromDispatcher = function () {
            DealsManager.OnDealsPLChange.Remove(onDealsPLChange);
            DealsManager.OnDealsChange.Remove(onDealsChange);
        };

        var populateObservableCollection = function () {
            var deal = DealsManager.Deals.GetItem(positionNumber);

            if (deal) {
                var row = toObservableRow(deal);
                observableOpenDealsCollection.Add(row);
            }
        };

        var onDealsChange = function (items) {
            if (items) {
                if (items.removedItems.length > REBUILD_COLLECTION_SIZE) {
                    stop();
                    start();
                } else {
                    removeItems(items.removedItems);
                    updateItems(items.editedItems);
                    addNewItems(items.newItems);
                }
            }
        };

        var onDealsPLChange = function (changes) {
            var updatedItems = changes.dealsIDs;
            for (var i = 0, ii = updatedItems.length; i < ii; i++) {
                var observable = observableOpenDealsCollection.Get(updatedItems[i]);
                if (observable) {
                    var deal = DealsManager.Deals.GetItem(updatedItems[i]);
                    if (deal) {
                        var delta = {
                            prevSpotRate: observable.spotRate(),
                            spotRate: deal.spotRate,
                            fwPips: deal.fwPips,
                            closingRate: deal.closingRate,
                            pl: deal.pl
                        };

                        observableOpenDealsCollection.Update(updatedItems[i], delta);
                    }
                }
            }
        };

        var removeItems = function (removedItems) {
            for (var i = 0; i < removedItems.length; i++) {
                observableOpenDealsCollection.Remove(removedItems[i]);
            }
        };

        var updateItems = function (updatedItems) {
            for (var i = 0, ii = updatedItems.length; i < ii; i++) {
                var deal = toObservableRow(DealsManager.Deals.GetItem(updatedItems[i]));
                if (deal) {
                    observableOpenDealsCollection.Update(deal.orderID, deal);
                }
            }
        };

        var addNewItems = function (newItems) {
            for (var i = 0, ii = newItems.length; i < ii; i++) {
                var deal = toObservableRow(DealsManager.Deals.GetItem(newItems[i]));
                if (deal) {
                    observableOpenDealsCollection.Add(deal);
                }
            }
        };

        var toObservableRow = function (deal) {
            return {
                positionNumber: deal.positionNumber,
                orderID: deal.orderID,
                exeTime: deal.exeTime,

                buyAmount: deal.buyAmount,
                buySymbolID: deal.buySymbolID,

                sellAmount: deal.sellAmount,
                sellSymbolID: deal.sellSymbolID,

                orderRate: deal.orderRate,
                valueDate: deal.valueDate,

                spotRate: ko.observable(deal.spotRate),
                fwPips: ko.observable(deal.fwPips),
                closingRate: ko.observable(deal.closingRate),

                pl: ko.observable(deal.pl),
                plSign: ko.observable(deal.pl.sign()),

                slRate: ko.observable(deal.slRate == 0 ? cEmptyRate : deal.slRate),
                tpRate: ko.observable(deal.tpRate == 0 ? cEmptyRate : deal.tpRate),

                prevSpotRate: ko.observable(deal.spotRate)
            };
        };

        return {
            Init: init,
            Start: start,
            Stop: stop,
            OpenDeals: observableOpenDealsCollection.Values
        };
    }
);

define("devicemanagers/ViewModelsManager", [
	"require",
	"knockout",
	"helpers/ObservableHelper",
	"configuration/initconfiguration",
	"managers/viewsmanager",
	"viewmodels/QuotesViewModel",
	"viewmodels/QuotesPresetViewModel",
	"viewmodels/ViewAndPrintWithdrawalViewModel",
	"viewmodels/BalanceViewModel",
	"viewmodels/NetExposureViewModel",
	"viewmodels/AccountMarketViewModel",
	"viewmodels/ActivityLogViewModel",
	"viewmodels/MarginStatusViewModel",
	"viewmodels/TradingSignalsTutorialsViewModel",

	"managers/historymanager",
	"initdatamanagers/Customer",

	"viewmodels/dialogs/DialogViewModel",
	"viewmodels/AccountBalanceViewModel",
	"viewmodels/relatedPositionViewModel",
], function ViewModelsManagerDef(require) {
	var initConfiguration = require("configuration/initconfiguration"),
		ko = require("knockout"),
		Customer = require("initdatamanagers/Customer"),
		vmDialog = require("viewmodels/dialogs/DialogViewModel"),
		vmHelpers = require("helpers/ObservableHelper"),
		vmRelatedPosition = require("viewmodels/relatedPositionViewModel"),
		vmViewAndPrintWithdrawal = require("viewmodels/ViewAndPrintWithdrawalViewModel"),
		vmBalance = require("viewmodels/BalanceViewModel"),
		vmNetExposure = require("viewmodels/NetExposureViewModel"),
		vmQuotesPreset = require("viewmodels/QuotesPresetViewModel"),
		vmAccountMarket = require("viewmodels/AccountMarketViewModel"),
		vmActivityLog = require("viewmodels/ActivityLogViewModel"),
		vmMarginStatus = require("viewmodels/MarginStatusViewModel"),
		vmTradingSignalTutorials = require("viewmodels/TradingSignalsTutorialsViewModel"),
		vmQuotes = require("viewmodels/QuotesViewModel"),
		vManager = require("managers/viewsmanager"),
		vmAccountBalance = require("viewmodels/AccountBalanceViewModel");

	function ViewModelsManager() {
		function onActiveFormChanged(formType) {
			//reset Idle Activity Time
			ActivitySupervisor.ResetTimeRequest();

			if (!vmDialog.persistent()) {
				vmDialog.close();
			}

			if (
				formType == eForms.Deals &&
				(formType == Customer.prop.startUpForm || formType == Customer.prop.mainPage)
			) {
				vmAccountMarket.UseTransitions(false);
				vmAccountMarket.IsCollapsed(false);
				vmAccountMarket.UseTransitions(true);
			} else {
				vmAccountMarket.UseTransitions(false);
				vmAccountMarket.IsCollapsed(true);
				vmAccountMarket.UseTransitions(true);
			}
		}

		//------------------ View Model Manager -------------
		function init(uiVersion, startUpForm) {
			vManager.Init(uiVersion);
			vManager.OnActiveFormChanged.Add(onActiveFormChanged);

			vmDialog.OnPreload.Add(function onPreload(dialogName, view, args) {
				vManager.ChangeViewState(view, eViewState.Start, args);
			});

			vmDialog.OnOpen.Add(function onDialogOpen(dialogName, view, args) {
				if (vManager.GetViewState(view) !== eViewState.Start) {
					vManager.ChangeViewState(view, eViewState.Start, args);
				}

				HistoryManager.PushPopupState(ePopupType.Dialog, dialogName);
			});

			vmDialog.OnClose.Add(function onDialogClose(dialogName, view) {
				vManager.ChangeViewState(view, eViewState.Stop);
				ko.postbox.publish(eAppEvents.dialogClosed);

				if (HistoryManager.HasDialog(dialogName)) {
					HistoryManager.Back();
				}
			});

			HistoryManager.OnStateChanged.Add(function (state) {
				// if more than 1 dialog is opened
				if (state.type === eHistoryStateType.CloseDialog) {
					vmDialog.close(state.popupId);
				}
			});

			vmQuotes.Init(initConfiguration.QuotesGridConfiguration);
			vmQuotes.OpenInDialog.Add(function (name, options, eView, args) {
				vmDialog.open(name, options, eView, args);
			});

			vmBalance.Init(initConfiguration.BalanceConfiguration);

			vmNetExposure.Init();
			vmRelatedPosition.Init();

			vmQuotesPreset.Init(initConfiguration.QuotesPresetConfiguration);
			vmViewAndPrintWithdrawal.Init(initConfiguration.ViewAndPrintWithdrawal);

			vmAccountMarket.Init();
			vmActivityLog.Init();

			vmMarginStatus.Init();

			vmTradingSignalTutorials.Init();

			vmAccountBalance.Init();

			start(startUpForm);
		}

		function start(startUpForm) {
			vManager.Start(startUpForm);
		}

		function isReactEnabled() {
			var configuration = Customer.prop.abTestings.configuration;
			return configuration["react-store"] === true;
		}

		function reactComponentsEnabled() {
			var configuration = Customer.prop.abTestings.configuration;
			var reactEnabled = isReactEnabled();
			return {
				"fx-core-api/summaryView": reactEnabled && configuration["fx-react-account-summary"] === true,
				"fx-core-api/quotesGrid": reactEnabled && configuration["fx-react-quotes-grid"] === true,
			};
		}

		return {
			Init: init,
			VmDialog: vmDialog,
			VmQuotes: vmQuotes,
			VmBalance: vmBalance,

			VmViewAndPrintWithdrawal: vmViewAndPrintWithdrawal,
			VmNetExposure: vmNetExposure,

			VmRelatedPosition: vmRelatedPosition,
			VmHelpers: vmHelpers,

			VManager: vManager,

			VmQuotesPreset: vmQuotesPreset,

			VmActivityLog: vmActivityLog,
			VmAccountMarket: vmAccountMarket,

			VmMarginStatus: vmMarginStatus,
			VmTradingSignalsTutorials: vmTradingSignalTutorials,

			VmAccountBalance: vmAccountBalance,
			IsReactEnabled: isReactEnabled,
			ReactComponentsEnabled: reactComponentsEnabled,
		};
	}

	var module = (window.$viewModelsManager = new ViewModelsManager());

	return module;
});

define("enums/paymentsconfigsettings", ["enums/enums"], function PaymentsConfigSettings(eDepositingActionType) {
	return [
		{
			Id: eDepositingActionType.Regular,
			ShowInMobile: 1,
			SubViews: [
				{
					ViewId: "genericcreditcard",
					Name: "CreditCard",
					ViewType: "vGenericCreditCard",
					ViewModel: "GenericCreditCard",
					DepositType: "creditcardgeneric",
					ControllerAction: "creditcard-genericcreditcard",
					MobileName: "GenericCreditCard",
				},
			],
		},
		{
			Id: eDepositingActionType.SafechargePPP,
			Name: "CreditCard3rdParty",
			ViewType: "vCreditCard3rdParty",
			DepositType: "safechargeppp",
			ControllerAction: "creditcard-safechargeppp",
			ShowInMobile: 1,
			Resources: ["creditcard_safechargeppp"],
		},
		{
			Id: eDepositingActionType.EmpCashU,
			Name: "EmpCashU",
			ViewType: "vEmpCashU",
			DepositType: "empcashu",
			ControllerAction: "emp-cashu",
			ViewModel: "DefaultEwallet",
			ShowInMobile: 1,
		},
		{
			Id: eDepositingActionType.SafeChargeCashier,
			Name: "SafechargeCashier",
			ViewType: "vSafeChargeCashier",
			DepositType: "safechargecaschier",
			ControllerAction: "safecharge-cashier",
			ViewModel: "DefaultEwallet",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_safecharge_cashier", "payments_ewallet"],
		},
		{
			Id: eDepositingActionType.Epaylinks,
			Name: "Epaylinks",
			ViewType: "vEpaylinks",
			DepositType: "epaylinks",
			ControllerAction: "deposit-defaultpaymentview",
			ViewModel: "DefaultEwallet",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.WireTransfer,
			Name: "RegularWireTransfer",
			ViewType: "vWireTransfer",
			DepositType: "regularWireTransfer",
			MobileName: "MobileRegularWireTransfer",
			ShowInMobile: 1,
			Resources: ["payments_regularWireTransfer"],
		},
		{
			Id: eDepositingActionType.Moneybookers,
			Name: "MoneyBookers",
			DepositType: "moneybookers",
			ViewType: "vMoneyBookers",
			ShowInMobile: 1,
			Resources: ["payments_moneyBookers"],
		},
		{
			Id: eDepositingActionType.GlobalCollectAPM,
			Name: "GlobalCollectAPM",
			ViewType: "vGlobalCollectAPM",
			DepositType: "globalCollectAPM",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.Astropay,
			Name: "Astropay",
			ViewType: "vAstropay",
			DepositType: "astropay",
			ShowInMobile: 1,
			Resources: ["payments_astropay"],
		},
		{
			Id: eDepositingActionType.NetellerGO,
			Name: "NetellerGO",
			ViewType: "vNetellerGO",
			DepositType: "netellerGO",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_genericcreditcard", "payments_ewallet"],
		},
		{
			Id: eDepositingActionType.PaySafeCard,
			Name: "PaySafeCard",
			ViewType: "vPaySafeCard",
			DepositType: "paySafeCard",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.InatecAPM,
			SubViews: [
				{
					ViewId: "giropay",
					Name: "InatecAPM",
					ViewType: "vInatecAPMGiropay",
					DepositType: "inatecAPM",
					ControllerAction: "inatecapm-giropay",
					Resources: ["payments_inatecAPM"],
				},
				{
					ViewId: "p24",
					Name: "InatecAPM",
					ViewType: "vInatecAPMPrzelewy24",
					DepositType: "inatecAPM",
					ControllerAction: "inatecapm-przelewy24",
					Resources: ["payments_inatecAPM"],
				},
			],
			ShowInMobile: 1,
		},
		{
			Id: eDepositingActionType.NoAPIClearer,
			Name: "NoAPIClearer",
			ViewType: "vNoAPIClearer",
			DepositType: "noAPIClearer",
			ControllerAction: "deposit-noapiclearer",
			ShowInMobile: 1,
			Resources: ["payments_concreteNames"],
		},
		{
			Id: eDepositingActionType.EcoPayz,
			Name: "EcoPayz",
			ViewType: "vEcoPayz",
			DepositType: "ecoPayz",
			ViewModel: "DefaultEwallet",
			ShowInMobile: 1,
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.SofortDirect,
			Name: "SofortDirect",
			ViewType: "vSofortDirect",
			DepositType: "sofortDirect",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.Kluwp,
			Name: "Kluwp",
			ViewType: "vKluwp",
			DepositType: "kluwp",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.RPN,
			Name: "RPN",
			ViewType: "vRPN",
			DepositType: "RPN",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.PayPal,
			Name: "PayPal",
			ViewType: "vPayPal",
			DepositType: "PayPal",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.AstropayCard,
			Name: "AstropayCard",
			ViewType: "vAstropayCard",
			DepositType: "AstropayCard",
			ViewModel: "AstropayCard",
			ShowInMobile: 1,
			Resources: ["payments_creditcardregular"],
		},
		{
			Id: eDepositingActionType.PayRetailers,
			Name: "PayRetailers",
			ViewType: "vPayRetailers",
			DepositType: "PayRetailers",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.RisingSunAPM,
			Name: "RisingSunAPM",
			ViewType: "vRisingSunAPM",
			DepositType: "RisingSunAPM",
			ViewModel: "DefaultEwallet",
			MobileName: "RisingSunAPM",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.Jeton,
			Name: "Jeton",
			ViewType: "vJeton",
			DepositType: "Jeton",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.ZotapayAPM,
			Name: "ZotapayAPM",
			ViewType: "vZotapayAPM",
			DepositType: "ZotapayAPM",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.BitWallet,
			Name: "BitWallet",
			ViewType: "vBitWallet",
			DepositType: "bitWallet",
			ViewModel: "EWalletExtended",
			ControllerAction: "ewalletextended-paymentview",
			ShowInMobile: 1,
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.NuveiAPM,
			Name: "NuveiAPM",
			ViewType: "vNuveiAPM",
			DepositType: "NuveiAPM",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.GlobePay,
			Name: "GlobePay",
			ViewType: "vGlobePay",
			DepositType: "GlobePay",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			Id: eDepositingActionType.AstropayWallet,
			Name: "AstropayWallet",
			ViewType: "vAstropayWallet",
			DepositType: "AstropayWallet",
			ViewModel: "DefaultEwallet",
			ControllerAction: "deposit-defaultpaymentview",
			ShowInMobile: 1,
			Templates: ["fx-template-payment-amount"],
			Resources: ["payments_ewallet"],
		},
		{
			"Id": eDepositingActionType.PerfectMoney,
			"Name": "PerfectMoney",
			"ViewType": "vPerfectMoney",
			"DepositType": "PerfectMoney",
			"ViewModel": "DefaultEwallet",
			"ControllerAction": "deposit-defaultpaymentview",
			"ShowInMobile": 1,
			"Templates": ["fx-template-payment-amount"],
			"Resources": ['payments_ewallet']
		}
	];
});

/* global UrlResolver, environmentData */
var PopupInNewWindowManager = function () {
    var deposit3rdPartyWindowName = "_system";
    var deposit3rdPartyWindowHandle = null;

    function redirect(communicationManager) {
        var urlParams = "?actionUrl=" + encodeURIComponent(communicationManager.ActionUrl) +
            "&postDataValue=" + encodeURIComponent(JSON.stringify(communicationManager.PostDataArr)) +
            "&hash=" + communicationManager.Hash +
            "&accountNumber=" + communicationManager.AccountNumber;

        var url = UrlResolver.combine(
            UrlResolver.getApplicationRelativePath(),
            "/Payments/Deposit/RedirectToClearerPage",
            urlParams
        );

        window.open(url, deposit3rdPartyWindowName);
    }

    function paymentUrlResolver() {
        var url = UrlResolver.combine(
            UrlResolver.getApplicationRelativePath(),
            "/Payments/Deposit/Spinner"
        );

        if (environmentData.isDesktop) {
            url = location.protocol + '//' + location.hostname + url;
        }

        return url;
    }

    function openPopup() {
        deposit3rdPartyWindowHandle = window.open(paymentUrlResolver(), deposit3rdPartyWindowName, "resizable=1, height=850, width=800, scrollbars=yes");
    }

    function resize(width, height) {
        deposit3rdPartyWindowHandle.resizeTo(width, height);
    }

    function close() {
        if (deposit3rdPartyWindowHandle) {
            deposit3rdPartyWindowHandle.close();
            deposit3rdPartyWindowHandle = null;
        }
    }

    //when inside mobile applications openPopup will be handled inside redirect function.
    if (!systemInfo.isNative) {
        openPopup();
    }

    function isPopupOpen() {
        return deposit3rdPartyWindowHandle && !deposit3rdPartyWindowHandle.closed;
    }

    function onClose(callback) {
        if (deposit3rdPartyWindowHandle && !deposit3rdPartyWindowHandle.closed) {
            setTimeout(function () {
                onClose(callback);
            }, 1000);
        } else {
            callback();
        }
    }

    return {
        Navigate: redirect,
        Resize: resize,
        Close: close,
        IsPopupOpen: isPopupOpen,
        OnClose: onClose
    };
};
define("managers/PopupInNewWindowManager", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.PopupInNewWindowManager;
    };
}(this)));

define("configuration/PaymentsConfiguration", [
	"require",
	"knockout",
	"configuration/initconfiguration",
	"enums/paymentsconfigsettings",
	"devicemanagers/ViewModelsManager",
	"managers/PopupInNewWindowManager",
], function (require) {
	var ko = require("knockout"),
		initConfiguration = require("configuration/initconfiguration"),
		paymentsConfigSettings = require("enums/paymentsconfigsettings"),
		PopupInNewWindowManager = require("managers/PopupInNewWindowManager"),
		ViewModelsManager = require("devicemanagers/ViewModelsManager");

	function setupConfiguration() {
		var paymentsConfiguration = {
			prepare3rdPartyView: PopupInNewWindowManager,
			formToDisplayForSuccessfulPayments: eForms.DepositSuccess,
			formToDisplayForPendingPayments: eForms.DepositPending,
			supportLastPaymentCategory: false,
			viewTypeForExistingCC: "genericcreditcard",
			showAllowedCreditCards: false,
			getClaimsTimeoutInMiliseconds: 30000,
			missingPaymentsRedirect: eForms.Deals,
		};

		var safeChargeCashierPaymentConfiguration = {
			prepare3rdPartyView: PopupInNewWindowManager,
			formToDisplayForSuccessfulPayments: eForms.DepositSuccess,
			formToDisplayForPendingPayments: eForms.DepositPending,
			currencySortPropertyName: "name",
		};

		var wireTransferConfiguration = {
			formToDisplayForSuccessfulPayments: eForms.WireTransferSuccess,
			formToDisplayForPendingPayments: eForms.Deals,
			formToDisplayForFailedPayments: eForms.RegularWireTransfer,
		};

		// payments
		initConfiguration.PaymentsConfiguration = paymentsConfiguration;
		initConfiguration.PaymentInNewWindowConfiguration = paymentsConfiguration;
		initConfiguration.PaymentWithCCConfiguration = paymentsConfiguration;
		initConfiguration.SafeChargeCashierPaymentConfiguration = safeChargeCashierPaymentConfiguration;
		initConfiguration.AstropayConfiguration = paymentsConfiguration;
		initConfiguration.AstropayCardConfiguration = paymentsConfiguration;
		initConfiguration.WireTransferConfiguration = wireTransferConfiguration;
	}

	function buildDeps(requiredDeps) {
		var commonContentDeps = ["payments_general"],
			currentContentDeps = [];

		currentContentDeps = [].concatUnique(requiredDeps);
		currentContentDeps = currentContentDeps.concatUnique(commonContentDeps);

		return currentContentDeps;
	}

	function registerComponentsForConcretePayments() {
		if (!paymentsConfigSettings) {
			return;
		}

		paymentsConfigSettings.forEach(function registerComponent(payment) {
			if (payment.SkipComponentGeneration) {
				return;
			}

			if (payment.SubViews) {
				payment.SubViews.forEach(function registerSubComponent(subview) {
					var componentName = String.format(
							"fx-payment-{0}-{1}",
							subview.Name.toLowerCase(),
							subview.ViewId.toLowerCase()
						),
						componentDef = {
							viewModel: {
								require: String.format(
									"viewmodels/Payments/{0}ViewModel",
									subview.ViewModel || subview.Name
								),
							},
							template: {
								require: payment.Templates
									? "text!FxNet/Devices/Web/UILayer/Views/Deposit/PaymentTemplates.html"
									: String.format(
											"text!partial-views/web-payments-{0}.html",
											subview.ControllerAction
									  ),
							},
							deps: buildDeps(payment.Resources || []).map(function (contentKey) {
								return "LoadDictionaryContent!" + contentKey;
							}),
						};

					ko.components.register(componentName, componentDef);
				});

				return;
			}

			var componentName = String.format("fx-payment-{0}", payment.Name.toLowerCase()),
				componentDef = {
					viewModel: {
						require: String.format("viewmodels/Payments/{0}ViewModel", payment.ViewModel || payment.Name),
					},
					template: {
						require: payment.Templates
							? "text!FxNet/Devices/Web/UILayer/Views/Deposit/PaymentTemplates.html"
							: String.format(
									"text!partial-views/web-payments-{0}.html",
									payment.ControllerAction || payment.Name.toLowerCase()
							  ),
					},
					deps: buildDeps(payment.Resources || []).map(function (contentKey) {
						return "LoadDictionaryContent!" + contentKey;
					}),
				};

			ko.components.register(componentName, componentDef);
		});
	}

	function registerComponentsForNotes() {
		ko.components.register("fx-componet-creditcard-regular-note", {
			template: { require: "text!webHtml/statichtml/creditcard/creditcard-regular-note.html" },
			deps: [
				"LoadDictionaryContent!payments_creditcardregular",
				"LoadDictionaryContent!payments_genericcreditcard",
			],
		});

		ko.components.register("fx-componet-wiretransfer-regular-note", {
			template: { require: "text!webHtml/statichtml/creditcard/wiretransfer-regular-note.html" },
			deps: ["LoadDictionaryContent!payments_regularWireTransfer"],
		});

		ko.components.register("fx-componet-ecopayz-note", {
			template: { require: "text!webHtml/statichtml/creditcard/ecopayz-note.html" },
			deps: ["LoadDictionaryContent!payments_regularWireTransfer", "LoadDictionaryContent!payments_general"],
		});

		ko.components.register("fx-deposit-notice", {
			viewModel: { require: "viewmodels/Payments/NoticeViewModel" },
			template: { require: "text!partial-views/web-payments-deposit-notice.html" },
		});
	}

	function registerComponentForListOfPayments() {
		ko.components.register("fx-concrete-payments", {
			viewModel: { require: "viewmodels/Payments/ConcretePaymentsViewModel" },
			template: { require: "text!webHtml/statichtml/Deposit/Payments.html" },
			deps: ["LoadDictionaryContent!payments_concreteView", "LoadDictionaryContent!payments_concreteNames"],
		});

		ko.components.register("fx-concrete-payments-form", {
			viewModel: { require: "viewmodels/Payments/ConcretePaymentFormViewModel" },
			template: { require: "text!webHtml/statichtml/Deposit/PaymentsForm.html" },
			deps: ["LoadDictionaryContent!payments_concreteView"],
		});

		ko.components.register("fx-component-payments-title", {
			viewModel: { instance: ViewModelsManager },
			template: { require: "text!webHtml/statichtml/Deposit/PaymentsTitle.html" },
			deps: ["LoadDictionaryContent!general_pagetitle"],
		});

		ko.components.register("fx-component-deposit-success-thankyou", {
			viewModel: { require: "viewmodels/deposit/ThankYouViewModel" },
			template: { require: "text!webHtml/statichtml/Deposit/thankyou-success.html" },
			deps: [
				"LoadDictionaryContent!FAQDEPOSITTHANKYOU",
				"LoadDictionaryContent!deposit_thankyou",
				"LoadDictionaryContent!deposit_thankyou_success",
			],
		});

		ko.components.register("fx-component-deposit-pending-thankyou", {
			viewModel: { require: "viewmodels/deposit/ThankYouViewModel" },
			template: { require: "text!webHtml/statichtml/Deposit/thankyou-pending.html" },
			deps: [
				"LoadDictionaryContent!FAQDEPOSITTHANKYOU",
				"LoadDictionaryContent!deposit_thankyou",
				"LoadDictionaryContent!deposit_thankyou_pending",
			],
		});

		ko.components.register("fx-component-wire-transfer-success", {
			viewModel: { require: "viewmodels/deposit/WireTransferSuccessViewModel" },
			template: { require: "text!webHtml/statichtml/Deposit/wire-transfer-success.html" },
			deps: ["LoadDictionaryContent!payments_regularWireTransferDeposit"],
		});

		ko.components.register("fx-concrete-payment-subtitle", {
			viewModel: { require: "viewmodels/Payments/ConcretePaymentSubtitleViewModel" },
			template: { require: "text!partial-views/web-payments-deposit-subtitle.html" },
		});

		ko.components.register("fx-component-deposit-container", {
			template: { element: "fx-template-deposit-container" },
		});
	}

	function registerComponentsForAlerts() {
		ko.components.register("fx-component-questionnaire-alert", {
			viewModel: { require: "deviceviewmodels/QuestionnaireAlertViewModel" },
			template: { require: "text!webHtml/statichtml/deposit-questionnaire-alert.html" },
		});
	}

	function registerDepositComponents() {
		setupConfiguration();

		registerComponentsForConcretePayments();
		registerComponentsForNotes();
		registerComponentForListOfPayments();
		registerComponentsForAlerts();
	}

	return {
		RegisterDepositComponents: registerDepositComponents,
	};
});

define('configuration/DealSlipsConfiguration', 
    [
        'require',
        'knockout'
    ],
    function EnableTradingConfiguration(require) {
        var ko = require('knockout');
        var components = [];

        function registerComponents(configuration) {
            var loadRevised = configuration['fx-revised-deal-slips'],
                dealComponents = [
                    {
                        name: 'fx-component-transaction-switcher',
                        vm: 'deviceviewmodels/TransactionSwitcherViewModel',
                        template: 'text!partial-views/web-deals-transactionswitcher.html'
                    },
                    {
                        name: 'fx-component-deal-tools',
                        vm: 'deviceviewmodels/Deals/DealToolsViewModel',
                        template: 'text!partial-views/web-deals-dealtools.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!deal-slip',
                            'helpers/CustomKOBindings/SpinnerFieldBinding'],
                        name: 'fx-component-new-deal-slip',
                        vm: 'deviceviewmodels/Deals/NewDealViewModel',
                        template: 'text!partial-views/web-deals-newdeal.html',
                    },
                    {
                        deps: ['modules/ComponentStyle!deal-slip',
                            'helpers/CustomKOBindings/SpinnerFieldBinding'],
                        name: 'fx-component-new-limit',
                        vm: 'deviceviewmodels/Deals/NewLimitViewModel',
                        template: 'text!partial-views/web-deals-newlimit.html',
                    }, 
                    {
                        deps: ['modules/ComponentStyle!deal-slip',
                            'LoadDictionaryContent!tooltipsStaticResource'],
                        name: 'fx-component-close-deal',
                        vm: 'deviceviewmodels/Deals/CloseDealViewModel',
                        template: 'text!partial-views/web-deals-closedeal.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!deal-slip',
                            'helpers/CustomKOBindings/SpinnerFieldBinding'],
                        name: 'fx-component-edit-closing-limit',
                        vm: 'deviceviewmodels/Deals/EditClosingLimitViewModel' ,
                        template: 'text!partial-views/web-deals-editclosinglimit.html' 
                    },
                    {
                        deps: ['modules/ComponentStyle!deal-slip',
                            'LoadDictionaryContent!deals_EditLimit',
                            'helpers/CustomKOBindings/SpinnerFieldBinding'],
                        name: 'fx-component-edit-limit',
                        vm: 'deviceviewmodels/Deals/EditLimitViewModel',
                        template: 'text!partial-views/web-deals-editlimit.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!deal-slip',
                            'LoadDictionaryContent!deals_newlimit'],
                        name: 'fx-component-new-pricealert',
                        vm: 'viewmodels/NewPriceAlertViewModel',
                        template: 'text!partial-views/web-limits-newpricealert.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!deals_DealMarketInfoTool'],
                        name: 'fx-component-market-info-tool',
                        vm: 'deviceviewmodels/MarketInfoToolViewModel',
                        template: 'text!partial-views/web-deals-dealmarketinfotool.html',
                    },
                    {
                        deps: ['LoadDictionaryContent!deals_DealSignalsTool'],
                        name: 'fx-component-signals-tool',
                        vm: 'deviceviewmodels/Signals/SignalsToolViewModel',
                        template: 'text!partial-views/web-deals-dealsignalstool.html',
                    }, 
                    {
                        name: 'fx-instrument-notavailable',
                        vm: 'viewmodels/InstrumentNotAvailableViewModel',
                        template: 'text!webHtml/statichtml/instrument-notavailable.html'
                    }, 
                    {
                        name: 'fx-component-transaction-switchwrap',
                        template: 'text!webHtml/statichtml/deals/transaction-switchwrap.html'
                    },
                    {
                        name: 'fx-component-main-chart',
                        vm: 'deviceviewmodels/MainChartViewModel',
                        template: 'text!webHtml/statichtml/Chart/MainChart.html'
                    }, 
                    {
                        name: 'fx-component-tile-transaction-switcher',
                        vm: 'deviceviewmodels/TileTransactionSwitcherViewModel',
                        template: 'text!webHtml/statichtml/TileTransactionSwitcher.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!chart_station'],
                        name: 'fx-component-tiled-layout',
                        vm: 'deviceviewmodels/TileLayoutViewModel',
                        template: 'text!webHtml/statichtml/TileLayout.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!tooltipsStaticResource'],
                        name: 'fx-component-open-deals-grid',
                        vm: 'deviceviewmodels/OpenDealsViewModel',
                        template: 'text!partial-views/web-deals-opendeals.html',
                    }
                ],
                revisedDealComponents = [
                    {
                        deps: ['LoadDictionaryContent!dialogsTitles'],
                        name: 'fx-component-transaction-switcher',
                        vm: 'deviceviewmodels/TransactionSwitcherViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/transaction-switcher.html'
                    },
                    {
                        name: 'fx-component-deal-tools',
                        deps: ['LoadDictionaryContent!deals_DealTools'],
                        vm: 'deviceviewmodels/Deals/Revised/DealToolsViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/deal-tools.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!revised-slips',
                            'helpers/CustomKOBindings/SpinnerFieldBinding',
                            'LoadDictionaryContent!deals_NewDeal',
                            'LoadDictionaryContent!deals_Notes'],
                        name: 'fx-component-new-deal-slip',
                        vm: 'deviceviewmodels/Deals/Revised/NewDealViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/new-deal.html',
                    },
                    {
                        deps: ['modules/ComponentStyle!revised-slips',
                            'helpers/CustomKOBindings/SpinnerFieldBinding',
                            'LoadDictionaryContent!deals_NewLimit',
                            'LoadDictionaryContent!deals_Notes'],
                        name: 'fx-component-new-limit',
                        vm: 'deviceviewmodels/Deals/Revised/NewLimitViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/new-limit.html',
                    }, 
                    {
                        deps: ['modules/ComponentStyle!revised-slips',
                            'LoadDictionaryContent!tooltipsStaticResource',
                            'LoadDictionaryContent!deals_CloseDeal'],
                        name: 'fx-component-close-deal',
                        vm: 'deviceviewmodels/Deals/Revised/CloseDealViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/close-deal.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!revised-slips',
                            'helpers/CustomKOBindings/SpinnerFieldBinding',
                            'LoadDictionaryContent!deals_EditClosingLimit',
                            'LoadDictionaryContent!deals_CloseDeal'],
                        name: 'fx-component-edit-closing-limit',
                        vm: 'deviceviewmodels/Deals/Revised/EditClosingLimitViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/edit-closinglimit.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!revised-slips',
                            'LoadDictionaryContent!deals_EditLimit',
                            'helpers/CustomKOBindings/SpinnerFieldBinding'],
                        name: 'fx-component-edit-limit',
                        vm: 'deviceviewmodels/Deals/Revised/EditLimitViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/edit-limit.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!revised-slips',
                            'LoadDictionaryContent!limits_NewPriceAlert'],
                        name: 'fx-component-new-pricealert',
                        vm: 'deviceviewmodels/Deals/Revised/NewPriceAlertViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/new-pricealert.html'
                    },
                    {
                        name: 'fx-component-dynamic-title-slip',
                        vm: 'deviceviewmodels/Deals/DynamicTitleSlip',
                        template: 'text!webHtml/statichtml/deals/dynamic-title-slip.html'
                    },
                    {
                        name: 'fx-component-slip-toggle',
                        vm: 'deviceviewmodels/Deals/SlipToggleViewModel',
                        template: 'text!webHtml/statichtml/deals/slip-toggle.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!deals_DealMarketInfoTool'],
                        name: 'fx-component-market-info-tool',
                        vm: 'deviceviewmodels/MarketInfoToolViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/marketinfo-tool.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!deals_DealMarketInfoTool'],
                        name: 'fx-component-market-info-summary',
                        vm: 'deviceviewmodels/Deals/MarketInfoSummaryViewModel',
                        template: 'text!webHtml/statichtml/deals/marketinfo-summary.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!deals_DealSignalsTool'],
                        name: 'fx-component-signals-tool',
                        vm: 'deviceviewmodels/Signals/SignalsToolViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/signals-tool.html',
                    },
                    {
                        deps: ['LoadDictionaryContent!deals_Notes'],
                        name: 'fx-component-deal-note',
                        vm: 'deviceviewmodels/Deals/DealNoteViewModel',
                        template: 'text!webHtml/statichtml/deals/deal-note.html',
                    },
                    {
                        name: 'fx-instrument-notavailable',
                        vm: 'viewmodels/InstrumentNotAvailableViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/instrument-notavailable.html'
                    }, 
                    {
                        name: 'fx-component-transaction-switchwrap',
                        template: 'text!webHtml/statichtml/deals/revised/transaction-switchwrap.html'
                    },
                    {
                        deps: ['modules/ComponentStyle!revised-chartstation'],
                        name: 'fx-component-main-chart',
                        vm: 'deviceviewmodels/MainChartViewModel',
                        template: 'text!webHtml/statichtml/Chart/revised/main-chart.html'
                    }, 
                    {
                        name: 'fx-component-tile-transaction-switcher',
                        vm: 'deviceviewmodels/TileTransactionSwitcherViewModel',
                        template: 'text!webHtml/statichtml/deals/revised/tile-transaction-switcher.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!chart_station'],
                        name: 'fx-component-tiled-layout',
                        vm: 'deviceviewmodels/TileLayoutViewModel',
                        template: 'text!webHtml/statichtml/Chart/revised/tiled-layout.html'
                    },
                    {
                        deps: ['LoadDictionaryContent!tooltipsStaticResource'],
                        name: 'fx-component-open-deals-grid',
                        vm: 'deviceviewmodels/OpenDealsViewModel',
                        template: 'text!partial-views/web-deals-opendeals.html',
                    }
                ];

            components = loadRevised ? revisedDealComponents : dealComponents;

            for (var i = 0; i < components.length; i++) {
                registerComponent(components[i]);
            }
        }

        function registerComponentByName(cName) {
            for (var i = 0; i < components.length; i++) {
                if (components[i].name == cName) {
                    registerComponent(components[i]);
                    break;
                }
            }
        }

        function registerComponent(config) {
            var component = {};

            if (config.hasOwnProperty('deps')) {
                component.deps = config.deps;
            } 

            if (config.hasOwnProperty('vm')) {
                component.viewModel = { require: config.vm };
            } 

            if (config.hasOwnProperty('template')) {
                component.template = { require: config.template };
            } else if (config.hasOwnProperty('element')) {
                component.template = { element: config.element };
            }

            ko.components.register(config.name, component);
        }

        function unRegisterComponents() {
            for (var i = 0; i < components.length; i++) {
                ko.components.unregister(components[i].name);
            }
        }

        return {
            RegisterComponent: registerComponent,
            RegisterComponentByName: registerComponentByName,
            RegisterComponents: registerComponents,
            UnRegisterComponents: unRegisterComponents
        };
    }
);
define(
    'modules/Printer',
    [
        'Q'
    ],
    function (Q) {
        var iframeElementData = {
                name: "fx-printIFrame",
                inUse: false
            },
            printDefer;

        function onAfterPrint() {
            var iframeElement = document.getElementById(iframeElementData.name);

            iframeElement.contentWindow.removeEventListener('afterprint', onAfterPrint, true);

            iframeElementData.inUse = false;
            printDefer.resolve('print done');
        }

        function prepareIframe() {
            var iframeElement = document.getElementById(iframeElementData.name);

            if (!iframeElement) {
                iframeElement = document.createElement("iframe");
                iframeElement.name = iframeElementData.name;
                iframeElement.id = iframeElementData.name;
                iframeElement.style.position = "absolute";
                iframeElement.style.top = "-9000px";

                document.body.appendChild(iframeElement);
            }
        }

        function writeToIframe(data) {
            var iframeElement = document.getElementById(iframeElementData.name),
                ifrDocument = iframeElement.contentWindow.document,
                style = getStyles(),
                script = "<script>"
                    + "\nstylesCount=" + style.count + ";"
                    + "\nfunction tryPrint(){"
                    + "\nif(--stylesCount<=0){"
                    + "\nsetTimeout(window.print, 1000)"
                    + "}"
                    + "};</script>";

            ifrDocument.open();
            ifrDocument.write(script + "\n" + style.styles + "\n" + data);
            ifrDocument.close();

            iframeElement.contentWindow.addEventListener('afterprint', onAfterPrint, true);
        }

        function getStyles() {
            var sStyles = "",
                count = 0;

            Array.prototype.forEach.call(document.styleSheets,
                function (styleSheet) {
                    if (!styleSheet.disabled) {
                        var styleSheetClone = styleSheet.ownerNode.cloneNode(true);
                        if (styleSheetClone.tagName === "LINK" && styleSheetClone.href) {
                            count++;
                            styleSheetClone.href = styleSheetClone.href.replace('dark', 'light');
                            sStyles += '<link rel="stylesheet" type="text/css" href="' + styleSheetClone.href + '" onload="tryPrint()">';
                        }
                    }
                });
            return { styles: sStyles, count: count };
        }

        function print(data) {
            if (iframeElementData.inUse) {
                return printDefer.promise;
            }

            iframeElementData.inUse = true;
            printDefer = Q.defer();
            printDefer.promise
                .timeout(30000, "print aborted")
                .fail(onAfterPrint);

            setTimeout(function () {
                prepareIframe();

                writeToIframe(data);
            }, 0);

            return printDefer.promise;
        }

        return {
            print: print
        }
    });
define(
    'modules/PrintModule',
    [
        "require",
        "knockout",
        'managers/viewsmanager',
        'devicemanagers/AlertsManager',
        "Dictionary",
        'handlers/general',
        "helpers/observabledataset",
        "modules/Printer",
        "configuration/initconfiguration"
    ],
    function (require) {
        var ko = require("knockout"),
            ViewsManager = require('managers/viewsmanager'),
            AlertsManager = require('devicemanagers/AlertsManager'),
            general = require('handlers/general'),
            Dictionary = require("Dictionary"),
            ObservableDataSet = require("helpers/observabledataset"),
            initConfiguration = require("configuration/initconfiguration"),
            printer = require("modules/Printer");

        function PrintModule() {
            var dataSet = new ObservableDataSet(ko, general),
                dataRows = ko.observable(),
                processPrint = ko.observable(false),
                componentSubscriber,
                dataSetIsLoadingDataSubScriber,
                disabled,
                canPrint,
                currentExportComponent;

            function setObservables() {
                disabled = ko.observable();

                canPrint = ko.pureComputed(function readyForPrint() {
                    return !(disabled() || processPrint());
                }).extend({ notify: "always" });

                currentExportComponent = ko.observable();//"default-empty-component");
                currentExportComponent.extend({ empty: true });
                currentExportComponent.extend({ notify: "always" });
            }

            function setSubscribers() {
                disabled.subscribeTo("printableDataAvailable", true, check4Data2Print);

                ko.postbox.subscribe("active-view", function (formType) {
                    //internal disable print/export before each form change
                    ko.postbox.publish("printableDataAvailable", {
                        reset: "on eAppEvents.formChangeEvent",
                        dataAvailable: false,
                        viewType: ViewsManager.ActiveFormType(),
                        nextViewType: formType,
                        viewModel: "ExportViewModel"
                    });
                });
            }

            function exportPrintHandler(view, historicalData) {
                if (disabled()) {
                    return;
                }
                processPrint(true);
                if (historicalData) {
                    exportHistoricalData(view);
                } else {
                    printElement(eClientExportTable[view])
                    .fin(function () {
                        processPrint(false);
                    })
                    .done();

                }
            }

            function exportHistoricalData(view) {
                dataSet.Clean();

                if (componentSubscriber) {
                    componentSubscriber.dispose();
                }

                componentSubscriber = ko.postbox.subscribe(eAppEvents.exportDataLoadedEvent, function (params) {
                    if (componentSubscriber) {
                        componentSubscriber.dispose();
                    }

                    var cols = general.cloneHardCopy(params.vm.DsColumns);
                    cols.DAL.onLoad = dataSetOnloadHandler;

                    // switching between active/executed/deleted limits needs filter update
                    cols.Filter = currentExportComponent() == eComponent[eForms.Deals] ? general.cloneHardCopy(ViewsManager.VmLimits.Filter) : cols.Filter;

                    cols.Filter.pagesize = initConfiguration.PrintConfiguration.pageSize;
                    cols.Filter.exportdata = true;
                    dataSet.UpdateColumnModel(cols);

                    if (dataSetIsLoadingDataSubScriber) {
                        dataSetIsLoadingDataSubScriber.dispose();
                    }

                    dataSetIsLoadingDataSubScriber = dataSet.IsLoadingData.subscribe(function (isLoading) {
                        if (!isLoading && dataSet.HasRecords()) {
                            dataRows(dataSet.DataRows());
                            dataSetIsLoadingDataSubScriber.dispose();
                            printElement(eServerExportTable[ViewsManager.ActiveFormType()])
                            .then(function () {
                                currentExportComponent(null);
                                processPrint(false);
                            })
                            .done();
                        }
                    });

                    dataSet.Load();
                });

                currentExportComponent(eComponent[view]);
            }

            function dataSetOnloadHandler(result) {
                if (eOperationStatus[result["status"]] === eOperationStatus.ExportValidationFailed) {
                    AlertsManager.UpdateAlert(AlertTypes.ServerResponseAlert, Dictionary.GetItem("ExportValidationFailedMsgTitle"), Dictionary.GetItem("ExportValidationFailedMsgText"), "");
                    AlertsManager.PopAlert(AlertTypes.ServerResponseAlert);
                    processPrint(false);
                }
            }

            function check4Data2Print(newVal) {
                newVal = general.isObjectType(newVal) ? newVal : { dataAvailable: newVal };

                //skip if active view is not the same as the active view from sender
                if (newVal.viewType !== ViewsManager.ActiveFormType()) {
                    return disabled();
                }

                return !newVal.dataAvailable;
            }

            function printElement(elementSelector) {
                var contentsNode = document.getElementById(elementSelector);
                if (!contentsNode) {
                    return;
                }
                return printer.print(contentsNode.outerHTML);
            }

            setObservables();
            setSubscribers();

            return {
                DataRows: dataRows,
                PrintHandler: exportPrintHandler,
                CurrentExportComponent: currentExportComponent,
                ProcessPrint: processPrint,
                CanPrint: canPrint
            };
        }

        return new PrintModule();
    }
);

define(
    'modules/ExportModule',
    [
        "require",
        "knockout",
        'managers/viewsmanager',
        'devicemanagers/AlertsManager',
        "Dictionary",
        'handlers/general',
        'configuration/initconfiguration',
        "helpers/observabledataset"
    ],
    function (require) {
        var ko = require("knockout"),
            ViewsManager = require('managers/viewsmanager'),
            AlertsManager = require('devicemanagers/AlertsManager'),
            general = require('handlers/general'),
            initConfiguration = require('configuration/initconfiguration'),
            Dictionary = require("Dictionary");

        function ExportModule() {
            var dataSet = new ObservableDataSet(ko, general),
                dataRows = ko.observable(),
                processCsv = ko.observable(false),
                componentSubscriber,
                dataSetIsLoadingDataSubScriber,
                disabled,
                canExport,
                currentExportComponent;

            function setObservables() {
                disabled = ko.observable();

                canExport = ko.pureComputed(function readyForExport() {
                    return !(disabled() || processCsv());
                }).extend({ notify: "always" });

                currentExportComponent = ko.observable();//"default-empty-component");
                currentExportComponent.extend({ empty: true });
                currentExportComponent.extend({ notify: "always" });
            }

            function setSubscribers() {
                disabled.subscribeTo("printableDataAvailable", true, check4Data2Print);

                ko.postbox.subscribe("active-view", function (formType) {
                    //internal disable print/export before each form change
                    ko.postbox.publish("printableDataAvailable", {
                        reset: "on eAppEvents.formChangeEvent",
                        dataAvailable: false,
                        viewType: ViewsManager.ActiveFormType(),
                        nextViewType: formType,
                        viewModel: "ExportViewModel"
                    });
                });
            }

            function exportCsvHandler(view, historicalData) {
                if (disabled()) {
                    return;
                }
                processCsv(true);
                if (historicalData) {
                    exportHistoricalData(view);
                } else {
                    exportTableElementToCsv(eClientExportTable[view]);
                    processCsv(false);
                }
            }

            function exportHistoricalData(view) {
                dataSet.Clean();

                if (componentSubscriber) {
                    componentSubscriber.dispose();
                }

                componentSubscriber = ko.postbox.subscribe(eAppEvents.exportDataLoadedEvent, function (params) {
                    if (componentSubscriber) {
                        componentSubscriber.dispose();
                    }

                    var cols = general.cloneHardCopy(params.vm.DsColumns);
                    cols.DAL.onLoad = dataSetOnloadHandler.bind(null, cols.Filter);
                    
                    // switching between active/executed/deleted limits needs filter update
                    cols.Filter = currentExportComponent() == eComponent[eForms.Deals] ? general.cloneHardCopy(ViewsManager.VmLimits.Filter) : cols.Filter;

                    cols.Filter.pagesize = initConfiguration.CsvConfiguration.pageSize;
                    cols.Filter.exportdata = true;
                    dataSet.UpdateColumnModel(cols);

                    if (dataSetIsLoadingDataSubScriber) {
                        dataSetIsLoadingDataSubScriber.dispose();
                    }

                    dataSetIsLoadingDataSubScriber = dataSet.IsLoadingData.subscribe(function (isLoading) {
                        if (!isLoading && dataSet.HasRecords()) {
                            dataRows(dataSet.DataRows());
                            dataSetIsLoadingDataSubScriber.dispose();
                            exportTableElementToCsv(eServerExportTable[ViewsManager.ActiveFormType()]);
                            currentExportComponent(null);
                            processCsv(false);
                        }
                    });

                    dataSet.Load();
                });

                currentExportComponent(eComponent[view]);
            }

            function dataSetOnloadHandler(filter, result) {
                filter.exportdata = false;
                filter.pagesize = null;
                if (eOperationStatus[result["status"]] === eOperationStatus.ExportValidationFailed) {
                    AlertsManager.UpdateAlert(AlertTypes.ServerResponseAlert, Dictionary.GetItem("ExportValidationFailedMsgTitle"), Dictionary.GetItem("ExportValidationFailedMsgText"), "");
                    AlertsManager.PopAlert(AlertTypes.ServerResponseAlert);
                    processCsv(false);
                }
            }

            function check4Data2Print(newVal) {
                newVal = general.isObjectType(newVal) ? newVal : { dataAvailable: newVal };

                //skip if active view is not the same as the active view from sender
                if (newVal.viewType !== ViewsManager.ActiveFormType()) {
                    return disabled();
                }

                return !newVal.dataAvailable;
            }

            function exportTableElementToCsv(tableName) {
                var table = document.getElementById(tableName),
                    rowLength = table.rows.length,
                    colLength = table.rows[0].cells.length,
                    tableString = cTextMarks.ZeroWidthNoBreakSpace,
                    fileName = tableName.replace("tbl", "").replace("Export", "").replace(/([A-Z])/g, " $1").trim() + ".csv",
                    cellText,
                    commasNum;

                // set filter string
                tableString += (table.caption ? (table.caption.innerText || table.caption.textContent) : "") + Array(colLength + 1).join(",") + "\r\n";

                // get column headers
                for (var i = 0; i < colLength; i++) {
                    cellText = (table.rows[0].cells[i].innerText || table.rows[0].cells[i].textContent).replace(/(?:\r\n|\r|\n)/g, " ").trim();
                    commasNum = table.rows[0].cells[i].hasAttribute("colspan") ? parseInt(table.rows[0].cells[i].getAttribute("colspan")) : 1;

                    tableString += cellText.split(",").join("") + Array(commasNum + 1).join(","); // empty column headers workaround
                }

                tableString = tableString.substring(0, tableString.length - 1) + "\r\n";

                // get row data
                for (var j = 1; j < rowLength; j++) {
                    for (var k = 0; k < table.rows[j].cells.length; k++) {
                        cellText = (table.rows[j].cells[k].innerText || table.rows[j].cells[k].textContent).replace(/(?:\r\n|\r|\n)/g, " ").trim();
                        tableString += cellText.split(",").join("");
                        commasNum = table.rows[j].cells[k].hasAttribute("colspan") ? parseInt(table.rows[j].cells[k].getAttribute("colspan")) : 1;
                        tableString += Array(commasNum + 1).join(",");
                    }
                    tableString += "\r\n";
                }

                if (navigator.msSaveBlob) { // IE 10.0, IE 11.0
                    var blob = new Blob([tableString], { type: "text/csv;charset=utf-8;" });
                    navigator.msSaveBlob(blob, fileName);
                } else { // Chrome, FF
                    var anchor = document.createElement("a");
                    anchor.style.position = "absolute";
                    anchor.style.top = "-1000000px";
                    document.body.appendChild(anchor);
                    anchor.setAttribute("href", "data:text/csv;charset=utf-8,\uFEFF" + cTextMarks.ZeroWidthNoBreakSpace + encodeURIComponent(tableString));
                    anchor.setAttribute("target", "_blank");
                    anchor.setAttribute("download", fileName);

                    anchor.click();
                    setTimeout(function () {
                        document.body.removeChild(anchor);
                    }, 500);
                }
            }

            setObservables();
            setSubscribers();

            return {
                DataRows: dataRows,
                ExportCsvHandler: exportCsvHandler,
                CurrentExportComponent: currentExportComponent,
                ProcessCsv: processCsv,
                CanExport: canExport
            };
        }

        return new ExportModule();
    }
);

define(
    'managers/PrintExportManager',
    [
        'require',
        'knockout',
        'modules/PrintModule',
        'modules/ExportModule'
    ],
    function () {
        function PrintExportManager(params) {
            var ko = require('knockout'),
                printModule = require('modules/PrintModule'),
                exportModule = require('modules/ExportModule'),
                currentExportComponent, dataRows;

            function isWorkingNow() {
                return printModule.ProcessPrint() || exportModule.ProcessCsv();
            }

            function setComputables() {
                dataRows = ko.pureComputed(function () {
                    var data = null;

                    if (printModule.ProcessPrint()) {
                        data = printModule.DataRows();
                    }

                    if (exportModule.ProcessCsv()) {
                        data = exportModule.DataRows();
                    }

                    return data;
                });

                currentExportComponent = ko.pureComputed(function () {
                    return printModule.CurrentExportComponent() || exportModule.CurrentExportComponent();
                });

                currentExportComponent.extend({ empty: true });
                currentExportComponent.extend({ notify: "always" });
            }

            function doPrint(contextId, historicalData) {
                if (!printModule.CanPrint()) {
                    return;
                }
                printModule.PrintHandler(contextId, historicalData);
            }

            function doExport(contextId, historicalData) {
                if (!exportModule.CanExport()) {
                    return;
                }
                exportModule.ExportCsvHandler(contextId, historicalData);
            }

            setComputables();

            return {
                DoPrint: doPrint,
                DoExport: doExport,
                CanPrint: printModule.CanPrint,
                CanExport: exportModule.CanExport,
                IsPrintingNow: printModule.ProcessPrint,
                CurrentExportComponent: currentExportComponent,
                IsWorkingNow: isWorkingNow,
                DataRows: dataRows
            }
        }

        return new PrintExportManager();
    });
define(
    'viewmodels/PrintExportViewModel',
    [
        'require',
        'managers/viewsmanager',
        'managers/PrintExportManager'
    ],
    function () {
        function PrintExportViewModel(_params) {
            var viewsManager = require('managers/viewsmanager'),
                printExportManager = require('managers/PrintExportManager'),
                params = _params || {},
                contextId = params.contextId || viewsManager.ActiveFormType(),
                historicalData = params.historicalData || viewsManager.Activeform().IsHistoricalData();

            function doPrint() {
                printExportManager.DoPrint(contextId, historicalData);
            }

            function doExport() {
                printExportManager.DoExport(contextId, historicalData);
            }

            return {
                DoPrint: doPrint,
                DoExport: doExport,
                CanPrint: printExportManager.CanPrint,
                CanExport: printExportManager.CanExport,
                CurrentExportComponent: printExportManager.CurrentExportComponent,
                DataRows: printExportManager.DataRows
            };
        }

        return {
            viewModel: PrintExportViewModel
        };
    }
);
var eSignalTrendsImageClasses = {
    South: "ico-sh-arrow-down",
    SouthEast: "ico-sh-arrow-south-east",
    East: "ico-sh-arrow-right",
    North: "ico-sh-arrow-up",
    NorthEast: "ico-sh-arrow-north-east",
    None: ""
};

var eSignalTrendsColorClasses = {
    Green: "green",
    Red: "red",
    Neutral: "neutral"
};

var eSignalTrendsValues = {
    StrongSell: "-2",
    Sell: "-1",
    Neutral: "0",
    Buy: "1",
    StrongBuy: "2"
};
define("customEnums/Consts", function(){});

var cDepositMessageKeys = {
    confirmation: 'depConfirmation',
    succeeded: 'depSucceeded',
    succeededTitle: 'depSucceededTitle',
    changeGeneratedPasswordAfterFirstDeposit: 'ChangeGeneratedPasswordAfterFirstDeposit',
    minDeposit: 'depMinDeposit',
    maxDeposit: 'depMaxDeposit',
    clearerMaxRangeDeposit: 'depMaxDepositRange',
    maxCCAllowed: 'depMaxCCAllowed',
    invalidCardType: 'depInvalidCardType',
    refundableClearer: 'depRefundableClearer',
    minMaxBlocked: 'depMinMaxBlocked',
    maxCardTypeUSDAmount: 'depMaxCardTypeUSDAmount',
    creditCardExpired: 'depCreditCardExpired',
    whiteListValidation: 'depWhiteListValidation',
    meikoPayMaxAmount: 'depMeikoPayMaxAmount',
    depositFailed: 'depDepositFailed',
    requestPended: 'depRequestPended',
    unableProcessRequest: 'depUnableProcessRequest',
    unsupportedCardType: 'depUnsupportedCardType',
    d3secureNotAllowed: 'd3secure',
    noSupportedClearers: 'noSupportedClearers',
    notEnrolledCard: 'notEnrolledCard',
    notice3DSecureDeposit: 'notice3DSecureDeposit',
    d3SecureMissed: 'depD3SecureMissed',
    removeCCMessage: 'depRemoveCCMessage',
    serverError: 'ServerError',
    moneyBookersDepositRequestCancelled: 'depMBDepositRequestCancelled',
    cancelledByUser: 'depCancelledByUser',
    pendingDepositRequest: 'depPendingDepositRequest'
};

var cDepositMessageKeyPrefixes = {
    succeededAdditionalWithDescriptor: 'depSucceededAdditionalWithDescriptor_',
    succeededAdditional: 'depSucceededAdditional_',
    ccBinCountryBlacklistWithCountryId: 'depCCBinCountryBlacklist_countryId_'
};

var cDepositMessageTitleKeys = {
    failedDepositMinimumDeposit: 'FailedDeposit_MinimumDeposit',
    failedDepositExpiryDate: 'FailedDeposit_ExpiryDate',
    failedDepositDoubleCheck: 'FailedDeposit_DoubleCheck',
    failedDepositSorry: 'FailedDeposit_Sorry'
};

var cEmptyGuid = "00000000-0000-0000-0000-000000000000";
define("constsenums/depositconstants", function(){});

define(
    'helpers/customkobindings/KoCustomBindings',
    [
        'require',
        'knockout',
        'handlers/general',
        'jquery',
        'vendor/jquery-ui',
        'customEnums/Consts',
        'constsenums/depositconstants',
        'handlers/languageHelper'
    ],
    function (require) {
        var ko = require('knockout'),
            $ = require('jquery'),
            general = require('handlers/general');

        // Web/Mobile
        ko.bindingHandlers.balloon = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()) || {};
                var $elementTrigger = $(element);

                $elementTrigger.uniqueId();
                var elementTriggerUniqueId = $elementTrigger.attr('id');

                if (!$elementTrigger.attr('title')) {
                    $elementTrigger.attr('title', '***missingTitleAttr');
                }

                if (options.closeEvent === 'click') {
                    // should call .off(
                    $elementTrigger.on('mouseout focusout', function (event) {
                        event.stopImmediatePropagation();
                    });

                    $(document).on(
                        'click.outsideBallon.' + elementTriggerUniqueId,
                        function () {
                            if ($elementTrigger.data('uiTooltipOpen')) {
                                closeTooltip($elementTrigger);
                            }
                        }
                    );
                }

                if (Browser.getBrowserName().toLowerCase() === 'safari') {
                    options.tooltipClass += ' safari';
                }

                $.extend(options.position, {
                    using: function (position, feedback) {
                        // close all opened tooltips in a case that one its closeEvent === click
                        $('[aria-describedby]').each(function (i, el) {
                            if (element !== el) {
                                closeTooltip($(el));
                            }
                        });

                        $elementTrigger.tooltip('open');

                        if (options.closeEvent === 'click') {
                            $elementTrigger.on('tooltipopen', function (e) {
                                var self = this,
                                    $balloon = $('#' + this.getAttribute('aria-describedby'));
                                // set close on click event on tooltip
                                $balloon.on('click', function () {
                                    closeTooltip($(self));
                                });
                            });
                        }

                        $(this).css(position);

                        if (
                            feedback &&
                            feedback.target &&
                            feedback.target.element &&
                            $(feedback.target.element).hasClass('customTooltipPurpose')
                        ) {
                            var isTooltipBellowElement =
                                $(this).offset().top > $(feedback.target.element).offset().top;

                            if (isTooltipBellowElement) {
                                $(feedback.target.element).addClass('customTooltipPurposeBottom');
                            } else {
                                $(feedback.target.element).removeClass(
                                    'customTooltipPurposeBottom'
                                );
                            }
                        } else {
                            $('<div>')
                                .addClass('arrow')
                                .addClass(feedback.vertical)
                                .addClass(feedback.horizontal)
                                .appendTo(this);
                        }
                    },
                });

                var closeTooltip = function (tooltipElement) {
                    if (!general.isObjectType(tooltipElement)) {
                        return;
                    }

                    if (general.isFunctionType(tooltipElement.removeClass)) {
                        tooltipElement.removeClass('toolTipButtonTrigered');
                    }

                    if (
                        general.isFunctionType(tooltipElement.tooltip) &&
                        !general.isNullOrUndefined(tooltipElement.data('ui-tooltip'))
                    ) {
                        tooltipElement.tooltip('close');
                    }
                };

                $elementTrigger.tooltip(options, {
                    show: false,
                    hide: false,
                    content: function () {
                        if (options.contentKey) {
                            return options.resourceName
                                ? Dictionary.GetItem(options.contentKey, options.resourceName)
                                : Dictionary.GetItem(options.contentKey);
                        }

                        return $(this).attr('title');
                    },
                });

                if (options.closeEvent === 'click') {
                    $elementTrigger.on('mouseenter focusin', function () {
                        $(this).addClass('toolTipButtonTrigered');
                    });
                }

                $elementTrigger.on('click.balloon', function () {
                    $elementTrigger.blur().tooltip('open');

                    if (options.closeEvent === 'click') {
                        $elementTrigger.on('tooltipopen', function (e) {
                            var $balloon = $('#' + this.getAttribute('aria-describedby'));

                            $balloon.on('click', function () {
                                closeTooltip($elementTrigger);
                            });
                        });
                    }

                    if (options.timeout && options.timeout > 0) {
                        clearTimeout($elementTrigger._closeTooltipTimer);
                        $elementTrigger._closeTooltipTimer = setTimeout(
                            function (tooltipElement) {
                                closeTooltip(tooltipElement);
                            },
                            options.timeout,
                            $elementTrigger
                        );
                    }
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (
                    elementToDispose
                ) {
                    clearTimeout(elementToDispose._closeTooltipTimer);

                    $(elementToDispose).off('.balloon');
                    $(elementToDispose).tooltip('destroy');
                    $(document).off('click.outsideBallon.' + elementTriggerUniqueId);
                });
            },
        };
        // For getting values from the resources Dictonary based on the prefix, suffix and/or resourceName
        // Web/Mobile
        ko.bindingHandlers.dictionaryBinding = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    prefix = allBindingsAccessor.get('prefix') || '',
                    suffix = allBindingsAccessor.get('suffix') || '',
                    dictionaryKey = prefix + rawValue + suffix,
                    resourceName = allBindingsAccessor.get('resourceName'),
                    value;

                if (dictionaryKey) {
                    value = resourceName
                        ? Dictionary.GetItem(dictionaryKey, resourceName, ' ')
                        : Dictionary.GetItem(dictionaryKey);
                    element.innerHTML = value;
                }
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    prefix = allBindingsAccessor.get('prefix') || '',
                    suffix = allBindingsAccessor.get('suffix') || '',
                    dictionaryKey = prefix + rawValue + suffix,
                    resourceName = allBindingsAccessor.get('resourceName'),
                    value;

                if (dictionaryKey) {
                    value = resourceName
                        ? Dictionary.GetItem(dictionaryKey, resourceName, ' ')
                        : Dictionary.GetItem(dictionaryKey);
                    element.innerHTML = value;
                }
            },
        };

        ko.bindingHandlers.hidden = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                ko.bindingHandlers.visible.update(element, function () {
                    return !value;
                });
            },
        };

        ko.bindingHandlers.visibility = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                if (value) {
                    $(element).css('visibility', 'visible');
                } else {
                    $(element).css('visibility', 'hidden');
                }
            },
        };

        ko.bindingHandlers.instrumentName = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var instId = ko.utils.unwrapObservable(valueAccessor()),
                    longName =
                        instId === Number.MAX_SAFE_INTEGER
                            ? Dictionary.GetItem('All_Instruments', 'deals_CloseDeal')
                            : $instrumentTranslationsManager.Long(instId);

                if (longName && longName.isRtlText()) {
                    element.classList.remove('ltr');
                } else {
                    element.classList.add('ltr');
                }

                element.innerHTML = longName;
            },
        };

        ko.bindingHandlers.nonRtlText = {
            update: function (element, valueAccessor) {
                var text = ko.utils.unwrapObservable(valueAccessor());

                if (text && general.isStringType(text) && text.isRtlText()) {
                    element.classList.remove('ltr');
                } else {
                    element.classList.add('ltr');
                }

                element.innerHTML = text;
            },
        };

        ko.bindingHandlers.instrumentShortName = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var id = ko.utils.unwrapObservable(valueAccessor()),
                    shortName = $instrumentTranslationsManager.Short(id);

                if (shortName && shortName.isRtlText()) {
                    element.classList.remove('ltr');
                } else {
                    element.classList.add('ltr');
                }

                element.innerHTML = shortName;
                return { controlsDescendantBindings: true };
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var id = ko.utils.unwrapObservable(valueAccessor()),
                    shortName = $instrumentTranslationsManager.Short(id);

                if (shortName && shortName.isRtlText()) {
                    element.classList.remove('ltr');
                } else {
                    element.classList.add('ltr');
                }

                element.innerHTML = shortName;
            },
        };

        ko.bindingHandlers.symbolName = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    value = $symbolsManager.GetTranslatedSymbolById(rawValue);

                element.innerHTML = value;
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    value = $symbolsManager.GetTranslatedSymbolById(rawValue);

                element.innerHTML = value;
            },
        };

        ko.bindingHandlers.numberWithCurrencySymbol = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    amountWithSign = Format.toNumberWithCurrency(options.value, options);

                element.innerHTML = amountWithSign;
            },
            update: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    amountWithSign = Format.toNumberWithCurrency(options.value, options);

                element.innerHTML = amountWithSign;
            },
        };

        ko.bindingHandlers.roundM = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var val = ko.utils.unwrapObservable(valueAccessor());

                if (val) {
                    var str = general.formatRoundM(val.toString());
                    $(element).text(str);
                }
            },
        };

        ko.bindingHandlers.roundMBasedOnThreshold = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var val = ko.utils.unwrapObservable(valueAccessor());

                if (val) {
                    var str = general.formatRoundMBasedOnThreshold(val.toString());
                    $(element).text(str);
                }
            },
        };

        ko.bindingHandlers.roundK = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var format = 'K',
                    val = ko.utils.unwrapObservable(valueAccessor());

                if (val) {
                    var str = general.formatNumber(val.toString(), format);
                    $(element).text(str);
                }
            },
        };

        ko.bindingHandlers.kAmount = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var format = 'K',
                    val = ko.utils.unwrapObservable(valueAccessor());

                if (val) {
                    var str = Format.toKAmount(val.toString(), format);
                    $(element).text(str);
                }
            },
        };

        ko.bindingHandlers.amount = (function () {
            var handleBinding = function (element, valueAccessor) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    isInput = $(element).is('input'),
                    amount =
                        Format.toAmount(rawValue) !== 'NA'
                            ? Format.toAmount(rawValue)
                            : rawValue;

                if (isInput) {
                    $(element).val(amount);
                } else {
                    $(element).text(amount);
                }
            };

            return {
                update: handleBinding,
            };
        })();

        ko.bindingHandlers.roundAmount = (function () {
            var handleBinding = function (element, valueAccessor) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    isInput = $(element).is('input'),
                    amount = rawValue; // Format.toAmount(rawValue) !== "NA" ? Format.toAmount(rawValue) : rawValue;

                if (rawValue !== '' && rawValue !== 'NA') {
                    amount = parseFloat(rawValue);

                    if (isNaN(amount)) {
                        amount = '';
                    } else {
                        amount = Math.ceil(Math.abs(amount));
                    }
                }

                if (isInput) {
                    $(element).val(amount);
                } else {
                    $(element).text(amount);
                }
            };

            return {
                init: handleBinding,
                update: handleBinding,
            };
        })();

        ko.bindingHandlers.limitAmount = (function () {
            var handleBinding = function (element, valueAccessor) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    isInput = $(element).is('input'),
                    amount = Format.toAmount(rawValue);

                if (amount === 'NA') {
                    amount = 0;
                }

                if (isInput) {
                    $(element).val(amount);
                } else {
                    $(element).text(general.formatNumberWithThousandsSeparator(amount));
                }
            };

            return {
                init: handleBinding,
                update: handleBinding,
            };
        })();

        // Returns the given value rounded with thousands separator
        ko.bindingHandlers.toHumanReadableNumericFormat = {
            init: function (element, valueAccessor) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor());
                $(element).text(
                    general.isEmptyValue(rawValue) ? '' : Format.toFixedAmount(rawValue)
                );
            },
            update: function (element, valueAccessor) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor());
                $(element).text(
                    general.isEmptyValue(rawValue) ? '' : Format.toFixedAmount(rawValue)
                );
            },
        };

        ko.bindingHandlers.round = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                var amount = 0;

                if (!general.isEmptyValue(value)) {
                    amount = Format.toFixedAmount(value);
                }

                $(element).text(amount);
            },
        };

        ko.bindingHandlers.percentage = {
            init: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor()),
                    el = $(element);
                if (el.is('input') && value) {
                    $(element).val(Format.toPercent(value));
                } else {
                    $(element).text(Format.toPercent(value));
                }
            },
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor()),
                    el = $(element);
                if (el.is('input') && value) {
                    $(element).val(Format.toPercent(value));
                } else {
                    $(element).text(Format.toPercent(value));
                }
            },
        };

        // Web/Mobile
        ko.bindingHandlers.smallFont = {
            update: function (element, valueAccessor, allBindingsAccessor) {
                var valueUnr = ko.utils.unwrapObservable(valueAccessor());
                var charThreshold = allBindingsAccessor.get('smallFontThreshold') || 5;

                if (!valueUnr) {
                    return;
                }

                var str = allBindingsAccessor.get('roundM')
                    ? general.formatRoundM(valueUnr.toString())
                    : valueUnr.toString();

                if (str.length > charThreshold) {
                    $(element).addClass('small-font');
                } else {
                    $(element).removeClass('small-font');
                }
            },
        };

        ko.bindingHandlers.dateFormatShortDayAndMonth = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                var date = general.SplitDateTime(
                    general.str2Date(value, 'd/m/Y H:M').ExtractDate()
                );
                var time = general.SplitDateTime(
                    general.str2Date(value, 'd/m/Y H:M').ExtractTime()
                );
                var result =
                    date.day +
                    '/' +
                    date.month.replace(/^0+/, '') +
                    ' ' +
                    time.hour +
                    ':' +
                    time.min;

                $(element).text(result);
            },
        };

        //07/07/17 15:01
        ko.bindingHandlers.dateFormatShortDayMonthYear = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                var date = general.SplitDateTime(
                    general.str2Date(value, 'd/m/Y H:M').ExtractDate()
                );
                var time = general.SplitDateTime(
                    general.str2Date(value, 'd/m/Y H:M').ExtractTime()
                );
                var result =
                    date.day +
                    '/' +
                    date.month +
                    '/' +
                    date.year.substr(2, 2) +
                    ' ' +
                    time.hour +
                    ':' +
                    time.min;
                $(element).text(result);
            },
        };

        ko.bindingHandlers.dateFormatLongDateWithTime = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                var options = {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: 'numeric',
                    hour12: false,
                };
                var result = general
                    .str2Date(value, 'd/m/Y H:M')
                    .toLocaleDateString('en-US', options);
                $(element).text(result);
            },
        };

        ko.bindingHandlers.addDotInRange = {
            // This will be called when the binding is first applied to an element
            // Set up any initial state, event handlers, etc. here
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var observable = valueAccessor(),
                    valueSubscriber,
                    previousValueSubscriber,
                    previousValue;

                // Store the previous value
                previousValueSubscriber = observable.subscribe(
                    function (_previousValue) {
                        previousValue = _previousValue;
                    },
                    null,
                    'beforeChange'
                );

                valueSubscriber = observable.subscribe(function (value) {
                    if (!mobile.check.s2_default) {
                        return;
                    }

                    if (
                        !value ||
                        value.indexOf('.') != -1 ||
                        value.length >= 5 ||
                        value == 'NA'
                    ) {
                        return;
                    }

                    if (
                        previousValue &&
                        previousValue.indexOf('.') == previousValue.length - 1
                    ) {
                        if (value == previousValue.substring(0, previousValue.length - 1)) {
                            return;
                        }
                    }

                    var ranges = [];
                    var ar = $(element).attr('data-range').split(',');
                    for (var i = 0; i < ar.length; i++) {
                        var rangeField = ar[i];
                        if (rangeField && rangeField in bindingContext.$data) {
                            ranges.push(bindingContext.$data[rangeField]);
                        }
                    }

                    if (ranges.length > 0) {
                        var formattedVal = Format.addDotInRange(
                            this.target(),
                            ranges,
                            previousValue
                        );
                        this.target(formattedVal);
                    }
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    if (previousValueSubscriber) {
                        previousValueSubscriber.dispose();
                        previousValueSubscriber = null;
                    }

                    if (valueSubscriber) {
                        valueSubscriber.dispose();
                        valueSubscriber = null;
                    }

                    element = null;
                });
            },
        };

        ko.bindingHandlers.clearQuoteColor = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                clearTimeout(element.clearQuoteColorTimer);

                element.clearQuoteColorTimer = setTimeout(
                    function (targetElement) {
                        $(targetElement).removeClass('green red up down');
                    },
                    1000,
                    element
                );
            },
        };

        ko.bindingHandlers.timeComponent = {
            update: function (element, valueAccessor, allBindingsAccessor) {
                var valueUnr = ko.utils.unwrapObservable(valueAccessor()) || '';
                var newValueUnr = valueUnr.split(' ')[1];

                if (newValueUnr) {
                    $(element).html(newValueUnr);
                }
            },
        };

        ko.bindingHandlers.formattedText = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var formatted,
                    originalText,
                    originalFormatTextAttr = 'originalFormatText',
                    $element = $(element),
                    allBindings = allBindingsAccessor();

                var getContent = function () {
                    var content;

                    if (allBindings.contentKey) {
                        content = Dictionary.GetItem(
                            allBindings.contentKey,
                            allBindings.resourceName
                        );
                    } else {
                        content = allBindings.encodeHTML ? $element.html() : $element.text();
                    }

                    return content;
                };

                if ($element.attr(originalFormatTextAttr)) {
                    originalText = $element.attr(originalFormatTextAttr);
                } else {
                    originalText = getContent();
                    $element.attr(originalFormatTextAttr, originalText);
                }

                if (allBindings.formatPattern) {
                    formatted = originalText.replace(
                        allBindings.formatPattern,
                        ko.utils.unwrapObservable(valueAccessor())
                    );
                } else {
                    formatted = String.format(
                        originalText,
                        ko.utils.unwrapObservable(valueAccessor())
                    );
                }

                if (allBindings.name) {
                    ko.postbox.publish(allBindings.name + '-text-formatted');
                }

                if (general.isDefinedType(allBindings.useAttr)) {
                    $element.attr(allBindings.useAttr, formatted);
                    $element.html('');

                    return;
                }

                if (allBindings.encodeHTML) {
                    $element.children().each(function (idx, item) {
                        ko.removeNode(item);
                    });

                    $element.html(formatted);
                    ko.applyBindingsToDescendants(bindingContext, element);
                } else {
                    $element.text(formatted);
                }
            },
        };

        ko.bindingHandlers.injectTemplate = {
            init: function () {
                return {
                    controlsDescendantBindings: true,
                };
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var $element = $(element),
                    allBindings = allBindingsAccessor(),
                    originalText = allBindings.encodeHTML
                        ? $element.html()
                        : $element.text(),
                    formatted = originalText;

                var values = ko.utils.unwrapObservable(valueAccessor());
                for (var i = 0; i < values.length; i++) {
                    var regExpForTemplates = new RegExp('\\{%' + i + '%\\}', 'gm');
                    formatted = originalText.replace(
                        regExpForTemplates,
                        "<!-- ko template: { name: '" + values[i] + "' } --><!-- /ko -->"
                    );
                }

                if (allBindings.encodeHTML) {
                    $element.children().each(function (idx, item) {
                        ko.removeNode(item);
                    });

                    $element.html(formatted);
                    ko.applyBindingsToDescendants(bindingContext, element);
                } else {
                    $element.text(formatted);
                }
            },
        };

        ko.bindingHandlers.showDate = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()) || {},
                    el = $(element),
                    options = {
                        value: '',
                        date: true,
                        time: {
                            hour: false,
                            min: false,
                            sec: false,
                        },
                    },
                    valueToDisplay = '';

                if (general.isPrimitiveType(rawValue)) {
                    options.value = rawValue;
                }
                else if (general.isDateType(rawValue)) {
                    var dateObj = new Date(rawValue);
                    options.value =
                        dateObj.getDate() +
                        '/' +
                        (dateObj.getMonth() + 1) +
                        '/' +
                        dateObj.getFullYear() +
                        ' ' +
                        dateObj.getHours() +
                        ':' +
                        dateObj.getMinutes() +
                        ':' +
                        dateObj.getSeconds();
                }
                else {
                    options = $.extend(options, rawValue);
                }

                if (general.isEmpty(options.value)) {
                    el.html('');
                    return;
                }

                var splitDateObj = general.SplitDateTime(options.value);
                if (options.date) {
                    valueToDisplay += splitDateObj.date;
                }
                if (options.time !== false) {
                    if (options.time === true) {
                        valueToDisplay += ' ' + splitDateObj.time;
                    } else {
                        if (options.time.hour) {
                            valueToDisplay += ' ' + splitDateObj.hour;
                        }
                        if (options.time.min) {
                            valueToDisplay += ':' + splitDateObj.min;
                        }
                        if (options.time.sec) {
                            valueToDisplay += ':' + splitDateObj.sec;
                        }
                    }
                }

                el.html(valueToDisplay);
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()) || {},
                    el = $(element),
                    options = {
                        value: '',
                        date: true,
                        time: {
                            hour: false,
                            min: false,
                            sec: false,
                        },
                    },
                    valueToDisplay = '';

                if (general.isPrimitiveType(rawValue)) {
                    options.value = rawValue;
                } else if (general.isDateType(rawValue)) {
                    var dateObj = new Date(rawValue);
                    options.value =
                        dateObj.getDate() +
                        '/' +
                        (dateObj.getMonth() + 1) +
                        '/' +
                        dateObj.getFullYear() +
                        ' ' +
                        dateObj.getHours() +
                        ':' +
                        dateObj.getMinutes() +
                        ':' +
                        dateObj.getSeconds();
                } else {
                    options = $.extend(options, rawValue);
                }

                if (general.isEmpty(options.value)) {
                    el.html('');
                    return;
                }

                var splitDateObj = general.SplitDateTime(options.value);
                if (options.date) {
                    valueToDisplay += splitDateObj.date;
                }
                if (options.time !== false) {
                    if (options.time === true) {
                        valueToDisplay += ' ' + splitDateObj.time;
                    } else {
                        if (options.time.hour) {
                            valueToDisplay += ' ' + splitDateObj.hour;
                        }
                        if (options.time.min) {
                            valueToDisplay += ':' + splitDateObj.min;
                        }
                        if (options.time.sec) {
                            valueToDisplay += ':' + splitDateObj.sec;
                        }
                    }
                }

                el.html(valueToDisplay);
            },
        };

        ko.bindingHandlers.valueDateText = {
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()) || {};
                var el = $(element);
                var valueToDisplay =
                    (rawValue.valueDate.isValueDateEmpty
                        ? Dictionary.GetItem('Daily') + ' '
                        : '') +
                    (general.isEmptyValue(rawValue.valueDate.date)
                        ? ''
                        : general.SplitDateTime(rawValue.valueDate.date).date +
                        (rawValue.showHour
                            ? ' ' + general.SplitDateTime(rawValue.valueDate.date).time
                            : ''));
                el.html(valueToDisplay);
            },
        };

        ko.bindingHandlers.showFwPips = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    value = general.toNumeric(rawValue).toFixed(1),
                    el = $(element);

                if (value >= 0) {
                    value = '+' + value;
                }

                el.html(value);
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    value = general.toNumeric(rawValue).toFixed(1),
                    el = $(element);

                if (value >= 0) {
                    value = '+' + value;
                }

                el.html(value);
            },
        };

        // Web/Mobile
        ko.bindingHandlers.trendFromSignalSign = {
            init: function (element, valueAccessor, allBindingsAccessor) {
                var el = $(element);
                var params = allBindingsAccessor();
                var pre = !general.isNullOrUndefined(params.pre) ? params.pre : '(';
                var post = !general.isNullOrUndefined(params.post) ? params.post : ')';
                var sign = general.toNumeric(ko.utils.unwrapObservable(valueAccessor()));

                function signFormat(value, prefix, suffix) {
                    return prefix + (value === 0 ? '=' : applySign(value)) + suffix;
                }

                function applySign(value) {
                    return value > 0 ? '+' + value : '-' + value;
                }

                general.toNumeric(sign) !== 'NA'
                    ? el.text(signFormat(sign, pre, post))
                    : el.text('');
            },
        };

        // Web/Mobile
        ko.bindingHandlers.imageFromSignalSign = {
            init: function (element, valueAccessor) {
                var sign = ko.utils.unwrapObservable(valueAccessor());
                var el = $(element);
                switch (sign) {
                    case eSignalTrendsValues.StrongSell:
                        el.addClass(eSignalTrendsImageClasses.South);
                        break;
                    case eSignalTrendsValues.Sell:
                        el.addClass(eSignalTrendsImageClasses.SouthEast);
                        break;
                    case eSignalTrendsValues.Neutral:
                        el.addClass(eSignalTrendsImageClasses.East);
                        break;
                    case eSignalTrendsValues.Buy:
                        el.addClass(eSignalTrendsImageClasses.NorthEast);
                        break;
                    case eSignalTrendsValues.StrongBuy:
                        el.addClass(eSignalTrendsImageClasses.North);
                        break;
                    default:
                        el.addClass(eSignalTrendsImageClasses.None);
                        break;
                }
            },
        };

        ko.bindingHandlers.styleFromSignalSign = {
            init: function (element, valueAccessor) {
                var sign = ko.utils.unwrapObservable(valueAccessor());
                var el = $(element);
                switch (sign) {
                    case eSignalTrendsValues.Buy:
                    case eSignalTrendsValues.StrongBuy:
                        el.addClass(eSignalTrendsColorClasses.Green);
                        break;
                    case eSignalTrendsValues.Sell:
                    case eSignalTrendsValues.StrongSell:
                        el.addClass(eSignalTrendsColorClasses.Red);
                        break;
                    default:
                        el.addClass(eSignalTrendsColorClasses.Neutral);
                }
            },
        };

        ko.bindingHandlers.toppedPercentage = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                var amount = 0;

                if (!general.isEmptyValue(value)) {
                    if (value > 100) {
                        amount = '>100%';
                    } else {
                        amount = Format.toPercent(value);
                    }
                }

                $(element).text(amount);
            },
        };

        ko.bindingHandlers.toFixed = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    allBindings = allBindingsAccessor(),
                    decimals = allBindings.decimals || 0,
                    valueAsNum = general.toNumeric(rawValue);

                if (valueAsNum) {
                    var roundingMultiplier = Math.pow(10, decimals),
                        valueToWrite =
                            Math.round(valueAsNum * roundingMultiplier) / roundingMultiplier;

                    if (!isNaN(valueToWrite)) {
                        $(element).text(valueToWrite);
                    } else {
                        $(element).text('');
                    }
                }
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    allBindings = allBindingsAccessor(),
                    decimals = allBindings.decimals || 0,
                    value = general.toNumeric(rawValue);

                if (value) {
                    var roundingMultiplier = Math.pow(10, decimals),
                        valueToWrite =
                            Math.round(value * roundingMultiplier) / roundingMultiplier;

                    if (!isNaN(valueToWrite)) {
                        $(element).text(valueToWrite);
                    } else {
                        $(element).text('');
                    }
                }
            },
        };

        ko.bindingHandlers.toFixedAmount = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    allBindings = allBindingsAccessor(),
                    decimals = allBindings.decimals || 0,
                    value = general.toNumeric(rawValue) || 0;

                if (!isNaN(value)) {
                    var roundingMultiplier = Math.pow(10, decimals),
                        amount = Math.round(value * roundingMultiplier) / roundingMultiplier;

                    $(element).text(Format.toFixedAmount(amount));
                }
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    allBindings = allBindingsAccessor(),
                    decimals = allBindings.decimals || 0,
                    value = general.toNumeric(rawValue) || 0;

                if (!isNaN(value)) {
                    var roundingMultiplier = Math.pow(10, decimals),
                        amount = Math.round(value * roundingMultiplier) / roundingMultiplier;

                    $(element).text(Format.toFixedAmount(amount));
                }
            },
        };

        ko.bindingHandlers.toFixedAmountWithoutRounding = {
            init: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    decimals = allBindingsAccessor().decimals || 0,
                    amount = general.toNumeric(rawValue) || 0;

                if (!isNaN(amount)) {
                    if (decimals > 0) {
                        var roundingMultiplier = Math.pow(10, decimals);
                        amount = Math.round(amount * roundingMultiplier) / roundingMultiplier;
                    }

                    $(element).text(Format.toNumberWithThousandsSeparator(amount));
                }
            },
            update: function (
                element,
                valueAccessor,
                allBindingsAccessor,
                viewModel,
                bindingContext
            ) {
                var rawValue = ko.utils.unwrapObservable(valueAccessor()),
                    decimals = allBindingsAccessor().decimals || 0,
                    amount = general.toNumeric(rawValue) || 0;

                if (!isNaN(amount)) {
                    if (decimals > 0) {
                        var roundingMultiplier = Math.pow(10, decimals);
                        amount = Math.round(amount * roundingMultiplier) / roundingMultiplier;
                    }

                    $(element).text(Format.toNumberWithThousandsSeparator(amount));
                }
            },
        };

        // Web/Mobile
        ko.bindingHandlers.iframeElement = {
            init: function (element, valueAccessor) {
                var iframe = $(element)[0].contentWindow;
                valueAccessor()(iframe);
            },
        };

        ko.bindingHandlers.logger = {
            update: function (element, valueAccessor, allBindings) {
                /* eslint no-console: 0 */
                //store a counter with this element
                var count = ko.utils.domData.get(element, '_ko_logger') || 0,
                    data = ko.toJS(valueAccessor() || allBindings());

                ko.utils.domData.set(element, '_ko_logger', ++count);

                if (window.console && console.log) {
                    console.log(count, element, data);
                }
            },
        };

        ko.bindingHandlers.htmlToString = {
            update: function (element, valueAccessor) {
                $(element).text($('<div>' + valueAccessor() + '</div>').text());
            },
        };

        ko.bindingHandlers.stopBinding = {
            init: function () {
                return { controlsDescendantBindings: true };
            },
        };

        ko.virtualElements.allowedBindings.stopBinding = true;

        // Web/Mobile
        ko.bindingHandlers.isProcessing = (function () {
            return {
                init: function (element) {
                    if (!(element.tagName === 'DIV' && $(element).hasClass('button'))) {
                        element.initialText = $(element).text();
                    }
                },
                update: function (element, valueAccessor) {
                    var params = ko.unwrap(valueAccessor());

                    if (params.switchText && params.showProcessIcon) {
                        $(element).text(Dictionary.GetItem('risk_processing'));
                    } else {
                        $(element).text(element.initialText);
                    }

                    if (params.showProcessIcon) {
                        $(element).addClass('js_processing');
                    } else {
                        $(element).removeClass('js_processing');
                    }
                },
            };
        })();

        // Web/Mobile
        ko.bindingHandlers.progressBar = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor());

                var minimumValue = ko.utils.unwrapObservable(options.minimumValue),
                    maximumValue = ko.utils.unwrapObservable(options.maximumValue),
                    currentValue = ko.utils.unwrapObservable(options.currentValue),
                    currencyId = ko.utils.unwrapObservable(options.currencyId),
                    progress = general.toNumeric(
                        (currentValue / (maximumValue - minimumValue)) * 100
                    ),
                    simpleProgressBar = options.simpleProgressBar || false,
                    bubbleOrientationChangeMaxValue = 85;

                progress = Math.min(progress, 100);

                if (simpleProgressBar) {
                    var $progressBarLine = $('<div>')
                        .addClass('current-value')
                        .css({ width: progress + '%' });
                    $(element).append($progressBarLine);
                    return;
                }

                $(element).append(
                    $('<span>')
                        .addClass('minimum-value direction-ltr')
                        .html(
                            Format.toNumberWithCurrency(minimumValue, {
                                maximumFractionDigits: 0,
                                currencyId: currencyId,
                            })
                        )
                );

                var $progressBar = $('<div>').addClass('cash-progress-bar'),
                    $currentValue = $('<div>')
                        .addClass('current-value')
                        .css({ width: progress + '%' }),
                    $bubble = $('<div>')
                        .addClass('bubble direction-ltr')
                        .html(
                            Format.toNumberWithCurrency(currentValue, {
                                currencyId: currencyId,
                            })
                        );

                if (progress > bubbleOrientationChangeMaxValue)
                    $bubble.addClass('reversed');

                $currentValue.append($bubble);
                $progressBar.append($currentValue);
                $(element).append($progressBar);
                $(element).append(
                    $('<span>')
                        .addClass('maximum-value direction-ltr')
                        .html(
                            Format.toNumberWithCurrency(maximumValue, {
                                currencyId: currencyId,
                            })
                        )
                );
                $(element)
                    .find('.minimum-value')
                    .width($(element).find('.minimum-value').width());
                $(element)
                    .find('.maximum-value')
                    .width($(element).find('.maximum-value').width());
            },
            update: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor());

                var minimumValue = general.toNumeric(
                    ko.utils.unwrapObservable(options.minimumValue)
                ),
                    maximumValue = general.toNumeric(
                        ko.utils.unwrapObservable(options.maximumValue)
                    ),
                    currentValue = general.toNumeric(
                        ko.utils.unwrapObservable(options.currentValue)
                    ),
                    currencyId = ko.utils.unwrapObservable(options.currencyId),
                    progress = general.toNumeric(
                        (currentValue / (maximumValue - minimumValue)) * 100
                    ),
                    bubbleOrientationChangeMaxValue = 85;

                progress = Math.min(progress, 100);
                $(element)
                    .find('.minimum-value')
                    .html(
                        Format.toNumberWithCurrency(minimumValue, {
                            maximumFractionDigits: 0,
                            currencyId: currencyId,
                        })
                    );
                $(element)
                    .find('.maximum-value')
                    .html(
                        Format.toNumberWithCurrency(maximumValue, { currencyId: currencyId })
                    );
                $(element)
                    .find('.current-value')
                    .css({ width: progress + '%' });
                $(element)
                    .find('.bubble')
                    .html(
                        Format.toNumberWithCurrency(currentValue, { currencyId: currencyId })
                    );

                if (progress > bubbleOrientationChangeMaxValue)
                    $(element).find('.bubble').addClass('reversed');
                $(element)
                    .find('.minimum-value, .maximum-value')
                    .addClass('text-positioned');
            },
        };

        ko.bindingHandlers.html5InputsProxy = {
            init: function (element, valueAccessor) {
                var observable = valueAccessor(),
                    currentValue = ko.utils.unwrapObservable(observable),
                    observableSubscriptions = observable.subscribe(function (value) {
                        if (value !== element.value) {
                            element.value = value;
                        }
                    });

                // keyup event
                function keyupEventListener(e) {
                    if (
                        element.validity.valid &&
                        !element.validity.badInput &&
                        observable() !== element.value
                    ) {
                        observable(element.value);
                    }
                }

                element.value = currentValue;
                element.addEventListener('keyup', keyupEventListener);

                // disposes
                ko.utils.domNodeDisposal.addDisposeCallback(element, function (
                    elementToDispose
                ) {
                    if (observableSubscriptions) {
                        observableSubscriptions.dispose();
                        observableSubscriptions = null;
                    }

                    elementToDispose.removeEventListener(
                        'keyup',
                        keyupEventListener,
                        false
                    );
                });
            },
        };

        ko.bindingHandlers.ratesClasses = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()) || {};

                if (options.disabled) {
                    return;
                }

                options.rateObservable.extend({ notify: 'always' });
                options.lastClass = ko.observable('');

                var subscriber = options.rateObservable.subscribe(addCssClasses, options);

                function addCssClasses(newValue) {
                    if (general.isFunctionType(options.showInput) && options.showInput()) {
                        this.lastClass('');
                        ko.applyBindingsToNode(element, { css: options.lastClass });

                        return;
                    }

                    switch (newValue) {
                        case eQuoteStates.Up:
                            this.lastClass(
                                this.lastClass() === this.up[0] ? this.up[1] : this.up[0]
                            );
                            break;
                        case eQuoteStates.Down:
                            this.lastClass(
                                this.lastClass() === this.down[0] ? this.down[1] : this.down[0]
                            );
                            break;
                        case eQuoteStates.NotChanged:
                            this.lastClass(this.notChanged);
                            break;
                        default:
                            this.lastClass('');
                    }
                }

                ko.applyBindingsToNode(element, { css: options.lastClass });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    if (subscriber) {
                        subscriber.dispose();
                        subscriber = null;
                    }
                });
            },
        };

        ko.bindingHandlers.attrIf = {
            update: function (element, valueAccessor, allBindingsAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor()) || {};
                ko.utils.objectForEach(value, function (attrName, attrValue) {
                    var show = ko.utils.unwrapObservable(attrValue);
                    if (typeof show !== 'undefined' && show !== null && show !== '') {
                        ko.bindingHandlers.attr.update(
                            element,
                            valueAccessor,
                            allBindingsAccessor
                        );
                    }
                });
            },
        };

        ko.bindingHandlers['data-automation'] = {
            init: function (element, valueAccessor) {
                var key = ko.utils.unwrapObservable(valueAccessor());

                if (!key) {
                    return;
                }

                element.setAttribute('data-automation', key);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (
                    elementToDispose
                ) {
                    elementToDispose.removeAttribute('data-automation');
                });
            },
        };

        ko.bindingHandlers.progressBarAutoResize = {
            update: function (element) {
                function setProgressBarWidth() {
                    setTimeout(function () {
                        var parent = $('.progress-steps ul'),
                            initialWidth = parent.innerWidth(),
                            leftMargin =
                                parent.find('li:first-child div').innerWidth() / 2 + 20,
                            rightMargin =
                                parent.find('li:visible:last div').innerWidth() / 2 + 20,
                            offset = leftMargin + rightMargin,
                            progressBarWidth = initialWidth - offset + 'px',
                            totalMargin = LanguageHelper.IsRtlLanguage()
                                ? '0 ' + leftMargin + 'px 0 ' + rightMargin + 'px'
                                : '0 ' + rightMargin + 'px 0 ' + leftMargin + 'px';

                        $(element).css({
                            width: progressBarWidth,
                            margin: totalMargin,
                        });
                    }, 200);
                }

                setProgressBarWidth();

                $(window).on('resize.progressBarAutoResize', setProgressBarWidth);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    $(window).off('resize.progressBarAutoResize', setProgressBarWidth);
                });
            },
        };

        ko.bindingHandlers.placeholder = {
            init: function (element, valueAccessor) {
                var options = ko.unwrap(valueAccessor()),
                    onFocusText = options.onFocus || '',
                    onBlurText = options.onBlur || '';

                var handleElementFocusChange = function (el, isFocused) {
                    var ownerDoc = el.ownerDocument;
                    if ('activeElement' in ownerDoc) {
                        var active;
                        try {
                            active = ownerDoc.activeElement;
                        } catch (e) {
                            active = ownerDoc.body;
                        }

                        isFocused = active === el;
                    }

                    element.setAttribute(
                        'placeholder',
                        isFocused ? onFocusText : onBlurText
                    );
                };

                var handleElementFocusIn = handleElementFocusChange.bind(
                    null,
                    element,
                    true
                );
                var handleElementFocusOut = handleElementFocusChange.bind(
                    null,
                    element,
                    false
                );

                ko.utils.registerEventHandler(element, 'focus', handleElementFocusIn);
                ko.utils.registerEventHandler(element, 'blur', handleElementFocusOut);

                handleElementFocusOut();
            },
        };

        /**
         * add "className" to "classElementId" if "valueElementId" has value
         */
        ko.bindingHandlers.cssIfValue = {
            init: function (
                element,
                valueAccessor,
                allBindings,
                viewModel,
                bindingContext
            ) {
                var options = valueAccessor() || {},
                    classElementId = options.classElementId || element.id,
                    valueElementId = options.valueElementId || element.id,
                    className = options.className,
                    classElement = document.getElementById(classElementId) || element,
                    valueElement = document.getElementById(valueElementId) || element,
                    isEmpty = ko.observable(false);

                if (general.isEmptyValue(className)) {
                    return;
                }

                general.isEmpty(!general.isEmptyValue(valueElement.value));

                function onDispose(elementToDispose) {
                    $(elementToDispose).off('change keyup', onChange);
                    isEmpty = null;
                }

                function onChange() {
                    general.isEmpty(!general.isEmptyValue(valueElement.value));
                }

                $(valueElement).on('change keyup', onChange);

                var cssBind = {};
                cssBind[className] = isEmpty;

                ko.applyBindingsToNode(classElement, { css: cssBind }, bindingContext);

                ko.utils.domNodeDisposal.addDisposeCallback(valueElement, onDispose);
            },
        };

        ko.bindingHandlers.scrollHere = {
            update: function (element, valueAccessor) {
                var value = ko.utils.unwrapObservable(valueAccessor());

                if (value) {
                    var boundRectagle = element.getBoundingClientRect();
                    if (boundRectagle.top < 0) {
                        window.scrollBy(0, boundRectagle.top);
                    }
                }
            },
        };

        ko.bindingHandlers.setFocusToId = {
            init: function (element, valueAccesor) {
                $(element).on('click', function () {
                    var elementId = '#' + valueAccesor();
                    $(elementId).trigger('focus');
                });
            },
        };

        ko.bindingHandlers.specificUploadButton = {
            init: function (element) {
                if (!(Browser.isChrome() || !Browser.isChromeOnIOS())) {
                    return;
                }

                element.parentElement.classList.add('specific');
            },
            update: function (element, valueAccessor) {
                if (!(Browser.isChrome() || !Browser.isChromeOnIOS())) {
                    return;
                }

                var isBrowseEnabled = ko.utils.unwrapObservable(valueAccessor());

                if (isBrowseEnabled) {
                    element.classList.add('enabled');
                } else {
                    element.classList.remove('enabled');
                }
            },
        };

        var ArrowList = function ArrowList(element) {
            var $rightArrowContainer = $(element).find('.right-arrow'),
                $leftArrowContainer = $(element).find('.left-arrow'),
                $scrollableContainer = $(element).find('.arrow-navigation-list'),
                $listParent = $(element),
                offset = 100,
                duration = 300,
                hiddenClass = 'hidden',
                liItemClass = '.list-item';

            function registerEvents() {
                $rightArrowContainer.on('click', function () {
                    var leftPos = $scrollableContainer.scrollLeft();

                    $scrollableContainer.animate(
                        {
                            scrollLeft: leftPos + offset,
                        },
                        duration,
                        function () {
                            if (isScrollRightEnd()) {
                                $rightArrowContainer.addClass(hiddenClass);
                            }

                            $leftArrowContainer.removeClass(hiddenClass);
                        }
                    );
                });

                $leftArrowContainer.on('click', function () {
                    var leftPos = $scrollableContainer.scrollLeft();

                    $scrollableContainer.animate(
                        {
                            scrollLeft: leftPos - offset,
                        },
                        duration,
                        function () {
                            $rightArrowContainer.removeClass(hiddenClass);

                            if (isScrollLeftEnd()) {
                                $leftArrowContainer.addClass(hiddenClass);
                            }
                        }
                    );
                });
            }

            function unregisterEvents() {
                $leftArrowContainer.off('click');
                $rightArrowContainer.off('click');
            }

            function isScrollLeftEnd() {
                var leftPos = $scrollableContainer.scrollLeft();
                return leftPos <= 0;
            }

            function isScrollRightEnd() {
                var newScrollLeft = $scrollableContainer.scrollLeft(),
                    width = $scrollableContainer.width(),
                    scrollWidth = $scrollableContainer.get(0).scrollWidth;

                return scrollWidth - newScrollLeft - width == 0;
            }

            function scrollToActiveItem() {
                var $listItems = $scrollableContainer.find(liItemClass);

                $listItems.each(function () {
                    var $activeElement = $(this).find('.active')[0];

                    if (!general.isNullOrUndefined($activeElement)) {
                        $scrollableContainer.animate(
                            {
                                scrollLeft: $(this).position().left,
                            },
                            duration,
                            function () {
                                if (isScrollRightEnd()) {
                                    $rightArrowContainer.addClass(hiddenClass);
                                } else if (isScrollLeftEnd()) {
                                    $leftArrowContainer.addClass(hiddenClass);
                                }
                            }
                        );
                    }
                });
            }

            function setListWidth() {
                var widthParent = $listParent.width();
                if (widthParent) {
                    $scrollableContainer.width(widthParent);
                }
            }

            function getTotalListWidth() {
                var $listItems = $scrollableContainer.find(liItemClass),
                    totalListWidth = 0;

                $listItems.each(function () {
                    totalListWidth += $(this).width();
                });

                return totalListWidth;
            }

            function setArrowsVisibleOnInit() {
                var widthParent = $listParent.width(),
                    totalListWidth = getTotalListWidth();

                if (widthParent < totalListWidth) {
                    $leftArrowContainer.removeClass(hiddenClass);
                    $rightArrowContainer.removeClass(hiddenClass);
                    setListWidth();
                } else {
                    $rightArrowContainer.addClass(hiddenClass);
                    $leftArrowContainer.addClass(hiddenClass);
                }
            }

            function isListWidthEmpty() {
                var widthParent = $listParent.width(),
                    totalListWidth = getTotalListWidth();

                return widthParent === 0 && totalListWidth === 0;
            }

            function setArrowsVisibleOnResize() {
                var widthParent = $listParent.width(),
                    totalListWidth = getTotalListWidth();

                if (widthParent <= totalListWidth) {
                    if (isScrollRightEnd()) {
                        $rightArrowContainer.addClass(hiddenClass);
                    } else {
                        $rightArrowContainer.removeClass(hiddenClass);
                    }

                    if (isScrollLeftEnd()) {
                        $leftArrowContainer.addClass(hiddenClass);
                    } else {
                        $leftArrowContainer.removeClass(hiddenClass);
                    }
                } else {
                    $rightArrowContainer.addClass(hiddenClass);
                    $leftArrowContainer.addClass(hiddenClass);
                }
            }

            return {
                isScrollRightEnd: isScrollRightEnd,
                setArrowsVisibleOnInit: setArrowsVisibleOnInit,
                setArrowsVisibleOnResize: setArrowsVisibleOnResize,
                setListWidth: setListWidth,
                scrollToActiveItem: scrollToActiveItem,
                registerEvents: registerEvents,
                unregisterEvents: unregisterEvents,
                isListWidthEmpty: isListWidthEmpty,
            };
        };

        ko.bindingHandlers.arrowList = {
            init: function (element, valueAccessor, allBindings, viewModel) {
                var arrowList = new ArrowList(element);

                viewModel.Data.itemsRendered = ko.observable(false);
                var intervalId;

                viewModel.Data.itemsRendered.subscribe(function (value) {
                    if (value) {
                        intervalId = setInterval(function () {
                            if (!arrowList.isListWidthEmpty()) {
                                arrowList.setArrowsVisibleOnInit();
                                arrowList.scrollToActiveItem();
                                viewModel.Data.itemsRendered(false);

                                clearInterval(intervalId);

                                setTimeout(function () {
                                    arrowList.setArrowsVisibleOnInit();
                                    arrowList.scrollToActiveItem();
                                }, 1000);
                            }
                        });
                    }
                });

                arrowList.registerEvents();

                $(window).on('resize', function () {
                    arrowList.setListWidth();
                    arrowList.setArrowsVisibleOnResize();
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    arrowList.unregisterEvents();
                    clearInterval(intervalId);
                });
            },
        };

        ko.bindingHandlers.renderArrowListItem = {
            update: function (element, valueAccessor) {
                var data = ko.unwrap(valueAccessor());
                var listLength = data.length;
                var currentIndex = data.index();

                if (currentIndex === listLength - 1) {
                    data.itemsRendered(true);
                }
            },
        };

        ko.bindingHandlers.electronicSignature = {
            init: function (element, valueAccessor, allBindings, viewModel) {
                var initTimeout,
                    setCanvasSize = function () {
                        element.setAttribute('width', element.parentElement.clientWidth);
                        element.setAttribute('height', element.parentElement.clientHeight);
                    },
                    initCanvas = function () {
                        if (initTimeout) {
                            clearTimeout(initTimeout);
                        }

                        if (
                            element.parentElement.clientWidth === 0 ||
                            element.parentElement.clientHeight === 0
                        ) {
                            initTimeout = setTimeout(function () {
                                initCanvas();
                            }, 200);
                        } else {
                            setCanvasSize();
                        }
                    },
                    resizeCallBack = function () {
                        var canvasW = element.getAttribute('width'),
                            canvasH = element.getAttribute('height');
                        if (
                            canvasW != element.parentElement.clientWidth ||
                            canvasH != element.parentElement.clientHeight
                        ) {
                            setCanvasSize();
                            viewModel.ClearSignature();
                        }
                    };

                initCanvas();
                viewModel.InitCanvas(element);

                window.addEventListener('resize', resizeCallBack);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    clearTimeout(initTimeout);
                    window.removeEventListener('resize', resizeCallBack);
                });
            },
        };

        ko.bindingHandlers.triggerClickWhen = {
            init: function (element, valueAccessor) {
                var subscribers = [],
                    options = valueAccessor(),
                    postboxTopic = options.postboxTopic;

                subscribers.push(
                    ko.postbox.subscribe(postboxTopic, function triggerClickOnce() {
                        subscribers.push(options.isActive.subscribe(isBrowseEnabledChanged));

                        isBrowseEnabledChanged(options.isActive());
                    })
                );

                function isBrowseEnabledChanged(isActive) {
                    if (!isActive) {
                        return;
                    }

                    element.click();

                    if (subscribers) {
                        general.disposeArray(subscribers);
                    }
                }

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    if (subscribers) {
                        general.disposeArray(subscribers);
                    }
                });
            },
        };

        ko.bindingHandlers.elementToImage = {
            init: function (element, valueAccessor, allBindings, viewModel) {
                var getPageTopoffset = function () {
                    return window.pageYOffset !== 0 ? -window.pageYOffset : 0;
                };
                viewModel.setPrintSettings(element, getPageTopoffset);
            },
        };

        ko.bindingHandlers.showIntrumentNotAvailable = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    $container = $(element);

                if (!options.isAvailable) {
                    $container.addClass('instrument-unavailable');
                } else {
                    $container.addClass('instrument-available');
                }
            },
            update: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    instrData = options.instrData,
                    $container = $(element),
                    $dealContainer = $('.' + options.dealContainerClass),
                    $instrUnavailableWrapper = $('.instrument-unavailable-wrapper'),
                    dealInstrUnavailableClass = 'deal-container-instrument-notavailable',
                    instrAvailableClass = 'instrument-available',
                    instrUnavailableClass = 'instrument-unavailable';

                $container.css({ height: 'auto' });

                if (!instrData.isAvailable) {
                    $instrUnavailableWrapper.show();
                    $dealContainer.addClass(dealInstrUnavailableClass);
                    $container.addClass(instrUnavailableClass);
                    $container.removeClass(instrAvailableClass);
                } else if (!instrData.isChanged) {
                    if (options.keepContainerHeight) {
                        $container.css({ height: $container.height() + 'px' });
                    }
                    $instrUnavailableWrapper.hide();
                } else {
                    $instrUnavailableWrapper.show();
                    $container.addClass(instrAvailableClass);
                    $container.removeClass(instrUnavailableClass);
                    $dealContainer.removeClass(dealInstrUnavailableClass);
                }
            },
        };

        ko.bindingHandlers.adjustMainContainerSize = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel) {
                var options = valueAccessor() || {},
                    topOffset = options.topOffset,
                    mainWr = document.getElementsByClassName('mainWrapper')[0],
                    el = document.getElementById(options.elementId),
                    calcTimeout;

                var setBodyMinHeight = function () {
                        var elementHeight = el.offsetHeight + topOffset;

                        mainWr.style.minHeight = '';
                        if (mainWr.offsetHeight < elementHeight) {
                            mainWr.style.minHeight = elementHeight + 'px';
                        }
                    },
                    calculateHeight = function () {
                        if (calcTimeout) {
                            clearTimeout(calcTimeout);
                        }

                        calcTimeout = setTimeout(function () {
                            setBodyMinHeight();
                        }, 500);
                    };

                calculateHeight();

                viewModel.Data.userFlowToggle.subscribe(function () {
                    calculateHeight();
                });

                window.addEventListener('resize', function () {
                    calculateHeight();
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    window.removeEventListener('resize', calculateHeight);
                    mainWr.style.minHeight = '';
                    clearTimeout(calcTimeout);
                });
            },
        };

        ko.bindingHandlers.trackingEvent = {
            init: function (element, valueAccessor) {
                var trackEvent = valueAccessor();

                function f() {
                    ko.postbox.publish(trackEvent.name, trackEvent.data);
                }

                element.addEventListener('click', f, false);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (
                    elementToDispose
                ) {
                    element.removeEventListener(f);
                });
            },
        };

        ko.bindingHandlers['play-walkthroug'] = {
            init: function (element, valueAccessor) {
                var walkthrough = require('fxnet/uilayer/Modules/WalkthroughsModule'),
                    walkthroughId = valueAccessor();

                function f(e) {
                    walkthrough.walkthroughWidget.play(walkthroughId);
                }

                element.addEventListener('click', f, false);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (
                    elementToDispose
                ) {
                    element.removeEventListener(f);
                });
            },
        };

        ko.bindingHandlers.securityLogo = {
            init: function (element) {
                var logoId = $(element).attr("id");
                window.__dcid = window.__dcid || []; window.__dcid.push([logoId, "15", "s", "black", "6VaWSBzf"]);

                (function () {
                    var cid = document.createElement("script");
                    cid.async = true;
                    cid.src = "//seal.digicert.com/seals/cascade/seal.min.js";
                    var s = document.getElementsByTagName("script");
                    var ls = s[(s.length - 1)];
                    ls.parentNode.insertBefore(cid, ls.nextSibling);
                }());
            }
        };
    });

/*!
 * jScrollPane - v2.2.1 - 2018-09-27
 * http://jscrollpane.kelvinluck.com/
 *
 * Copyright (c) 2014 Kelvin Luck
 * Copyright (c) 2017-2018 Tuukka Pasanen
 * Dual licensed under the MIT or GPL licenses.
 */

// Script: jScrollPane - cross browser customisable scrollbars
//
// *Version: 2.2.1, Last updated: 2018-09-27*
//
// Project Home - http://jscrollpane.kelvinluck.com/
// GitHub       - http://github.com/vitch/jScrollPane
// CND          - https://cdnjs.com/libraries/jScrollPane
// Source       - https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/script/jquery.jscrollpane.min.js
// (Minified)   - https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/script/jquery.jscrollpane.js
// CSS          - https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/style/jquery.jscrollpane.css
// (Minified)   - https://cdnjs.cloudflare.com/ajax/libs/jScrollPane/2.2.1/style/jquery.jscrollpane.min.css
//
// About: License
//
// Copyright (c) 2017 Kelvin Luck
// Copyright (c) 2017-2018 Tuukka Pasanen
// Dual licensed under the MIT or GPL Version 2 licenses.
// http://jscrollpane.kelvinluck.com/MIT-LICENSE.txt
// http://jscrollpane.kelvinluck.com/GPL-LICENSE.txt
//
// About: Examples
//
// All examples and demos are available through the jScrollPane example site at:
// http://jscrollpane.kelvinluck.com/
//
// About: Support and Testing
//
// This plugin is tested on the browsers below and has been found to work reliably on them. If you run
// into a problem on one of the supported browsers then please visit the support section on the jScrollPane
// website (http://jscrollpane.kelvinluck.com/) for more information on getting support. You are also
// welcome to fork the project on GitHub if you can contribute a fix for a given issue.
//
// jQuery Versions - jQuery 3.x. Although script should work from jQuery 1.1 and up but no promises are made.
// Browsers Tested - See jQuery browser support page: https://jquery.com/browser-support/. Only modern
//                   browsers are supported.
//
// About: Release History
//
// 2.2.1       - (2018-09-27) No changed applied to release so same as RC1/2
// 2.2.1-rc.2  - (2018-06-14) Sucked NPM release have to make new Release.. this is 2018!
// 2.2.1-rc.1  - (2018-06-14) Fixed CSSLint warnings which can lead CSS problems in
//                            production! Please report a issue if this breaks something!
//                            * Merged:
//                            - #360 Register to globally available version of jQuery
// 2.2.0       - (2018-05-16) No changes to RC1
// 2.2.0-rc.1  - (2018-04-28) Merged resize sensor to find out size changes of screen and
//                            again little bit tuned this to support more npm goodies.
//                            * Merged:
//                            - #361 Event based reinitialising - Resize Sensor
//                            - #359 Use npm scripts and local dev dependencies to build the project
// 2.1.3       - (2018-04-04) No changes from Release Candidate 2 so making release
// 2.1.3-rc.2  - (2018-03-13) Now using 'script/jquery.jscrollpane.min.js' main
//                            in package.json rather than 'Gruntfile.js'
// 2.1.3-rc.1  - (2018-03-05) Moving Gruntfile.js to root and example HTML
//                            to subdirectory examples
// 2.1.2       - (2018-02-16) Just on console.log remove and Release!
//                            This version should play nicely with NPM
// 2.1.2-rc.2  - (2018-02-03) Update package.json main-tag
// 2.1.2-rc.1  - (2018-01-18) Release on NPM.
// 2.1.1       - (2018-01-12) As everyone stays silent then we just release! No changes from RC.1
// 2.1.1-rc.1  - (2017-12-23) Started to slowly merge stuff (HO HO HO Merry Christmas!)
//             * Merged
//             - #349 - ScrollPane reinitialization should adapt to changed container size
//             - #335 Set drag bar width/height with .css instead of .width/.height
//             - #297 added two settings: always show HScroll and VScroll
//             * Bugs
//             - #8 Make it possible to tell a scrollbar to be "always on"
// 2.1.0  - (2017-12-16) Update jQuery to version 3.x

(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('vendor/jquery.jscrollpane',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory(jQuery || require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    $.fn.jScrollPane = function (settings) {
        // JScrollPane "class" - public methods are available through $('selector').data('jsp')
        function JScrollPane(elem, s) {
            var settings, jsp = this, pane, paneWidth, paneHeight, container, contentWidth, contentHeight,
                percentInViewH, percentInViewV, isScrollableV, isScrollableH, verticalDrag, dragMaxY,
                verticalDragPosition, horizontalDrag, dragMaxX, horizontalDragPosition,
                verticalBar, verticalTrack, scrollbarWidth, verticalTrackHeight, verticalDragHeight, arrowUp, arrowDown,
                horizontalBar, horizontalTrack, horizontalTrackWidth, horizontalDragWidth, arrowLeft, arrowRight,
                reinitialiseInterval, originalPadding, originalPaddingTotalWidth, previousContentWidth,
                wasAtTop = true, wasAtLeft = true, wasAtBottom = false, wasAtRight = false,
                originalElement = elem.clone(false, false).empty(), resizeEventsAdded = false,
                mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';

            var reinitialiseFn = function () {
                // if size has changed then reinitialise
                if (settings.resizeSensorDelay > 0) {
                    setTimeout(function () {
                        initialise(settings);
                    }, settings.resizeSensorDelay);
                }
                else {
                    initialise(settings);
                }
            };

            if (elem.css('box-sizing') === 'border-box') {
                originalPadding = 0;
                originalPaddingTotalWidth = 0;
            } else {
                originalPadding = elem.css('paddingTop') + ' ' +
                    elem.css('paddingRight') + ' ' +
                    elem.css('paddingBottom') + ' ' +
                    elem.css('paddingLeft');
                originalPaddingTotalWidth = (parseInt(elem.css('paddingLeft'), 10) || 0) +
                    (parseInt(elem.css('paddingRight'), 10) || 0);
            }

            function initialise(s) {

                var /*firstChild, lastChild, */isMaintainingPositon, lastContentX, lastContentY,
                    hasContainingSpaceChanged, originalScrollTop, originalScrollLeft,
                    newPaneWidth, newPaneHeight, maintainAtBottom = false, maintainAtRight = false;

                settings = s;

                if (pane === undefined) {
                    originalScrollTop = elem.scrollTop();
                    originalScrollLeft = elem.scrollLeft();

                    elem.css(
                        {
                            overflow: 'hidden',
                            padding: 0
                        }
                    );
                    // TODO: Deal with where width/ height is 0 as it probably means the element is hidden and we should
                    // come back to it later and check once it is unhidden...
                    paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
                    paneHeight = elem.innerHeight();

                    elem.width(paneWidth);

                    pane = $('<div class="jspPane" />').css('padding', originalPadding).append(elem.children());
                    container = $('<div class="jspContainer" />')
                        .css({
                            'width': paneWidth + 'px',
                            'height': paneHeight + 'px'
                        }
                        ).append(pane).appendTo(elem);

					/*
					// Move any margins from the first and last children up to the container so they can still
					// collapse with neighbouring elements as they would before jScrollPane
					firstChild = pane.find(':first-child');
					lastChild = pane.find(':last-child');
					elem.css(
						{
							'margin-top': firstChild.css('margin-top'),
							'margin-bottom': lastChild.css('margin-bottom')
						}
					);
					firstChild.css('margin-top', 0);
					lastChild.css('margin-bottom', 0);
					*/
                } else {
                    elem.css('width', '');

                    // To measure the required dimensions accurately, temporarily override the CSS positioning
                    // of the container and pane.
                    container.css({ width: 'auto', height: 'auto' });
                    pane.css('position', 'static');

                    newPaneWidth = elem.innerWidth() + originalPaddingTotalWidth;
                    newPaneHeight = elem.innerHeight();
                    pane.css('position', 'absolute');

                    maintainAtBottom = settings.stickToBottom && isCloseToBottom();
                    maintainAtRight = settings.stickToRight && isCloseToRight();

                    hasContainingSpaceChanged = newPaneWidth !== paneWidth || newPaneHeight !== paneHeight;

                    paneWidth = newPaneWidth;
                    paneHeight = newPaneHeight;
                    container.css({ width: paneWidth, height: paneHeight });

                    // If nothing changed since last check...
                    if (!hasContainingSpaceChanged && previousContentWidth == contentWidth && pane.outerHeight() == contentHeight) {
                        elem.width(paneWidth);
                        return;
                    }
                    previousContentWidth = contentWidth;

                    pane.css('width', '');
                    elem.width(paneWidth);

                    container.find('>.jspVerticalBar,>.jspHorizontalBar').remove().end();
                }

                pane.css('overflow', 'auto');
                if (s.contentWidth) {
                    contentWidth = s.contentWidth;
                } else {
                    contentWidth = pane[0].scrollWidth;
                }
                contentHeight = pane[0].scrollHeight;
                pane.css('overflow', '');

                percentInViewH = contentWidth / paneWidth;
                percentInViewV = contentHeight / paneHeight;
                isScrollableV = percentInViewV > 1 || settings.alwaysShowVScroll;
                isScrollableH = percentInViewH > 1 || settings.alwaysShowHScroll;

                if (!(isScrollableH || isScrollableV)) {
                    elem.removeClass('jspScrollable');
                    pane.css({
                        top: 0,
                        left: 0,
                        width: container.width() - originalPaddingTotalWidth
                    });
                    removeMousewheel();
                    removeFocusHandler();
                    removeKeyboardNav();
                    removeClickOnTrack();
                } else {
                    elem.addClass('jspScrollable');

                    isMaintainingPositon = settings.maintainPosition && (verticalDragPosition || horizontalDragPosition);
                    if (isMaintainingPositon) {
                        lastContentX = contentPositionX();
                        lastContentY = contentPositionY();
                    }

                    initialiseVerticalScroll();
                    initialiseHorizontalScroll();
                    resizeScrollbars();

                    if (isMaintainingPositon) {
                        scrollToX(maintainAtRight ? (contentWidth - paneWidth) : lastContentX, false);
                        scrollToY(maintainAtBottom ? (contentHeight - paneHeight) : lastContentY, false);
                    }

                    initFocusHandler();
                    initMousewheel();
                    initTouch();

                    if (settings.enableKeyboardNavigation) {
                        initKeyboardNav();
                    }
                    if (settings.clickOnTrack) {
                        initClickOnTrack();
                    }

                    observeHash();
                    if (settings.hijackInternalLinks) {
                        hijackInternalLinks();
                    }
                }

                if (!settings.resizeSensor && settings.autoReinitialise && !reinitialiseInterval) {
                    reinitialiseInterval = setInterval(
                        function () {
                            initialise(settings);
                        },
                        settings.autoReinitialiseDelay
                    );
                } else if (!settings.resizeSensor && !settings.autoReinitialise && reinitialiseInterval) {
                    clearInterval(reinitialiseInterval);
                }

                if (settings.resizeSensor && !resizeEventsAdded) {

                    // detect size change in content
                    detectSizeChanges(pane, reinitialiseFn);

                    // detect size changes of scroll element
                    detectSizeChanges(elem, reinitialiseFn);

                    // detect size changes of container
                    detectSizeChanges(elem.parent(), reinitialiseFn);

                    // add a reinit on window resize also for safety
                    window.addEventListener('resize', reinitialiseFn);

                    resizeEventsAdded = true;
                }

                if (originalScrollTop && elem.scrollTop(0)) {
                    scrollToY(originalScrollTop, false);
                }

                if (originalScrollLeft && elem.scrollLeft(0)) {
                    scrollToX(originalScrollLeft, false);
                }

                elem.trigger('jsp-initialised', [isScrollableH || isScrollableV]);
            }

            function detectSizeChanges(element, callback) {

                // create resize event elements - based on resize sensor: https://github.com/flowkey/resize-sensor/
                var resizeWidth, resizeHeight;
                var resizeElement = document.createElement('div');
                var resizeGrowElement = document.createElement('div');
                var resizeGrowChildElement = document.createElement('div');
                var resizeShrinkElement = document.createElement('div');
                var resizeShrinkChildElement = document.createElement('div');

                // add necessary styling
                resizeElement.style.cssText = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';
                resizeGrowElement.style.cssText = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';
                resizeShrinkElement.style.cssText = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';

                resizeGrowChildElement.style.cssText = 'position: absolute; left: 0; top: 0;';
                resizeShrinkChildElement.style.cssText = 'position: absolute; left: 0; top: 0; width: 200%; height: 200%;';

                // Create a function to programmatically update sizes
                var updateSizes = function () {

                    resizeGrowChildElement.style.width = resizeGrowElement.offsetWidth + 10 + 'px';
                    resizeGrowChildElement.style.height = resizeGrowElement.offsetHeight + 10 + 'px';

                    resizeGrowElement.scrollLeft = resizeGrowElement.scrollWidth;
                    resizeGrowElement.scrollTop = resizeGrowElement.scrollHeight;

                    resizeShrinkElement.scrollLeft = resizeShrinkElement.scrollWidth;
                    resizeShrinkElement.scrollTop = resizeShrinkElement.scrollHeight;

                    resizeWidth = element.width();
                    resizeHeight = element.height();
                };

                // create functions to call when content grows
                var onGrow = function () {

                    // check to see if the content has change size
                    if (element.width() > resizeWidth || element.height() > resizeHeight) {

                        // if size has changed then reinitialise
                        callback.apply(this, []);
                    }
                    // after reinitialising update sizes
                    updateSizes();
                };

                // create functions to call when content shrinks
                var onShrink = function () {

                    // check to see if the content has change size
                    if (element.width() < resizeWidth || element.height() < resizeHeight) {

                        // if size has changed then reinitialise
                        callback.apply(this, []);
                    }
                    // after reinitialising update sizes
                    updateSizes();
                };

                // bind to scroll events
                resizeGrowElement.addEventListener('scroll', onGrow.bind(this));
                resizeShrinkElement.addEventListener('scroll', onShrink.bind(this));

                // nest elements before adding to pane
                resizeGrowElement.appendChild(resizeGrowChildElement);
                resizeShrinkElement.appendChild(resizeShrinkChildElement);

                resizeElement.appendChild(resizeGrowElement);
                resizeElement.appendChild(resizeShrinkElement);

                element.append(resizeElement);

                // ensure parent element is not statically positioned
                if (window.getComputedStyle(element[0], null).getPropertyValue('position') === 'static') {
                    element[0].style.position = 'relative';
                }

                // update sizes initially
                updateSizes();
            }

            function initialiseVerticalScroll() {
                if (isScrollableV) {

                    container.append(
                        $('<div class="jspVerticalBar" />').append(
                            $('<div class="jspCap jspCapTop" />'),
                            $('<div class="jspTrack" />').append(
                                $('<div class="jspDrag" />').append(
                                    $('<div class="jspDragTop" />'),
                                    $('<div class="jspDragBottom" />')
                                )
                            ),
                            $('<div class="jspCap jspCapBottom" />')
                        )
                    );

                    verticalBar = container.find('>.jspVerticalBar');
                    verticalTrack = verticalBar.find('>.jspTrack');
                    verticalDrag = verticalTrack.find('>.jspDrag');

                    if (settings.showArrows) {
                        arrowUp = $('<a class="jspArrow jspArrowUp" />').on(
                            'mousedown.jsp', getArrowScroll(0, -1)
                        ).on('click.jsp', nil);
                        arrowDown = $('<a class="jspArrow jspArrowDown" />').on(
                            'mousedown.jsp', getArrowScroll(0, 1)
                        ).on('click.jsp', nil);
                        if (settings.arrowScrollOnHover) {
                            arrowUp.on('mouseover.jsp', getArrowScroll(0, -1, arrowUp));
                            arrowDown.on('mouseover.jsp', getArrowScroll(0, 1, arrowDown));
                        }

                        appendArrows(verticalTrack, settings.verticalArrowPositions, arrowUp, arrowDown);
                    }

                    verticalTrackHeight = paneHeight;
                    container.find('>.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow').each(
                        function () {
                            verticalTrackHeight -= $(this).outerHeight();
                        }
                    );


                    verticalDrag.on(
                        "mouseenter",
                        function () {
                            verticalDrag.addClass('jspHover');
                        }
                    ).on(
                        "mouseleave",
                        function () {
                            verticalDrag.removeClass('jspHover');
                        }
                    ).on(
                        'mousedown.jsp',
                        function (e) {
                            // Stop IE from allowing text selection
                            $('html').on('dragstart.jsp selectstart.jsp', nil);

                            verticalDrag.addClass('jspActive');

                            var startY = e.pageY - verticalDrag.position().top;

                            $('html').on(
                                'mousemove.jsp',
                                function (e) {
                                    positionDragY(e.pageY - startY, false);
                                }
                            ).on('mouseup.jsp mouseleave.jsp', cancelDrag);
                            return false;
                        }
                    );
                    sizeVerticalScrollbar();
                }
            }

            function sizeVerticalScrollbar() {
                verticalTrack.height(verticalTrackHeight + 'px');
                verticalDragPosition = 0;
                scrollbarWidth = settings.verticalGutter + verticalTrack.outerWidth();

                // Make the pane thinner to allow for the vertical scrollbar
                pane.width(paneWidth - scrollbarWidth - originalPaddingTotalWidth);

                // Add margin to the left of the pane if scrollbars are on that side (to position
                // the scrollbar on the left or right set it's left or right property in CSS)
                try {
                    if (verticalBar.position().left === 0) {
                        pane.css('margin-left', scrollbarWidth + 'px');
                    }
                } catch (err) {
                }
            }

            function initialiseHorizontalScroll() {
                if (isScrollableH) {

                    container.append(
                        $('<div class="jspHorizontalBar" />').append(
                            $('<div class="jspCap jspCapLeft" />'),
                            $('<div class="jspTrack" />').append(
                                $('<div class="jspDrag" />').append(
                                    $('<div class="jspDragLeft" />'),
                                    $('<div class="jspDragRight" />')
                                )
                            ),
                            $('<div class="jspCap jspCapRight" />')
                        )
                    );

                    horizontalBar = container.find('>.jspHorizontalBar');
                    horizontalTrack = horizontalBar.find('>.jspTrack');
                    horizontalDrag = horizontalTrack.find('>.jspDrag');

                    if (settings.showArrows) {
                        arrowLeft = $('<a class="jspArrow jspArrowLeft" />').on(
                            'mousedown.jsp', getArrowScroll(-1, 0)
                        ).on('click.jsp', nil);
                        arrowRight = $('<a class="jspArrow jspArrowRight" />').on(
                            'mousedown.jsp', getArrowScroll(1, 0)
                        ).on('click.jsp', nil);
                        if (settings.arrowScrollOnHover) {
                            arrowLeft.on('mouseover.jsp', getArrowScroll(-1, 0, arrowLeft));
                            arrowRight.on('mouseover.jsp', getArrowScroll(1, 0, arrowRight));
                        }
                        appendArrows(horizontalTrack, settings.horizontalArrowPositions, arrowLeft, arrowRight);
                    }

                    horizontalDrag.on(
                        "mouseenter",
                        function () {
                            horizontalDrag.addClass('jspHover');
                        }
                    ).on(
                        "mouseleave",
                        function () {
                            horizontalDrag.removeClass('jspHover');
                        }
                    ).on(
                        'mousedown.jsp',
                        function (e) {
                            // Stop IE from allowing text selection
                            $('html').on('dragstart.jsp selectstart.jsp', nil);

                            horizontalDrag.addClass('jspActive');

                            var startX = e.pageX - horizontalDrag.position().left;

                            $('html').on(
                                'mousemove.jsp',
                                function (e) {
                                    positionDragX(e.pageX - startX, false);
                                }
                            ).on('mouseup.jsp mouseleave.jsp', cancelDrag);
                            return false;
                        }
                    );
                    horizontalTrackWidth = container.innerWidth();
                    sizeHorizontalScrollbar();
                }
            }

            function sizeHorizontalScrollbar() {
                container.find('>.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow').each(
                    function () {
                        horizontalTrackWidth -= $(this).outerWidth();
                    }
                );

                horizontalTrack.width(horizontalTrackWidth + 'px');
                horizontalDragPosition = 0;
            }

            function resizeScrollbars() {
                if (isScrollableH && isScrollableV) {
                    var horizontalTrackHeight = horizontalTrack.outerHeight(),
                        verticalTrackWidth = verticalTrack.outerWidth();
                    verticalTrackHeight -= horizontalTrackHeight;
                    $(horizontalBar).find('>.jspCap:visible,>.jspArrow').each(
                        function () {
                            horizontalTrackWidth += $(this).outerWidth();
                        }
                    );
                    horizontalTrackWidth -= verticalTrackWidth;
                    paneHeight -= verticalTrackWidth;
                    paneWidth -= horizontalTrackHeight;
                    horizontalTrack.parent().append(
                        $('<div class="jspCorner" />').css('width', horizontalTrackHeight + 'px')
                    );
                    sizeVerticalScrollbar();
                    sizeHorizontalScrollbar();
                }
                // reflow content
                if (isScrollableH) {
                    pane.width((container.outerWidth() - originalPaddingTotalWidth) + 'px');
                }
                contentHeight = pane.outerHeight();
                percentInViewV = contentHeight / paneHeight;

                if (isScrollableH) {
                    horizontalDragWidth = Math.ceil(1 / percentInViewH * horizontalTrackWidth);
                    if (horizontalDragWidth > settings.horizontalDragMaxWidth) {
                        horizontalDragWidth = settings.horizontalDragMaxWidth;
                    } else if (horizontalDragWidth < settings.horizontalDragMinWidth) {
                        horizontalDragWidth = settings.horizontalDragMinWidth;
                    }
                    horizontalDrag.css('width', horizontalDragWidth + 'px');
                    dragMaxX = horizontalTrackWidth - horizontalDragWidth;
                    _positionDragX(horizontalDragPosition); // To update the state for the arrow buttons
                }
                if (isScrollableV) {
                    verticalDragHeight = Math.ceil(1 / percentInViewV * verticalTrackHeight);
                    if (verticalDragHeight > settings.verticalDragMaxHeight) {
                        verticalDragHeight = settings.verticalDragMaxHeight;
                    } else if (verticalDragHeight < settings.verticalDragMinHeight) {
                        verticalDragHeight = settings.verticalDragMinHeight;
                    }
                    verticalDrag.css('height', verticalDragHeight + 'px');
                    dragMaxY = verticalTrackHeight - verticalDragHeight;
                    _positionDragY(verticalDragPosition); // To update the state for the arrow buttons
                }
            }

            function appendArrows(ele, p, a1, a2) {
                var p1 = "before", p2 = "after", aTemp;

                // Sniff for mac... Is there a better way to determine whether the arrows would naturally appear
                // at the top or the bottom of the bar?
                if (p == "os") {
                    p = /Mac/.test(navigator.platform) ? "after" : "split";
                }
                if (p == p1) {
                    p2 = p;
                } else if (p == p2) {
                    p1 = p;
                    aTemp = a1;
                    a1 = a2;
                    a2 = aTemp;
                }

                ele[p1](a1)[p2](a2);
            }

            function getArrowScroll(dirX, dirY, ele) {
                return function () {
                    arrowScroll(dirX, dirY, this, ele);
                    this.blur();
                    return false;
                };
            }

            function arrowScroll(dirX, dirY, arrow, ele) {
                arrow = $(arrow).addClass('jspActive');

                var eve,
                    scrollTimeout,
                    isFirst = true,
                    doScroll = function () {
                        if (dirX !== 0) {
                            jsp.scrollByX(dirX * settings.arrowButtonSpeed);
                        }
                        if (dirY !== 0) {
                            jsp.scrollByY(dirY * settings.arrowButtonSpeed);
                        }
                        scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.arrowRepeatFreq);
                        isFirst = false;
                    };

                doScroll();

                eve = ele ? 'mouseout.jsp' : 'mouseup.jsp';
                ele = ele || $('html');
                ele.on(
                    eve,
                    function () {
                        arrow.removeClass('jspActive');
                        if (scrollTimeout) {
                            clearTimeout(scrollTimeout);
                        }
                        scrollTimeout = null;
                        ele.off(eve);
                    }
                );
            }

            function initClickOnTrack() {
                removeClickOnTrack();
                if (isScrollableV) {
                    verticalTrack.on(
                        'mousedown.jsp',
                        function (e) {
                            if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
                                var clickedTrack = $(this),
                                    offset = clickedTrack.offset(),
                                    direction = e.pageY - offset.top - verticalDragPosition,
                                    scrollTimeout,
                                    isFirst = true,
                                    doScroll = function () {
                                        var offset = clickedTrack.offset(),
                                            pos = e.pageY - offset.top - verticalDragHeight / 2,
                                            contentDragY = paneHeight * settings.scrollPagePercent,
                                            dragY = dragMaxY * contentDragY / (contentHeight - paneHeight);
                                        if (direction < 0) {
                                            if (verticalDragPosition - dragY > pos) {
                                                jsp.scrollByY(-contentDragY);
                                            } else {
                                                positionDragY(pos);
                                            }
                                        } else if (direction > 0) {
                                            if (verticalDragPosition + dragY < pos) {
                                                jsp.scrollByY(contentDragY);
                                            } else {
                                                positionDragY(pos);
                                            }
                                        } else {
                                            cancelClick();
                                            return;
                                        }
                                        scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
                                        isFirst = false;
                                    },
                                    cancelClick = function () {
                                        if (scrollTimeout) {
                                            clearTimeout(scrollTimeout);
                                        }
                                        scrollTimeout = null;
                                        $(document).off('mouseup.jsp', cancelClick);
                                    };
                                doScroll();
                                $(document).on('mouseup.jsp', cancelClick);
                                return false;
                            }
                        }
                    );
                }

                if (isScrollableH) {
                    horizontalTrack.on(
                        'mousedown.jsp',
                        function (e) {
                            if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
                                var clickedTrack = $(this),
                                    offset = clickedTrack.offset(),
                                    direction = e.pageX - offset.left - horizontalDragPosition,
                                    scrollTimeout,
                                    isFirst = true,
                                    doScroll = function () {
                                        var offset = clickedTrack.offset(),
                                            pos = e.pageX - offset.left - horizontalDragWidth / 2,
                                            contentDragX = paneWidth * settings.scrollPagePercent,
                                            dragX = dragMaxX * contentDragX / (contentWidth - paneWidth);
                                        if (direction < 0) {
                                            if (horizontalDragPosition - dragX > pos) {
                                                jsp.scrollByX(-contentDragX);
                                            } else {
                                                positionDragX(pos);
                                            }
                                        } else if (direction > 0) {
                                            if (horizontalDragPosition + dragX < pos) {
                                                jsp.scrollByX(contentDragX);
                                            } else {
                                                positionDragX(pos);
                                            }
                                        } else {
                                            cancelClick();
                                            return;
                                        }
                                        scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
                                        isFirst = false;
                                    },
                                    cancelClick = function () {
                                        if (scrollTimeout) {
                                            clearTimeout(scrollTimeout);
                                        }
                                        scrollTimeout = null;
                                        $(document).off('mouseup.jsp', cancelClick);
                                    };
                                doScroll();
                                $(document).on('mouseup.jsp', cancelClick);
                                return false;
                            }
                        }
                    );
                }
            }

            function removeClickOnTrack() {
                if (horizontalTrack) {
                    horizontalTrack.off('mousedown.jsp');
                }
                if (verticalTrack) {
                    verticalTrack.off('mousedown.jsp');
                }
            }

            function cancelDrag() {
                $('html').off('dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp');

                if (verticalDrag) {
                    verticalDrag.removeClass('jspActive');
                }
                if (horizontalDrag) {
                    horizontalDrag.removeClass('jspActive');
                }
            }

            function positionDragY(destY, animate) {
                if (!isScrollableV) {
                    return;
                }
                if (destY < 0) {
                    destY = 0;
                } else if (destY > dragMaxY) {
                    destY = dragMaxY;
                }

                // allow for devs to prevent the JSP from being scrolled
                var willScrollYEvent = new $.Event("jsp-will-scroll-y");
                elem.trigger(willScrollYEvent, [destY]);

                if (willScrollYEvent.isDefaultPrevented()) {
                    return;
                }

                var tmpVerticalDragPosition = destY || 0;

                var isAtTop = tmpVerticalDragPosition === 0,
                    isAtBottom = tmpVerticalDragPosition == dragMaxY,
                    percentScrolled = destY / dragMaxY,
                    destTop = -percentScrolled * (contentHeight - paneHeight);

                // can't just check if(animate) because false is a valid value that could be passed in...
                if (animate === undefined) {
                    animate = settings.animateScroll;
                }
                if (animate) {
                    jsp.animate(verticalDrag, 'top', destY, _positionDragY, function () {
                        elem.trigger('jsp-user-scroll-y', [-destTop, isAtTop, isAtBottom]);
                    });
                } else {
                    verticalDrag.css('top', destY);
                    _positionDragY(destY);
                    elem.trigger('jsp-user-scroll-y', [-destTop, isAtTop, isAtBottom]);
                }

            }

            function _positionDragY(destY) {
                if (destY === undefined) {
                    destY = verticalDrag.position().top;
                }

                container.scrollTop(0);
                verticalDragPosition = destY || 0;

                var isAtTop = verticalDragPosition === 0,
                    isAtBottom = verticalDragPosition == dragMaxY,
                    percentScrolled = destY / dragMaxY,
                    destTop = -percentScrolled * (contentHeight - paneHeight);

                if (wasAtTop != isAtTop || wasAtBottom != isAtBottom) {
                    wasAtTop = isAtTop;
                    wasAtBottom = isAtBottom;
                    elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
                }

                updateVerticalArrows(isAtTop, isAtBottom);
                pane.css('top', destTop);
                elem.trigger('jsp-scroll-y', [-destTop, isAtTop, isAtBottom]).trigger('scroll');
            }

            function positionDragX(destX, animate) {
                if (!isScrollableH) {
                    return;
                }
                if (destX < 0) {
                    destX = 0;
                } else if (destX > dragMaxX) {
                    destX = dragMaxX;
                }


                // allow for devs to prevent the JSP from being scrolled
                var willScrollXEvent = new $.Event("jsp-will-scroll-x");
                elem.trigger(willScrollXEvent, [destX]);

                if (willScrollXEvent.isDefaultPrevented()) {
                    return;
                }

                var tmpHorizontalDragPosition = destX || 0;

                var isAtLeft = tmpHorizontalDragPosition === 0,
                    isAtRight = tmpHorizontalDragPosition == dragMaxX,
                    percentScrolled = destX / dragMaxX,
                    destLeft = -percentScrolled * (contentWidth - paneWidth);

                if (animate === undefined) {
                    animate = settings.animateScroll;
                }
                if (animate) {
                    jsp.animate(horizontalDrag, 'left', destX, _positionDragX, function () {
                        elem.trigger('jsp-user-scroll-x', [-destLeft, isAtLeft, isAtRight]);
                    });
                } else {
                    horizontalDrag.css('left', destX);
                    _positionDragX(destX);
                    elem.trigger('jsp-user-scroll-x', [-destLeft, isAtLeft, isAtRight]);
                }
            }

            function _positionDragX(destX) {
                if (destX === undefined) {
                    destX = horizontalDrag.position().left;
                }

                container.scrollTop(0);
                horizontalDragPosition = destX || 0;

                var isAtLeft = horizontalDragPosition === 0,
                    isAtRight = horizontalDragPosition == dragMaxX,
                    percentScrolled = destX / dragMaxX,
                    destLeft = -percentScrolled * (contentWidth - paneWidth);

                if (wasAtLeft != isAtLeft || wasAtRight != isAtRight) {
                    wasAtLeft = isAtLeft;
                    wasAtRight = isAtRight;
                    elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
                }

                updateHorizontalArrows(isAtLeft, isAtRight);
                pane.css('left', destLeft);
                elem.trigger('jsp-scroll-x', [-destLeft, isAtLeft, isAtRight]).trigger('scroll');
            }

            function updateVerticalArrows(isAtTop, isAtBottom) {
                if (settings.showArrows) {
                    arrowUp[isAtTop ? 'addClass' : 'removeClass']('jspDisabled');
                    arrowDown[isAtBottom ? 'addClass' : 'removeClass']('jspDisabled');
                }
            }

            function updateHorizontalArrows(isAtLeft, isAtRight) {
                if (settings.showArrows) {
                    arrowLeft[isAtLeft ? 'addClass' : 'removeClass']('jspDisabled');
                    arrowRight[isAtRight ? 'addClass' : 'removeClass']('jspDisabled');
                }
            }

            function scrollToY(destY, animate) {
                var percentScrolled = destY / (contentHeight - paneHeight);
                positionDragY(percentScrolled * dragMaxY, animate);
            }

            function scrollToX(destX, animate) {
                var percentScrolled = destX / (contentWidth - paneWidth);
                positionDragX(percentScrolled * dragMaxX, animate);
            }

            function scrollToElement(ele, stickToTop, animate) {
                var e, eleHeight, eleWidth, eleTop = 0, eleLeft = 0, viewportTop, viewportLeft, maxVisibleEleTop, maxVisibleEleLeft, destY, destX;

                // Legal hash values aren't necessarily legal jQuery selectors so we need to catch any
                // errors from the lookup...
                try {
                    e = $(ele);
                } catch (err) {
                    return;
                }
                eleHeight = e.outerHeight();
                eleWidth = e.outerWidth();

                container.scrollTop(0);
                container.scrollLeft(0);

                // loop through parents adding the offset top of any elements that are relatively positioned between
                // the focused element and the jspPane so we can get the true distance from the top
                // of the focused element to the top of the scrollpane...
                while (!e.is('.jspPane')) {
                    eleTop += e.position().top;
                    eleLeft += e.position().left;
                    e = e.offsetParent();
                    if (/^body|html$/i.test(e[0].nodeName)) {
                        // we ended up too high in the document structure. Quit!
                        return;
                    }
                }

                viewportTop = contentPositionY();
                maxVisibleEleTop = viewportTop + paneHeight;
                if (eleTop < viewportTop || stickToTop) { // element is above viewport
                    destY = eleTop - settings.horizontalGutter;
                } else if (eleTop + eleHeight > maxVisibleEleTop) { // element is below viewport
                    destY = eleTop - paneHeight + eleHeight + settings.horizontalGutter;
                }
                if (!isNaN(destY)) {
                    scrollToY(destY, animate);
                }

                viewportLeft = contentPositionX();
                maxVisibleEleLeft = viewportLeft + paneWidth;
                if (eleLeft < viewportLeft || stickToTop) { // element is to the left of viewport
                    destX = eleLeft - settings.horizontalGutter;
                } else if (eleLeft + eleWidth > maxVisibleEleLeft) { // element is to the right viewport
                    destX = eleLeft - paneWidth + eleWidth + settings.horizontalGutter;
                }
                if (!isNaN(destX)) {
                    scrollToX(destX, animate);
                }

            }

            function contentPositionX() {
                return -pane.position().left;
            }

            function contentPositionY() {
                return -pane.position().top;
            }

            function isCloseToBottom() {
                var scrollableHeight = contentHeight - paneHeight;
                return (scrollableHeight > 20) && (scrollableHeight - contentPositionY() < 10);
            }

            function isCloseToRight() {
                var scrollableWidth = contentWidth - paneWidth;
                return (scrollableWidth > 20) && (scrollableWidth - contentPositionX() < 10);
            }

            function initMousewheel() {
                container.off(mwEvent).on(
                    mwEvent,
                    function (event, delta, deltaX, deltaY) {

                        if (!horizontalDragPosition) horizontalDragPosition = 0;
                        if (!verticalDragPosition) verticalDragPosition = 0;

                        var dX = horizontalDragPosition, dY = verticalDragPosition, factor = event.deltaFactor || settings.mouseWheelSpeed;
                        jsp.scrollBy(deltaX * factor, -deltaY * factor, false);
                        // return true if there was no movement so rest of screen can scroll
                        return dX == horizontalDragPosition && dY == verticalDragPosition;
                    }
                );
            }

            function removeMousewheel() {
                container.off(mwEvent);
            }

            function nil() {
                return false;
            }

            function initFocusHandler() {
                pane.find(':input,a').off('focus.jsp').on(
                    'focus.jsp',
                    function (e) {
                        scrollToElement(e.target, false);
                    }
                );
            }

            function removeFocusHandler() {
                pane.find(':input,a').off('focus.jsp');
            }

            function initKeyboardNav() {
                var keyDown, elementHasScrolled, validParents = [];
                if (isScrollableH) {
                    validParents.push(horizontalBar[0]);
                }

                if (isScrollableV) {
                    validParents.push(verticalBar[0]);
                }

                // IE also focuses elements that don't have tabindex set.
                pane.on(
                    'focus.jsp',
                    function () {
                        elem.focus();
                    }
                );

                elem.attr('tabindex', 0)
                    .off('keydown.jsp keypress.jsp')
                    .on(
                        'keydown.jsp',
                        function (e) {
                            if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)) {
                                return;
                            }
                            var dX = horizontalDragPosition, dY = verticalDragPosition;
                            switch (e.keyCode) {
                                case 40: // down
                                case 38: // up
                                case 34: // page down
                                case 32: // space
                                case 33: // page up
                                case 39: // right
                                case 37: // left
                                    keyDown = e.keyCode;
                                    keyDownHandler();
                                    break;
                                case 35: // end
                                    scrollToY(contentHeight - paneHeight);
                                    keyDown = null;
                                    break;
                                case 36: // home
                                    scrollToY(0);
                                    keyDown = null;
                                    break;
                            }

                            elementHasScrolled = e.keyCode == keyDown && dX != horizontalDragPosition || dY != verticalDragPosition;
                            return !elementHasScrolled;
                        }
                    ).on(
                        'keypress.jsp', // For FF/ OSX so that we can cancel the repeat key presses if the JSP scrolls...
                        function (e) {
                            if (e.keyCode == keyDown) {
                                keyDownHandler();
                            }
                            // If the keypress is not related to the area, ignore it. Fixes problem with inputs inside scrolled area. Copied from line 955.
                            if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)) {
                                return;
                            }
                            return !elementHasScrolled;
                        }
                    );

                if (settings.hideFocus) {
                    elem.css('outline', 'none');
                    if ('hideFocus' in container[0]) {
                        elem.attr('hideFocus', true);
                    }
                } else {
                    elem.css('outline', '');
                    if ('hideFocus' in container[0]) {
                        elem.attr('hideFocus', false);
                    }
                }

                function keyDownHandler() {
                    var dX = horizontalDragPosition, dY = verticalDragPosition;
                    switch (keyDown) {
                        case 40: // down
                            jsp.scrollByY(settings.keyboardSpeed, false);
                            break;
                        case 38: // up
                            jsp.scrollByY(-settings.keyboardSpeed, false);
                            break;
                        case 34: // page down
                        case 32: // space
                            jsp.scrollByY(paneHeight * settings.scrollPagePercent, false);
                            break;
                        case 33: // page up
                            jsp.scrollByY(-paneHeight * settings.scrollPagePercent, false);
                            break;
                        case 39: // right
                            jsp.scrollByX(settings.keyboardSpeed, false);
                            break;
                        case 37: // left
                            jsp.scrollByX(-settings.keyboardSpeed, false);
                            break;
                    }

                    elementHasScrolled = dX != horizontalDragPosition || dY != verticalDragPosition;
                    return elementHasScrolled;
                }
            }

            function removeKeyboardNav() {
                elem.attr('tabindex', '-1')
                    .removeAttr('tabindex')
                    .off('keydown.jsp keypress.jsp');

                pane.off('.jsp');
            }

            function observeHash() {
                if (location.hash && location.hash.length > 1) {
                    var e,
                        retryInt,
                        hash = escape(location.hash.substr(1)) // hash must be escaped to prevent XSS
                        ;
                    try {
                        e = $('#' + hash + ', a[name="' + hash + '"]');
                    } catch (err) {
                        return;
                    }

                    if (e.length && pane.find(hash)) {
                        // nasty workaround but it appears to take a little while before the hash has done its thing
                        // to the rendered page so we just wait until the container's scrollTop has been messed up.
                        if (container.scrollTop() === 0) {
                            retryInt = setInterval(
                                function () {
                                    if (container.scrollTop() > 0) {
                                        scrollToElement(e, true);
                                        $(document).scrollTop(container.position().top);
                                        clearInterval(retryInt);
                                    }
                                },
                                50
                            );
                        } else {
                            scrollToElement(e, true);
                            $(document).scrollTop(container.position().top);
                        }
                    }
                }
            }

            function hijackInternalLinks() {
                // only register the link handler once
                if ($(document.body).data('jspHijack')) {
                    return;
                }

                // remember that the handler was bound
                $(document.body).data('jspHijack', true);

                // use live handler to also capture newly created links
                $(document.body).delegate('a[href*="#"]', 'click', function (event) {
                    // does the link point to the same page?
                    // this also takes care of cases with a <base>-Tag or Links not starting with the hash #
                    // e.g. <a href="index.html#test"> when the current url already is index.html
                    var href = this.href.substr(0, this.href.indexOf('#')),
                        locationHref = location.href,
                        hash,
                        element,
                        container,
                        jsp,
                        scrollTop,
                        elementTop;
                    if (location.href.indexOf('#') !== -1) {
                        locationHref = location.href.substr(0, location.href.indexOf('#'));
                    }
                    if (href !== locationHref) {
                        // the link points to another page
                        return;
                    }

                    // check if jScrollPane should handle this click event
                    hash = escape(this.href.substr(this.href.indexOf('#') + 1));

                    // find the element on the page
                    try {
                        element = $('#' + hash + ', a[name="' + hash + '"]');
                    } catch (e) {
                        // hash is not a valid jQuery identifier
                        return;
                    }

                    if (!element.length) {
                        // this link does not point to an element on this page
                        return;
                    }

                    container = element.closest('.jspScrollable');
                    jsp = container.data('jsp');

                    // jsp might be another jsp instance than the one, that bound this event
                    // remember: this event is only bound once for all instances.
                    jsp.scrollToElement(element, true);

                    if (container[0].scrollIntoView) {
                        // also scroll to the top of the container (if it is not visible)
                        scrollTop = $(window).scrollTop();
                        elementTop = element.offset().top;
                        if (elementTop < scrollTop || elementTop > scrollTop + $(window).height()) {
                            container[0].scrollIntoView();
                        }
                    }

                    // jsp handled this event, prevent the browser default (scrolling :P)
                    event.preventDefault();
                });
            }

            // Init touch on iPad, iPhone, iPod, Android
            function initTouch() {
                var startX,
                    startY,
                    touchStartX,
                    touchStartY,
                    moved,
                    moving = false;

                container.off('touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick').on(
                    'touchstart.jsp',
                    function (e) {
                        var touch = e.originalEvent.touches[0];
                        startX = contentPositionX();
                        startY = contentPositionY();
                        touchStartX = touch.pageX;
                        touchStartY = touch.pageY;
                        moved = false;
                        moving = true;
                    }
                ).on(
                    'touchmove.jsp',
                    function (ev) {
                        if (!moving) {
                            return;
                        }

                        var touchPos = ev.originalEvent.touches[0],
                            dX = horizontalDragPosition, dY = verticalDragPosition;

                        jsp.scrollTo(startX + touchStartX - touchPos.pageX, startY + touchStartY - touchPos.pageY);

                        moved = moved || Math.abs(touchStartX - touchPos.pageX) > 5 || Math.abs(touchStartY - touchPos.pageY) > 5;

                        // return true if there was no movement so rest of screen can scroll
                        return dX == horizontalDragPosition && dY == verticalDragPosition;
                    }
                ).on(
                    'touchend.jsp',
                    function (e) {
                        moving = false;
						/*if(moved) {
							return false;
						}*/
                    }
                ).on(
                    'click.jsp-touchclick',
                    function (e) {
                        if (moved) {
                            moved = false;
                            return false;
                        }
                    }
                );
            }

            function destroy() {
                var currentY = contentPositionY(),
                    currentX = contentPositionX();
                elem.removeClass('jspScrollable').off('.jsp');
                pane.off('.jsp');
                elem.replaceWith(originalElement.append(pane.children()));
                originalElement.scrollTop(currentY);
                originalElement.scrollLeft(currentX);

                // clear reinitialize timer if active
                if (reinitialiseInterval) {
                    clearInterval(reinitialiseInterval);
                }
            }

            // Public API
            $.extend(
                jsp,
                {
                    // Reinitialises the scroll pane (if it's internal dimensions have changed since the last time it
                    // was initialised). The settings object which is passed in will override any settings from the
                    // previous time it was initialised - if you don't pass any settings then the ones from the previous
                    // initialisation will be used.
                    reinitialise: function (s) {
                        s = $.extend({}, settings, s);
                        initialise(s);
                    },
                    // Scrolls the specified element (a jQuery object, DOM node or jQuery selector string) into view so
                    // that it can be seen within the viewport. If stickToTop is true then the element will appear at
                    // the top of the viewport, if it is false then the viewport will scroll as little as possible to
                    // show the element. You can also specify if you want animation to occur. If you don't provide this
                    // argument then the animateScroll value from the settings object is used instead.
                    scrollToElement: function (ele, stickToTop, animate) {
                        scrollToElement(ele, stickToTop, animate);
                    },
                    // Scrolls the pane so that the specified co-ordinates within the content are at the top left
                    // of the viewport. animate is optional and if not passed then the value of animateScroll from
                    // the settings object this jScrollPane was initialised with is used.
                    scrollTo: function (destX, destY, animate) {
                        scrollToX(destX, animate);
                        scrollToY(destY, animate);
                    },
                    // Scrolls the pane so that the specified co-ordinate within the content is at the left of the
                    // viewport. animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    scrollToX: function (destX, animate) {
                        scrollToX(destX, animate);
                    },
                    // Scrolls the pane so that the specified co-ordinate within the content is at the top of the
                    // viewport. animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    scrollToY: function (destY, animate) {
                        scrollToY(destY, animate);
                    },
                    // Scrolls the pane to the specified percentage of its maximum horizontal scroll position. animate
                    // is optional and if not passed then the value of animateScroll from the settings object this
                    // jScrollPane was initialised with is used.
                    scrollToPercentX: function (destPercentX, animate) {
                        scrollToX(destPercentX * (contentWidth - paneWidth), animate);
                    },
                    // Scrolls the pane to the specified percentage of its maximum vertical scroll position. animate
                    // is optional and if not passed then the value of animateScroll from the settings object this
                    // jScrollPane was initialised with is used.
                    scrollToPercentY: function (destPercentY, animate) {
                        scrollToY(destPercentY * (contentHeight - paneHeight), animate);
                    },
                    // Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
                    // the value of animateScroll from the settings object this jScrollPane was initialised with is used.
                    scrollBy: function (deltaX, deltaY, animate) {
                        jsp.scrollByX(deltaX, animate);
                        jsp.scrollByY(deltaY, animate);
                    },
                    // Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
                    // the value of animateScroll from the settings object this jScrollPane was initialised with is used.
                    scrollByX: function (deltaX, animate) {
                        var destX = contentPositionX() + Math[deltaX < 0 ? 'floor' : 'ceil'](deltaX),
                            percentScrolled = destX / (contentWidth - paneWidth);
                        positionDragX(percentScrolled * dragMaxX, animate);
                    },
                    // Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
                    // the value of animateScroll from the settings object this jScrollPane was initialised with is used.
                    scrollByY: function (deltaY, animate) {
                        var destY = contentPositionY() + Math[deltaY < 0 ? 'floor' : 'ceil'](deltaY),
                            percentScrolled = destY / (contentHeight - paneHeight);
                        positionDragY(percentScrolled * dragMaxY, animate);
                    },
                    // Positions the horizontal drag at the specified x position (and updates the viewport to reflect
                    // this). animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    positionDragX: function (x, animate) {
                        positionDragX(x, animate);
                    },
                    // Positions the vertical drag at the specified y position (and updates the viewport to reflect
                    // this). animate is optional and if not passed then the value of animateScroll from the settings
                    // object this jScrollPane was initialised with is used.
                    positionDragY: function (y, animate) {
                        positionDragY(y, animate);
                    },
                    // This method is called when jScrollPane is trying to animate to a new position. You can override
                    // it if you want to provide advanced animation functionality. It is passed the following arguments:
                    //  * ele          - the element whose position is being animated
                    //  * prop         - the property that is being animated
                    //  * value        - the value it's being animated to
                    //  * stepCallback - a function that you must execute each time you update the value of the property
                    //  * completeCallback - a function that will be executed after the animation had finished
                    // You can use the default implementation (below) as a starting point for your own implementation.
                    animate: function (ele, prop, value, stepCallback, completeCallback) {
                        var params = {};
                        params[prop] = value;
                        ele.animate(
                            params,
                            {
                                'duration': settings.animateDuration,
                                'easing': settings.animateEase,
                                'queue': false,
                                'step': stepCallback,
                                'complete': completeCallback
                            }
                        );
                    },
                    // Returns the current x position of the viewport with regards to the content pane.
                    getContentPositionX: function () {
                        return contentPositionX();
                    },
                    // Returns the current y position of the viewport with regards to the content pane.
                    getContentPositionY: function () {
                        return contentPositionY();
                    },
                    // Returns the width of the content within the scroll pane.
                    getContentWidth: function () {
                        return contentWidth;
                    },
                    // Returns the height of the content within the scroll pane.
                    getContentHeight: function () {
                        return contentHeight;
                    },
                    // Returns the horizontal position of the viewport within the pane content.
                    getPercentScrolledX: function () {
                        return contentPositionX() / (contentWidth - paneWidth);
                    },
                    // Returns the vertical position of the viewport within the pane content.
                    getPercentScrolledY: function () {
                        return contentPositionY() / (contentHeight - paneHeight);
                    },
                    // Returns whether or not this scrollpane has a horizontal scrollbar.
                    getIsScrollableH: function () {
                        return isScrollableH;
                    },
                    // Returns whether or not this scrollpane has a vertical scrollbar.
                    getIsScrollableV: function () {
                        return isScrollableV;
                    },
                    // Gets a reference to the content pane. It is important that you use this method if you want to
                    // edit the content of your jScrollPane as if you access the element directly then you may have some
                    // problems (as your original element has had additional elements for the scrollbars etc added into
                    // it).
                    getContentPane: function () {
                        return pane;
                    },
                    // Scrolls this jScrollPane down as far as it can currently scroll. If animate isn't passed then the
                    // animateScroll value from settings is used instead.
                    scrollToBottom: function (animate) {
                        positionDragY(dragMaxY, animate);
                    },
                    // Hijacks the links on the page which link to content inside the scrollpane. If you have changed
                    // the content of your page (e.g. via AJAX) and want to make sure any new anchor links to the
                    // contents of your scroll pane will work then call this function.
                    hijackInternalLinks: $.noop,
                    // Removes the jScrollPane and returns the page to the state it was in before jScrollPane was
                    // initialised.
                    destroy: function () {
                        destroy();
                    }
                }
            );

            initialise(s);
        }

        // Pluginifying code...
        settings = $.extend({}, $.fn.jScrollPane.defaults, settings);

        // Apply default speed
        $.each(['arrowButtonSpeed', 'trackClickSpeed', 'keyboardSpeed'], function () {
            settings[this] = settings[this] || settings.speed;
        });

        return this.each(
            function () {
                var elem = $(this), jspApi = elem.data('jsp');
                if (jspApi) {
                    jspApi.reinitialise(settings);
                } else {
                    $("script", elem).filter('[type="text/javascript"],:not([type])').remove();
                    jspApi = new JScrollPane(elem, settings);
                    elem.data('jsp', jspApi);
                }
            }
        );
    };

    $.fn.jScrollPane.defaults = {
        showArrows: false,
        maintainPosition: true,
        stickToBottom: false,
        stickToRight: false,
        clickOnTrack: true,
        autoReinitialise: false,
        autoReinitialiseDelay: 500,
        verticalDragMinHeight: 0,
        verticalDragMaxHeight: 99999,
        horizontalDragMinWidth: 0,
        horizontalDragMaxWidth: 99999,
        contentWidth: undefined,
        animateScroll: false,
        animateDuration: 300,
        animateEase: 'linear',
        hijackInternalLinks: false,
        verticalGutter: 4,
        horizontalGutter: 4,
        mouseWheelSpeed: 3,
        arrowButtonSpeed: 0,
        arrowRepeatFreq: 50,
        arrowScrollOnHover: false,
        trackClickSpeed: 0,
        trackClickRepeatFreq: 70,
        verticalArrowPositions: 'split',
        horizontalArrowPositions: 'split',
        enableKeyboardNavigation: true,
        hideFocus: false,
        keyboardSpeed: 0,
        initialDelay: 300,        // Delay before starting repeating
        speed: 30,		// Default speed when others falsey
        scrollPagePercent: 0.8,		// Percent of visible area scrolled when pageUp/Down or track area pressed
        alwaysShowVScroll: false,
        alwaysShowHScroll: false,
        resizeSensor: false,
        resizeSensorDelay: 0,
    };

}));
/*!
 * JavaScript Custom Forms
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.2.3
 */
;(function(root, factory) {
	'use strict';
	if (typeof define === 'function' && define.amd) {
		define('vendor/jcf',['jquery'], factory);
	} else if (typeof exports === 'object') {
		module.exports = factory(require('jquery'));
	} else {
		root.jcf = factory(jQuery);
	}
}(this, function($) {
	'use strict';

	// define version
	var version = '1.2.3';

	// private variables
	var customInstances = [];

	// default global options
	var commonOptions = {
		optionsKey: 'jcf',
		dataKey: 'jcf-instance',
		rtlClass: 'jcf-rtl',
		focusClass: 'jcf-focus',
		pressedClass: 'jcf-pressed',
		disabledClass: 'jcf-disabled',
		hiddenClass: 'jcf-hidden',
		resetAppearanceClass: 'jcf-reset-appearance',
		unselectableClass: 'jcf-unselectable'
	};

	// detect device type
	var isTouchDevice = ('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch,
		isWinPhoneDevice = /Windows Phone/.test(navigator.userAgent);
	commonOptions.isMobileDevice = !!(isTouchDevice || isWinPhoneDevice);

	// create global stylesheet if custom forms are used
	var createStyleSheet = function() {
		var styleTag = $('<style>').appendTo('head'),
			styleSheet = styleTag.prop('sheet') || styleTag.prop('styleSheet');

		// crossbrowser style handling
		var addCSSRule = function(selector, rules, index) {
			index = index || 0;
			if (styleSheet.insertRule) {
				styleSheet.insertRule(selector + '{' + rules + '}', index);
			} else {
				styleSheet.addRule(selector, rules, index);
			}
		};

		// add special rules
		addCSSRule('.' + commonOptions.hiddenClass, 'position:absolute !important;left:-9999px !important;height:1px !important;width:1px !important;margin:0 !important;border-width:0 !important;-webkit-appearance:none;-moz-appearance:none;appearance:none');
		addCSSRule('.' + commonOptions.rtlClass + ' .' + commonOptions.hiddenClass, 'right:-9999px !important; left: auto !important');
		addCSSRule('.' + commonOptions.unselectableClass, '-webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0);');
		addCSSRule('.' + commonOptions.resetAppearanceClass, 'background: none; border: none; -webkit-appearance: none; appearance: none; opacity: 0; filter: alpha(opacity=0);');

		// detect rtl pages
		var html = $('html'), body = $('body');
		if (html.css('direction') === 'rtl' || body.css('direction') === 'rtl') {
			html.addClass(commonOptions.rtlClass);
		}

		// handle form reset event
		html.on('reset', function() {
			setTimeout(function() {
				api.refreshAll();
			}, 0);
		});

		// mark stylesheet as created
		commonOptions.styleSheetCreated = true;
	};

	// simplified pointer events handler
	(function() {
		var pointerEventsSupported = navigator.pointerEnabled || navigator.msPointerEnabled,
			touchEventsSupported = ('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch,
			eventList, eventMap = {}, eventPrefix = 'jcf-';

		// detect events to attach
		if (pointerEventsSupported) {
			eventList = {
				pointerover: navigator.pointerEnabled ? 'pointerover' : 'MSPointerOver',
				pointerdown: navigator.pointerEnabled ? 'pointerdown' : 'MSPointerDown',
				pointermove: navigator.pointerEnabled ? 'pointermove' : 'MSPointerMove',
				pointerup: navigator.pointerEnabled ? 'pointerup' : 'MSPointerUp'
			};
		} else {
			eventList = {
				pointerover: 'mouseover',
				pointerdown: 'mousedown' + (touchEventsSupported ? ' touchstart' : ''),
				pointermove: 'mousemove' + (touchEventsSupported ? ' touchmove' : ''),
				pointerup: 'mouseup' + (touchEventsSupported ? ' touchend' : '')
			};
		}

		// create event map
		$.each(eventList, function(targetEventName, fakeEventList) {
			$.each(fakeEventList.split(' '), function(index, fakeEventName) {
				eventMap[fakeEventName] = targetEventName;
			});
		});

		// jQuery event hooks
		$.each(eventList, function(eventName, eventHandlers) {
			eventHandlers = eventHandlers.split(' ');
			$.event.special[eventPrefix + eventName] = {
				setup: function() {
					var self = this;
					$.each(eventHandlers, function(index, fallbackEvent) {
						if (self.addEventListener) self.addEventListener(fallbackEvent, fixEvent, false);
						else self['on' + fallbackEvent] = fixEvent;
					});
				},
				teardown: function() {
					var self = this;
					$.each(eventHandlers, function(index, fallbackEvent) {
						if (self.addEventListener) self.removeEventListener(fallbackEvent, fixEvent, false);
						else self['on' + fallbackEvent] = null;
					});
				}
			};
		});

		// check that mouse event are not simulated by mobile browsers
		var lastTouch = null;
		var mouseEventSimulated = function(e) {
			var dx = Math.abs(e.pageX - lastTouch.x),
				dy = Math.abs(e.pageY - lastTouch.y),
				rangeDistance = 25;

			if (dx <= rangeDistance && dy <= rangeDistance) {
				return true;
			}
		};

		// normalize event
		var fixEvent = function(e) {
			var origEvent = e || window.event,
				touchEventData = null,
				targetEventName = eventMap[origEvent.type];

			e = $.event.fix(origEvent);
			e.type = eventPrefix + targetEventName;

			if (origEvent.pointerType) {
				switch (origEvent.pointerType) {
					case 2: e.pointerType = 'touch'; break;
					case 3: e.pointerType = 'pen'; break;
					case 4: e.pointerType = 'mouse'; break;
					default: e.pointerType = origEvent.pointerType;
				}
			} else {
				e.pointerType = origEvent.type.substr(0, 5); // "mouse" or "touch" word length
			}

			if (!e.pageX && !e.pageY) {
				touchEventData = origEvent.changedTouches ? origEvent.changedTouches[0] : origEvent;
				e.pageX = touchEventData.pageX;
				e.pageY = touchEventData.pageY;
			}

			if (origEvent.type === 'touchend') {
				lastTouch = { x: e.pageX, y: e.pageY };
			}
			if (e.pointerType === 'mouse' && lastTouch && mouseEventSimulated(e)) {
				return;
			} else {
				return ($.event.dispatch || $.event.handle).call(this, e);
			}
		};
	}());

	// custom mousewheel/trackpad handler
	(function() {
		var wheelEvents = ('onwheel' in document || document.documentMode >= 9 ? 'wheel' : 'mousewheel DOMMouseScroll').split(' '),
			shimEventName = 'jcf-mousewheel';

		$.event.special[shimEventName] = {
			setup: function() {
				var self = this;
				$.each(wheelEvents, function(index, fallbackEvent) {
					if (self.addEventListener) self.addEventListener(fallbackEvent, fixEvent, false);
					else self['on' + fallbackEvent] = fixEvent;
				});
			},
			teardown: function() {
				var self = this;
				$.each(wheelEvents, function(index, fallbackEvent) {
					if (self.addEventListener) self.removeEventListener(fallbackEvent, fixEvent, false);
					else self['on' + fallbackEvent] = null;
				});
			}
		};

		var fixEvent = function(e) {
			var origEvent = e || window.event;
			e = $.event.fix(origEvent);
			e.type = shimEventName;

			// old wheel events handler
			if ('detail'      in origEvent) { e.deltaY = -origEvent.detail;      }
			if ('wheelDelta'  in origEvent) { e.deltaY = -origEvent.wheelDelta;  }
			if ('wheelDeltaY' in origEvent) { e.deltaY = -origEvent.wheelDeltaY; }
			if ('wheelDeltaX' in origEvent) { e.deltaX = -origEvent.wheelDeltaX; }

			// modern wheel event handler
			if ('deltaY' in origEvent) {
				e.deltaY = origEvent.deltaY;
			}
			if ('deltaX' in origEvent) {
				e.deltaX = origEvent.deltaX;
			}

			// handle deltaMode for mouse wheel
			e.delta = e.deltaY || e.deltaX;
			if (origEvent.deltaMode === 1) {
				var lineHeight = 16;
				e.delta *= lineHeight;
				e.deltaY *= lineHeight;
				e.deltaX *= lineHeight;
			}

			return ($.event.dispatch || $.event.handle).call(this, e);
		};
	}());

	// extra module methods
	var moduleMixin = {
		// provide function for firing native events
		fireNativeEvent: function(elements, eventName) {
			$(elements).each(function() {
				var element = this, eventObject;
				if (element.dispatchEvent) {
					eventObject = document.createEvent('HTMLEvents');
					eventObject.initEvent(eventName, true, true);
					element.dispatchEvent(eventObject);
				} else if (document.createEventObject) {
					eventObject = document.createEventObject();
					eventObject.target = element;
					element.fireEvent('on' + eventName, eventObject);
				}
			});
		},
		// bind event handlers for module instance (functions beggining with "on")
		bindHandlers: function() {
			var self = this;
			$.each(self, function(propName, propValue) {
				if (propName.indexOf('on') === 0 && $.isFunction(propValue)) {
					// dont use $.proxy here because it doesn't create unique handler
					self[propName] = function() {
						return propValue.apply(self, arguments);
					};
				}
			});
		}
	};

	// public API
	var api = {
		version: version,
		modules: {},
		getOptions: function() {
			return $.extend({}, commonOptions);
		},
		setOptions: function(moduleName, moduleOptions) {
			if (arguments.length > 1) {
				// set module options
				if (this.modules[moduleName]) {
					$.extend(this.modules[moduleName].prototype.options, moduleOptions);
				}
			} else {
				// set common options
				$.extend(commonOptions, moduleName);
			}
		},
		addModule: function(proto) {
			// proto is factory function
			if ($.isFunction(proto)) {
				proto = proto($, window);
			}

			// add module to list
			var Module = function(options) {
				// save instance to collection
				if (!options.element.data(commonOptions.dataKey)) {
					options.element.data(commonOptions.dataKey, this);
				}
				customInstances.push(this);

				// save options
				this.options = $.extend({}, commonOptions, this.options, getInlineOptions(options.element), options);

				// bind event handlers to instance
				this.bindHandlers();

				// call constructor
				this.init.apply(this, arguments);
			};

			// parse options from HTML attribute
			var getInlineOptions = function(element) {
				var dataOptions = element.data(commonOptions.optionsKey),
					attrOptions = element.attr(commonOptions.optionsKey);

				if (dataOptions) {
					return dataOptions;
				} else if (attrOptions) {
					try {
						return $.parseJSON(attrOptions);
					} catch (e) {
						// ignore invalid attributes
					}
				}
			};

			// set proto as prototype for new module
			Module.prototype = proto;

			// add mixin methods to module proto
			$.extend(proto, moduleMixin);
			if (proto.plugins) {
				$.each(proto.plugins, function(pluginName, plugin) {
					$.extend(plugin.prototype, moduleMixin);
				});
			}

			// override destroy method
			var originalDestroy = Module.prototype.destroy;
			Module.prototype.destroy = function() {
				this.options.element.removeData(this.options.dataKey);

				for (var i = customInstances.length - 1; i >= 0; i--) {
					if (customInstances[i] === this) {
						customInstances.splice(i, 1);
						break;
					}
				}

				if (originalDestroy) {
					originalDestroy.apply(this, arguments);
				}
			};

			// save module to list
			this.modules[proto.name] = Module;
		},
		getInstance: function(element) {
			return $(element).data(commonOptions.dataKey);
		},
		replace: function(elements, moduleName, customOptions) {
			var self = this,
				instance;

			if (!commonOptions.styleSheetCreated) {
				createStyleSheet();
			}

			$(elements).each(function() {
				var moduleOptions,
					element = $(this);

				instance = element.data(commonOptions.dataKey);
				if (instance) {
					instance.refresh();
				} else {
					if (!moduleName) {
						$.each(self.modules, function(currentModuleName, module) {
							if (module.prototype.matchElement.call(module.prototype, element)) {
								moduleName = currentModuleName;
								return false;
							}
						});
					}
					if (moduleName) {
						moduleOptions = $.extend({ element: element }, customOptions);
						instance = new self.modules[moduleName](moduleOptions);
					}
				}
			});
			return instance;
		},
		refresh: function(elements) {
			$(elements).each(function() {
				var instance = $(this).data(commonOptions.dataKey);
				if (instance) {
					instance.refresh();
				}
			});
		},
		destroy: function(elements) {
			$(elements).each(function() {
				var instance = $(this).data(commonOptions.dataKey);
				if (instance) {
					instance.destroy();
				}
			});
		},
		replaceAll: function(context) {
			var self = this;
			$.each(this.modules, function(moduleName, module) {
				$(module.prototype.selector, context).each(function() {
					if (this.className.indexOf('jcf-ignore') < 0) {
						self.replace(this, moduleName);
					}
				});
			});
		},
		refreshAll: function(context) {
			if (context) {
				$.each(this.modules, function(moduleName, module) {
					$(module.prototype.selector, context).each(function() {
						var instance = $(this).data(commonOptions.dataKey);
						if (instance) {
							instance.refresh();
						}
					});
				});
			} else {
				for (var i = customInstances.length - 1; i >= 0; i--) {
					customInstances[i].refresh();
				}
			}
		},
		destroyAll: function(context) {
			if (context) {
				$.each(this.modules, function(moduleName, module) {
					$(module.prototype.selector, context).each(function(index, element) {
						var instance = $(element).data(commonOptions.dataKey);
						if (instance) {
							instance.destroy();
						}
					});
				});
			} else {
				while (customInstances.length) {
					customInstances[0].destroy();
				}
			}
		}
	};

	// we need to make JCF available globally if we're in AMD environment
	if (typeof define === 'function' && define.amd) {
		window.jcf = api;
	}

	return api;
}));

/*!
 * JavaScript Custom Forms : Select Module
 *
 * Copyright 2014-2015 PSD2HTML - http://psd2html.com/jcf
 * Released under the MIT license (LICENSE.txt)
 *
 * Version: 1.2.3
 */

var jcfselect = function (jcf) {

    jcf.addModule(function ($, window) {
        'use strict';

        var module = {
            name: 'Select',
            selector: 'select',
            options: {
                element: null,
                multipleCompactStyle: false
            },
            plugins: {
                ListBox: ListBox,
                ComboBox: ComboBox,
                SelectList: SelectList
            },
            matchElement: function (element) {
                return element.is('select');
            },
            init: function () {
                this.element = $(this.options.element);
                this.createInstance();
            },
            isListBox: function () {
                return this.element.is('[size]:not([jcf-size]), [multiple]');
            },
            createInstance: function () {
                if (this.instance) {
                    this.instance.destroy();
                }
                if (this.isListBox() && !this.options.multipleCompactStyle) {
                    this.instance = new ListBox(this.options);
                } else {
                    this.instance = new ComboBox(this.options);
                }
            },
            refresh: function () {
                var typeMismatch = (this.isListBox() && this.instance instanceof ComboBox) ||
                    (!this.isListBox() && this.instance instanceof ListBox);

                if (typeMismatch) {
                    this.createInstance();
                } else {
                    this.instance.refresh();
                }
            },
            destroy: function () {
                this.instance.destroy();
            }
        };

        // combobox module
        function ComboBox(options) {
            this.options = $.extend({
                wrapNative: true,
                wrapNativeOnMobile: true,
                fakeDropInBody: true,
                useCustomScroll: true,
                flipDropToFit: true,
                maxVisibleItems: 10,
                fakeAreaStructure: '<span class="jcf-select"><span class="jcf-select-text"></span><span class="jcf-select-opener"></span></span>',
                fakeDropStructure: '<div class="jcf-select-drop"><div class="jcf-select-drop-content"></div></div>',
                optionClassPrefix: 'jcf-option-',
                selectClassPrefix: 'jcf-select-',
                dropContentSelector: '.jcf-select-drop-content',
                selectTextSelector: '.jcf-select-text',
                dropActiveClass: 'jcf-drop-active',
                flipDropClass: 'jcf-drop-flipped'
            }, options);
            this.init();
        }
        $.extend(ComboBox.prototype, {
            init: function () {
                this.initStructure();
                this.bindHandlers();
                this.attachEvents();
                this.refresh();
            },
            initStructure: function () {
                // prepare structure
                this.win = $(window);
                this.doc = $(document);
                this.realElement = $(this.options.element);
                this.fakeElement = $(this.options.fakeAreaStructure).insertAfter(this.realElement);
                this.selectTextContainer = this.fakeElement.find(this.options.selectTextSelector);
                this.selectText = $('<span></span>').appendTo(this.selectTextContainer);
                makeUnselectable(this.fakeElement);

                // copy classes from original select
                this.fakeElement.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));

                // handle compact multiple style
                if (this.realElement.prop('multiple')) {
                    this.fakeElement.addClass('jcf-compact-multiple');
                }

                // detect device type and dropdown behavior
                if (this.options.isMobileDevice && this.options.wrapNativeOnMobile && !this.options.wrapNative) {
                    this.options.wrapNative = true;
                }

                if (this.options.wrapNative) {
                    // wrap native select inside fake block
                    this.realElement.prependTo(this.fakeElement).css({
                        position: 'absolute',
                        height: '100%',
                        width: '100%'
                    }).addClass(this.options.resetAppearanceClass);
                } else {
                    // just hide native select
                    this.realElement.addClass(this.options.hiddenClass);
                    this.fakeElement.attr('title', this.realElement.attr('title'));
                    this.fakeDropTarget = this.options.fakeDropInBody ? $('body') : this.fakeElement;
                }
            },
            attachEvents: function () {
                // delayed refresh handler
                var self = this;
                this.delayedRefresh = function () {
                    setTimeout(function () {
                        self.refresh();
                        if (self.list) {
                            self.list.refresh();
                            self.list.scrollToActiveOption();
                        }
                    }, 1);
                };

                // native dropdown event handlers
                if (this.options.wrapNative) {
                    this.realElement.on({
                        focus: this.onFocus,
                        change: this.onChange,
                        click: this.onChange,
                        keydown: this.delayedRefresh
                    });
                } else {
                    // custom dropdown event handlers
                    this.realElement.on({
                        focus: this.onFocus,
                        change: this.onChange,
                        keydown: this.onKeyDown
                    });
                    this.fakeElement.on({
                        'jcf-pointerdown': this.onSelectAreaPress
                    });
                }
            },
            onKeyDown: function (e) {
                if (e.which === 13) {
                    this.toggleDropdown();
                } else if (this.dropActive) {
                    this.delayedRefresh();
                }
            },
            onChange: function () {
                this.refresh();
            },
            onFocus: function () {
                if (!this.pressedFlag || !this.focusedFlag) {
                    this.fakeElement.addClass(this.options.focusClass);
                    this.realElement.on('blur', this.onBlur);
                    this.toggleListMode(true);
                    this.focusedFlag = true;
                }

                if (this.options.onFocus && typeof this.options.onFocus === "function") {
                    this.options.onFocus();
                }
            },

            onBlur: function () {
                if (!this.pressedFlag) {
                    this.fakeElement.removeClass(this.options.focusClass);
                    this.realElement.off('blur', this.onBlur);
                    this.toggleListMode(false);
                    this.focusedFlag = false;

                    if (this.options.onBlur && typeof this.options.onBlur === "function") {
                        this.options.onBlur();
                    }
                }
            },
            onResize: function () {
                if (this.dropActive) {
                    this.hideDropdown();
                }
            },
            onSelectDropPress: function () {
                this.pressedFlag = true;
            },
            onSelectDropRelease: function (e, pointerEvent) {
                this.pressedFlag = false;
                if (pointerEvent.pointerType === 'mouse') {
                    if (!this.options.disableFocus) {
                        this.realElement.focus();
                        if (this.options.onFocus && typeof this.options.onFocus === "function") {
                            this.options.onFocus();
                        }
                    }
                }
            },
            onSelectAreaPress: function (e) {
                // skip click if drop inside fake element or real select is disabled
                var dropClickedInsideFakeElement = !this.options.fakeDropInBody && $(e.target).closest(this.dropdown).length;
                if (dropClickedInsideFakeElement || e.button > 1 || this.realElement.is(':disabled')) {
                    return;
                }

                // toggle dropdown visibility
                this.selectOpenedByEvent = e.pointerType;
                this.toggleDropdown();

                // misc handlers
                if (!this.focusedFlag) {
                    if (e.pointerType === 'mouse') {
                        if (!this.options.disableFocus) {
                            this.realElement.focus();
                            if (this.options.onFocus && typeof this.options.onFocus === "function") {
                                this.options.onFocus();
                            }
                        }
                    } else {
                        this.onFocus(e);
                    }
                }
                this.pressedFlag = true;
                this.fakeElement.addClass(this.options.pressedClass);
                this.doc.on('jcf-pointerup', this.onSelectAreaRelease);
            },
            onSelectAreaRelease: function (e) {
                if (this.focusedFlag && e.pointerType === 'mouse') {
                    if (!this.options.disableFocus) {
                        this.realElement.focus();
                    }
                }
                this.pressedFlag = false;
                this.fakeElement.removeClass(this.options.pressedClass);
                this.doc.off('jcf-pointerup', this.onSelectAreaRelease);
            },
            onOutsideClick: function (e) {
                var target = $(e.target),
                    clickedInsideSelect = target.closest(this.fakeElement).length || target.closest(this.dropdown).length;

                if (!clickedInsideSelect) {
                    this.hideDropdown();
                }
            },
            onSelect: function () {
                this.refresh();

                if (this.realElement.prop('multiple')) {
                    this.repositionDropdown();
                } else {
                    this.hideDropdown();
                }

                this.fireNativeEvent(this.realElement, 'change');
            },
            toggleListMode: function (state) {
                if (!this.options.wrapNative) {
                    if (state) {
                        // temporary change select to list to avoid appearing of native dropdown
                        this.realElement.attr({
                            size: 4,
                            'jcf-size': ''
                        });
                    } else {
                        // restore select from list mode to dropdown select
                        if (!this.options.wrapNative) {
                            this.realElement.removeAttr('size jcf-size');
                        }
                    }
                }
            },
            createDropdown: function () {
                // destroy previous dropdown if needed
                if (this.dropdown) {
                    this.list.destroy();
                    this.dropdown.remove();
                }

                // create new drop container
                this.dropdown = $(this.options.fakeDropStructure).appendTo(this.fakeDropTarget);
                this.dropdown.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));
                makeUnselectable(this.dropdown);

                // handle compact multiple style
                if (this.realElement.prop('multiple')) {
                    this.dropdown.addClass('jcf-compact-multiple');
                }

                // set initial styles for dropdown in body
                if (this.options.fakeDropInBody) {
                    this.dropdown.css({
                        position: 'absolute',
                        top: -9999
                    });
                }

                // create new select list instance
                this.list = new SelectList({
                    useHoverClass: true,
                    handleResize: false,
                    alwaysPreventMouseWheel: true,
                    maxVisibleItems: this.options.maxVisibleItems,
                    useCustomScroll: this.options.useCustomScroll,
                    holder: this.dropdown.find(this.options.dropContentSelector),
                    multipleSelectWithoutKey: this.realElement.prop('multiple'),
                    element: this.realElement
                });
                $(this.list).on({
                    select: this.onSelect,
                    press: this.onSelectDropPress,
                    release: this.onSelectDropRelease
                });
            },
            repositionDropdown: function () {
                var selectOffset = this.fakeElement.offset(),
                    fakeElementBounds = this.fakeElement[0].getBoundingClientRect(),
                    selectWidth = fakeElementBounds.width || fakeElementBounds.right - fakeElementBounds.left,
                    selectHeight = this.fakeElement.outerHeight(),
                    dropHeight = this.dropdown.css('width', selectWidth).outerHeight(),
                    winScrollTop = this.win.scrollTop(),
                    winHeight = this.win.height(),
                    calcTop, calcLeft, bodyOffset, needFlipDrop = false;

                // check flip drop position
                if (selectOffset.top + selectHeight + dropHeight > winScrollTop + winHeight && selectOffset.top - dropHeight > winScrollTop) {
                    needFlipDrop = true;
                }

                if (this.options.fakeDropInBody) {
                    bodyOffset = this.fakeDropTarget.css('position') !== 'static' ? this.fakeDropTarget.offset().top : 0;
                    if (this.options.flipDropToFit && needFlipDrop) {
                        // calculate flipped dropdown position
                        calcLeft = selectOffset.left;
                        calcTop = selectOffset.top - dropHeight - bodyOffset;
                    } else {
                        // calculate default drop position
                        calcLeft = selectOffset.left;
                        calcTop = selectOffset.top + selectHeight - bodyOffset;
                    }

                    // update drop styles
                    this.dropdown.css({
                        width: selectWidth,
                        left: calcLeft,
                        top: calcTop
                    });
                }

                // refresh flipped class
                this.dropdown.add(this.fakeElement).toggleClass(this.options.flipDropClass, this.options.flipDropToFit && needFlipDrop);
            },
            showDropdown: function () {
                // do not show empty custom dropdown
                if (!this.realElement.prop('options').length) {
                    return;
                }

                // create options list if not created
                if (!this.dropdown) {
                    this.createDropdown();
                }

                // show dropdown
                this.dropActive = true;
                this.dropdown.appendTo(this.fakeDropTarget);
                this.fakeElement.addClass(this.options.dropActiveClass);
                this.refreshSelectedText();
                this.repositionDropdown();
                this.list.setScrollTop(this.savedScrollTop);
                this.list.refresh();

                // add temporary event handlers
                this.win.on('resize', this.onResize);
                this.doc.on('jcf-pointerdown', this.onOutsideClick);
            },
            hideDropdown: function () {
                if (this.dropdown) {
                    this.savedScrollTop = this.list.getScrollTop();
                    this.fakeElement.removeClass(this.options.dropActiveClass + ' ' + this.options.flipDropClass);
                    this.dropdown.removeClass(this.options.flipDropClass).detach();
                    this.doc.off('jcf-pointerdown', this.onOutsideClick);
                    this.win.off('resize', this.onResize);
                    this.dropActive = false;
                    if (this.selectOpenedByEvent === 'touch') {
                        this.onBlur();
                    }
                }
            },
            toggleDropdown: function () {
                if (this.dropActive) {
                    this.hideDropdown();
                } else {
                    this.showDropdown();
                }
            },
            refreshSelectedText: function () {
                // redraw selected area
                var selectedIndex = this.realElement.prop('selectedIndex'),
                    selectedOption = this.realElement.prop('options')[selectedIndex],
                    selectedOptionImage = selectedOption ? selectedOption.getAttribute('data-image') : null,
                    selectedOptionText = '',
                    selectedOptionClasses,
                    self = this;

                if (this.realElement.prop('multiple')) {
                    $.each(this.realElement.prop('options'), function (index, option) {
                        if (option.selected) {
                            selectedOptionText += (selectedOptionText ? ', ' : '') + option.innerHTML;
                        }
                    });
                    if (!selectedOptionText) {
                        selectedOptionText = self.realElement.attr('placeholder') || '';
                    }
                    this.selectText.removeAttr('class').html(selectedOptionText);
                } else if (!selectedOption) {
                    if (this.selectImage) {
                        this.selectImage.hide();
                    }
                    this.selectText.removeAttr('class').empty();
                    this.currentSelectedText = '';
                } else if (this.currentSelectedText !== selectedOption.innerHTML || this.currentSelectedImage !== selectedOptionImage) {
                    selectedOptionClasses = getPrefixedClasses(selectedOption.className, this.options.optionClassPrefix);
                    this.selectText.attr('class', selectedOptionClasses).html(selectedOption.innerHTML);

                    if (selectedOptionImage) {
                        if (!this.selectImage) {
                            this.selectImage = $('<img>').prependTo(this.selectTextContainer).hide();
                        }
                        this.selectImage.attr('src', selectedOptionImage).show();
                    } else if (this.selectImage) {
                        this.selectImage.hide();
                    }

                    this.currentSelectedText = selectedOption.innerHTML;
                    this.currentSelectedImage = selectedOptionImage;
                }
            },
            refresh: function () {
                // refresh fake select visibility
                if (this.realElement.prop('style').display === 'none') {
                    this.fakeElement.hide();
                } else {
                    this.fakeElement.show();
                }

                // refresh selected text
                this.refreshSelectedText();

                // handle disabled state
                this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
            },
            destroy: function () {
                // restore structure
                if (this.options.wrapNative) {
                    this.realElement.insertBefore(this.fakeElement).css({
                        position: '',
                        height: '',
                        width: ''
                    }).removeClass(this.options.resetAppearanceClass);
                } else {
                    this.realElement.removeClass(this.options.hiddenClass);
                    if (this.realElement.is('[jcf-size]')) {
                        this.realElement.removeAttr('size jcf-size');
                    }
                }

                // removing element will also remove its event handlers
                this.fakeElement.remove();

                // remove other event handlers
                this.doc.off('jcf-pointerup', this.onSelectAreaRelease);
                this.realElement.off({
                    focus: this.onFocus
                });
            }
        });

        // listbox module
        function ListBox(options) {
            this.options = $.extend({
                wrapNative: true,
                useCustomScroll: true,
                fakeStructure: '<span class="jcf-list-box"><span class="jcf-list-wrapper"></span></span>',
                selectClassPrefix: 'jcf-select-',
                listHolder: '.jcf-list-wrapper'
            }, options);
            this.init();
        }
        $.extend(ListBox.prototype, {
            init: function () {
                this.bindHandlers();
                this.initStructure();
                this.attachEvents();
            },
            initStructure: function () {
                this.realElement = $(this.options.element);
                this.fakeElement = $(this.options.fakeStructure).insertAfter(this.realElement);
                this.listHolder = this.fakeElement.find(this.options.listHolder);
                makeUnselectable(this.fakeElement);

                // copy classes from original select
                this.fakeElement.addClass(getPrefixedClasses(this.realElement.prop('className'), this.options.selectClassPrefix));
                this.realElement.addClass(this.options.hiddenClass);

                this.list = new SelectList({
                    useCustomScroll: this.options.useCustomScroll,
                    holder: this.listHolder,
                    selectOnClick: false,
                    element: this.realElement
                });
            },
            attachEvents: function () {
                // delayed refresh handler
                var self = this;
                this.delayedRefresh = function (e) {
                    if (e && (e.which === 16 || e.ctrlKey || e.metaKey || e.altKey)) {
                        // ignore modifier keys
                        return;
                    } else {
                        clearTimeout(self.refreshTimer);
                        self.refreshTimer = setTimeout(function () {
                            self.refresh();
                            self.list.scrollToActiveOption();
                        }, 1);
                    }
                };

                // other event handlers
                this.realElement.on({
                    focus: this.onFocus,
                    click: this.delayedRefresh,
                    keydown: this.delayedRefresh
                });

                // select list event handlers
                $(this.list).on({
                    select: this.onSelect,
                    press: this.onFakeOptionsPress,
                    release: this.onFakeOptionsRelease
                });
            },
            onFakeOptionsPress: function (e, pointerEvent) {
                this.pressedFlag = true;
                if (pointerEvent.pointerType === 'mouse') {
                    if (!this.options.disableFocus) {
                        this.realElement.focus();
                    }
                }
            },
            onFakeOptionsRelease: function (e, pointerEvent) {
                this.pressedFlag = false;
                if (pointerEvent.pointerType === 'mouse') {
                    if (!this.options.disableFocus) {
                        this.realElement.focus();
                    }
                }
            },
            onSelect: function () {
                this.fireNativeEvent(this.realElement, 'change');
                this.fireNativeEvent(this.realElement, 'click');
            },
            onFocus: function () {
                if (!this.pressedFlag || !this.focusedFlag) {
                    this.fakeElement.addClass(this.options.focusClass);
                    this.realElement.on('blur', this.onBlur);
                    this.focusedFlag = true;
                }
            },
            onBlur: function () {
                if (!this.pressedFlag) {
                    this.fakeElement.removeClass(this.options.focusClass);
                    this.realElement.off('blur', this.onBlur);
                    this.focusedFlag = false;
                }
            },
            refresh: function () {
                this.fakeElement.toggleClass(this.options.disabledClass, this.realElement.is(':disabled'));
                this.list.refresh();
            },
            destroy: function () {
                this.list.destroy();
                this.realElement.insertBefore(this.fakeElement).removeClass(this.options.hiddenClass);
                this.fakeElement.remove();
            }
        });

        // options list module
        function SelectList(options) {
            this.options = $.extend({
                holder: null,
                maxVisibleItems: 10,
                selectOnClick: true,
                useHoverClass: false,
                useCustomScroll: false,
                handleResize: true,
                multipleSelectWithoutKey: false,
                alwaysPreventMouseWheel: false,
                indexAttribute: 'data-index',
                cloneClassPrefix: 'jcf-option-',
                containerStructure: '<span class="jcf-list"><span class="jcf-list-content"></span></span>',
                containerSelector: '.jcf-list-content',
                captionClass: 'jcf-optgroup-caption',
                disabledClass: 'jcf-disabled',
                optionClass: 'jcf-option',
                groupClass: 'jcf-optgroup',
                hoverClass: 'jcf-hover',
                selectedClass: 'jcf-selected',
                scrollClass: 'jcf-scroll-active'
            }, options);
            this.init();
        }
        $.extend(SelectList.prototype, {
            init: function () {
                this.initStructure();
                this.refreshSelectedClass();
                this.attachEvents();
            },
            initStructure: function () {
                this.element = $(this.options.element);
                this.indexSelector = '[' + this.options.indexAttribute + ']';
                this.container = $(this.options.containerStructure).appendTo(this.options.holder);
                this.listHolder = this.container.find(this.options.containerSelector);
                this.lastClickedIndex = this.element.prop('selectedIndex');
                this.rebuildList();

                // save current selection in multiple select
                if (this.element.prop('multiple')) {
                    this.previousSelection = this.getSelectedOptionsIndexes();
                }
            },
            attachEvents: function () {
                this.bindHandlers();
                this.listHolder.on('jcf-pointerdown', this.indexSelector, this.onItemPress);
                this.listHolder.on('jcf-pointerdown', this.onPress);

                if (this.options.useHoverClass) {
                    this.listHolder.on('jcf-pointerover', this.indexSelector, this.onHoverItem);
                }
            },
            onPress: function (e) {
                $(this).trigger('press', e);
                this.listHolder.on('jcf-pointerup', this.onRelease);
            },
            onRelease: function (e) {
                $(this).trigger('release', e);
                this.listHolder.off('jcf-pointerup', this.onRelease);
            },
            onHoverItem: function (e) {
                var hoverIndex = parseFloat(e.currentTarget.getAttribute(this.options.indexAttribute));
                this.fakeOptions.removeClass(this.options.hoverClass).eq(hoverIndex).addClass(this.options.hoverClass);
            },
            onItemPress: function (e) {
                if (e.pointerType === 'touch' || this.options.selectOnClick) {
                    // select option after "click"
                    this.tmpListOffsetTop = this.list.offset().top;
                    this.listHolder.on('jcf-pointerup', this.indexSelector, this.onItemRelease);
                } else {
                    // select option immediately
                    this.onSelectItem(e);
                }
            },
            onItemRelease: function (e) {
                // remove event handlers and temporary data
                this.listHolder.off('jcf-pointerup', this.indexSelector, this.onItemRelease);

                // simulate item selection
                if (this.tmpListOffsetTop === this.list.offset().top) {
                    this.listHolder.on('click', this.indexSelector, { savedPointerType: e.pointerType }, this.onSelectItem);
                }
                delete this.tmpListOffsetTop;
            },
            onSelectItem: function (e) {
                var clickedIndex = parseFloat(e.currentTarget.getAttribute(this.options.indexAttribute)),
                    pointerType = e.data && e.data.savedPointerType || e.pointerType || 'mouse',
                    range;

                // remove click event handler
                this.listHolder.off('click', this.indexSelector, this.onSelectItem);

                // ignore clicks on disabled options
                if (e.button > 1 || this.realOptions[clickedIndex].disabled) {
                    return;
                }

                if (this.element.prop('multiple')) {
                    if (e.metaKey || e.ctrlKey || pointerType === 'touch' || this.options.multipleSelectWithoutKey) {
                        // if CTRL/CMD pressed or touch devices - toggle selected option
                        this.realOptions[clickedIndex].selected = !this.realOptions[clickedIndex].selected;
                    } else if (e.shiftKey) {
                        // if SHIFT pressed - update selection
                        range = [this.lastClickedIndex, clickedIndex].sort(function (a, b) {
                            return a - b;
                        });
                        this.realOptions.each(function (index, option) {
                            option.selected = (index >= range[0] && index <= range[1]);
                        });
                    } else {
                        // set single selected index
                        this.element.prop('selectedIndex', clickedIndex);
                    }
                } else {
                    this.element.prop('selectedIndex', clickedIndex);
                }

                // save last clicked option
                if (!e.shiftKey) {
                    this.lastClickedIndex = clickedIndex;
                }

                // refresh classes
                this.refreshSelectedClass();

                // scroll to active item in desktop browsers
                if (pointerType === 'mouse') {
                    this.scrollToActiveOption();
                }

                // make callback when item selected
                $(this).trigger('select');
            },
            rebuildList: function () {
                // rebuild options
                var self = this,
                    rootElement = this.element[0];

                // recursively create fake options
                this.storedSelectHTML = rootElement.innerHTML;
                this.optionIndex = 0;
                this.list = $(this.createOptionsList(rootElement));
                this.listHolder.empty().append(this.list);
                this.realOptions = this.element.find('option');
                this.fakeOptions = this.list.find(this.indexSelector);
                this.fakeListItems = this.list.find('.' + this.options.captionClass + ',' + this.indexSelector);
                delete this.optionIndex;

                // detect max visible items
                var maxCount = this.options.maxVisibleItems,
                    sizeValue = this.element.prop('size');
                if (sizeValue > 1 && !this.element.is('[jcf-size]')) {
                    maxCount = sizeValue;
                }

                // handle scrollbar
                var needScrollBar = this.fakeOptions.length > maxCount;
                this.container.toggleClass(this.options.scrollClass, needScrollBar);
                if (needScrollBar) {
                    // change max-height
                    this.listHolder.css({
                        maxHeight: this.getOverflowHeight(maxCount),
                        overflow: 'auto'
                    });

                    if (this.options.useCustomScroll && jcf.modules.Scrollable) {
                        // add custom scrollbar if specified in options
                        jcf.replace(this.listHolder, 'Scrollable', {
                            handleResize: this.options.handleResize,
                            alwaysPreventMouseWheel: this.options.alwaysPreventMouseWheel
                        });
                        return;
                    }
                }

                // disable edge wheel scrolling
                if (this.options.alwaysPreventMouseWheel) {
                    this.preventWheelHandler = function (e) {
                        var currentScrollTop = self.listHolder.scrollTop(),
                            maxScrollTop = self.listHolder.prop('scrollHeight') - self.listHolder.innerHeight();

                        // check edge cases
                        if ((currentScrollTop <= 0 && e.deltaY < 0) || (currentScrollTop >= maxScrollTop && e.deltaY > 0)) {
                            e.preventDefault();
                        }
                    };
                    this.listHolder.on('jcf-mousewheel', this.preventWheelHandler);
                }
            },
            refreshSelectedClass: function () {
                var self = this,
                    selectedItem,
                    isMultiple = this.element.prop('multiple'),
                    selectedIndex = this.element.prop('selectedIndex');

                if (isMultiple) {
                    this.realOptions.each(function (index, option) {
                        self.fakeOptions.eq(index).toggleClass(self.options.selectedClass, !!option.selected);
                    });
                } else {
                    this.fakeOptions.removeClass(this.options.selectedClass + ' ' + this.options.hoverClass);
                    selectedItem = this.fakeOptions.eq(selectedIndex).addClass(this.options.selectedClass);
                    if (this.options.useHoverClass) {
                        selectedItem.addClass(this.options.hoverClass);
                    }
                }
            },
            scrollToActiveOption: function () {
                // scroll to target option
                var targetOffset = this.getActiveOptionOffset();
                if (typeof targetOffset === 'number') {
                    this.listHolder.prop('scrollTop', targetOffset);
                }
            },
            getSelectedOptionsIndexes: function () {
                var selection = [];
                this.realOptions.each(function (index, option) {
                    if (option.selected) {
                        selection.push(index);
                    }
                });
                return selection;
            },
            getChangedSelectedIndex: function () {
                var selectedIndex = this.element.prop('selectedIndex'),
                    self = this,
                    found = false,
                    targetIndex = null;

                if (this.element.prop('multiple')) {
                    // multiple selects handling
                    this.currentSelection = this.getSelectedOptionsIndexes();
                    $.each(this.currentSelection, function (index, optionIndex) {
                        if (!found && self.previousSelection.indexOf(optionIndex) < 0) {
                            if (index === 0) {
                                found = true;
                            }
                            targetIndex = optionIndex;
                        }
                    });
                    this.previousSelection = this.currentSelection;
                    return targetIndex;
                } else {
                    // single choice selects handling
                    return selectedIndex;
                }
            },
            getActiveOptionOffset: function () {
                // calc values
                var currentIndex = this.getChangedSelectedIndex();

                // selection was not changed
                if (currentIndex === null) {
                    return;
                }

                // find option and scroll to it if needed
                var dropHeight = this.listHolder.height(),
                    dropScrollTop = this.listHolder.prop('scrollTop'),
                    fakeOption = this.fakeOptions.eq(currentIndex),
                    fakeOptionOffset = fakeOption.offset().top - this.list.offset().top,
                    fakeOptionHeight = fakeOption.innerHeight();

                // scroll list
                if (fakeOptionOffset + fakeOptionHeight >= dropScrollTop + dropHeight) {
                    // scroll down (always scroll to option)
                    return fakeOptionOffset - dropHeight + fakeOptionHeight;
                } else if (fakeOptionOffset < dropScrollTop) {
                    // scroll up to option
                    return fakeOptionOffset;
                }
            },
            getOverflowHeight: function (sizeValue) {
                var item = this.fakeListItems.eq(sizeValue - 1),
                    listOffset = this.list.offset().top,
                    itemOffset = item.offset().top,
                    itemHeight = item.innerHeight();

                return itemOffset + itemHeight - listOffset;
            },
            getScrollTop: function () {
                return this.listHolder.scrollTop();
            },
            setScrollTop: function (value) {
                this.listHolder.scrollTop(value);
            },
            createOption: function (option) {
                var newOption = document.createElement('span');
                newOption.className = this.options.optionClass;
                newOption.innerHTML = option.innerHTML;
                newOption.setAttribute(this.options.indexAttribute, this.optionIndex++);

                var optionImage, optionImageSrc = option.getAttribute('data-image');
                if (optionImageSrc) {
                    optionImage = document.createElement('img');
                    optionImage.src = optionImageSrc;
                    newOption.insertBefore(optionImage, newOption.childNodes[0]);
                }
                if (option.disabled) {
                    newOption.className += ' ' + this.options.disabledClass;
                }
                if (option.className) {
                    newOption.className += ' ' + getPrefixedClasses(option.className, this.options.cloneClassPrefix);
                }
                return newOption;
            },
            createOptGroup: function (optgroup) {
                var optGroupContainer = document.createElement('span'),
                    optGroupName = optgroup.getAttribute('label'),
                    optGroupCaption, optGroupList;

                // create caption
                optGroupCaption = document.createElement('span');
                optGroupCaption.className = this.options.captionClass;
                optGroupCaption.innerHTML = optGroupName;
                optGroupContainer.appendChild(optGroupCaption);

                // create list of options
                if (optgroup.children.length) {
                    optGroupList = this.createOptionsList(optgroup);
                    optGroupContainer.appendChild(optGroupList);
                }

                optGroupContainer.className = this.options.groupClass;
                return optGroupContainer;
            },
            createOptionContainer: function () {
                var optionContainer = document.createElement('li');
                return optionContainer;
            },
            createOptionsList: function (container) {
                var self = this,
                    list = document.createElement('ul');

                $.each(container.children, function (index, currentNode) {
                    var item = self.createOptionContainer(currentNode),
                        newNode;

                    switch (currentNode.tagName.toLowerCase()) {
                        case 'option': newNode = self.createOption(currentNode); break;
                        case 'optgroup': newNode = self.createOptGroup(currentNode); break;
                    }
                    list.appendChild(item).appendChild(newNode);
                });
                return list;
            },
            refresh: function () {
                // check for select innerHTML changes
                if (this.storedSelectHTML !== this.element.prop('innerHTML')) {
                    this.rebuildList();
                }

                // refresh custom scrollbar
                var scrollInstance = jcf.getInstance(this.listHolder);
                if (scrollInstance) {
                    scrollInstance.refresh();
                }

                // refresh selectes classes
                this.refreshSelectedClass();
            },
            destroy: function () {
                this.listHolder.off('jcf-mousewheel', this.preventWheelHandler);
                this.listHolder.off('jcf-pointerdown', this.indexSelector, this.onSelectItem);
                this.listHolder.off('jcf-pointerover', this.indexSelector, this.onHoverItem);
                this.listHolder.off('jcf-pointerdown', this.onPress);
            }
        });

        // helper functions
        var getPrefixedClasses = function (className, prefixToAdd) {
            return className ? className.replace(/[\s]*([\S]+)+[\s]*/gi, prefixToAdd + '$1 ') : '';
        };
        var makeUnselectable = (function () {
            var unselectableClass = jcf.getOptions().unselectableClass;
            function preventHandler(e) {
                e.preventDefault();
            }
            return function (node) {
                node.addClass(unselectableClass).on('selectstart', preventHandler);
            };
        }());

        return module;
    });

};

define("vendor/jcf.selectModule", ["vendor/jcf"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (jcf) {
				return this.jcfselect(jcf);
			};
        ret = fn.apply(global, arguments);
        return ret || global.jcf.modules.Select;
    };
}(this)));

define(
    'devicehelpers/KoCustomBindings',
    [
        'require',
        'knockout',
        'handlers/general',
        'jquery',
        "global/UrlResolver",
        "vendor/jquery.jscrollpane",
        'vendor/jcf.selectModule',
        'vendor/jcf',
        'handlers/languageHelper'
    ],
    function (require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            $ = require('jquery'),
            jcf = require('vendor/jcf'),
            UrlResolver = require('global/UrlResolver');

        ko.bindingHandlers.showSpinner = {
            init: function () { },
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                $(element).css('position', 'relative');

                var isShow = ko.utils.unwrapObservable(valueAccessor()),
                    spinnerBox = document.getElementById("spinnerBox"),
                    parentBox;

                if (spinnerBox && spinnerBox.parentNode) {
                    parentBox = spinnerBox.parentNode;
                }
                if (isShow) {
                    if (spinnerBox) {
                        spinnerBox.parentNode.removeChild(spinnerBox);

                        if (!general.isNullOrUndefined(parentBox)) {
                            parentBox.appendChild(spinnerBox);
                        }

                        spinnerBox.style.display = "block";
                    }
                }
                else {
                    if (spinnerBox && parentBox) {
                        spinnerBox.parentNode.removeChild(spinnerBox);
                        parentBox.appendChild(spinnerBox);

                        spinnerBox.style.display = "none";
                    }
                }
            }
        };

        ko.bindingHandlers.setDialogPos = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(".setDialogPos");
                });
            },
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var value = ko.utils.unwrapObservable(valueAccessor());
                var config = {
                    dialogPosition: null,
                    parentIsCollapsed: null,
                    parentTopElement: null,
                    topOffset: 0,
                    parentLeftElement: null,
                    leftOffset: 0,
                    RTLoffset: 0
                };

                Object.assign(config, value);

                $(element).on("click.setDialogPos", function () {
                    var topPos = -1, leftPos = -1;

                    if (!config.parentIsCollapsed()) {
                        if ($(config.parentTopElement).length > 0) {
                            topPos = $(config.parentTopElement).offset().top - $("#TradingsControls").offset().top + config.topOffset;
                        }

                        if ($(config.parentLeftElement).length > 0) {
                            leftPos = $(config.parentLeftElement).offset().left - $("#TradingsControls").offset().left + config.leftOffset;
                        }
                    }

                    var position = {
                        top: topPos,
                        left: leftPos,
                        offset: config.RTLoffset
                    };

                    config.dialogPosition(position);
                });
            }
        };

        ko.bindingHandlers.dialog = {
            init: function (element, valueAccessor, allBindingsAccessor) {
                var allBindings = allBindingsAccessor(),
                    dialogModel = ko.utils.unwrapObservable(allBindings.dialogInstance),
                    options = ko.utils.unwrapObservable(valueAccessor()) || {},
                    viewToAppend = ko.utils.unwrapObservable(dialogModel.element) || false,
                    parentElement = $(viewToAppend).parent(),
                    dialogEl = $(element).find('.dialogContainer'),
                    namespaceEvent = eAppEvents.formChangedEvent + '.' + dialogModel.name;

                //prep environment
                $(document).on(namespaceEvent, function rePosition() {
                    // {} is default: { my: "center", at: "center", of: window });
                    if ($.data(element, "ui-dialog")) {
                        dialogEl.dialog("option", "position", options.position || {});
                    }
                });

                ko.utils.extend(options, {
                    open: function dialogOpenHandler() { },
                    beforeClose: function dialogCloseHandler(jQueryEvent, data) {
                        if (dialogModel) {
                            var dialogOptions = dialogModel.getOptions();

                            if (general.isNullOrUndefined(dialogOptions) && dialogOptions.preventClose && !dialogOptions.preventClose.canClose) {
                                jQueryEvent.preventDefault();
                                jQueryEvent.stopPropagation();
                                dialogOptions.preventClose.actionOnPrevent();
                            }
                            else {
                                if (jQueryEvent.keyCode === $.ui.keyCode.ESCAPE) {
                                    jQueryEvent.preventDefault();
                                    jQueryEvent.stopPropagation();
                                    setTimeout(function () { DialogViewModel.close(); }, 10);

                                    return false;
                                }
                                else {
                                    DialogViewModel.close();
                                }
                            }
                        }
                    }
                });

                // !!! append view to dialog element
                dialogEl.append(viewToAppend);

                // !!! dialog instantiation
                dialogEl.dialog(options);

                var jqDialog = dialogEl.data("uiDialog");
                $(element).data('dialogElementId', jqDialog.element.prop('id'));

                //customizing the dialog title, which could be a string or a function. 
                jqDialog._title = function handleDialogTitle(titleElement) {
                    if (typeof this.options.title === "function") {
                        var computedCustomTitle = this.options.title();

                        fixMousedownOnSelectElement(computedCustomTitle);
                        titleElement.append(computedCustomTitle);
                    }
                    else {
                        titleElement.html(this.options.title);
                    }

                    function fixMousedownOnSelectElement(el) {
                        el.on('mousedown', function (mouseDownEvent) {
                            mouseDownEvent.stopPropagation();
                        });
                    }
                };

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    $(document).off(namespaceEvent);

                    parentElement.append(viewToAppend);
                    viewToAppend = null;
                    parentElement = null;

                    dialogEl.dialog("destroy");
                    dialogEl = null;
                    dialogModel = null;
                    element = null;
                });
            },
            update: function (element, valueAccessor, allBindingsAccessor) {
                var allBindings = allBindingsAccessor(),
                    dialogModel = ko.utils.unwrapObservable(allBindings.dialogInstance),
                    timeout = ko.utils.unwrapObservable(dialogModel.openTimeout),
                    options = ko.utils.unwrapObservable(dialogModel.getOptions()) || {},
                    viewToAppend = ko.utils.unwrapObservable(dialogModel.element) || false,
                    isRtlLanguage = LanguageHelper.IsRtlLanguage(),
                    dialogEl = $('#' + $(element).data('dialogElementId')),
                    dialogParent = dialogEl.parent();

                function placeDialogAtLocationFromOptions() {
                    if (options.left && options.left > 0) {
                        var left = options.left;

                        if (isRtlLanguage) {
                            left = left - dialogParent.width() + options.offset;
                        }

                        dialogParent.position({
                            my: 'left+' + left + ' top+' + (options.top + window.pageYOffset),
                            at: 'left top',
                            of: options.appendTo
                        });
                    }

                    $("body > .ui-widget-overlay").css('position', 'fixed');
                }

                function placeDialogVerticallyCentered() {
                    dialogParent.draggable({ containment: options.appendTo });
                    dialogParent.position({ my: "center", at: "center", of: options.appendTo });
                }

                function placeDialogAtTop() {
                    var isDialogTallerThanWindow = dialogParent.height() > $(window).height();

                    dialogParent.position({ my: 'top', at: 'top', of: options.appendTo });

                    if (!options.appendTo || isDialogTallerThanWindow) {
                        dialogParent.draggable({ containment: 'document' });
                        $("body > .ui-widget-overlay").css('position', 'fixed');
                    }
                    else {
                        dialogParent.draggable({ containment: options.appendTo });
                        $(".ui-widget-overlay").css('position', 'absolute');
                    }
                }

                function ensurePositioningOptionsHaveValues() {
                    if (general.isDefinedType(options.appendTo)) {
                        return;
                    }

                    options.appendTo = "body";

                    if (general.isDefinedType(options.useDialogPosition) || general.isDefinedType(options.useDefaultPosition)) {
                        return;
                    }

                    options.useDialogPosition = true;
                }

                function ensureDialogHeaderIsVisible() {
                    if (dialogParent.position().top >= 0) {
                        return;
                    }

                    dialogParent.css('top', '0');
                    dialogParent.draggable({ containment: 'document' });
                }

                function ensureDialogContentIsVisible() {
                    $(dialogModel.element).css('visibility', 'visible');
                }

                function getTitleElement(componentHtml, titleElement) {
                    return $(componentHtml).find('#' + titleElement);
                }

                options.open = function openHandler() {
                    ensureDialogContentIsVisible();
                    ensurePositioningOptionsHaveValues();

                    if (options.useDialogPosition) {
                        placeDialogAtLocationFromOptions();
                    }
                    else if (options.useDefaultPosition) {
                        placeDialogVerticallyCentered();
                    }
                    else {
                        placeDialogAtTop();
                    }

                    ensureDialogHeaderIsVisible();

                    if (options.customTitle) {
                        dialogEl.dialog("option", "title", getTitleElement.bind(null, viewToAppend, options.customTitle));

                        var existingDialogCloseHandler = dialogEl.dialog("option", "beforeClose");

                        dialogEl.dialog("option", "beforeClose", function () {
                            $('#' + options.customTitle).remove();
                            existingDialogCloseHandler.apply(null, arguments);
                        });
                    }

                    if (!dialogEl[0].contains(document.activeElement)) {
                        //some dialogs doesn't set an active element
                        $('select:visible:first, div:visible:first', dialogEl).trigger('focus');
                    }
                }; // set options for the dialog

                setTimeout(function (dialogElement, dialogOptions) {
                    if (dialogElement.hasClass('ui-dialog-content')) {
                        dialogElement.dialog("option", dialogOptions);
                        dialogElement.dialog("open");
                    }
                }, timeout, dialogEl, options);
            }
        };

        ko.bindingHandlers.componentLoaded = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                ko.postbox.publish(valueAccessor().appEvent, valueAccessor().params);
            }
        };

        ko.bindingHandlers.alternateRows = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var allBindings = allBindingsAccessor(),
                    even = allBindings.evenClass,
                    odd = allBindings.oddClass,
                    everyRows = allBindings.everyRows || 1,
                    $el = $(element),
                    evenFormula = [];

                ko.utils.unwrapObservable(valueAccessor()); //creates the dependency

                //update odd rows
                $el.children("*").addClass(odd).removeClass(even);

                for (var i = everyRows; i > 0; i--) {
                    var el = (2 * everyRows) + "n";

                    if (i < everyRows) {
                        el += "-" + (everyRows - i);
                    }

                    evenFormula.push(":nth-child(" + el + ")");
                }

                $el.children(evenFormula.join(",")).addClass(even).removeClass(odd);
            },
            update: function (element, valueAccessor, allBindingsAccessor) {
                var allBindings = allBindingsAccessor(),
                    even = allBindings.evenClass,
                    odd = allBindings.oddClass,
                    everyRows = allBindings.everyRows || 1,
                    $el = $(element),
                    evenFormula = [];

                ko.utils.unwrapObservable(valueAccessor()); //creates the dependency

                //update odd rows
                $el.children("*").addClass(odd).removeClass(even);

                for (var i = everyRows; i > 0; i--) {
                    var el = (2 * everyRows) + "n";

                    if (i < everyRows) {
                        el += "-" + (everyRows - i);
                    }

                    evenFormula.push(":nth-child(" + el + ")");
                }

                $el.children(evenFormula.join(",")).addClass(even).removeClass(odd);
            }
        };

        ko.bindingHandlers.datepicker = {
            init: function (element, valueAccessor, allBindingsAccessor) {
                //initialize datepicker with some optional options
                var options = allBindingsAccessor().datepickeroptions || {};

                $.extend(options, {
                    dateFormat: "dd/mm/yy",
                    changeMonth: true,
                    changeYear: true
                });

                $(element).datepicker(options);

                //handle the field changing
                $(element).on("change.datepicker", function () {
                    var observable = valueAccessor(),
                        newDateValue = $(this).datepicker("getDate"),
                        newStrValue = $.datepicker.formatDate("dd/mm/yy", newDateValue);

                    observable(newStrValue);

                    $(this).blur();
                });

                //handle disposal (if KO removes by the template binding)
                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(".datepicker");
                    $(elementToDispose).datepicker("destroy");
                });
            },
            update: function (element, valueAccessor) {
                var observableValue = ko.utils.unwrapObservable(valueAccessor()),
                    observableDate = $.datepicker.parseDate("dd/mm/yy", observableValue),
                    pickerDate = $(element).datepicker("getDate");

                if (observableDate - pickerDate !== 0) {
                    $(element).datepicker("setDate", observableDate);
                }
            }
        };

        ko.bindingHandlers.datepickerbutton = {
            init: function (element, valueAccessor, allBindingsAccessor) {
                var allBindings = allBindingsAccessor(),
                    fieldID = allBindings.field || "",
                    customClass = allBindings.customClass || "",
                    customLabel = allBindings.customLabel || "",
                    field = null,
                    dateFormat = "dd/mm/yy",
                    datePickerOptions = allBindings.datepickeroptions || {};

                if (!general.isEmptyValue(fieldID)) {
                    field = document.getElementById(fieldID);
                }

                if (!field || $(field).hasClass('hasDatepicker'))
                    return; // execute only once

                var timeLastClosed = new Date(0);

                var IEDoubleDisplayFix = {
                    beforeShow: function () {
                        return new Date() - timeLastClosed >= 500;
                    },
                    onClose: function () {
                        timeLastClosed = new Date();
                    }
                };

                datePickerOptions = $.extend({
                    changeMonth: true,
                    changeYear: true,
                    dateFormat: dateFormat,
                    firstDay: 1
                }, IEDoubleDisplayFix, datePickerOptions);

                $(field).datepicker(datePickerOptions);

                $(field).datepicker("option", "onSelect", function () {
                    var observable = valueAccessor(),
                        newDateValue = $(this).datepicker("getDate"),
                        newStrValue = $.datepicker.formatDate(dateFormat, newDateValue);

                    observable(newStrValue);

                    $(this).datepicker("hide");
                });

                $(field).datepicker("option", {
                    "onChangeMonthYear": function (year, month, inst) {
                        addWrappers(inst.input, $("#ui-datepicker-div"));
                    },
                    "beforeShow": function (input, inst) {
                        addWrappers(inst.input, $("#ui-datepicker-div"));
                    },
                    "orientation": "bottom"
                });

                // Attach click event
                $(element).on("click.datepickerbutton", function () {
                    if (!$(field).datepicker("widget").is(":visible")) {
                        $(field).datepicker("show");
                    }
                });

                setTimeout(function (contentElement, uiElement) {
                    addWrappers(contentElement, uiElement);
                }, 0, element, $("#ui-datepicker-div"));

                function addWrappers(contentElements, uiElement) {

                    uiElement.removeClass("positioned");

                    setTimeout(function (item, innerUiElement) {
                        if (customClass && $("#ui-datepicker-div .content-wrapper").length === 0) {
                            innerUiElement.addClass(customClass).wrapInner($("<div>").addClass("content-wrapper"));
                        }

                        if (customLabel && $("#ui-datepicker-div label").length === 0) {
                            innerUiElement.prepend($("<label>").html(customLabel));
                        }

                        innerUiElement.wrapInner($("<div>").addClass("wrapper"));
                        innerUiElement.addClass("positioned");

                        if ($(item).offset().top >= innerUiElement.offset().top) {
                            innerUiElement.removeClass("above-input below-input").addClass("above-input");
                            $("#ui-datepicker-div .wrapper").removeClass("above-input below-input").addClass("above-input");

                        }
                        else {
                            innerUiElement.removeClass("above-input below-input").addClass("below-input");
                            $("#ui-datepicker-div .wrapper").removeClass("above-input below-input").addClass("below-input");
                        }
                    }, 0, contentElements, uiElement);
                }

                // Handle the field changings
                $(field).on("change.datepickerbutton", function () {
                    var observable = valueAccessor(),
                        newDateValue = $(this).datepicker("getDate"),
                        newStrValue = $.datepicker.formatDate(dateFormat, newDateValue);

                    observable(newStrValue);
                    $(this).blur();
                });

                //handle disposal (if KO removes by the template binding)
                ko.utils.domNodeDisposal.addDisposeCallback(field, function (elementToDispose) {
                    $(elementToDispose).off(".datepickerbutton");
                    $(field).off(".datepickerbutton");
                    $(field).datepicker("destroy");
                    field = null;
                });
            },
            update: function (element, valueAccessor, allBindingsAccessor) {
                var allBindings = allBindingsAccessor(),
                    fieldID = allBindings.field || "",
                    field = null,
                    dateFormat = "dd/mm/yy",
                    datePickerOptions = allBindings.datepickeroptions || {};

                if (!general.isEmptyValue(fieldID)) {
                    field = document.getElementById(fieldID);
                }
                //update min/max date
                $(field).datepicker(datePickerOptions);

                if (field && $(field).hasClass('hasDatepicker')) {
                    var observableValue = ko.utils.unwrapObservable(valueAccessor()),
                        pickerDate = $(field).datepicker("getDate"),
                        observableDate = observableValue && $.datepicker.parseDate(dateFormat, observableValue);

                    if (observableDate - pickerDate !== 0) {
                        $(field).datepicker("setDate", observableDate);
                    }
                }
            }
        };

        ko.bindingHandlers.slideUp = {
            init: function (element, valueAccessor) {
                var visible = ko.utils.unwrapObservable(valueAccessor());

                $(element).toggle(!visible);
            },
            update: function (element, valueAccessor, allBindingsAccessor) {
                var collapse = ko.utils.unwrapObservable(valueAccessor()),
                    allBindings = allBindingsAccessor(),
                    durationParam = allBindings.duration || "slow",
                    completedFn = (typeof allBindings.slideUpCompleted === "function") ? allBindings.slideUpCompleted : function () { },
                    duration = ko.utils.unwrapObservable(durationParam);

                if (!duration) {
                    duration = 0;
                }
                else if (duration === true) {
                    duration = 400;
                }

                if (collapse) {
                    $(element).slideUp(duration, completedFn);
                }
                else {
                    $(element).slideDown(duration, completedFn);
                }
            }
        };

        ko.bindingHandlers.loadBannerHtml = {
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var value = ko.utils.unwrapObservable(valueAccessor());

                var config = {
                    html: '',
                    applyKoBindings: false,
                    loadedHtmlHandler: function (oldContent) { return oldContent; },
                    htmlAttachedHandler: function () { }
                };

                $.extend(config, value);

                var alteredContent = config.loadedHtmlHandler(config.html);

                $(element).html(alteredContent);

                config.htmlAttachedHandler();

                if (config.applyKoBindings) {
                    //applying the bindings to the element itself reruns this binding
                    var loadedContent = $(element).children()[0];
                    ko.applyBindings($viewModelsManager, loadedContent);
                }
            }
        };

        ko.bindingHandlers.windowPopupOpen = {
            init: function (element) {
                $(element).on('click.windowPopup', function (clickEventObject) {
                    var WindowParams = "height=710px,width=1000px,scrollbars=yes,resizable=1,location=no,center=yes,titlebar=no";
                    window.open($(this).attr('href'), 'tsHelp', WindowParams);
                    return false;
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(".windowPopup");
                });
            }
        };

        ko.bindingHandlers.loadHtml = {
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var $element = $(element),
                    value = ko.utils.unwrapObservable(valueAccessor());

                var config = {
                    url: null,
                    applyKoBindings: false,
                    loadedHtmlHandler: function (oldContent) { return oldContent; },
                    htmlAttachedHandler: function () { },
                    noCache: false,
                    isStaticFile: false
                };

                $.extend(config, value);

                if (config.noCache) {
                    config.url += (config.url.indexOf('?') > -1) ? '&' : '?';
                    config.url += (new Date()).getTime();
                }

                if (config.isStaticFile === true) {
                    config.url = UrlResolver.combine(UrlResolver.getStaticFilePath(), config.url);
                }
                else {
                    config.url = UrlResolver.combine(UrlResolver.getApplicationRelativePath(), config.url);
                }

                $.get(config.url, function (content) {
                    //if response arrived after domNodeDisposal config and $element must be checked
                    if (general.isNullOrUndefined(config) || general.isNullOrUndefined($element)) {
                        return false;
                    }

                    var alteredContent = config.loadedHtmlHandler(content);

                    $element.html(alteredContent);

                    config.htmlAttachedHandler();

                    if (config.applyKoBindings) {
                        //applying the bindings to the element itself reruns this binding
                        var loadedContent = $element.children()[0];
                        ko.applyBindings($viewModelsManager, loadedContent);
                    }
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    config = null;
                    $element = null;
                });
            }
        };

        ko.bindingHandlers.appendElementWhen = {
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var options = ko.unwrap(valueAccessor()),
                    shouldAppend = ko.unwrap(options.trigger()),
                    $elementToHandle,
                    $parent;

                options = options || {};

                $elementToHandle = $(options.elementSelector);
                if (!$elementToHandle.length) {
                    return;
                }

                if (options.originalCssClass) {
                    $elementToHandle.toggleClass(options.originalCssClass, !shouldAppend);
                }

                if (options.appendedCssClass) {
                    $elementToHandle.toggleClass(options.appendedCssClass, shouldAppend);
                }

                if (shouldAppend) {
                    $parent = $elementToHandle.parent();
                    $elementToHandle = $elementToHandle.detach();
                    $elementToHandle.appendTo(element);
                    $elementToHandle.data("originalParent", $parent);
                }
                else {
                    $parent = $elementToHandle.data("originalParent");

                    if ($parent && $parent.length) {
                        $elementToHandle.removeData("originalParent");
                        $elementToHandle = $elementToHandle.detach();
                        $elementToHandle.appendTo($parent);
                    }
                }
            }
        };

        ko.bindingHandlers.toggle = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var options = valueAccessor() || {},
                    $element = $(element),
                    $targetElement = $('#' + options.targetElement),
                    subscriber = options.observable.subscribe(function (value) {
                        if (value) {
                            $element.removeClass(options.offClass).addClass(options.onClass);
                            $targetElement.show();
                        }
                        else {
                            $element.removeClass(options.onClass).addClass(options.offClass);
                            $targetElement.hide();
                        }
                    });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    if (subscriber) {
                        subscriber.dispose();
                        subscriber = null;
                    }

                    $targetElement = null;
                    $element = null;
                });
            }
        };

        ko.bindingHandlers.timedToggle = {
            init: function (element, valueAccessor) {
                var options = valueAccessor() || {},
                    oldValue,
                    subscriber = options.observable.subscribe(function (value) {
                        if (!general.isDefinedType(oldValue)) {
                            oldValue = value;
                        }

                        if (value !== oldValue && oldValue) {
                            $(element).removeClass(options.defaultClass).addClass(options.timedClass);
                            oldValue = value;

                            setTimeout(function (elementToRemove) {
                                $(elementToRemove).removeClass(options.timedClass).addClass(options.defaultClass);
                            }, options.timeout, element);
                        }
                    });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    if (subscriber) {
                        subscriber.dispose();
                        subscriber = null;
                    }

                    options = null;
                });
            }
        };

        ko.bindingHandlers.trigger = {
            init: function (element, valueAccessor) {
                var triggerFunction = ko.utils.unwrapObservable(valueAccessor());

                if (!general.isFunctionType(triggerFunction)) {
                    throw new TypeError("Please provide a function to execute when the element is triggered!");
                }

                $(element)
                    .on("click.trigger", triggerFunction)
                    .on("keypress.trigger", function (e) {
                        var enterPressed = e.which == cKeyCode.CtrlEnter || e.which == cKeyCode.Enter;

                        if (enterPressed) {
                            triggerFunction();
                        }
                    });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(".trigger");
                });
            }
        };

        ko.bindingHandlers.keypressTrigger = {
            init: function (element, valueAccessor) {
                var triggerFunction = ko.utils.unwrapObservable(valueAccessor());

                if (!general.isFunctionType(triggerFunction)) {
                    return;
                }

                $(element)
                    .on("keypress.keypressTrigger", function (e) {
                        var enterPressed = e.which == cKeyCode.CtrlEnter || e.which == cKeyCode.Enter;

                        if (enterPressed) {
                            triggerFunction();
                        }
                    });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(".keypressTrigger");
                });
            }
        };

        ko.bindingHandlers.destroyElement = {
            init: function (element, valueAccessor) {
                var removeFromDom = ko.utils.unwrapObservable(valueAccessor());

                if (removeFromDom) {
                    $(element).remove();
                }
            }
        };

        ko.bindingHandlers.draggable = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var opts = valueAccessor() || {};
                var bindings = allBindingsAccessor();
                var options = {
                    scroll: false,
                    containment: $('.alert-overlay')
                };

                if (bindings && bindings.dragStopAutoHeight) {
                    options.stop = function () {
                        if (element.style && element.style.height && element.style.height !== 'auto') {
                            element.style.height = 'auto';
                        }
                    };
                }

                options = $.extend(options, opts);
                $(element).draggable(options);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).draggable("destroy");
                });
            }
        };

        ko.bindingHandlers.toolTip = {
            init: function (element) {
                var isRtlLanguage = LanguageHelper.IsRtlLanguage();

                $(element).tooltip({
                    autoShow: false,
                    tooltipClass: "file_filter",
                    position: {
                        my: isRtlLanguage ? "right-40 center" : "left+20 center",
                        at: "right center",
                        using: function (position, feedback) {
                            $(this).css(position);
                            $("<div>")
                                .addClass("arrow")
                                .appendTo(this);
                        }
                    }
                });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).tooltip("destroy");
                });
            }
        };

        ko.bindingHandlers.fadeVisible = {
            init: function (element, valueAccessor) {
                var visible = ko.unwrap(valueAccessor());

                $(element).toggle(visible);
            },
            update: function (element, valueAccessor) {
                var visible = ko.unwrap(valueAccessor());

                if (visible) {
                    $(element).fadeIn();
                }
                else {
                    $(element).fadeOut();
                }
            }
        };

        ko.bindingHandlers.tokenReplace = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var el = $(element),
                    innerText = el.text(),
                    modifiers = "g",
                    opts = ko.utils.unwrapObservable(valueAccessor()) || {},
                    options = {
                        token: '',
                        replace: '',
                        ignoreCase: false
                    };

                $.extend(options, opts);

                if (options.ignoreCase === true) {
                    modifiers += "i";
                }

                var regex = new RegExp(general.escapeRe(options.token), modifiers);

                el.text(innerText.replace(regex, options.replace));
            },
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var el = $(element),
                    innerText = el.text(),
                    modifiers = "g",
                    opts = ko.utils.unwrapObservable(valueAccessor()) || {},
                    options = {
                        token: '',
                        replace: '',
                        ignoreCase: false
                    };

                $.extend(options, opts);

                if (options.ignoreCase === true) {
                    modifiers += "i";
                }

                var regex = new RegExp(general.escapeRe(options.token), modifiers);

                el.text(innerText.replace(regex, options.replace));
            }
        };

        ko.bindingHandlers.otmDisplay = {
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var val = ko.utils.unwrapObservable(valueAccessor());
                $(element).text(Math.round(val) + ' %');
            }
        };

        ko.bindingHandlers.jScrollPane = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    postBoxTopic = options.postBoxTopic,
                    postBoxTopicSubscriber,
                    reinitOnWindowResize = function () {
                        ko.postbox.publish(postBoxTopic);
                    };
                // set options
                options = $.extend({}, {
                    autoReinitialise: false,
                    autoReinitialiseDelay: 200,
                    verticalDragMinHeight: 20,
                    reinitialiseDelay: 150
                }, options);

                options.reinitialiseDelay = Math.max(options.reinitialiseDelay, 200);
                window.addEventListener('resize', reinitOnWindowResize);

                if (postBoxTopic) {
                    postBoxTopicSubscriber = ko.postbox.subscribe(postBoxTopic, function () {
                        setTimeout(function (el, logData) {
                            var jscroll = $(el).data('jsp');

                            if (jscroll) {
                                try {
                                    jscroll.reinitialise();
                                }
                                catch (e) {
                                    e.message = "ko.bindingHandlers.jScrollPane ko.postbox.subscribe setTimeout jscroll.reinitialise,  original message: " +
                                        e.message + JSON.stringify(logData, null, 4);

                                    throw e;
                                }
                            }
                        }, options.reinitialiseDelay, element, { postBoxTopic: postBoxTopic, options: options, page: location.href });
                    });
                }

                $(element).jScrollPane(options);

                function jscrollOnWheelHandler(wheelEvent) {
                    //from "jquery.jscrollpane.js" for unbind 
                    var mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';
                    $('.jspContainer', element).unbind(mwEvent);

                    //calculate delta?
                    var deltas = {
                        wheelDeltaX: (general.isDefinedType(wheelEvent.wheelDeltaX) ? wheelEvent.wheelDeltaX : wheelEvent.deltaX) * $.fn.jScrollPane.defaults.mouseWheelSpeed,
                        wheelDeltaY: (general.isDefinedType(wheelEvent.wheelDeltaY) ? -wheelEvent.wheelDeltaY : wheelEvent.deltaY) * $.fn.jScrollPane.defaults.mouseWheelSpeed
                    };

                    $(element).data('jsp').scrollBy(deltas.wheelDeltaX, deltas.wheelDeltaY, false);
                    wheelEvent.preventDefault();
                }

                element.querySelector('.jspContainer').addEventListener('wheel', jscrollOnWheelHandler,
                    Browser.isPassiveEventListenersSupported() ? { capture: true, passive: false } : true);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    window.removeEventListener('resize', reinitOnWindowResize);
                    if (postBoxTopicSubscriber) {
                        postBoxTopicSubscriber.dispose();
                        postBoxTopicSubscriber = null;
                    }

                    elementToDispose.querySelector('.jspContainer').removeEventListener('wheel', jscrollOnWheelHandler,
                        Browser.isPassiveEventListenersSupported() ? { capture: true, passive: false } : true);

                    var jscroll = $(elementToDispose).data('jsp');

                    if (jscroll) {
                        jscroll.destroy();
                    }

                    element = null;
                });
            },
            update: function (element, valueAccessor) {
                var options = valueAccessor();
                if (options.postBoxTopic) {
                    ko.postbox.publish(options.postBoxTopic);
                }
            }
        };

        ko.bindingHandlers.scrollWithFixedhead = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    targetId = $("#" + options.targetElement),
                    customWidth = targetId.width() - 16,
                    existingCssClasses = targetId.attr("class");

                if (options.showIfMoreThan && options.length <= options.showIfMoreThan) {
                    return;
                }

                targetId.find("th").each(function () {
                    $(this).css({ "width": $(this).outerWidth() + "px" });
                });

                var clone = targetId
                    .find("thead")
                    .clone()
                    .addClass("static"),

                    headTemplate =
                        "<div class='clone-wrapper'>" +
                        "<table style='width: " + customWidth + "px' class='" + existingCssClasses + " clone'>" +
                        "<thead>" +
                        clone.html() +
                        "</thead>" +
                        "</table>" +
                        "</div>";

                $(element).prepend(headTemplate);

                setTimeout(function () {
                    $(targetId).find("thead").remove();
                }, 50);


                setTimeout(function (elementToScroll) {
                    $(elementToScroll).find(".scroll").jScrollPane({
                        showArrows: true
                    });
                }, 0, element);

                function jscrollOnWheelHandler(wheelEvent) {
                    //from "jquery.jscrollpane.js" for unbind 
                    var mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';
                    $('.jspContainer', element).unbind(mwEvent);

                    //calculate delta?
                    var deltas = {
                        wheelDeltaX: (general.isDefinedType(wheelEvent.wheelDeltaX) ? wheelEvent.wheelDeltaX : wheelEvent.deltaX) * $.fn.jScrollPane.defaults.mouseWheelSpeed,
                        wheelDeltaY: (general.isDefinedType(wheelEvent.wheelDeltaY) ? -wheelEvent.wheelDeltaY : wheelEvent.deltaY) * $.fn.jScrollPane.defaults.mouseWheelSpeed
                    }

                    $('.scroll', element).data('jsp').scrollBy(deltas.wheelDeltaX, deltas.wheelDeltaY, false);
                    wheelEvent.preventDefault();
                }

                setTimeout(function (elementToScroll) {
                    elementToScroll.querySelector('.jspContainer').addEventListener('wheel', jscrollOnWheelHandler,
                        Browser.isPassiveEventListenersSupported() ? { capture: true, passive: false } : true);
                }, 0, element);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    elementToDispose.querySelector('.jspContainer').removeEventListener('wheel', jscrollOnWheelHandler,
                        Browser.isPassiveEventListenersSupported() ? { capture: true, passive: false } : true);

                    var jscroll = $('.scroll', elementToDispose).data("jsp");
                    if (jscroll) {
                        jscroll.destroy();
                    }
                });
            }
        };

        ko.bindingHandlers.ddDropdown = {
            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var params = valueAccessor();
                var el = $(element);

                if (params.isInitDDdropdown) {
                    el.msDropdown({
                        roundedBorder: false,
                        height: 300,
                        zIndex: 99999,
                        roundedCorner: false
                    });
                }
                else {
                    var oDropdown = el.msDropdown().data("dd");
                    oDropdown.destroy();
                }
            }
        };

        ko.bindingHandlers.gridHeightCalculator = {
            init: function (element, bindingParams) {
                var params = bindingParams();
                $(element).css({
                    height: params.rowCount * params.rowHeight + 'px',
                    'background-color': 'rgba(0, 0, 0, 0)'
                });
            }
        };

        ko.bindingHandlers.tabs = {
            init: function (element) {
                $(element).find('.tabs').tabs();

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).find('.tabs').tabs("destroy");
                });
            }
        };

        ko.bindingHandlers.resetPaymentDiv = {
            update: function (element, valueAccessor) {
                var observable = valueAccessor();

                if (!observable() && observable() !== 0) {
                    return;
                }

                if ($('#concretePayments').length)
                    $('#paymentTypesContainer').appendTo("#concretePayments");
            }
        };

        ko.bindingHandlers.paymentDivWithIntercalation = {
            init: function (element, valueAccessor) {
                var options = valueAccessor();
                if (!ko.toJS(options.missingInfo)) {
                    $('#paymentTypesContainer').hide();
                }
            },
            update: function (element, valueAccessor) {
                var options = valueAccessor();
                var disableAutoScrolling = ko.utils.unwrapObservable(options.disableAutoScrolling);

                if (!options.payment()) {
                    $('#paymentTypesContainer').hide();

                    if (!disableAutoScrolling &&
                        ($("#concretePayments div.card-wrap:visible").length > 0)) {
                        window.scrollTo(0, $('#concretePayments div.card-wrap:visible').last().offset().top);
                    }

                    return;
                }

                var divId = options.getPaymentId(options.payment);
                var top = $('#' + divId).offset().top;
                var lastDivOnRow = null;

                $('#concretePayments div.card-wrap:visible')
                    .each(function (index, div) {
                        var currentDiv = $(div);
                        if (currentDiv.offset().top === top) {
                            lastDivOnRow = currentDiv;
                        }
                    });

                if (lastDivOnRow) {
                    lastDivOnRow.after($('#paymentTypesContainer'));
                }

                $('#paymentTypesContainer').show();

                if (!disableAutoScrolling) {
                    window.scrollTo(0, top);
                }
            }
        };

        ko.bindingHandlers.customSelect = {
            init: function (element, valueAccessor, allBindingsAccessor) {
                var $element = $(element),
                    options = ko.utils.unwrapObservable(valueAccessor()) || {},
                    observableValue = allBindingsAccessor().value,
                    jcfOptions = allBindingsAccessor().customSelectOptions || {},
                    onReadySubscriber,
                    observableValueSubscriber,
                    disableSubscriber;

                var childrenCompleteSubscriber = ko.bindingEvent.subscribe(element, 'childrenComplete', function () {
                    jcf.refresh($element);
                });

                if (jcfOptions.refreshWhenObservableValueChanges &&
                    observableValue &&
                    ko.isObservable(observableValue)) {
                    observableValueSubscriber = observableValue.subscribe(function () {
                        setTimeout(function () {
                            jcf.refresh($element);
                        }, 0);
                    });
                }

                if (options.onReady && ko.isObservable(options.onReady)) {
                    onReadySubscriber = options.onReady.subscribe(function (isRendered) {
                        if (isRendered) {
                            jcf.refresh($element);
                        }
                    });
                }

                jcf.replace($element, "Select", jcfOptions);

                var allBindings = allBindingsAccessor() || {};

                if (allBindings.disable && ko.isObservable(allBindings.disable)) {
                    disableSubscriber = allBindings.disable.subscribe(function () {
                        jcf.refresh($element);
                    });
                }

                ko.utils.domNodeDisposal.addDisposeCallback(element,
                    function (elementToDispose) {
                        if (onReadySubscriber) {
                            onReadySubscriber.dispose();
                            onReadySubscriber = null;
                        }

                        if (observableValueSubscriber) {
                            observableValueSubscriber.dispose();
                            observableValueSubscriber = null;
                        }

                        if (disableSubscriber) {
                            disableSubscriber.dispose();
                            disableSubscriber = null;
                        }

                        if (childrenCompleteSubscriber) {
                            childrenCompleteSubscriber.dispose();
                            childrenCompleteSubscriber = null;
                        }

                        jcf.destroy($(elementToDispose));
                        $element = null;
                    }
                );
            }
        };

        ko.bindingHandlers.nonRtlOptions = {
            init: function (element) {
                var isRtlLanguage = LanguageHelper.IsRtlLanguage(),
                    options = element.options,
                    shouldSetToLtr = isRtlLanguage && element.options && element.options.length;

                if (!shouldSetToLtr) {
                    return;
                }

                for (var i = 0; i < options.length; i++) {
                    var option = options[i];

                    if (option.text && !option.text.isRtlText()) {
                        option.innerHTML = '<span class="ltr">' + option.innerHTML + '</span>';
                    }
                }
            }
        };

        ko.bindingHandlers.dealSlipToggle = {
            init: function (element, valueAccessor) {
                var options = valueAccessor(),
                    trakingEventName = options.trakingEventName;

                var isFullScreenSubscriber = options.isFullScreen.subscribe(function (isFullScreen) {
                    var $body = $(document.body),
                        $chartContainer = $(element).closest('.advinion-chart').length > 0 && $(element).closest('.advinion-chart').is(':visible')
                            ? $(element).closest('.advinion-chart')
                            : $(element).closest('.deal-slip');

                    $(document.body).off('keydown.dealSlipToggle');
                    $chartContainer.toggleClass('fullscreen').toggleClass('expanded');
                    $body.toggleClass('chartpage-fullscreen');

                    if (isFullScreen) {
                        $(document.body).on('keydown.dealSlipToggle', function (event) {
                            if (event.keyCode !== $.ui.keyCode.ESCAPE) {
                                return;
                            }

                            if (options.isFullScreen()) {
                                HistoryManager.Back();

                                event.preventDefault();
                                event.stopPropagation();
                            }
                        });
                    }
                    ko.postbox.publish(trakingEventName, { element: isFullScreen ? 'expand-button' : 'collapse-button' });
                }, options);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    $(element).closest('.deal-slip').off('.dealSlipToggle');
                    $(document.body).keydown = options.keydownHandler;
                    $(document.body).off('keydown.dealSlipToggle');

                    if (isFullScreenSubscriber) {
                        isFullScreenSubscriber.dispose();
                        isFullScreenSubscriber = null;
                    }
                });
            }
        };

        ko.bindingHandlers.createChartUsingCanvas = {
            update: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    risePercent = options.risePercent,
                    fallPercent = options.fallPercent,
                    isDisable = options.isDisable,
                    isRtlLanguage = LanguageHelper.IsRtlLanguage();

                var context = element.getContext('2d');
                context.clearRect(0, 0, element.width, element.height);

                var radius = 75,
                    lineWidth = 35,
                    x = (isRtlLanguage ? 1 : 0) * (lineWidth + radius),
                    y = element.height / 2,
                    startAngleRise = isRtlLanguage ? 0.5 * Math.PI : 1.5 * Math.PI,
                    endAngleRise = isRtlLanguage ? (0.5 + fallPercent) * Math.PI : (1.5 + risePercent) * Math.PI,
                    counterClockwise = false;

                context.beginPath();
                context.arc(x, y, radius, startAngleRise, endAngleRise, counterClockwise);
                context.lineWidth = lineWidth;
                context.strokeStyle = isDisable ? '#ccc' : isRtlLanguage ? 'red' : 'green';
                context.stroke();

                var startAngleFall = endAngleRise;
                var endAngleFall = isRtlLanguage ? 1.5 * Math.PI : 0.5 * Math.PI;

                context.beginPath();
                context.arc(x, y, radius, startAngleFall, endAngleFall, counterClockwise);
                context.lineWidth = lineWidth;
                context.strokeStyle = isDisable ? '#ccc' : isRtlLanguage ? '#4dac4c' : '#ec4443';
                context.stroke();
            }
        };

        ko.bindingHandlers.triggerEventOnWindowResize = {
            init: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    lastWidth = 0,
                    lastHeight = 0;

                function resizeHandler(targetElement) {
                    var trigger = false,
                        newWidth = $(targetElement).width(),
                        newHeight = $(targetElement).height();

                    if (lastWidth !== newWidth) {
                        lastWidth = newWidth;
                        trigger = true;
                    }

                    if (lastHeight !== newHeight) {
                        lastHeight = newHeight;
                        trigger = true;
                    }

                    if (trigger) {
                        ko.postbox.publish(options.eventName, { 'width': newWidth, 'height': newHeight });
                    }
                }

                $(window).on("resize.triggerEventOnWindowResize", resizeHandler.bind(window, element));

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    $(window).off("resize.triggerEventOnWindowResize", resizeHandler);
                });
            }
        };

        ko.bindingHandlers.toggleElement = {
            update: function (element, valueAccessor) {
                var collapse = ko.utils.unwrapObservable(valueAccessor());
                if (collapse)
                    $(element).hide();
                else
                    $(element).show();
            }
        };

        ko.bindingHandlers.tileLayoutSelector = {
            update: function (element, valueAccessor) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    clickEventKey = 'click.tileLayoutSelector.' + (options.id || '0'),
                    layoutExpandedSubscriber;

                if (!ko.isObservable(options.layoutExpanded)) {
                    return;
                }

                layoutExpandedSubscriber = options.layoutExpanded.subscribe(function (isExpanded) {
                    if (isExpanded) {
                        $(document).bind(clickEventKey, helpForSelfClose);
                    }
                    else {
                        $(document).unbind(clickEventKey);
                    }
                });

                function helpForSelfClose() {
                    if (options.layoutExpanded()) {
                        options.layoutExpanded(false);
                        $(document).unbind(clickEventKey);
                    }
                }

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    if (layoutExpandedSubscriber && general.isFunctionType(layoutExpandedSubscriber.dispose)) {
                        layoutExpandedSubscriber.dispose();
                        layoutExpandedSubscriber = null;
                    }

                    $(document).unbind(clickEventKey);
                });
            }
        };

        ko.bindingHandlers.addSpanToLastWord = {
            init: function (element) {
                var html = $(element).html();
                var text = $(element).text().trim();
                var lastWord = text.substring(text.lastIndexOf(" ") + 1);
                var processedText = '<span class="inline-block">' + lastWord;

                html = html.replace(lastWord, processedText) + '</span>';
                $(element).html(html);
            }
        };

        ko.bindingHandlers.disableEnterKey = {
            init: function (element) {
                var eventName = 'keypress.' + $(element).attr('id');

                function preventEnterKeypress(event) {
                    if (event.keyCode === $.ui.keyCode.ENTER) {
                        event.preventDefault();
                    }
                }

                $(element).on(eventName, preventEnterKeypress);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(eventName);
                });
            }
        };

        ko.bindingHandlers.hoverOnClick = {
            init: function (element) {

                $(element)
                    .on("touchstart.hoverOnClick", function () {
                        $(this).trigger("click");
                    });

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    $(elementToDispose).off(".hoverOnClick");
                });
            }
        };

        ko.bindingHandlers.accordion = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var allBindings = allBindingsAccessor();

                function closeAccordionSection() {
                    $('.accordion-section').removeClass('active');
                    $('.accordion-section-content').slideUp(300).removeClass('open');
                }

                $(element).click(function (e) {
                    // Grab current anchor value
                    var currentAttrValue = $(this).attr('for');

                    if ($(this).is('.active')) {
                        closeAccordionSection();
                    }
                    else {
                        closeAccordionSection();

                        ko.postbox.publish(allBindings.openEventName, ko.dataFor(this.parentElement.parentElement));

                        // Add active class to section title
                        $(this).addClass('active');
                        // Open up the hidden content panel
                        $(element).find('#' + currentAttrValue).slideDown(300).addClass('open');
                    }

                    e.preventDefault();
                });
            }
        };

        ko.bindingHandlers.menu = {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var options = ko.utils.unwrapObservable(valueAccessor()),
                    itemCss = options.css;

                function removeSelection() {
                    $('.' + itemCss).removeClass('activeMenu');
                }

                $(element).on('click', function (e) {
                    removeSelection();

                    if (!$(this).is('.activeMenu')) {
                        $(this).addClass('activeMenu');
                    }

                    e.preventDefault();
                });
            }
        };

        ko.bindingHandlers.adjustHcContainer = {
            init: function (element, va) {
                var options = ko.utils.unwrapObservable(va()),
                    offset = options.offset;

                var adjustOnScroll = function () {
                    var referenceValue;

                    if (!options.visible()) {
                        return;
                    }

                    if (window.pageYOffset == 0) {
                        element.style.height = '';
                        element.style.top = '';
                    }
                    else {
                        referenceValue = window.pageYOffset <= offset ? window.pageYOffset : offset;
                        element.style.top = (offset - referenceValue) + 'px';
                        element.style.height = "calc(100% - " + (offset - referenceValue) + "px)";
                    }
                };

                var adjustOnResize = function () {
                    if (options.visible() && window.emilyScrollContainer &&
                        general.isFunctionType(window.emilyScrollContainer)) {
                        window.emilyScrollContainer();
                    }
                };

                window.addEventListener('scroll', adjustOnScroll);
                window.addEventListener('resize', adjustOnResize);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    window.removeEventListener('scroll', adjustOnScroll);
                    window.removeEventListener('resize', adjustOnResize);
                });
            }
        };

        ko.bindingHandlers.loadOdealsOnScroll = {
            init: function (element, valueAccessor) {
                var opts = ko.utils.unwrapObservable(valueAccessor());

                var currentRenders = opts.model.CurrentRenders,
                    lazyLoadDealsData = function () {
                        var allLoaded = opts.model.LastDealPosition() === (opts.model.DealsList().length - 1);

                        if (!allLoaded) {
                            currentRenders(currentRenders() + 1);
                        }
                    };

                var callOnScroll = function () {
                    if (!element.getClientRects()[0]) {
                        return;
                    }

                    var elTop = element.getClientRects()[0].top,
                        elHeight = element.getClientRects()[0].height;
                    var diff = elTop + elHeight < window.innerHeight;

                    if (diff && !opts.model.IsRenderingData()) {
                        lazyLoadDealsData();
                    }
                };

                window.addEventListener('scroll', callOnScroll);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    window.removeEventListener('scroll', callOnScroll);
                });
            }
        };

        ko.bindingHandlers.dealSlipCenter = {
            init: function (element, va) {
                var opts = ko.utils.unwrapObservable(va()),
                    dialogEl = $('.' + opts.elementClass),
                    to,
                    flagSubscribe,
                    toDelay = 0,
                    centerSlip = function () {
                        dialogEl.center();
                    },
                    centerSlipDelay = function () {
                        if (to) {
                            clearTimeout(to);
                        }
                        to = setTimeout(function () {
                            dialogEl.center();
                        }, toDelay);
                    }, 
                    recenter = opts.recenterWithDelay ? centerSlipDelay : centerSlip;

                if (opts.chartStationPage) {
                    return;
                }

                recenter();
                if (opts.flag) {

                    flagSubscribe = opts.flag.subscribe(recenter);
                }
                window.addEventListener('resize', recenter);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function () {
                    if (flagSubscribe) {
                        flagSubscribe.dispose();
                        flagSubscribe = null;
                    }
                    clearTimeout(to);
                    window.removeEventListener('resize', recenter);
                });
            }
        };
    }
);

define('helpers/CustomKOBindings/PrintBinding',
    [
        'require',
        'knockout',
        'managers/PrintExportManager'
    ],
    function (require) {
        var ko = require('knockout'),
            printExportManager = require('managers/PrintExportManager');

        // will add to element class "cssClass" when is in process of print
        ko.bindingHandlers.printing = {
            init: function (element) {
                var cssClass = 'fx-is-printing';

                function addRemovePrintClass(isProcessing) {
                    if (isProcessing) {
                        element.classList.add(cssClass);
                    } else {
                        element.classList.remove(cssClass);
                    }
                }

                var subscriber = printExportManager.IsPrintingNow.subscribe(addRemovePrintClass);

                ko.utils.domNodeDisposal.addDisposeCallback(element, function (elementToDispose) {
                    if (subscriber) {
                        subscriber.dispose();
                    }
                });
            }
        }
    });
define("trackingIntExt/TrackingData", [
	"require",
	"knockout",
	"handlers/general",
	"initdatamanagers/Customer",
	"devicemanagers/StatesManager",
	"modules/systeminfo",
	"JSONHelper",
	"handlers/Cookie",
	"global/apiIM",
	"handlers/Logger",
	"tracking/TrackingCommonData",
], function (require) {
	var ko = require("knockout"),
		general = require("handlers/general"),
		customer = require("initdatamanagers/Customer"),
		statesManager = require("devicemanagers/StatesManager"),
		systemInfo = require("modules/systeminfo"),
		JSONHelper = require("JSONHelper"),
		cookie = require("handlers/Cookie"),
		apiIM = require("global/apiIM"),
		logger = require("handlers/Logger"),
		TrackingCommonData = require("tracking/TrackingCommonData"),
		properties = {},
		nonTrackingProperties = {};

	function init() {
		properties = TrackingCommonData(FxNet.SessionStorage);
		updateStaticData();

		var cookieTracking = cookie.ReadCookie("TrackingData");

		if (!general.isNullOrUndefined(cookieTracking)) {
			var trackingData = JSON.parse(cookieTracking);

			Object.assign(properties, trackingData);
		}
	}

	function getProperties() {
		updateRealTimeData();
		return properties;
	}

	function getNonTrackingProperties() {
		return nonTrackingProperties;
	}

	function updateStaticData() {
		var countriesCollection = systemInfo.get("countries");

		properties.AccountNumber = customer.prop.accountNumber;
		properties.Broker = customer.prop.brokerName;
		properties.AccountType = customer.prop.customerType === eCustomerType.TradingBonus ? "Practice" : "Real";

		properties.SAProcess = customer.prop.SAProcess;
		properties.Serial = customer.prop.serial === 0 ? null : customer.prop.serial;
		properties.Country = countriesCollection[customer.prop.countryID];

		properties.GroupName = customer.prop.abTestings.groupsNames;
		properties.TestName = customer.prop.abTestings.testsNames;
	}

	function updateRealTimeData() {
		properties.AML = getAMLStatusName();

		properties.Currency = customer.prop.selectedCcyName();
		properties.FolderType = mapFolderTypeData(
			statesManager.States.FolderTypeId(),
			customer.prop.isLive,
			customer.prop.isPending
		);
	}

	function getErrorTrackingData() {
		var messageObj = {
			Domain: window.location.host,
			Broker: properties.Broker,
			Language: CookieHandler.ReadCookie("Language"),
			Country: properties.Country,
			AmlStatus: properties.AML,
			Browser: properties.Browser,
			OperatingSystem: properties.OS,
			ResolutionScreen: properties.ResolutionScreen,
			OsVersion: properties.OSVersion,
			BrowserVersion: properties.BrowserVersion,
			Device: properties.Device,
			TrackingSessionId: properties.TrackingSessionId,
		};

		return messageObj;
	}

	function updateScmmData() {
		customer.InitialScmmData(dataLoadCompleteFromScmm);
	}

	function dataLoadCompleteFromScmm(scmmResponse) {
		var scmmDataArray = JSONHelper.STR2JSON("TUserTracking.dataLoadCompleteFromScmm", scmmResponse);

		var scmmData = scmmDataArray[0];

		if (scmmData) {
			updateNonTrackingProperties(scmmData);
			removeObsoleteProperties(scmmData);
			Object.assign(properties, scmmData);
		} else {
			logger.warn("Internal/TrackingData", "SCMM data is empty");
		}

		ko.postbox.publish("scmm-data-loaded", true);
	}

	function updateNonTrackingProperties(scmmData) {
		nonTrackingProperties.FolderName = scmmData.FolderName;
		nonTrackingProperties.RetentionPerson = scmmData.RetentionPerson;
		nonTrackingProperties.RetentionEmail = scmmData.RetentionEmail;
		nonTrackingProperties.PotentialValue = scmmData.PotentialValue;
		nonTrackingProperties.SiteTriggerName = scmmData.SiteTriggerName;
	}

	function removeObsoleteProperties(scmmData) {
		if (general.isNullOrUndefined(scmmData)) {
			return;
		}

		delete scmmData.LastDepositDate;
		delete scmmData.LastDealDate;
		delete scmmData.VolumeCategory;
		delete scmmData.DepositCategory;
		delete scmmData.FolderName;
		delete scmmData.RetentionPerson;
		delete scmmData.RetentionEmail;
		delete scmmData.PotentialValue;
		delete scmmData.SiteTriggerName;
		delete scmmData.ActualDealType;
		delete scmmData.TradedCurrencies;
		delete scmmData.TradedMetals;
		delete scmmData.TradedShares;
		delete scmmData.TradedIndices;
		delete scmmData.TradedCommodities;
	}

	function getAMLStatusName() {
		var statusId = statesManager.States.AmlStatus();

		for (var prop in eAMLStatus) {
			if (eAMLStatus.hasOwnProperty(prop) && eAMLStatus[prop] == statusId) {
				return prop.toString();
			}
		}

		return statusId;
	}

	function incrementDealsNumber() {
		if (!properties.hasOwnProperty("NumberOfDeals")) {
			properties.NumberOfDeals = 0;
			return;
		}

		properties.NumberOfDeals = Number(properties.NumberOfDeals) + 1;
	}

	function incrementDepositsNumber() {
		if (!properties.hasOwnProperty("NumberOfDeposits")) {
			properties.NumberOfDeposits = 0;
			return;
		}

		properties.NumberOfDeposits = Number(properties.NumberOfDeposits) + 1;
	}

	function mapFolderTypeData(folderTypeId, isLive, isPending) {
		switch (folderTypeId) {
			case 0:
				return "None";

			case 1:
				return "Other";

			case 2: {
				if (isLive) {
					return "Live";
				}

				if (isPending) {
					return "Pending";
				}

				return "Other";
			}

			case 3:
				return "Other";

			case 4:
				return "Nostro";

			case 5:
				return "PTA";

			case 6:
				return "DebitFraud";

			case 9:
				return "DemoGame";
		}

		return "Other";
	}

	function updateAccountStatus(value) {
		properties.AccountStatus = Object.keys(eUserStatus).find(function (key) {
			return eUserStatus[key] === value;
		});
	}

	return {
		init: init,
		getProperties: getProperties,
		getNonTrackingProperties: getNonTrackingProperties,
		incrementDealsNumber: incrementDealsNumber,
		incrementDepositsNumber: incrementDepositsNumber,
		updateScmmData: updateScmmData,
		getErrorTrackingData: getErrorTrackingData,
		updateAccountStatus: updateAccountStatus,
	};
});

/*!
 * Globalize
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

(function( window, undefined ) {

var Globalize,
	// private variables
	regexHex,
	regexInfinity,
	regexParseFloat,
	regexTrim,
	// private JavaScript utility functions
	arrayIndexOf,
	endsWith,
	extend,
	isArray,
	isFunction,
	isObject,
	startsWith,
	trim,
	truncate,
	zeroPad,
	// private Globalization utility functions
	appendPreOrPostMatch,
	expandFormat,
	formatDate,
	formatNumber,
	getTokenRegExp,
	getEra,
	getEraYear,
	parseExact,
	parseNegativePattern;

// Global variable (Globalize) or CommonJS module (globalize)
Globalize = function( cultureSelector ) {
	return new Globalize.prototype.init( cultureSelector );
};

if ( typeof require !== "undefined" &&
	typeof exports !== "undefined" &&
	typeof module !== "undefined" ) {
	// Assume CommonJS
	module.exports = Globalize;
} else {
	// Export as global variable
	window.Globalize = Globalize;
}

Globalize.cultures = {};

Globalize.prototype = {
	constructor: Globalize,
	init: function( cultureSelector ) {
		this.cultures = Globalize.cultures;
		this.cultureSelector = cultureSelector;

		return this;
	}
};
Globalize.prototype.init.prototype = Globalize.prototype;

// 1. When defining a culture, all fields are required except the ones stated as optional.
// 2. Each culture should have a ".calendars" object with at least one calendar named "standard"
//    which serves as the default calendar in use by that culture.
// 3. Each culture should have a ".calendar" object which is the current calendar being used,
//    it may be dynamically changed at any time to one of the calendars in ".calendars".
Globalize.cultures[ "default" ] = {
	// A unique name for the culture in the form <language code>-<country/region code>
	name: "en",
	// the name of the culture in the english language
	englishName: "English",
	// the name of the culture in its own language
	nativeName: "English",
	// whether the culture uses right-to-left text
	isRTL: false,
	// "language" is used for so-called "specific" cultures.
	// For example, the culture "es-CL" means "Spanish, in Chili".
	// It represents the Spanish-speaking culture as it is in Chili,
	// which might have different formatting rules or even translations
	// than Spanish in Spain. A "neutral" culture is one that is not
	// specific to a region. For example, the culture "es" is the generic
	// Spanish culture, which may be a more generalized version of the language
	// that may or may not be what a specific culture expects.
	// For a specific culture like "es-CL", the "language" field refers to the
	// neutral, generic culture information for the language it is using.
	// This is not always a simple matter of the string before the dash.
	// For example, the "zh-Hans" culture is netural (Simplified Chinese).
	// And the "zh-SG" culture is Simplified Chinese in Singapore, whose lanugage
	// field is "zh-CHS", not "zh".
	// This field should be used to navigate from a specific culture to it's
	// more general, neutral culture. If a culture is already as general as it
	// can get, the language may refer to itself.
	language: "en",
	// numberFormat defines general number formatting rules, like the digits in
	// each grouping, the group separator, and how negative numbers are displayed.
	numberFormat: {
		// [negativePattern]
		// Note, numberFormat.pattern has no "positivePattern" unlike percent and currency,
		// but is still defined as an array for consistency with them.
		//   negativePattern: one of "(n)|-n|- n|n-|n -"
		pattern: [ "-n" ],
		// number of decimal places normally shown
		decimals: 2,
		// string that separates number groups, as in 1,000,000
		",": ",",
		// string that separates a number from the fractional portion, as in 1.99
		".": ".",
		// array of numbers indicating the size of each number group.
		// TODO: more detailed description and example
		groupSizes: [ 3 ],
		// symbol used for positive numbers
		"+": "+",
		// symbol used for negative numbers
		"-": "-",
		// symbol used for NaN (Not-A-Number)
		"NaN": "NaN",
		// symbol used for Negative Infinity
		negativeInfinity: "-Infinity",
		// symbol used for Positive Infinity
		positiveInfinity: "Infinity",
		percent: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %"
			//   positivePattern: one of "n %|n%|%n|% n"
			pattern: [ "-n %", "n %" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent a percentage
			symbol: "%"
		},
		currency: {
			// [negativePattern, positivePattern]
			//   negativePattern: one of "($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)"
			//   positivePattern: one of "$n|n$|$ n|n $"
			pattern: [ "($n)", "$n" ],
			// number of decimal places normally shown
			decimals: 2,
			// array of numbers indicating the size of each number group.
			// TODO: more detailed description and example
			groupSizes: [ 3 ],
			// string that separates number groups, as in 1,000,000
			",": ",",
			// string that separates a number from the fractional portion, as in 1.99
			".": ".",
			// symbol used to represent currency
			symbol: "$"
		}
	},
	// calendars defines all the possible calendars used by this culture.
	// There should be at least one defined with name "standard", and is the default
	// calendar used by the culture.
	// A calendar contains information about how dates are formatted, information about
	// the calendar's eras, a standard set of the date formats,
	// translations for day and month names, and if the calendar is not based on the Gregorian
	// calendar, conversion functions to and from the Gregorian calendar.
	calendars: {
		standard: {
			// name that identifies the type of calendar this is
			name: "Gregorian_USEnglish",
			// separator of parts of a date (e.g. "/" in 11/05/1955)
			"/": "/",
			// separator of parts of a time (e.g. ":" in 05:44 PM)
			":": ":",
			// the first day of the week (0 = Sunday, 1 = Monday, etc)
			firstDay: 0,
			days: {
				// full day names
				names: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
				// abbreviated day names
				namesAbbr: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
				// shortest day names
				namesShort: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ]
			},
			months: {
				// full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
				names: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", "" ],
				// abbreviated month names
				namesAbbr: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "" ]
			},
			// AM and PM designators in one of these forms:
			// The usual view, and the upper and lower case versions
			//   [ standard, lowercase, uppercase ]
			// The culture does not use AM or PM (likely all standard date formats use 24 hour time)
			//   null
			AM: [ "AM", "am", "AM" ],
			PM: [ "PM", "pm", "PM" ],
			eras: [
				// eras in reverse chronological order.
				// name: the name of the era in this culture (e.g. A.D., C.E.)
				// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
				// offset: offset in years from gregorian calendar
				{
					"name": "A.D.",
					"start": null,
					"offset": 0
				}
			],
			// when a two digit year is given, it will never be parsed as a four digit
			// year greater than this year (in the appropriate era for the culture)
			// Set it as a full year (e.g. 2029) or use an offset format starting from
			// the current year: "+19" would correspond to 2029 if the current year 2010.
			twoDigitYearMax: 2029,
			// set of predefined date and time patterns used by the culture
			// these represent the format someone in this culture would expect
			// to see given the portions of the date that are shown.
			patterns: {
				// short date pattern
				d: "M/d/yyyy",
				// long date pattern
				D: "dddd, MMMM dd, yyyy",
				// short time pattern
				t: "h:mm tt",
				// long time pattern
				T: "h:mm:ss tt",
				// long date, short time pattern
				f: "dddd, MMMM dd, yyyy h:mm tt",
				// long date, long time pattern
				F: "dddd, MMMM dd, yyyy h:mm:ss tt",
				// month/day pattern
				M: "MMMM dd",
				// month/year pattern
				Y: "yyyy MMMM",
				// S is a sortable format that does not vary by culture
				S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"
			}
			// optional fields for each calendar:
			/*
			monthsGenitive:
				Same as months but used when the day preceeds the month.
				Omit if the culture has no genitive distinction in month names.
				For an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx
			convert:
				Allows for the support of non-gregorian based calendars. This convert object is used to
				to convert a date to and from a gregorian calendar date to handle parsing and formatting.
				The two functions:
					fromGregorian( date )
						Given the date as a parameter, return an array with parts [ year, month, day ]
						corresponding to the non-gregorian based year, month, and day for the calendar.
					toGregorian( year, month, day )
						Given the non-gregorian year, month, and day, return a new Date() object
						set to the corresponding date in the gregorian calendar.
			*/
		}
	},
	// For localized strings
	messages: {}
};

Globalize.cultures[ "default" ].calendar = Globalize.cultures[ "default" ].calendars.standard;

Globalize.cultures.en = Globalize.cultures[ "default" ];

Globalize.cultureSelector = "en";

//
// private variables
//

regexHex = /^0x[a-f0-9]+$/i;
regexInfinity = /^[+\-]?infinity$/i;
regexParseFloat = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/;
regexTrim = /^\s+|\s+$/g;

//
// private JavaScript utility functions
//

arrayIndexOf = function( array, item ) {
	if ( array.indexOf ) {
		return array.indexOf( item );
	}
	for ( var i = 0, length = array.length; i < length; i++ ) {
		if ( array[i] === item ) {
			return i;
		}
	}
	return -1;
};

endsWith = function( value, pattern ) {
	return value.substr( value.length - pattern.length ) === pattern;
};

extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction(target) ) {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isObject(copy) || (copyIsArray = isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];

					} else {
						clone = src && isObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

isArray = Array.isArray || function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Array]";
};

isFunction = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Function]";
};

isObject = function( obj ) {
	return Object.prototype.toString.call( obj ) === "[object Object]";
};

startsWith = function( value, pattern ) {
	return value.indexOf( pattern ) === 0;
};

trim = function( value ) {
	return ( value + "" ).replace( regexTrim, "" );
};

truncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};

zeroPad = function( str, count, left ) {
	var l;
	for ( l = str.length; l < count; l += 1 ) {
		str = ( left ? ("0" + str) : (str + "0") );
	}
	return str;
};

//
// private Globalization utility functions
//

appendPreOrPostMatch = function( preMatch, strings ) {
	// appends pre- and post- token match strings while removing escaped characters.
	// Returns a single quote count which is used to determine if the token occurs
	// in a string literal.
	var quoteCount = 0,
		escaped = false;
	for ( var i = 0, il = preMatch.length; i < il; i++ ) {
		var c = preMatch.charAt( i );
		switch ( c ) {
			case "\'":
				if ( escaped ) {
					strings.push( "\'" );
				}
				else {
					quoteCount++;
				}
				escaped = false;
				break;
			case "\\":
				if ( escaped ) {
					strings.push( "\\" );
				}
				escaped = !escaped;
				break;
			default:
				strings.push( c );
				escaped = false;
				break;
		}
	}
	return quoteCount;
};

expandFormat = function( cal, format ) {
	// expands unspecified or single character date formats into the full pattern.
	format = format || "F";
	var pattern,
		patterns = cal.patterns,
		len = format.length;
	if ( len === 1 ) {
		pattern = patterns[ format ];
		if ( !pattern ) {
			throw "Invalid date format string \'" + format + "\'.";
		}
		format = pattern;
	}
	else if ( len === 2 && format.charAt(0) === "%" ) {
		// %X escape format -- intended as a custom format string that is only one character, not a built-in format.
		format = format.charAt( 1 );
	}
	return format;
};

formatDate = function( value, format, culture ) {
	var cal = culture.calendar,
		convert = cal.convert,
		ret;

	if ( !format || !format.length || format === "i" ) {
		if ( culture && culture.name.length ) {
			if ( convert ) {
				// non-gregorian calendar, so we cannot use built-in toLocaleString()
				ret = formatDate( value, cal.patterns.F, culture );
			}
			else {
				var eraDate = new Date( value.getTime() ),
					era = getEra( value, cal.eras );
				eraDate.setFullYear( getEraYear(value, cal, era) );
				ret = eraDate.toLocaleString();
			}
		}
		else {
			ret = value.toString();
		}
		return ret;
	}

	var eras = cal.eras,
		sortable = format === "s";
	format = expandFormat( cal, format );

	// Start with an empty string
	ret = [];
	var hour,
		zeros = [ "0", "00", "000" ],
		foundDay,
		checkedDay,
		dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
		quoteCount = 0,
		tokenRegExp = getTokenRegExp(),
		converted;

	function padZeros( num, c ) {
		var r, s = num + "";
		if ( c > 1 && s.length < c ) {
			r = ( zeros[c - 2] + s);
			return r.substr( r.length - c, c );
		}
		else {
			r = s;
		}
		return r;
	}

	function hasDay() {
		if ( foundDay || checkedDay ) {
			return foundDay;
		}
		foundDay = dayPartRegExp.test( format );
		checkedDay = true;
		return foundDay;
	}

	function getPart( date, part ) {
		if ( converted ) {
			return converted[ part ];
		}
		switch ( part ) {
			case 0:
				return date.getFullYear();
			case 1:
				return date.getMonth();
			case 2:
				return date.getDate();
			default:
				throw "Invalid part value " + part;
		}
	}

	if ( !sortable && convert ) {
		converted = convert.fromGregorian( value );
	}

	for ( ; ; ) {
		// Save the current index
		var index = tokenRegExp.lastIndex,
			// Look for the next pattern
			ar = tokenRegExp.exec( format );

		// Append the text before the pattern (or the end of the string if not found)
		var preMatch = format.slice( index, ar ? ar.index : format.length );
		quoteCount += appendPreOrPostMatch( preMatch, ret );

		if ( !ar ) {
			break;
		}

		// do not replace any matches that occur inside a string literal.
		if ( quoteCount % 2 ) {
			ret.push( ar[0] );
			continue;
		}

		var current = ar[ 0 ],
			clength = current.length;

		switch ( current ) {
			case "ddd":
				//Day of the week, as a three-letter abbreviation
			case "dddd":
				// Day of the week, using the full name
				var names = ( clength === 3 ) ? cal.days.namesAbbr : cal.days.names;
				ret.push( names[value.getDay()] );
				break;
			case "d":
				// Day of month, without leading zero for single-digit days
			case "dd":
				// Day of month, with leading zero for single-digit days
				foundDay = true;
				ret.push(
					padZeros( getPart(value, 2), clength )
				);
				break;
			case "MMM":
				// Month, as a three-letter abbreviation
			case "MMMM":
				// Month, using the full name
				var part = getPart( value, 1 );
				ret.push(
					( cal.monthsGenitive && hasDay() ) ?
					( cal.monthsGenitive[ clength === 3 ? "namesAbbr" : "names" ][ part ] ) :
					( cal.months[ clength === 3 ? "namesAbbr" : "names" ][ part ] )
				);
				break;
			case "M":
				// Month, as digits, with no leading zero for single-digit months
			case "MM":
				// Month, as digits, with leading zero for single-digit months
				ret.push(
					padZeros( getPart(value, 1) + 1, clength )
				);
				break;
			case "y":
				// Year, as two digits, but with no leading zero for years less than 10
			case "yy":
				// Year, as two digits, with leading zero for years less than 10
			case "yyyy":
				// Year represented by four full digits
				part = converted ? converted[ 0 ] : getEraYear( value, cal, getEra(value, eras), sortable );
				if ( clength < 4 ) {
					part = part % 100;
				}
				ret.push(
					padZeros( part, clength )
				);
				break;
			case "h":
				// Hours with no leading zero for single-digit hours, using 12-hour clock
			case "hh":
				// Hours with leading zero for single-digit hours, using 12-hour clock
				hour = value.getHours() % 12;
				if ( hour === 0 ) hour = 12;
				ret.push(
					padZeros( hour, clength )
				);
				break;
			case "H":
				// Hours with no leading zero for single-digit hours, using 24-hour clock
			case "HH":
				// Hours with leading zero for single-digit hours, using 24-hour clock
				ret.push(
					padZeros( value.getHours(), clength )
				);
				break;
			case "m":
				// Minutes with no leading zero for single-digit minutes
			case "mm":
				// Minutes with leading zero for single-digit minutes
				ret.push(
					padZeros( value.getMinutes(), clength )
				);
				break;
			case "s":
				// Seconds with no leading zero for single-digit seconds
			case "ss":
				// Seconds with leading zero for single-digit seconds
				ret.push(
					padZeros( value.getSeconds(), clength )
				);
				break;
			case "t":
				// One character am/pm indicator ("a" or "p")
			case "tt":
				// Multicharacter am/pm indicator
				part = value.getHours() < 12 ? ( cal.AM ? cal.AM[0] : " " ) : ( cal.PM ? cal.PM[0] : " " );
				ret.push( clength === 1 ? part.charAt(0) : part );
				break;
			case "f":
				// Deciseconds
			case "ff":
				// Centiseconds
			case "fff":
				// Milliseconds
				ret.push(
					padZeros( value.getMilliseconds(), 3 ).substr( 0, clength )
				);
				break;
			case "z":
				// Time zone offset, no leading zero
			case "zz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), clength )
				);
				break;
			case "zzz":
				// Time zone offset with leading zero
				hour = value.getTimezoneOffset() / 60;
				ret.push(
					( hour <= 0 ? "+" : "-" ) + padZeros( Math.floor(Math.abs(hour)), 2 ) +
					// Hard coded ":" separator, rather than using cal.TimeSeparator
					// Repeated here for consistency, plus ":" was already assumed in date parsing.
					":" + padZeros( Math.abs(value.getTimezoneOffset() % 60), 2 )
				);
				break;
			case "g":
			case "gg":
				if ( cal.eras ) {
					ret.push(
						cal.eras[ getEra(value, eras) ].name
					);
				}
				break;
		case "/":
			ret.push( cal["/"] );
			break;
		default:
			throw "Invalid date format pattern \'" + current + "\'.";
		}
	}
	return ret.join( "" );
};

// formatNumber
(function() {
	var expandNumber;

	expandNumber = function( number, precision, formatInfo ) {
		var groupSizes = formatInfo.groupSizes,
			curSize = groupSizes[ 0 ],
			curGroupIndex = 1,
			factor = Math.pow( 10, precision ),
			rounded = Math.round( number * factor ) / factor;

		if ( !isFinite(rounded) ) {
			rounded = number;
		}
		number = rounded;

		var numberString = number+"",
			right = "",
			split = numberString.split( /e/i ),
			exponent = split.length > 1 ? parseInt( split[1], 10 ) : 0;
		numberString = split[ 0 ];
		split = numberString.split( "." );
		numberString = split[ 0 ];
		right = split.length > 1 ? split[ 1 ] : "";

		if ( exponent > 0 ) {
			right = zeroPad( right, exponent, false );
			numberString += right.slice( 0, exponent );
			right = right.substr( exponent );
		}
		else if ( exponent < 0 ) {
			exponent = -exponent;
			numberString = zeroPad( numberString, exponent + 1, true );
			right = numberString.slice( -exponent, numberString.length ) + right;
			numberString = numberString.slice( 0, -exponent );
		}

		if ( precision > 0 ) {
			right = formatInfo[ "." ] +
				( (right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision) );
		}
		else {
			right = "";
		}

		var stringIndex = numberString.length - 1,
			sep = formatInfo[ "," ],
			ret = "";

		while ( stringIndex >= 0 ) {
			if ( curSize === 0 || curSize > stringIndex ) {
				return numberString.slice( 0, stringIndex + 1 ) + ( ret.length ? (sep + ret + right) : right );
			}
			ret = numberString.slice( stringIndex - curSize + 1, stringIndex + 1 ) + ( ret.length ? (sep + ret) : "" );

			stringIndex -= curSize;

			if ( curGroupIndex < groupSizes.length ) {
				curSize = groupSizes[ curGroupIndex ];
				curGroupIndex++;
			}
		}

		return numberString.slice( 0, stringIndex + 1 ) + sep + ret + right;
	};

	formatNumber = function( value, format, culture ) {
		if ( !isFinite(value) ) {
			if ( value === Infinity ) {
				return culture.numberFormat.positiveInfinity;
			}
			if ( value === -Infinity ) {
				return culture.numberFormat.negativeInfinity;
			}
			return culture.numberFormat.NaN;
		}
		if ( !format || format === "i" ) {
			return culture.name.length ? value.toLocaleString() : value.toString();
		}
		format = format || "D";

		var nf = culture.numberFormat,
			number = Math.abs( value ),
			precision = -1,
			pattern;
		if ( format.length > 1 ) precision = parseInt( format.slice(1), 10 );

		var current = format.charAt( 0 ).toUpperCase(),
			formatInfo;

		switch ( current ) {
			case "D":
				pattern = "n";
				number = truncate( number );
				if ( precision !== -1 ) {
					number = zeroPad( "" + number, precision, true );
				}
				if ( value < 0 ) number = "-" + number;
				break;
			case "N":
				formatInfo = nf;
				/* falls through */
			case "C":
				formatInfo = formatInfo || nf.currency;
				/* falls through */
			case "P":
				formatInfo = formatInfo || nf.percent;
				pattern = value < 0 ? formatInfo.pattern[ 0 ] : ( formatInfo.pattern[1] || "n" );
				if ( precision === -1 ) precision = formatInfo.decimals;
				number = expandNumber( number * (current === "P" ? 100 : 1), precision, formatInfo );
				break;
			default:
				throw "Bad number format specifier: " + current;
		}

		var patternParts = /n|\$|-|%/g,
			ret = "";
		for ( ; ; ) {
			var index = patternParts.lastIndex,
				ar = patternParts.exec( pattern );

			ret += pattern.slice( index, ar ? ar.index : pattern.length );

			if ( !ar ) {
				break;
			}

			switch ( ar[0] ) {
				case "n":
					ret += number;
					break;
				case "$":
					ret += nf.currency.symbol;
					break;
				case "-":
					// don't make 0 negative
					if ( /[1-9]/.test(number) ) {
						ret += nf[ "-" ];
					}
					break;
				case "%":
					ret += nf.percent.symbol;
					break;
			}
		}

		return ret;
	};

}());

getTokenRegExp = function() {
	// regular expression for matching date and time tokens in format strings.
	return (/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g);
};

getEra = function( date, eras ) {
	if ( !eras ) return 0;
	var start, ticks = date.getTime();
	for ( var i = 0, l = eras.length; i < l; i++ ) {
		start = eras[ i ].start;
		if ( start === null || ticks >= start ) {
			return i;
		}
	}
	return 0;
};

getEraYear = function( date, cal, era, sortable ) {
	var year = date.getFullYear();
	if ( !sortable && cal.eras ) {
		// convert normal gregorian year to era-shifted gregorian
		// year by subtracting the era offset
		year -= cal.eras[ era ].offset;
	}
	return year;
};

// parseExact
(function() {
	var expandYear,
		getDayIndex,
		getMonthIndex,
		getParseRegExp,
		outOfRange,
		toUpper,
		toUpperArray;

	expandYear = function( cal, year ) {
		// expands 2-digit year into 4 digits.
		if ( year < 100 ) {
			var now = new Date(),
				era = getEra( now ),
				curr = getEraYear( now, cal, era ),
				twoDigitYearMax = cal.twoDigitYearMax;
			twoDigitYearMax = typeof twoDigitYearMax === "string" ? new Date().getFullYear() % 100 + parseInt( twoDigitYearMax, 10 ) : twoDigitYearMax;
			year += curr - ( curr % 100 );
			if ( year > twoDigitYearMax ) {
				year -= 100;
			}
		}
		return year;
	};

	getDayIndex = function	( cal, value, abbr ) {
		var ret,
			days = cal.days,
			upperDays = cal._upperDays;
		if ( !upperDays ) {
			cal._upperDays = upperDays = [
				toUpperArray( days.names ),
				toUpperArray( days.namesAbbr ),
				toUpperArray( days.namesShort )
			];
		}
		value = toUpper( value );
		if ( abbr ) {
			ret = arrayIndexOf( upperDays[1], value );
			if ( ret === -1 ) {
				ret = arrayIndexOf( upperDays[2], value );
			}
		}
		else {
			ret = arrayIndexOf( upperDays[0], value );
		}
		return ret;
	};

	getMonthIndex = function( cal, value, abbr ) {
		var months = cal.months,
			monthsGen = cal.monthsGenitive || cal.months,
			upperMonths = cal._upperMonths,
			upperMonthsGen = cal._upperMonthsGen;
		if ( !upperMonths ) {
			cal._upperMonths = upperMonths = [
				toUpperArray( months.names ),
				toUpperArray( months.namesAbbr )
			];
			cal._upperMonthsGen = upperMonthsGen = [
				toUpperArray( monthsGen.names ),
				toUpperArray( monthsGen.namesAbbr )
			];
		}
		value = toUpper( value );
		var i = arrayIndexOf( abbr ? upperMonths[1] : upperMonths[0], value );
		if ( i < 0 ) {
			i = arrayIndexOf( abbr ? upperMonthsGen[1] : upperMonthsGen[0], value );
		}
		return i;
	};

	getParseRegExp = function( cal, format ) {
		// converts a format string into a regular expression with groups that
		// can be used to extract date fields from a date string.
		// check for a cached parse regex.
		var re = cal._parseRegExp;
		if ( !re ) {
			cal._parseRegExp = re = {};
		}
		else {
			var reFormat = re[ format ];
			if ( reFormat ) {
				return reFormat;
			}
		}

		// expand single digit formats, then escape regular expression characters.
		var expFormat = expandFormat( cal, format ).replace( /([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1" ),
			regexp = [ "^" ],
			groups = [],
			index = 0,
			quoteCount = 0,
			tokenRegExp = getTokenRegExp(),
			match;

		// iterate through each date token found.
		while ( (match = tokenRegExp.exec(expFormat)) !== null ) {
			var preMatch = expFormat.slice( index, match.index );
			index = tokenRegExp.lastIndex;

			// don't replace any matches that occur inside a string literal.
			quoteCount += appendPreOrPostMatch( preMatch, regexp );
			if ( quoteCount % 2 ) {
				regexp.push( match[0] );
				continue;
			}

			// add a regex group for the token.
			var m = match[ 0 ],
				len = m.length,
				add;
			switch ( m ) {
				case "dddd": case "ddd":
				case "MMMM": case "MMM":
				case "gg": case "g":
					add = "(\\D+)";
					break;
				case "tt": case "t":
					add = "(\\D*)";
					break;
				case "yyyy":
				case "fff":
				case "ff":
				case "f":
					add = "(\\d{" + len + "})";
					break;
				case "dd": case "d":
				case "MM": case "M":
				case "yy": case "y":
				case "HH": case "H":
				case "hh": case "h":
				case "mm": case "m":
				case "ss": case "s":
					add = "(\\d\\d?)";
					break;
				case "zzz":
					add = "([+-]?\\d\\d?:\\d{2})";
					break;
				case "zz": case "z":
					add = "([+-]?\\d\\d?)";
					break;
				case "/":
					add = "(\\/)";
					break;
				default:
					throw "Invalid date format pattern \'" + m + "\'.";
			}
			if ( add ) {
				regexp.push( add );
			}
			groups.push( match[0] );
		}
		appendPreOrPostMatch( expFormat.slice(index), regexp );
		regexp.push( "$" );

		// allow whitespace to differ when matching formats.
		var regexpStr = regexp.join( "" ).replace( /\s+/g, "\\s+" ),
			parseRegExp = { "regExp": regexpStr, "groups": groups };

		// cache the regex for this format.
		return re[ format ] = parseRegExp;
	};

	outOfRange = function( value, low, high ) {
		return value < low || value > high;
	};

	toUpper = function( value ) {
		// "he-IL" has non-breaking space in weekday names.
		return value.split( "\u00A0" ).join( " " ).toUpperCase();
	};

	toUpperArray = function( arr ) {
		var results = [];
		for ( var i = 0, l = arr.length; i < l; i++ ) {
			results[ i ] = toUpper( arr[i] );
		}
		return results;
	};

	parseExact = function( value, format, culture ) {
		// try to parse the date string by matching against the format string
		// while using the specified culture for date field names.
		value = trim( value );
		var cal = culture.calendar,
			// convert date formats into regular expressions with groupings.
			// use the regexp to determine the input format and extract the date fields.
			parseInfo = getParseRegExp( cal, format ),
			match = new RegExp( parseInfo.regExp ).exec( value );
		if ( match === null ) {
			return null;
		}
		// found a date format that matches the input.
		var groups = parseInfo.groups,
			era = null, year = null, month = null, date = null, weekDay = null,
			hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
			pmHour = false;
		// iterate the format groups to extract and set the date fields.
		for ( var j = 0, jl = groups.length; j < jl; j++ ) {
			var matchGroup = match[ j + 1 ];
			if ( matchGroup ) {
				var current = groups[ j ],
					clength = current.length,
					matchInt = parseInt( matchGroup, 10 );
				switch ( current ) {
					case "dd": case "d":
						// Day of month.
						date = matchInt;
						// check that date is generally in valid range, also checking overflow below.
						if ( outOfRange(date, 1, 31) ) return null;
						break;
					case "MMM": case "MMMM":
						month = getMonthIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "M": case "MM":
						// Month.
						month = matchInt - 1;
						if ( outOfRange(month, 0, 11) ) return null;
						break;
					case "y": case "yy":
					case "yyyy":
						year = clength < 4 ? expandYear( cal, matchInt ) : matchInt;
						if ( outOfRange(year, 0, 9999) ) return null;
						break;
					case "h": case "hh":
						// Hours (12-hour clock).
						hour = matchInt;
						if ( hour === 12 ) hour = 0;
						if ( outOfRange(hour, 0, 11) ) return null;
						break;
					case "H": case "HH":
						// Hours (24-hour clock).
						hour = matchInt;
						if ( outOfRange(hour, 0, 23) ) return null;
						break;
					case "m": case "mm":
						// Minutes.
						min = matchInt;
						if ( outOfRange(min, 0, 59) ) return null;
						break;
					case "s": case "ss":
						// Seconds.
						sec = matchInt;
						if ( outOfRange(sec, 0, 59) ) return null;
						break;
					case "tt": case "t":
						// AM/PM designator.
						// see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
						// the AM tokens. If not, fail the parse for this format.
						pmHour = cal.PM && ( matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2] );
						if (
							!pmHour && (
								!cal.AM || ( matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2] )
							)
						) return null;
						break;
					case "f":
						// Deciseconds.
					case "ff":
						// Centiseconds.
					case "fff":
						// Milliseconds.
						msec = matchInt * Math.pow( 10, 3 - clength );
						if ( outOfRange(msec, 0, 999) ) return null;
						break;
					case "ddd":
						// Day of week.
					case "dddd":
						// Day of week.
						weekDay = getDayIndex( cal, matchGroup, clength === 3 );
						if ( outOfRange(weekDay, 0, 6) ) return null;
						break;
					case "zzz":
						// Time zone offset in +/- hours:min.
						var offsets = matchGroup.split( /:/ );
						if ( offsets.length !== 2 ) return null;
						hourOffset = parseInt( offsets[0], 10 );
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						var minOffset = parseInt( offsets[1], 10 );
						if ( outOfRange(minOffset, 0, 59) ) return null;
						tzMinOffset = ( hourOffset * 60 ) + ( startsWith(matchGroup, "-") ? -minOffset : minOffset );
						break;
					case "z": case "zz":
						// Time zone offset in +/- hours.
						hourOffset = matchInt;
						if ( outOfRange(hourOffset, -12, 13) ) return null;
						tzMinOffset = hourOffset * 60;
						break;
					case "g": case "gg":
						var eraName = matchGroup;
						if ( !eraName || !cal.eras ) return null;
						eraName = trim( eraName.toLowerCase() );
						for ( var i = 0, l = cal.eras.length; i < l; i++ ) {
							if ( eraName === cal.eras[i].name.toLowerCase() ) {
								era = i;
								break;
							}
						}
						// could not find an era with that name
						if ( era === null ) return null;
						break;
				}
			}
		}
		var result = new Date(), defaultYear, convert = cal.convert;
		defaultYear = convert ? convert.fromGregorian( result )[ 0 ] : result.getFullYear();
		if ( year === null ) {
			year = defaultYear;
		}
		else if ( cal.eras ) {
			// year must be shifted to normal gregorian year
			// but not if year was not specified, its already normal gregorian
			// per the main if clause above.
			year += cal.eras[( era || 0 )].offset;
		}
		// set default day and month to 1 and January, so if unspecified, these are the defaults
		// instead of the current day/month.
		if ( month === null ) {
			month = 0;
		}
		if ( date === null ) {
			date = 1;
		}
		// now have year, month, and date, but in the culture's calendar.
		// convert to gregorian if necessary
		if ( convert ) {
			result = convert.toGregorian( year, month, date );
			// conversion failed, must be an invalid match
			if ( result === null ) return null;
		}
		else {
			// have to set year, month and date together to avoid overflow based on current date.
			result.setFullYear( year, month, date );
			// check to see if date overflowed for specified month (only checked 1-31 above).
			if ( result.getDate() !== date ) return null;
			// invalid day of week.
			if ( weekDay !== null && result.getDay() !== weekDay ) {
				return null;
			}
		}
		// if pm designator token was found make sure the hours fit the 24-hour clock.
		if ( pmHour && hour < 12 ) {
			hour += 12;
		}
		result.setHours( hour, min, sec, msec );
		if ( tzMinOffset !== null ) {
			// adjust timezone to utc before applying local offset.
			var adjustedMin = result.getMinutes() - ( tzMinOffset + result.getTimezoneOffset() );
			// Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
			// to ensure both these fields will not exceed this range.	adjustedMin will range
			// somewhere between -1440 and 1500, so we only need to split this into hours.
			result.setHours( result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60 );
		}
		return result;
	};
}());

parseNegativePattern = function( value, nf, negativePattern ) {
	var neg = nf[ "-" ],
		pos = nf[ "+" ],
		ret;
	switch ( negativePattern ) {
		case "n -":
			neg = " " + neg;
			pos = " " + pos;
			/* falls through */
		case "n-":
			if ( endsWith(value, neg) ) {
				ret = [ "-", value.substr(0, value.length - neg.length) ];
			}
			else if ( endsWith(value, pos) ) {
				ret = [ "+", value.substr(0, value.length - pos.length) ];
			}
			break;
		case "- n":
			neg += " ";
			pos += " ";
			/* falls through */
		case "-n":
			if ( startsWith(value, neg) ) {
				ret = [ "-", value.substr(neg.length) ];
			}
			else if ( startsWith(value, pos) ) {
				ret = [ "+", value.substr(pos.length) ];
			}
			break;
		case "(n)":
			if ( startsWith(value, "(") && endsWith(value, ")") ) {
				ret = [ "-", value.substr(1, value.length - 2) ];
			}
			break;
	}
	return ret || [ "", value ];
};

//
// public instance functions
//

Globalize.prototype.findClosestCulture = function( cultureSelector ) {
	return Globalize.findClosestCulture.call( this, cultureSelector );
};

Globalize.prototype.format = function( value, format, cultureSelector ) {
	return Globalize.format.call( this, value, format, cultureSelector );
};

Globalize.prototype.localize = function( key, cultureSelector ) {
	return Globalize.localize.call( this, key, cultureSelector );
};

Globalize.prototype.parseInt = function( value, radix, cultureSelector ) {
	return Globalize.parseInt.call( this, value, radix, cultureSelector );
};

Globalize.prototype.parseFloat = function( value, radix, cultureSelector ) {
	return Globalize.parseFloat.call( this, value, radix, cultureSelector );
};

Globalize.prototype.culture = function( cultureSelector ) {
	return Globalize.culture.call( this, cultureSelector );
};

//
// public singleton functions
//

Globalize.addCultureInfo = function( cultureName, baseCultureName, info ) {

	var base = {},
		isNew = false;

	if ( typeof cultureName !== "string" ) {
		// cultureName argument is optional string. If not specified, assume info is first
		// and only argument. Specified info deep-extends current culture.
		info = cultureName;
		cultureName = this.culture().name;
		base = this.cultures[ cultureName ];
	} else if ( typeof baseCultureName !== "string" ) {
		// baseCultureName argument is optional string. If not specified, assume info is second
		// argument. Specified info deep-extends specified culture.
		// If specified culture does not exist, create by deep-extending default
		info = baseCultureName;
		isNew = ( this.cultures[ cultureName ] == null );
		base = this.cultures[ cultureName ] || this.cultures[ "default" ];
	} else {
		// cultureName and baseCultureName specified. Assume a new culture is being created
		// by deep-extending an specified base culture
		isNew = true;
		base = this.cultures[ baseCultureName ];
	}

	this.cultures[ cultureName ] = extend(true, {},
		base,
		info
	);
	// Make the standard calendar the current culture if it's a new culture
	if ( isNew ) {
		this.cultures[ cultureName ].calendar = this.cultures[ cultureName ].calendars.standard;
	}
};

Globalize.findClosestCulture = function( name ) {
	var match;
	if ( !name ) {
		return this.findClosestCulture( this.cultureSelector ) || this.cultures[ "default" ];
	}
	if ( typeof name === "string" ) {
		name = name.split( "," );
	}
	if ( isArray(name) ) {
		var lang,
			cultures = this.cultures,
			list = name,
			i, l = list.length,
			prioritized = [];
		for ( i = 0; i < l; i++ ) {
			name = trim( list[i] );
			var pri, parts = name.split( ";" );
			lang = trim( parts[0] );
			if ( parts.length === 1 ) {
				pri = 1;
			}
			else {
				name = trim( parts[1] );
				if ( name.indexOf("q=") === 0 ) {
					name = name.substr( 2 );
					pri = parseFloat( name );
					pri = isNaN( pri ) ? 0 : pri;
				}
				else {
					pri = 1;
				}
			}
			prioritized.push({ lang: lang, pri: pri });
		}
		prioritized.sort(function( a, b ) {
			if ( a.pri < b.pri ) {
				return 1;
			} else if ( a.pri > b.pri ) {
				return -1;
			}
			return 0;
		});
		// exact match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			match = cultures[ lang ];
			if ( match ) {
				return match;
			}
		}

		// neutral language match
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			do {
				var index = lang.lastIndexOf( "-" );
				if ( index === -1 ) {
					break;
				}
				// strip off the last part. e.g. en-US => en
				lang = lang.substr( 0, index );
				match = cultures[ lang ];
				if ( match ) {
					return match;
				}
			}
			while ( 1 );
		}

		// last resort: match first culture using that language
		for ( i = 0; i < l; i++ ) {
			lang = prioritized[ i ].lang;
			for ( var cultureKey in cultures ) {
				var culture = cultures[ cultureKey ];
				if ( culture.language === lang ) {
					return culture;
				}
			}
		}
	}
	else if ( typeof name === "object" ) {
		return name;
	}
	return match || null;
};

Globalize.format = function( value, format, cultureSelector ) {
	var culture = this.findClosestCulture( cultureSelector );
	if ( value instanceof Date ) {
		value = formatDate( value, format, culture );
	}
	else if ( typeof value === "number" ) {
		value = formatNumber( value, format, culture );
	}
	return value;
};

Globalize.localize = function( key, cultureSelector ) {
	return this.findClosestCulture( cultureSelector ).messages[ key ] ||
		this.cultures[ "default" ].messages[ key ];
};

Globalize.parseDate = function( value, formats, culture ) {
	culture = this.findClosestCulture( culture );

	var date, prop, patterns;
	if ( formats ) {
		if ( typeof formats === "string" ) {
			formats = [ formats ];
		}
		if ( formats.length ) {
			for ( var i = 0, l = formats.length; i < l; i++ ) {
				var format = formats[ i ];
				if ( format ) {
					date = parseExact( value, format, culture );
					if ( date ) {
						break;
					}
				}
			}
		}
	} else {
		patterns = culture.calendar.patterns;
		for ( prop in patterns ) {
			date = parseExact( value, patterns[prop], culture );
			if ( date ) {
				break;
			}
		}
	}

	return date || null;
};

Globalize.parseInt = function( value, radix, cultureSelector ) {
	return truncate( Globalize.parseFloat(value, radix, cultureSelector) );
};

Globalize.parseFloat = function( value, radix, cultureSelector ) {
	// radix argument is optional
	if ( typeof radix !== "number" ) {
		cultureSelector = radix;
		radix = 10;
	}

	var culture = this.findClosestCulture( cultureSelector );
	var ret = NaN,
		nf = culture.numberFormat;

	if ( value.indexOf(culture.numberFormat.currency.symbol) > -1 ) {
		// remove currency symbol
		value = value.replace( culture.numberFormat.currency.symbol, "" );
		// replace decimal seperator
		value = value.replace( culture.numberFormat.currency["."], culture.numberFormat["."] );
	}

	//Remove percentage character from number string before parsing
	if ( value.indexOf(culture.numberFormat.percent.symbol) > -1){
		value = value.replace( culture.numberFormat.percent.symbol, "" );
	}

	// remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR
	value = value.replace( / /g, "" );

	// allow infinity or hexidecimal
	if ( regexInfinity.test(value) ) {
		ret = parseFloat( value );
	}
	else if ( !radix && regexHex.test(value) ) {
		ret = parseInt( value, 16 );
	}
	else {

		// determine sign and number
		var signInfo = parseNegativePattern( value, nf, nf.pattern[0] ),
			sign = signInfo[ 0 ],
			num = signInfo[ 1 ];

		// #44 - try parsing as "(n)"
		if ( sign === "" && nf.pattern[0] !== "(n)" ) {
			signInfo = parseNegativePattern( value, nf, "(n)" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		// try parsing as "-n"
		if ( sign === "" && nf.pattern[0] !== "-n" ) {
			signInfo = parseNegativePattern( value, nf, "-n" );
			sign = signInfo[ 0 ];
			num = signInfo[ 1 ];
		}

		sign = sign || "+";

		// determine exponent and number
		var exponent,
			intAndFraction,
			exponentPos = num.indexOf( "e" );
		if ( exponentPos < 0 ) exponentPos = num.indexOf( "E" );
		if ( exponentPos < 0 ) {
			intAndFraction = num;
			exponent = null;
		}
		else {
			intAndFraction = num.substr( 0, exponentPos );
			exponent = num.substr( exponentPos + 1 );
		}
		// determine decimal position
		var integer,
			fraction,
			decSep = nf[ "." ],
			decimalPos = intAndFraction.indexOf( decSep );
		if ( decimalPos < 0 ) {
			integer = intAndFraction;
			fraction = null;
		}
		else {
			integer = intAndFraction.substr( 0, decimalPos );
			fraction = intAndFraction.substr( decimalPos + decSep.length );
		}
		// handle groups (e.g. 1,000,000)
		var groupSep = nf[ "," ];
		integer = integer.split( groupSep ).join( "" );
		var altGroupSep = groupSep.replace( /\u00A0/g, " " );
		if ( groupSep !== altGroupSep ) {
			integer = integer.split( altGroupSep ).join( "" );
		}
		// build a natively parsable number string
		var p = sign + integer;
		if ( fraction !== null ) {
			p += "." + fraction;
		}
		if ( exponent !== null ) {
			// exponent itself may have a number patternd
			var expSignInfo = parseNegativePattern( exponent, nf, "-n" );
			p += "e" + ( expSignInfo[0] || "+" ) + expSignInfo[ 1 ];
		}
		if ( regexParseFloat.test(p) ) {
			ret = parseFloat( p );
		}
	}
	return ret;
};

Globalize.culture = function( cultureSelector ) {
	// setter
	if ( typeof cultureSelector !== "undefined" ) {
		this.cultureSelector = cultureSelector;
	}
	// getter
	return this.findClosestCulture( cultureSelector ) || this.cultures[ "default" ];
};

}( this ));
define("vendor/globalize", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Globalize;
    };
}(this)));

define(
    'configuration/PlugInConfiguration',[
        'require',
        'jquery',
        'knockout',
        'handlers/general',
        'handlers/Cookie',
        'handlers/Logger',
        'devicemanagers/ViewModelsManager',
        'configuration/PaymentsConfiguration',
        'configuration/DealSlipsConfiguration',
        'modules/systeminfo',
        'configuration/initconfiguration',
        'viewmodels/PrintExportViewModel',
        'helpers/customkobindings/KoCustomBindings',
        'devicehelpers/KoCustomBindings',
        'helpers/CustomKOBindings/PrintBinding',
        'trackingIntExt/TrackingData',
        'vendor/globalize',
        'global/UrlResolver',
    ],
    function (require) {
        var ko = require('knockout'),
            general = require('handlers/general'),
            $ = require('jquery'),
            CookieHandler = require('handlers/Cookie'),
            Logger = require('handlers/Logger'),
            ViewModelsManager = require('devicemanagers/ViewModelsManager'),
            PaymentsConfiguration = require('configuration/PaymentsConfiguration'),
            DealSlipsConfiguration = require('configuration/DealSlipsConfiguration'),
            systemInfo = require('modules/systeminfo'),
            trackingData = require('trackingIntExt/TrackingData'),
            Globalize = require('vendor/globalize'),
            urlResolver = require('global/UrlResolver');

        function PlugInConfiguration() {
            function bindKO(rootElement) {
                ko.options.deferUpdates = false;
                if (!general.isDefinedType(rootElement)) {
                    rootElement = window.document.body;
                }

                try {
                    ko.applyBindingsWithValidation(ViewModelsManager, rootElement, {
                        registerExtenders: true,
                        messagesOnModified: true,
                        insertMessages: false,
                        parseInputAttributes: true,
                        decorateInputElement: true,
                        messageTemplate: null,
                        errorElementClass: 'validationElement',
                    });
                } catch (ex) {
                    Logger.log('PlugInConfiguration.bindKO', ex.message, '', eErrorSeverity.warning);
                }
            }

            function adjustHtml() {
                //prevent spaces in user text
                $(document)
                    .off('keydown')
                    .on('keydown', function (event) {
                        var doPrevent = false;

                        if (event.keyCode === 8) {
                            var d = event.srcElement || event.target;

                            if (
                                (d.tagName.toUpperCase() === 'INPUT' &&
                                    (d.type.toUpperCase() === 'TEXT' || d.type.toUpperCase() === 'PASSWORD')) ||
                                d.tagName.toUpperCase() === 'TEXTAREA'
                            ) {
                                doPrevent = d.readOnly || d.disabled;
                            }
                        }

                        if (doPrevent) {
                            event.preventDefault();
                        }
                    });

                $(document).on(eAppEvents.formChangeEvent, function () {
                    $(document).scrollTop(0);
                    $(document).trigger(eAppEvents.formChangedEvent);
                });
            }

            function addPixel() {
                var links = CookieHandler.ReadCookie('LinksForPixel');

                if (links) {
                    var arrayLinks = links.split(',');
                    var im = new Image();

                    arrayLinks.forEach(function addLinksToImage(link) {
                        if (link != '') {
                            im.src = link;
                        }
                    });

                    CookieHandler.EraseCookie('LinksForPixel');
                }
            }

            function exposeUI() { }

            function updateScmmTrackingData() {
                if (trackingData) {
                    trackingData.updateScmmData();
                }
            }

            function registerComponents(configuration) {
                configuration = configuration || {};

                ko.components.register('fx-component-loader', {
                    viewModel: { require: 'viewmodels/common/ComponentLoader' },
                    template: { require: 'text!webHtml/statichtml/common/component-loader.html' },
                });

                ko.components.register('fx-instrument-price-alert', {
                    viewModel: { require: 'viewmodels/InstrumentPriceAlertViewModel' },
                    template: { require: 'text!webHtml/statichtml/instrument-price-alert.html' },
                });

                ko.components.register('fx-customer-activation', {
                    viewModel: { require: 'viewmodels/MissingCustomerInformationViewModel' },
                    template: { require: 'text!controllers/Customer/MissingInformation' },
                });

                ko.components.register('fx-open-question', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/question/open-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/open-question.html' },
                });

                ko.components.register('fx-phone-number-question', {
                    viewModel: { require: 'viewmodels/questionnaire/question/phone-number-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/phone-number-question.html' },
                });

                ko.components.register('fx-questions-wrapper', {
                    viewModel: { require: 'viewmodels/questionnaire/question/questions-wrapper' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/questions-wrapper.html' },
                });

                ko.components.register('fx-overridable-question', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/question/overridable-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/open-question.html' },
                });

                ko.components.register('fx-radio-question', {
                    viewModel: { require: 'viewmodels/questionnaire/question/radio-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/radio-question.html' },
                });

                ko.components.register('fx-select-question', {
                    viewModel: { require: 'viewmodels/questionnaire/question/select-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/select-question.html' },
                });

                ko.components.register('fx-radiolist-question', {
                    viewModel: { require: 'viewmodels/questionnaire/question/radio-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/radiolist-question.html' },
                });

                ko.components.register('fx-search-question', {
                    deps: ['helpers/CustomKOBindings/AutocompleteBinding'],
                    viewModel: { require: 'viewmodels/questionnaire/question/search-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/search-question.html' },
                });

                ko.components.register('fx-date-question', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/question/date-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/date-question.html' },
                });

                ko.components.register('fx-checkbox-question', {
                    viewModel: { require: 'viewmodels/questionnaire/question/checkbox-question' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/checkbox-question.html' },
                });

                ko.components.register('fx-questionnaire', {
                    viewModel: { require: 'viewmodels/questionnaire/question/questionnaire' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/questionnaire.html' },
                });

                ko.components.register('fx-tooltip', {
                    viewModel: { require: 'viewmodels/common/tool-tip' },
                    template: { require: 'text!webHtml/statichtml/common/tool-tip.html' },
                });

                ko.components.register('fx-question-validation-balloon', {
                    template: {
                        require: 'text!webHtml/statichtml/questionnaire/question/question-validation-balloon.html',
                    },
                });

                ko.components.register('fx-question-tooltip-balloon', {
                    viewModel: { require: 'viewmodels/questionnaire/question-tooltip-balloon' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/question/question-tooltip-balloon.html' },
                });

                ko.components.register('fx-progress-bar-a', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/progress-bar-a' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/progress-bar-a.html' },
                });

                ko.components.register('fx-progress-title', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/progress-title' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/progress-title-a.html' },
                });

                ko.components.register('fx-questionnaire-right-side', {
                    template: { require: 'text!webHtml/statichtml/questionnaire/questionnaire-right-side.html' },
                });

                ko.components.register('fx-client-questionnaire', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/client-questionnaire' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/client-questionnaire.html' },
                });

                ko.components.register('fx-welcome-client-questionnaire', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/welcome-client-questionnaire' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/welcome-client-questionnaire.html' },
                });

                ko.components.register('fx-component-userflow-wrap', {
                    deps: ['LoadDictionaryContent!account_hub'],
                    viewModel: { require: 'viewmodels/Account/UserFlowWrapViewModel' },
                    template: { require: 'text!webHtml/statichtml/account/user-flow-wrap.html' },
                });

                ko.components.register('fx-component-account-userflow-br' + urlResolver.getBroker(), {
                    viewModel: { require: 'deviceviewmodels/account/UserFlowViewModel' },
                    template: {
                        require: 'text!webHtml/statichtml/account/userflow-br' + urlResolver.getBroker() + '.html',
                    },
                });

                ko.components.register('fx-thankyou-client-questionnaire', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/thankyou-client-questionnaire' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/thankyou-client-questionnaire.html' },
                });

                ko.components.register('fx-unsuccessful-client-questionnaire', {
                    deps: ['LoadDictionaryContent!client_questionnaire'],
                    viewModel: { require: 'viewmodels/questionnaire/unsuccessful-client-questionnaire' },
                    template: { require: 'text!webHtml/statichtml/questionnaire/unsuccessful-client-questionnaire.html' },
                });

                ko.components.register('fx-aml-status-page', {
                    viewModel: { require: 'viewmodels/AmlViewModel' },
                    template: { require: 'text!partial-views/web-compliance-amlstatus.html' },
                });

                ko.components.register('fx-upload-documents-page', {
                    deps: [
                        'LoadDictionaryContent!FAQUPLOADDOCUMENTS',
                        'LoadDictionaryContent!compliance_UploadDocuments',
                        'LoadDictionaryContent!Tooltip',
                        'LoadDictionaryContent!Category',
                        'LoadDictionaryContent!Status',
                        'LoadDictionaryContent!UploadDocumentsStatusPopUpMessages',
                    ],
                    viewModel: { require: 'viewmodels/UploadDocumentsViewModel' },
                    template: { require: 'text!webHtml/statichtml/compliance/upload-documents.html' },
                });

                ko.components.register('fx-component-require-margin-text', {
                    viewModel: { require: 'viewmodels/Deals/DealMarginViewModel' },
                    template: { require: 'text!partial-views/web-deals-requiremargin.html' },
                });

                ko.components.register('fx-component-converted-amount-text', {
                    viewModel: { require: 'viewmodels/Deals/ConvertedAmountViewModel' },
                    template: { require: 'text!partial-views/web-deals-convertedamount.html' },
                });

                ko.components.register('fx-component-chart-tool', {
                    viewModel: { require: 'deviceviewmodels/ChartToolViewModel' },
                    template: { require: 'text!webHtml/statichtml/deals/deal-charttool.html' },
                });

                ko.components.register('fx-component-market-info-rates', {
                    deps: ['LoadDictionaryContent!deals_DealMarketInfoTool'],
                    viewModel: { require: 'viewmodels/Deals/MarketInfoRatesViewModel' },
                    template: { require: 'text!webHtml/statichtml/deals/market-info-rates.html' },
                });

                ko.components.register('fx-component-rate-range-indicator', {
                    deps: ['LoadDictionaryContent!deals_DealMarketInfoTool'],
                    viewModel: { require: 'viewmodels/Deals/RateRangeIndicatorViewModel' },
                    template: { require: 'text!webHtml/statichtml/deals/rate-range-indicator.html' },
                });

                ko.components.register('fx-component-economic-calendar-tool', {
                    deps: [
                        'LoadDictionaryContent!economicCalendarLongData',
                        'LoadDictionaryContent!economicCalendar',
                        'LoadDictionaryContent!economicCalendar_tools_static',
                    ],
                    viewModel: { require: 'viewmodels/EconomicCalendarViewModel' },
                    template: { require: 'text!partial-views/web-deals-dealcalendartool.html' },
                });

                ko.components.register('fx-component-instrument-info-tool', {
                    deps: ['LoadDictionaryContent!deals_DealMarketInfoTool'],
                    viewModel: { require: 'viewmodels/Deals/InstrumentInfoViewModel' },
                    template: { require: 'text!partial-views/web-deals-instrumentinfotool.html' },
                });

                ko.components.register('fx-component-cash-back', {
                    viewModel: { require: 'viewmodels/CashBackViewModel' },
                    template: { require: 'text!partial-views/web-deals-cashback.html' },
                    synchronous: true,
                });

                ko.components.register('fx-component-live-cash-back', {
                    viewModel: { require: 'viewmodels/BonusViewModel' },
                    template: { require: 'text!partial-views/web-deals-livecashback.html' },
                    synchronous: true,
                });

                ko.components.register('fx-component-spread-discount', {
                    viewModel: { require: 'viewmodels/BonusViewModel' },
                    template: { require: 'text!partial-views/web-deals-spreaddiscount.html' },
                    synchronous: true,
                });

                // Export data registrations
                ko.components.register('fx-component-export-buttons', {
                    viewModel: { require: 'viewmodels/PrintExportViewModel' },
                    template: { element: 'fx-template-export-buttons' },
                });

                ko.components.register('fx-component-export', {
                    viewModel: { require: 'viewmodels/PrintExportViewModel' },
                    template: { element: 'fx-template-export' },
                });

                ko.components.register('closed-deals', {
                    viewModel: { require: 'viewmodels/PrintExportViewModel' },
                    template: { require: 'text!partial-views/web-export-closeddeals.html' },
                });

                ko.components.register('account-statement', {
                    viewModel: { require: 'viewmodels/PrintExportViewModel' },
                    template: { require: 'text!partial-views/web-export-accountstatment.html' },
                });

                ko.components.register('activity-log', {
                    viewModel: { require: 'viewmodels/PrintExportViewModel' },
                    template: { require: 'text!partial-views/web-export-activitylog.html' },
                });

                ko.components.register('fx-component-accountcard-records', {
                    deps: ['LoadDictionaryContent!deals_AccountCardRecords'],
                    viewModel: { require: 'deviceviewmodels/AccountCardRecordsViewModel' },
                    template: { require: 'text!partial-views/web-deals-accountcardrecords.html' },
                });

                ko.components.register('fx-component-rolledover', {
                    viewModel: { require: 'deviceviewmodels/RolledOverViewModel' },
                    template: { require: 'text!partial-views/web-deals-rolledover.html' },
                });

                ko.components.register('fx-component-contract-rollover', {
                    viewModel: { require: 'deviceviewmodels/ContractRolloverViewModel' },
                    template: { require: 'text!partial-views/web-deals-contractrollover.html' },
                });

                ko.components.register('fx-component-personal-details', {
                    deps: ['LoadDictionaryContent!country_names'],
                    viewModel: { require: 'viewmodels/PersonalDetailsViewModel' },
                    template: { require: 'text!partial-views/web-customer-PersonalDetailsPartial.html' },
                });

                ko.components.register('fx-component-market-closed-view', {
                    viewModel: { require: 'viewmodels/MarketClosedViewModel' },
                    template: { element: 'fx-template-market-closed' },
                });

                ko.components.register('fx-schedule-group', {
                    deps: ['LoadDictionaryContent!schedulegrouphtml'],
                    viewModel: { require: 'viewmodels/Deals/ScheduleGroupViewModel' },
                    template: { require: 'text!html/statichtml/deals/schedule-group.html' },
                });

                ko.components.register('fx-component-netexposures-summary', {
                    viewModel: { instance: { VmNetExposure: ViewModelsManager.VmNetExposure } },
                    template: { require: 'text!partial-views/web-customer-netexposuresummary.html' },
                });

                if (ViewModelsManager.ReactComponentsEnabled()['fx-core-api/summaryView']) {
                    ko.components.register('fx-component-account-summary', {
                        react: 'fx-core-api/SummaryView',
                        deps: [
                            'LoadDictionaryContent!summaryview_accountsummary',
                            'LoadDictionaryContent!summaryview_exposures',
                        ],
                    });
                } else {
                    ko.components.register('fx-component-account-summary', {
                        viewModel: { require: 'viewmodels/WalletViewModel' },
                        template: { require: 'text!webHtml/statichtml/AcccountSummaryWallet.html' },
                        deps: [
                            'LoadDictionaryContent!summaryview_accountsummary',
                            'LoadDictionaryContent!summaryview_exposures',
                        ],
                    });
                }

                if (ViewModelsManager.ReactComponentsEnabled()['fx-core-api/quotesGrid']) {
                    ko.components.register('fx-component-quotes-grid', {
                        react: 'fx-core-api/QuotesView',
                        deps: ['LoadDictionaryContent!summaryview_quotesgrid'],
                    });
                }

                ko.components.register('fx-component-main-header', {
                    deps: ['LoadDictionaryContent!menus_mainmenu'],
                    viewModel: { require: 'viewmodels/menuviewmodel' },
                    template: { require: 'text!webHtml/statichtml/MainHeader.html' },
                });

                ko.components.register('fx-component-summary-view', {
                    viewModel: { instance: ViewModelsManager },
                    template: { element: 'fx-template-summary-view' },
                    deps: ['LoadDictionaryContent!summaryview_quotesgrid'],
                });

                ko.components.register('fx-component-control-title', {
                    deps: ['LoadDictionaryContent!general_controltitle'],
                    viewModel: { instance: ViewModelsManager },
                    template: { require: 'text!webHtml/statichtml/ControlTitle.html' },
                });

                ko.components.register('fx-component-page-title', {
                    deps: ['LoadDictionaryContent!general_pagetitle'],
                    viewModel: { instance: ViewModelsManager },
                    template: { require: 'text!webHtml/statichtml/PageTitle.html' },
                });

                ko.components.register('fx-component-validation', {
                    viewModel: { instance: ViewModelsManager },
                    template: { element: 'fx-template-validation' },
                });

                ko.components.register('fx-component-dialog-box', {
                    viewModel: { instance: ViewModelsManager },
                    template: { element: 'fx-template-dialog-box' },
                });

                ko.components.register('fx-component-modal-iframe', {
                    viewModel: { instance: ViewModelsManager },
                    template: { element: 'fx-template-modal-iframe' },
                });

                ko.components.register('fx-component-spinner-box', {
                    viewModel: { require: 'managers/SpinnerManager' },
                    template: { require: 'text!partial-views/web-customer-spinnerbox.html' },
                });

                ko.components.register('fx-component-footer', {
                    template: { element: 'fx-template-footer' },
                });

                ko.components.register('fx-custom-dropdown', {
                    viewModel: { require: 'viewmodels/CustomDropDown' },
                    template: { require: 'text!partial-views/web-navigation-customdropdown.html' },
                });

                ko.components.register('fx-component-change-password', {
                    viewModel: { require: 'viewmodels/ChangePasswordViewModel' },
                    template: {
                        require: 'text!account/changepasswordpartial?SuppressExpirationMessage=true&refresh=' + Date.now(),
                    },
                });

                ko.components.register('fx-component-open-deals-grid-tab-header', {
                    viewModel: { require: 'deviceviewmodels/OpenDealsViewModel' },
                    template: { element: 'fx-template-open-deals-grid-tab-header' },
                    deps: ['LoadDictionaryContent!tooltipsStaticResource'],
                });

                ko.components.register('fx-component-limits-grid-tab-header', {
                    viewModel: { require: 'deviceviewmodels/LimitsViewModel' },
                    template: { element: 'fx-template-limits-grid-tab-header' },
                });

                ko.components.register('fx-component-closed-deals-grid-tab-header', {
                    template: { element: 'fx-template-closed-deals-grid-tab-header' },
                });

                ko.components.register('fx-component-openeddeal-row', {
                    viewModel: { require: 'deviceviewmodels/OpenedDealRowViewModel' },
                    template: { require: 'text!webHtml/statichtml/deals/openeddeal-row.html' },
                    deps: ['LoadDictionaryContent!tooltipsStaticResource', 'LoadDictionaryContent!datagrids_opendeals'],
                });

                ko.components.register('fx-component-limits-grid', {
                    viewModel: { require: 'deviceviewmodels/LimitsViewModel' },
                    template: { require: 'text!partial-views/web-deals-limits.html' },
                    deps: ['LoadDictionaryContent!tooltipsStaticResource'],
                });

                ko.components.register('fx-component-price-alerts-grid', {
                    viewModel: { require: 'deviceviewmodels/PriceAlertsViewModel' },
                    template: { require: 'text!partial-views/web-limits-pricealerts.html' },
                });

                ko.components.register('fx-component-closed-deals-grid', {
                    deps: ['helpers/CustomKOBindings/NumericFieldBinding'],
                    viewModel: { require: 'deviceviewmodels/ClosedDealsViewModel' },
                    template: { require: 'text!partial-views/web-deals-closeddeals.html' },
                });

                ko.components.register('fx-component-account-closed-deals', {
                    viewModel: { require: 'deviceviewmodels/AccountClosedDealsViewModel' },
                    template: { require: 'text!partial-views/web-deals-closeddeals.html' },
                });

                ko.components.register('fx-component-deals-tabs', {
                    viewModel: { require: 'viewmodels/TabsViewModel' },
                    template: { element: 'fx-template-deals-tabs' },
                    deps: ['LoadDictionaryContent!tooltipsStaticResource'],
                });

                ko.components.register('fx-component-sort', {
                    viewModel: { require: 'viewmodels/SortStateViewModel' },
                    template: { require: 'text!webHtml/statichtml/sort-up-down-button.html' },
                });

                ko.components.register('fx-component-trading-signals', {
                    viewModel: { require: 'deviceviewmodels/Signals/TradingSignalsViewModel' },
                    template: { require: 'text!partial-views/web-signals-signals.html' },
                });

                ko.components.register('signals-alerts-grid', {
                    viewModel: { require: 'deviceviewmodels/Signals/SignalsAlertGridViewModel' },
                    template: { require: 'text!partial-views/web-signals-signalsalertsgrid.html' },
                });

                ko.components.register('signals-candle-stick-grid', {
                    viewModel: { require: 'deviceviewmodels/Signals/SignalsCandleStickGridViewModel' },
                    template: { require: 'text!partial-views/web-signals-signalscandlestickgrid.html' },
                });

                ko.components.register('signals-technical-analisis-grid', {
                    viewModel: { require: 'deviceviewmodels/Signals/SignalsTechnicalAnalisisGridViewModel' },
                    template: { require: 'text!partial-views/web-signals-signalstechnicalanalisisgrid.html' },
                });

                ko.components.register('signal-technical-analysis-full', {
                    viewModel: { require: 'deviceviewmodels/Signals/SignalTechAnalysisFullViewModel' },
                    template: { require: 'text!partial-views/web-signals-signaltechanalysisfull.html' },
                });

                ko.components.register('signals-service-grid', {
                    viewModel: { require: 'deviceviewmodels/Signals/SignalsServiceViewModel' },
                    template: { require: 'text!partial-views/web-signals-signalsservice.html' },
                });

                ko.components.register('signals-disclamer-grid', {
                    viewModel: { require: 'deviceviewmodels/Signals/SignalsDisclamerViewModel' },
                    template: { require: 'text!partial-views/web-signals-signalsdisclamer.html' },
                });

                ko.components.register('fx-notifications-settings', {
                    viewModel: { require: 'viewmodels/NotificationsSettingsViewModel' },
                    template: { require: 'text!partial-views/web-compliance-notificationssettings.html' },
                    deps: ['LoadDictionaryContent!compliance_NotificationsSettings'],
                });

                ko.components.register('fx-account-preferences', {
                    deps: ['LoadDictionaryContent!account_hub'],
                    viewModel: { require: 'viewmodels/AccountPreferencesViewModel' },
                    template: { require: 'text!partial-views/web-account-AccountPreferences.html' },
                });

                ko.components.register('fx-component-transaction-report', {
                    viewModel: { require: 'viewmodels/TransactionsReportViewModel' },
                    template: { require: 'text!webHtml/statichtml/Account/TransactionsReport.html' },
                });

                ko.components.register('fx-component-demo-deposit-icon', {
                    viewModel: { require: 'viewmodels/demoDeposit/demo-deposit-icon' },
                    template: { require: 'text!webHtml/statichtml/demoDeposit/demo-deposit-icon.html' },
                });

                ko.components.register('fx-component-demo-banner-openclosedeal', {
                    viewModel: { require: 'viewmodels/DemoBannerViewModel' },
                    template: { require: 'text!webHtml/statichtml/demoaccount-banner.html' },
                });

                ko.components.register('fx-component-chart', {
                    viewModel: { require: 'deviceviewmodels/ChartViewModel' },
                    template: { element: 'fx-template-chart-item' },
                });

                ko.components.register('fx-component-dropdown-instrument-search', {
                    deps: ['helpers/CustomKOBindings/AutocompleteBinding'],
                    viewModel: { require: 'deviceviewmodels/DropdownInstrumentSearchViewModel' },
                    template: { require: 'text!webHtml/statichtml/DropdownInstrumentSearch.html' },
                });

                ko.components.register('fx-component-tile-dropdown-instrument-search', {
                    deps: ['helpers/CustomKOBindings/AutocompleteBinding'],
                    viewModel: { require: 'deviceviewmodels/DropdownInstrumentSearchViewModel' },
                    template: { require: 'text!webHtml/statichtml/TileDropdownInstrumentSearch.html' },
                });

                ko.components.register('fx-component-closed-deals-instrument-search', {
                    deps: ['helpers/CustomKOBindings/AutocompleteBinding'],
                    viewModel: { require: 'deviceviewmodels/ClosedDealsInstrumentSearchViewModel' },
                    template: { require: 'text!webHtml/statichtml/ClosedDealsInstrumentSearch.html' },
                });

                ko.components.register('fx-component-preset-instrument-search', {
                    deps: ['helpers/CustomKOBindings/AutocompleteBinding'],
                    viewModel: { require: 'deviceviewmodels/PresetInstrumentSearchViewModel' },
                    template: { require: 'text!webHtml/statichtml/PresetInstrumentSearch.html' },
                });

                ko.components.register('fx-component-dropdown-presets', {
                    viewModel: { require: 'deviceviewmodels/PresetDropdownListViewModel' },
                    template: { require: 'text!webHtml/statichtml/PresetDropdownList.html' },
                });

                ko.components.register('fx-component-scroll', {
                    viewModel: { require: 'deviceviewmodels/ScrollComponentViewModel' },
                    template: { element: 'fx-scroll-bar-template' },
                });

                ko.components.register('fx-component-withdrawal', {
                    viewModel: { require: 'viewmodels/Withdrawal/WithdrawalViewModel' },
                    template: { require: 'text!partial-views/web-withdrawal-withdrawal.html' },
                });

                ko.components.register('fx-component-withdrawalbankdetails', {
                    viewModel: { require: 'viewmodels/Withdrawal/WithdrawalBankDetailsViewModel' },
                    template: { require: 'text!partial-views/web-withdrawal-withdrawalbankdetails.html' },
                });

                ko.components.register('fx-component-withdrawal-ccdetails', {
                    viewModel: { require: 'viewmodels/Withdrawal/WithdrawalCreditCardDetailsViewModel' },
                    template: { require: 'text!partial-views/web-withdrawal-withdrawalcreditcarddetails.html' },
                });

                ko.components.register('faq', {
                    viewModel: { require: 'viewmodels/Content/FaqQuestionViewModel' },
                    template: { require: 'text!webHtml/statichtml/content/content-faq-question.html' },
                });

                ko.components.register('fx-component-faq', {
                    viewModel: { require: 'viewmodels/questionnaire/FaqViewModel' },
                    template: { require: 'text!webHtml/statichtml/faq.html' },
                });

                ko.components.register('fx-component-faq-deposit', {
                    viewModel: { require: 'viewmodels/questionnaire/FaqViewModel' },
                    template: { require: 'text!webHtml/statichtml/faq.html' },
                    deps: ['LoadDictionaryContent!FAQDEPOSIT', 'LoadDictionaryContent!FAQDEPOSITTHANKYOU'],
                });

                ko.components.register('fx-component-support', {
                    viewModel: { require: 'viewmodels/questionnaire/SupportViewModel' },
                    template: { require: 'text!webHtml/statichtml/support.html' },
                });

                ko.components.register('fx-component-amount-spinner', {
                    viewModel: { require: 'viewmodels/AmountSpinnerFieldViewModel' },
                    template: { require: 'text!webHtml/statichtml/AmountSpinnerField.html' },
                });

                ko.components.register('fx-component-low-margin-spinner', {
                    viewModel: { require: 'viewmodels/LowMarginSpinnerViewModel' },
                    template: { require: 'text!webHtml/statichtml/LowMarginSpinnerField.html' },
                });

                ko.components.register('fx-component-search-country', {
                    deps: ['helpers/CustomKOBindings/AutocompleteBinding', 'LoadDictionaryContent!country_names'],
                    viewModel: { require: 'deviceviewmodels/SearchCountryViewModel' },
                    template: { require: 'text!webHtml/statichtml/SearchCountry.html' },
                });

                ko.components.register('fx-component-deposit-confirmation', {
                    deps: ['LoadDictionaryContent!compliance_DepositConfirmation'],
                    viewModel: { require: 'viewmodels/deposit/DepositConfirmationViewModel' },
                    template: { require: 'text!webHtml/statichtml/deposit/deposit-confirmation.html' },
                });

                ko.components.register('fx-component-electronic-signature', {
                    viewModel: { require: 'viewmodels/deposit/ElectronicSignatureViewModel' },
                    template: { require: 'text!webHtml/statichtml/deposit/electronic-signature.html' },
                });

                ko.components.register('fx-component-account-header', {
                    deps: ['LoadDictionaryContent!account_hub'],
                    viewModel: { require: 'viewmodels/accounthub/AccountHeaderViewModel' },
                    template: { require: 'text!webHtml/statichtml/AccountHub/AccountHeader.html' },
                });

                ko.components.register('fx-component-account-hub-countdown', {
                    deps: ['LoadDictionaryContent!account_hub'],
                    viewModel: { require: 'viewmodels/accounthub/AccountHubCountdownViewModel' },
                    template: { require: 'text!webHtml/statichtml/AccountHub/AccountHubCountdown.html' },
                });

                ko.components.register('fx-component-account-hub', {
                    deps: ['LoadDictionaryContent!account_hub'],
                    viewModel: { require: 'viewmodels/accounthub/AccountHubCardViewModel' },
                    template: { require: 'text!webHtml/statichtml/AccountHub/AccountHubCard.html' },
                });

                ko.components.register('fx-component-access-request-signals-details', {
                    deps: ['LoadDictionaryContent!accessRequest'],
                    viewModel: { require: 'viewmodels/AccessRequestViewModel' },
                    template: { require: 'text!webHtml/statichtml/Signals/SignalDetailsAccessRequest.html' },
                });

                ko.components.register('fx-component-access-request-signals', {
                    deps: ['LoadDictionaryContent!accessRequest'],
                    viewModel: { require: 'viewmodels/AccessRequestViewModel' },
                    template: { require: 'text!webHtml/statichtml/Signals/SignalsAccessRequest.html' },
                });

                ko.components.register('fx-component-extension-request-videolessons', {
                    deps: ['LoadDictionaryContent!accessRequest'],
                    viewModel: { require: 'viewmodels/AccessRequestViewModel' },
                    template: { require: 'text!webHtml/statichtml/Tutorials/VideoLessonsExtensionRequest.html' },
                });

                ko.components.register('fx-component-extension-request-tutorials', {
                    deps: ['LoadDictionaryContent!accessRequest'],
                    viewModel: { require: 'viewmodels/AccessRequestViewModel' },
                    template: { require: 'text!webHtml/statichtml/Tutorials/TutorialsExtensionRequest.html' },
                });

                ko.components.register('fx-component-trading-tutorials', {
                    deps: ['tutorials/tutorials'],
                    viewModel: { instance: ViewModelsManager },
                    template: { require: 'text!controllers/Tools/Tutorials/Pips' },
                });

                ko.components.register('fx-component-trading-educational-tutorials', {
                    deps: ['tutorials/tutorials'],
                    viewModel: { instance: ViewModelsManager },
                    template: { require: 'text!controllers/Tools/Tutorials/Educational' },
                });

                ko.components.register('fx-component-tutorials-pips-partial', {
                    deps: ['LoadDictionaryContent!accessRequest'],
                    viewModel: { require: 'deviceviewmodels/TutorialsViewModel' },
                    template: { require: 'text!controllers/Tools/Tutorials/_Tutorials' },
                });

                ko.components.register('fx-component-tutorials-educational-partial', {
                    deps: ['LoadDictionaryContent!accessRequest'],
                    viewModel: { require: 'deviceviewmodels/TutorialsViewModel' },
                    template: { require: 'text!controllers/Tools/Tutorials/_VideoLessons' },
                });

                ko.components.register('fx-component-pending-withdrawal', {
                    deps: ['LoadDictionaryContent!withdrawal_pendingwithdrawals'],
                    viewModel: { require: 'viewmodels/Withdrawal/PendingWithdrawalsViewModel' },
                    template: { require: 'text!webHtml/statichtml/Withdrawal/PendingWithdrawals.html' },
                });

                ko.components.register('account-summary-not-active', {
                    deps: ['LoadDictionaryContent!summaryview_accountsummary', 'LoadDictionaryContent!account_hub'],
                    viewModel: { require: 'viewmodels/AccountSummaryNotActiveViewModel' },
                    template: { require: 'text!webHtml/statichtml/AccountSummaryNotActive.html' },
                });

                if (configuration['fx-component-activation-slip'] === true) {
                    ko.components.register('fx-component-activation-slip', {
                        deps: ['LoadDictionaryContent!account_hub'],
                        viewModel: { require: 'deviceviewmodels/ActivationSlipViewModel' },
                        template: { require: 'text!webHtml/statichtml/ActivationSlip.html' },
                    });
                }

                ko.components.register('fx-balloon-validation', {
                    template: { require: 'text!webHtml/statichtml/balloon-validation.html' },
                });

                ko.components.register('fx-component-withdrawal-wrapper', {
                    template: { require: 'text!webHtml/statichtml/withdrawal-wrapper.html' },
                });

                ko.components.register('fx-component-navigation-wizard', {
                    deps: ['LoadDictionaryContent!navigationWizard'],
                    viewModel: { require: 'viewmodels/NavigationWizardViewModel' },
                    template: { require: 'text!webHtml/statichtml/navigation-wizard.html' },
                });

                ko.components.register('fx-component-amount-requested', {
                    deps: ['LoadDictionaryContent!withdrawal_withdrawalrequest'],
                    viewModel: { require: 'viewmodels/Withdrawal/AmountRequestedViewModel' },
                    template: { require: 'text!webHtml/statichtml/Withdrawal/amount-requested.html' },
                });

                ko.components.register('fx-component-withdrawal-amount', {
                    deps: ['LoadDictionaryContent!withdrawal_withdrawalrequest'],
                    viewModel: { require: 'deviceviewmodels/Withdrawal/Wizard/WithdrawalSetAmountViewModel' },
                    template: { require: 'text!webHtml/statichtml/withdrawal/wizard/withdrawal-setamount.html' },
                });

                ko.components.register('fx-component-withdrawal-method', {
                    deps: ['LoadDictionaryContent!withdrawal_withdrawalrequest'],
                    viewModel: { require: 'deviceviewmodels/Withdrawal/Wizard/WithdrawalSetMethodViewModel' },
                    template: { require: 'text!webHtml/statichtml/withdrawal/wizard/withdrawal-setmethod.html' },
                });

                ko.components.register('fx-component-withdrawal-setbankdetails', {
                    deps: [
                        'helpers/CustomKOBindings/AutocompleteBinding',
                        'LoadDictionaryContent!country_names',
                        'LoadDictionaryContent!withdrawal_withdrawalrequest',
                    ],
                    viewModel: { require: 'deviceviewmodels/Withdrawal/Wizard/WithdrawalSetbankdetailsViewModel' },
                    template: { require: 'text!webHtml/statichtml/withdrawal/wizard/withdrawal-setbankdetails.html' },
                });

                ko.components.register('fx-component-withdrawal-setccdetails', {
                    deps: [
                        'LoadDictionaryContent!withdrawal_withdrawalrequest',
                        'LoadDictionaryContent!payments_concreteView',
                        'LoadDictionaryContent!payments_concreteNames',
                    ],
                    viewModel: { require: 'deviceviewmodels/Withdrawal/Wizard/WithdrawalSetCCDetailsViewModel' },
                    template: { require: 'text!webHtml/statichtml/withdrawal/wizard/withdrawal-setccdetails.html' },
                });

                ko.components.register('fx-component-withdrawal-setapproval', {
                    deps: ['LoadDictionaryContent!views_vMobileWithdrawal', 'LoadDictionaryContent!country_names'],
                    viewModel: { require: 'deviceviewmodels/Withdrawal/Wizard/WithdrawalSetApprovalViewModel' },
                    template: { require: 'text!webHtml/statichtml/withdrawal/wizard/withdrawal-setapproval.html' },
                });

                ko.components.register('fx-component-withdrawal-thankyou', {
                    deps: [
                        'LoadDictionaryContent!navigationWizard',
                        'LoadDictionaryContent!withdrawal_withdrawalrequest',
                        'LoadDictionaryContent!Category',
                    ],
                    viewModel: { require: 'viewmodels/Withdrawal/WithdrawalThankYouViewModel' },
                    template: { require: 'text!webHtml/statichtml/withdrawal/withdrawal-thankyou.html' },
                });

                ko.components.register('fx-component-toolbar', {
                    viewModel: { require: 'deviceviewmodels/ToolbarViewModel' },
                    template: { require: 'text!webHtml/statichtml/toolbartemplate.html' },
                    deps: ['LoadDictionaryContent!Toolbar'],
                });

                ko.components.register('fx-component-help-center-action', {
                    viewModel: { require: 'viewmodels/HelpCenter/HelpCenterActionViewModel' },
                    template: { require: 'text!webHtml/statichtml/HelpCenter/help-center-action.html' },
                });

                ko.components.register('fx-component-help-center', {
                    deps: ['LoadDictionaryContent!HelpCenterWalkthroughs', 'LoadDictionaryContent!HelpCenterTradingGuide'],
                    viewModel: { require: 'deviceviewmodels/HelpCenterViewModel' },
                    template: { require: 'text!webHtml/statichtml/HelpCenter/help-center.html' },
                });

                ko.components.register('fx-confirm-documentverification', {
                    deps: [
                        'LoadDictionaryContent!compliance_UploadDocuments',
                        'LoadDictionaryContent!UploadDocumentsStatusPopUpMessages',
                    ],
                    viewModel: { require: 'deviceviewmodels/UploadDocuments/VerificationDocumentViewModel' },
                    template: { require: 'text!webHtml/statichtml/Compliance/confirm-verification-document.html' },
                });

                ko.components.register('fx-documentverification-modal', {
                    deps: ['LoadDictionaryContent!compliance_UploadDocuments'],
                    viewModel: { require: 'deviceviewmodels/UploadDocuments/VerificationDocumentModal' },
                    template: { require: 'text!webHtml/statichtml/Compliance/verification-document-modal.html' },
                });

                PaymentsConfiguration.RegisterDepositComponents();
                DealSlipsConfiguration.RegisterComponents(configuration);

                registerBackofficeComponents();
            }

            function registerBackofficeComponents() {
                window.enableTradingComponentRegistered = ko.observable(false);

                if (!systemInfo.get('hasTradingPermission')) {
                    return;
                }

                ko.components.unregister('fx-component-change-password');
                ko.components.register('fx-component-change-password', {
                    deps: ['LoadDictionaryContent!account_ChangePasswordPartial'],
                    viewModel: { require: 'viewmodels/ChangePasswordViewModel' },
                    template: { require: 'text!webHtml/statichtml/backoffice/ChangePassword.html' }
                });

                require(['configuration/EnableTradingConfiguration'],
                    function (enableTradingConfiguration) {
                        enableTradingConfiguration.RegisterComponents();
                        window.enableTradingComponentRegistered(true);
                    },
                    function doingNothing() {
                        return;
                    }
                );
            }

            function adjustCulture() {
                if (typeof Globalize !== 'undefined') {
                    var cultureInfo = {
                        numberFormat: {},
                    };

                    cultureInfo.numberFormat[','] = '';
                    Globalize.addCultureInfo('noThousandsSeparator', 'default', cultureInfo);
                    window.Globalize = Globalize;
                }

                return true;
            }

            return {
                AdjustCulture: adjustCulture,
                RegisterComponents: registerComponents,
                RegisterContentTemplateComponents: function () { },
                BindKO: bindKO,
                AdjustHtml: adjustHtml,
                AddPixel: addPixel,
                ExposeUI: exposeUI,
                UpdateScmmTrackingData: updateScmmTrackingData,
            };
        }

        return PlugInConfiguration();
    }
);


define("devicecustommodules/PostLoginAlertController", [
	"require",
	"knockout",
	"customEnums/ViewsEnums",
	"dataaccess/dalCommon",
	"enums/alertenums",
	"devicemanagers/AlertsManager",
	"devicemanagers/StatesManager",
	"initdatamanagers/Customer",
	"managers/viewsmanager",
	"Dictionary",
	"modules/environmentData",
	"viewmodels/dialogs/DialogViewModel",
	"StateObject!PostLoginAlerts",
],
    function PostLoginAlertControllerDef(require) {
	var ko = require("knockout"),
		dalCommon = require("dataaccess/dalCommon"),
		AlertsManager = require("devicemanagers/AlertsManager"),
		StatesManager = require("devicemanagers/StatesManager"),
		Customer = require("initdatamanagers/Customer"),
		ViewsManager = require("managers/viewsmanager"),
		Dictionary = require("Dictionary"),
		environmentData = require("modules/environmentData").get(),
		DialogViewModel = require("viewmodels/dialogs/DialogViewModel"),
		postLoginAlerts = require("StateObject!PostLoginAlerts");

        var PostLoginAlertController = function PostLoginAlertControllerClass() {
		var observablePostLoginAlertObject = {},
			self,
			silentMode = ko.observable(0),
			subscriptions = [];

		var silentModeEnum = {
			Off: 0,
			On: 1,
		};

		function init() {
			self = this;

			setComputedDisplayAlerts();

			subscribToCSFlags();
			subscribeToPortfolioFlags();
			subscribeToServerErrors();

			subscriptions.push(
				postLoginAlerts.subscribe("SetAlertsBehaviorMode", function (mode) {
                        silentMode(mode);
				})
			);
		}

		function alertNotDisplayedThisSession(alert) {
			alert.popCounter(alert.popCounter() + 1);

			if (alert.popCounter() < 2) {
				return true;
			}

			return false;
		}

		//---------------Client State Flags---------------
		function subscribToCSFlags() {
			StatesManager.States.ExposureCoverageAlert.subscribe(function (flagValue) {
				if (flagValue == eCSFlagStates.Active) {
					AlertsManager.UpdateAlert(PostClientStatesLoginsAlerts.ExposureCoverageAlert);

					var alert = AlertsManager.GetAlert(PostClientStatesLoginsAlerts.ExposureCoverageAlert);

					if (alertNotDisplayedThisSession(alert)) {
						AlertsManager.PopAlert(PostClientStatesLoginsAlerts.ExposureCoverageAlert);
					}
				}
			});

			StatesManager.States.SystemMode.subscribe(function (flagValue) {
				if (Customer.prop.isQA) {
					return;
				}

				switch (flagValue) {
					case 2:
						AlertsManager.UpdateAlert(PostClientStatesLoginsAlerts.SystemModeApplicationClosing);
						AlertsManager.PopAlert(PostClientStatesLoginsAlerts.SystemModeApplicationClosing);
						break;

					case 3:
						AlertsManager.UpdateAlert(PostClientStatesLoginsAlerts.SystemMode);
						AlertsManager.PopAlert(PostClientStatesLoginsAlerts.SystemMode);
						break;

					case 4:
						AlertsManager.UpdateAlert(PostClientStatesLoginsAlerts.SystemModeApplicationShutDown);
						AlertsManager.PopAlert(PostClientStatesLoginsAlerts.SystemModeApplicationShutDown);
						break;

					default:
						break;
				}
			});
		}

		//----------------Portfolio Flags-----------
		function subscribeToPortfolioFlags() {
			StatesManager.States.IsDemo.subscribe(function (flagValue) {
				if (environmentData.switchToPlatform === ePlatformSwitch.Demo && flagValue === true) {
					AlertsManager.UpdateAlert(PostPortfoliosLoginsAlerts.IsDemo);
					AlertsManager.PopAlert(PostPortfoliosLoginsAlerts.IsDemo);
				}
			});

			StatesManager.States.IsActive.subscribe(function () {
				if (environmentData.switchToPlatform === ePlatformSwitch.Real && Customer.prop.hasActiveDemo) {
					AlertsManager.UpdateAlert(PostPortfoliosLoginsAlerts.IsReal);
					AlertsManager.PopAlert(PostPortfoliosLoginsAlerts.IsReal);
				}
			});

			observablePostLoginAlertObject.displayAmlAlert.subscribe(function (flagValue) {
				if (flagValue === true) {
					var option = {
						title: Dictionary.GetItem("AMLStatus", "dialogsTitles", " "),
						closeOnEscape: false,
						width: 620,
						dialogClass: "fx-dialog amlPopup",
					};

					DialogViewModel.openAsync(
						eAppEvents.amlStatusLoadedEvent,
						eDialog.AmlStatus,
						option,
						eViewTypes.vAmlStatus,
						null
					);
				}
			});

			observablePostLoginAlertObject.displayCddKycAlert.subscribe(function (flagValue) {
				if (flagValue === true) {
					// redirect to cdd alert will be visible only if the aml has no status
					ViewsManager.SwitchViewVisible(eForms.ClientQuestionnaire);
				}
			});
		}

		function subscribeToServerErrors() {
			StatesManager.States.Forbidden.subscribe(function () {
				if (!Customer.isAuthenticated()) {
					return;
				}

				AlertsManager.UpdateAlert(
					AlertTypes.ServerResponseAlert,
					Dictionary.GetItem("GenericAlert", "dialogsTitles", " "),
					Dictionary.GetItem("Forbidden"),
					null
				);
				AlertsManager.PopAlert(AlertTypes.ServerResponseAlert);
			});

			StatesManager.States.ServerErrorStatus.subscribe(function (flagValue) {
				if (flagValue != eErrorSeverity.critical && !Customer.isAuthenticated()) {
					return;
				}

				switch (flagValue) {
					case eErrorSeverity.critical:
						dalCommon.Logout(eLoginLogoutReason.web_postLoginAlertController_serverError);
						break;

					case eErrorSeverity.high:
						AlertsManager.UpdateAlert(
							AlertTypes.SessionEndedAlert,
							Dictionary.GetItem("sessionEndedLogoutAlertTitle"),
							Dictionary.GetItem("sessionEndedLogout"),
							null,
							{
								onCloseAction: function () {
									dalCommon.Logout(eLoginLogoutReason.alert_exitApp);
								},
							}
						);
						AlertsManager.PopAlert(AlertTypes.SessionEndedAlert);
						break;

					case eErrorSeverity.medium:
						AlertsManager.UpdateAlert(
							AlertTypes.SessionEndedAlert,
							Dictionary.GetItem("sessionEndedAlertTitle"),
							Dictionary.GetItem("sessionEnded"),
							null
						);
						AlertsManager.PopAlert(AlertTypes.SessionEndedAlert);
						break;

					default:
						break;
				}
			});
		}

		function setComputedDisplayAlerts() {
			observablePostLoginAlertObject.displayCddKycAlert = ko.computed(function () {
				return StatesManager.States.shouldCddRedirect() && silentMode() === silentModeEnum.Off;
			}, self);

			observablePostLoginAlertObject.displayAmlAlert = ko.computed(function () {
				if (
					StatesManager.States.IsAmlRestricted() == true &&
					StatesManager.States.IsCddStatusNotComplete() == false &&
					StatesManager.States.IsActiveButNotSinceTradingBonus() == true &&
					silentMode() == silentModeEnum.Off
				) {
					return true;
				}

				return false;
			}, self);
		}

		function dispose() {
			subscriptions.forEach(function (subscriber) {
				subscriber();
			});
		}

		return {
			Init: init,
			SubscribToCSFlags: subscribToCSFlags,
			SubscribeToPortfolioFlags: subscribeToPortfolioFlags,
			SubscribeToServerErrors: subscribeToServerErrors,
			dispose: dispose,
		};
	};

	return new PostLoginAlertController();
});

var TDALRetention = function () {
    //-----------------------------------------------------------------
    // getToken
    //-----------------------------------------------------------------
    function getToken(onSuccess) {
        var ajaxer = new TAjaxer();

        var params = "";

        return ajaxer.promises.get(
            "TDALRetention/getToken",
            $customer.prop.interactiveMessagesToken,
            params,
            onSuccess,
            function (error) {
                ErrorManager.onError("TDALRetention/getToken", ErrorManager.getFullExceptionMessage(error), eErrorSeverity.high);
            },
            null, null, null, false
        );
    }
    return {
        GetToken: getToken
    };
};
define("dataaccess/dalRetention", ["generalmanagers/ErrorManager"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (em) {
				return this.TDALRetention(em);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TDALRetention;
    };
}(this)));


define("managers/RetentionManager", [
	"require",
	"knockout",
	"handlers/general",
	"handlers/Delegate",
	"modules/environmentData",
	"initdatamanagers/Customer",
	"dataaccess/dalRetention",
	"managers/viewsmanager",
	"StateObject!SessionSupervisor",
	"Q",
	"global/apiIM",
], function (require) {
	var ko = require("knockout"),
		general = require("handlers/general"),
		environmentData = require("modules/environmentData").get(),
		Customer = require("initdatamanagers/Customer"),
		dalRetention = require("dataaccess/dalRetention"),
		ViewsManager = require("managers/viewsmanager"),
		stateObject = require("StateObject!SessionSupervisor"),
		onSmartBannerDelegate = require("handlers/Delegate"),
		Q = require("Q"),
		apiIM = require("global/apiIM"),
		CurrentToken;

	var IMRequestIntervalModes = {
		PreLogin: -1,
		Login: 0,
		InSession: 1,
		AccountSwitch: 2,
	};

	function RetentionManager() {
		var onSmartBanner = new onSmartBannerDelegate(),
			isTokenReceived = Q.defer(),
			isApiImAlreadyInitialized = false;

		var subscribeToInteractiveMessage = function (token) {
			stateObject.set("userLoggedIn", false);

			stateObject.subscribe("userLoggedIn", function (value) {
				if (!isApiImAlreadyInitialized || value === true) {
					window.JSON2 = JSON;

					var requestIntervalMode;
					if (environmentData.switchToPlatform) {
						requestIntervalMode = IMRequestIntervalModes.AccountSwitch;
					} else if (value) {
						requestIntervalMode = IMRequestIntervalModes.Login;
					} else {
						requestIntervalMode = IMRequestIntervalModes.InSession;
					}

					var uiActionCallbacks = {
						deposit: depositCallback,
						accept: acceptCallback,
						walkthrough: walkThroughCallback,
						privacypolicy: privacypolicyCallback,
						imClosedDeals: imClosedDealsCallback,
						imOpenDeals: imOpenDealsCallback,
						imNewDeal: imNewDealCallback,
					};

					apiIM.InitAll(
						token,
						Customer.prop.interactiveMessagesUrl,
						Customer.prop.language,
						15000,
						uiActionCallbacks,
						requestIntervalMode,
						"false",
						invokeSmartBanner
					);
					apiIM.InitAll(
						token,
						Customer.prop.interactiveMessagesUrl,
						Customer.prop.language,
						36000000,
						uiActionCallbacks,
						IMRequestIntervalModes.InSession,
						"true",
						invokeSmartBanner
					);

					isApiImAlreadyInitialized = true;
				}
			});
		};

		var invokeSmartBanner = function () {
			var apiImArgs = general.argsToArray(arguments);
			onSmartBanner.Invoke.apply(null, apiImArgs);
		};

		var updateCurrentToken = function (responseText) {
			if (responseText.indexOf("ServerError") === -1 && general.containsHtmlTags(responseText) !== true) {
				CurrentToken = responseText;
				isTokenReceived.resolve(responseText);
			}
		};

		var updateToken = function () {
			return dalRetention.GetToken(updateCurrentToken);
		};

		var getCurrentToken = function () {
			return CurrentToken;
		};

		var depositCallback = function (args) {
			// go to deposit page
			sendRewardClickedEvent();

			if (!Customer.prop.isDemo) {
				ViewsManager.RedirectToForm(eForms.Deposit, {});
			}
		};

		var acceptCallback = function () {
			sendRewardClickedEvent();
		};

		var privacypolicyCallback = function () {
			sendRewardClickedEvent();
		};

		var imClosedDealsCallback = function () {
			sendRewardClickedEvent();
		};

		var imNewDealCallback = function () {
			sendRewardClickedEvent();
		};

		var imOpenDealsCallback = function () {
			sendRewardClickedEvent();
		};

		var walkThroughCallback = function () {
			if (typeof window.__walkthroughwidget != "undefined") window.__walkthroughwidget.play(2425);
		};

		var sendRewardClickedEvent = function () {
			ko.postbox.publish("reward-cta-clicked", {});
		};

		return {
			OnSmartBanner: onSmartBanner,
			SubscribeToInteractiveMessage: subscribeToInteractiveMessage,
			UpdateToken: updateToken,
			GetCurrentToken: getCurrentToken,
		};
	}

	return new RetentionManager();
});

function StorageFactory(storageType) {
	var inMemoryStorage = {},
		isNativeSupported = StorageFactory.isSupported(storageType),
		storage = (function () {
			if (isNativeSupported)
				switch (storageType) {
					case StorageFactory.eStorageType.session:
						return window.sessionStorage;
						break;
					case StorageFactory.eStorageType.local:
					default:
						return window.localStorage;
						break;
				}
		})();

	function getItem(_key) {
		if (isNativeSupported) {
			return storage.getItem(_key);
		}
		return inMemoryStorage[_key] || null;
	}

	function setItem(_key, _value) {
		if (isNativeSupported) {
			storage.setItem(_key, _value);
		} else {
			inMemoryStorage[_key] = _value;
		}
	}

	function removeItem(_key) {
		if (isNativeSupported) {
			storage.removeItem(_key);
		} else {
			delete inMemoryStorage[_key];
		}
	}

	function clear() {
		if (isNativeSupported) {
			storage.clear();
		} else {
			inMemoryStorage = {};
		}
	}

	function key(n) {
		if (isNativeSupported) {
			return storage.key(n);
		} else {
			return Object.keys(inMemoryStorage)[n] || null;
		}
	}

	return {
		getItem: getItem,
		setItem: setItem,
		removeItem: removeItem,
		clear: clear,
		key: key,
	};
}

StorageFactory.isSupported = function (storageType) {
	try {
		var storage = null;
		switch (storageType) {
			case StorageFactory.eStorageType.session:
				storage = window.sessionStorage;
				break;
			case StorageFactory.eStorageType.local:
			default:
				storage = window.localStorage;
				break;
		}
		var _key = "__tst_strg_key__";
		storage.setItem(_key, _key);
		storage.removeItem(_key);
		return true;
	} catch (e) {
		return false;
	}
};

StorageFactory.eStorageType = {
	local: 0,
	session: 1,
};

(function (root, factory) {
	if (typeof define === "function" && define.amd) {
		// AMD. Register as an anonymous module.
		define('global/storagefactory',[], factory);
	} else {
		// Browser globals
		root = factory();
	}
})(typeof self !== "undefined" ? self : this, function () {
	// Use b in some fashion.

	// Just return a value to define the module export.
	// This example returns an object, but the module
	// can return a function as the exported value.
	return StorageFactory;
});

define(
    'generalmanagers/SessionSupervisor',
    [
        'require',
        'JSONHelper',
        'dataaccess/dalCommon',
        'generalmanagers/ErrorManager',
        'generalmanagers/ShutDownHandler',
        'modules/systeminfo',
        'StateObject!SessionSupervisor',
        'StateObject!SystemNotificationEvents',
        'global/storagefactory',
        'enums/DataMembersPositions'
    ],
    function(require) {
        var JSONHelper = require('JSONHelper'),
            dalCommon = require('dataaccess/dalCommon'),
            ErrorManager = require('generalmanagers/ErrorManager'),
            ShutDownHandler = require('generalmanagers/ShutDownHandler'),
            systemInfo = require('modules/systeminfo'),
            stateObject = require('StateObject!SessionSupervisor'),
            stateObjectNotificationsEvents = require('StateObject!SystemNotificationEvents'),
            storageFactory = require('global/storagefactory');

        function SessionSupervisor() {
            var timer = null,
                timeout = 60000,
                stopAll = false,
                sessionStorage = storageFactory(storageFactory.eStorageType.session);

            function start() {
                stateObjectNotificationsEvents.set(eShutDownHandlerTopics.stopKeepAliveCalls, null);
                stateObjectNotificationsEvents.subscribe(eShutDownHandlerTopics.stopKeepAliveCalls, stopDataCalls);

                keepAlive();
            }

            function keepAlive() {
                if (!stopAll) {
                    dalCommon.KeepAlive(onKeepAliveComplete);
                }
            }

            function stopDataCalls() {
                stopAll = true;

                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            }

            function onKeepAliveComplete(responseText) {
                var response = JSONHelper.STR2JSON('SessionSupervisor/onKeepAliveComplete', responseText, eErrorSeverity.low);

                if (response && response.result != 'SecurityError' && response.result != 'ServerError') {
                    if (response.result[eKeepAlive.Success]) {
                        systemInfo.save('securityToken', response.securityToken);

                        stateObject.update('userLoggedIn', response.userLoggedIn);

                        if (response.isSessionGap) {
                            sessionStorage.removeItem('TrackingSessionId');
                        }

                        if (!stopAll) {
                            if (timer) {
                                clearTimeout(timer);
                                timer = null;
                            }

                            timer = setTimeout(keepAlive, timeout);
                        }
                    }
                    else {
                        switch (response.result[eKeepAlive.Error]) {
                            case eKeepAliveError.SessionMissingOrDuplicate:
                                ShutDownHandler.StopRunningServices();

                                require(['devicealerts/DoubleLoginAlert'], function showDoubleLoginAlert(DoubleLoginAlert) {
                                    DoubleLoginAlert.Show();
                                });                                
                                break;

                            case eKeepAliveError.HttpContextRequired:
                                ErrorManager.onError('Keepalive', 'HttpContextRequired', eErrorSeverity.low);
                                dalCommon.Login(eLoginLogoutReason.sessionSupervisor_keepAliveHttpContextRequired);
                                break;
                        }
                    }
                }
                else {
                    // not logout for caseses of rememeberme
                    dalCommon.Login(eLoginLogoutReason.sessionSupervisor_keepAliveCompleteError);
                }
            }

            return {
                Start: start
            };
        }

        return SessionSupervisor;
    }
);

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/datalayer', [], factory);
    } else {
        root.dataLayer = factory(root);
    }
}(typeof self !== 'undefined' ? self : this, function (root) {
    root = root || window;
    root.dataLayer = root.dataLayer || [];

    var _dataLayer = root.dataLayer,
        maxDataLayerLength = 350, //GTM has 300
        _isGTMActive;

    function isGTMEnabled() {
        if (typeof _isGTMActive !== 'boolean') {
            for (var idx = 0; idx < _dataLayer.length; idx++) {
                if (!_dataLayer[idx]) {
                    continue;
                }

                var event = _dataLayer[idx].event || '';

                if (0 === event.indexOf('gtm.')) {
                    _isGTMActive = true;
                    break;
                }
            }
        }

        _isGTMActive = _isGTMActive || false;

        return _isGTMActive;
    }

    function truncateDataLayer() {
        if (maxDataLayerLength > _dataLayer.length) {
            return;
        }

        //if GTM is loaded size is managed by him 
        if (isGTMEnabled()) {
            return;
        } else {
            for (; maxDataLayerLength < _dataLayer.length;)
                _dataLayer.shift();
        }
    }

    function _newPush() {
        var pushParams = [].slice.call(arguments, 0);

        var g = _dataLayer.originalPush.apply(_dataLayer, pushParams);

        //call subscribers
        _dataLayer.subscribers.forEach(function (f) {
            try {
                f.apply(this, pushParams);
            } catch (e) { }
        });

        truncateDataLayer();

        var h = ("boolean" !== typeof g) || g;
        return h;
    }

    _dataLayer.init = function () {

        _dataLayer.originalPush = _dataLayer.push;
        _dataLayer.push = _newPush;

        _dataLayer.subscribers = [];
        _dataLayer.subscribers.originalPush = _dataLayer.subscribers.push;

        _dataLayer.subscribers.push = function (s) {
            if (0 > _dataLayer.subscribers.indexOf(s)) {
                var pushParams = [].slice.call(arguments, 0);
                _dataLayer.subscribers.originalPush.apply(_dataLayer.subscribers, pushParams);
            }
        }
    }

    return _dataLayer;
}));
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/googleTagManager', ['tracking/loggers/datalayer'], factory);
    } else {
        root.googleTagManager = factory(root.dataLayer);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer) {
    var googleTagManagerAccountId;

    function init(gAccId) {
        googleTagManagerAccountId = gAccId;
        doGoogleTagManager();
    }

    function startChat() {
        try {
            dataLayer.push({ "event": "start-chat" });
        } catch (ex) {
            ErrorManager.onError('startChat', 'Google Tag Manager has failed', eErrorSeverity.low);
        }
    }

    function configAttributes(oAttributes) {
        ko.postbox.publish(eFxNetEvents.GtmConfigurationSet, oAttributes);
    }

    function doGoogleTagManager() {

        var w = window;
        var d = document;
        var s = 'script';
        var l = 'dataLayer';
        var i = googleTagManagerAccountId;

        w[l] = w[l] || [];
        w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
        var f = d.getElementsByTagName(s)[0],
            j = d.createElement(s),
            dl = l != 'dataLayer' ? '&l=' + l : '';
        j.async = true;
        j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);

    }

    window.googleTagManager = {
        Init: init,
        StartChat: startChat,
        ConfigAttributes: configAttributes
    }

    return window.googleTagManager;
}));
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('tracking/loggers/gglanalitycsconfigs', [], factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.gglAnalitycsConfigs = factory();
    }
}(typeof self !== 'undefined' ? self : this, function () {
    
    var eventSections = {
        'login-view': 'Login',
        'switch-tab': 'Market Watch',
        'account-summary-advanced': 'Account Summary',
        'account-summary-interaction': 'Account Summary',
        'account-summary-simple': 'Account Summary',
        'cancel-limit': 'Limits',
        'change-currency': 'General',
        'change-language': 'General',
        'close-deal-success': 'Deal',
        'deal-slip-dragged': 'Deal',
        'deal-slip-error': 'Deal',
        'deal-slip-interaction': 'Deal',
        'deal-slip-submit': 'Deal',
        'deal-slip-success': 'Deal',
        'deal-slip-view': 'Deal',
        'deposit-error': 'Deposit',
        'deposit-interaction': 'Deposit',
        'deposit-submit': 'Deposit',
        'deposit-success': 'Depost',
        'deposit-view': 'Deposit',
        'forgot-password-error': 'Password',
        'forgot-password-interaction': 'Password',
        'forgot-password-submit': 'Password',
        'forgot-password-success': 'Password',
        'forgot-password-view': 'Password',
        'help-click': 'Help',
        'hide-help-center': 'Help',
        'information-maximize': 'Market Watch',
        'information-minimize': 'Market Watch',
        'instrument-advanced': 'Market Watch',
        'instrument-simple': 'Market Watch',
        'interaction': 'General',
        'login-error': 'Login',
        'login-interaction': 'Login',
        'login-submit': 'Login',
        'login-success': 'Login',
        'net-exposure-one-currency': 'Account Summary',
        'net-exposure-original-currency': 'Account Summary',
        'new-limit-dragged': 'Limits',
        'new-limit-error': 'Limits',
        'new-limit-submit': 'Limits',
        'new-limit-success': 'Limits',
        'new-limit-view': 'Limits',
        'registration-error': 'Registration',
        'registration-interaction': 'Registration',
        'registration-submit': 'Registration',
        'registration-success': 'Registration',
        'registration-view': 'Registration',
        'request-new-password-error': 'Password',
        'request-new-password-interaction': 'Password',
        'request-new-password-submit': 'Password',
        'request-new-password-view': 'Password',
        'show-help-center': 'Help',
        'sign-out': 'General',
        'update-limit': 'Limits',
        'walkthrough-ended': 'Walkthrough',
        'walkthrough-show-step': 'Walkthrough',
        'walkthrough-started': 'Walkthrough',
        'withdrawal-cancel': 'withdrawal',
        'withdrawal-interaction': 'withdrawal',
        'withdrawal-print': 'withdrawal',
        'withdrawal-submit': 'withdrawal',
        'withdrawal-success': 'withdrawal',
        'withdrawal-view': 'withdrawal',
        'account-type-view': 'Registration',
        'withdrawal-error': 'withdrawal',
        'demo-click': 'Registration',
        'real-click': 'Registration',
        'agreement-view': 'General',
        'request-new-password-success': 'Password',
        'message-clicked': 'Messages',
        'message-view': 'Messages',
        'instrument-show-more': 'Instrument',
        'instrument-show-less': 'Instrument',
        'filter-apply': 'General',
        'SmartBannerDeposit': 'Messages',
        'SmartBannerViewOfferButtonCallback': 'Messages'
    };
    var viewNames = {
        '1': 'Main',
        '2': 'Open Deals',
        '3': 'Limits',
        '4': 'Closed Deals',
        '5': 'Account Statement',
        '6': 'Deposit',
        '7': 'Withdrawal',
        '8': 'Activity Log',
        '9': 'Personal Details',
        '10': 'Financial Details',
        '11': 'Change Password',
        '12': 'View and Print Withdrawal',
        '13': 'Transaction Report',
        '14': 'Upload Documents',
        '15': 'Trading Signals',
        '16': 'Third Party',
        '17': 'Chart Analysis',
        '18': 'Binary Options',
        '19': 'Tutorials',
        '20': 'Education',
        '21': 'Charts',
        '22': 'CDD Financial Details'
    };

    function getSection(eventName) {
        return eventSections[eventName] || 'None';
    }

    function getName(viewId) {
        return viewNames[viewId] || viewId;
    }

    return {
        GetSection: getSection,
        GetName: getName
    };
}));
/*global trackingData */
(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        define("tracking/loggers/fxeventslogger",
            [
                "tracking/loggers/datalayer",
                "tracking/loggers/gglanalitycsconfigs"
            ],
            factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.fxEventsLogger = factory(root.dataLayer, root.fxTracking.gglAnalitycsConfigs);
    }
}(typeof self !== "undefined" ? self : this, function (dataLayer, gglAnalyticsConfig) {
    var ignoredEvents = [
        "fb-ready",
        "create-helpwidget",
        "load-google-analytics",
        "trackingdata-loaded",
        "interaction",
        "hotjar-init",
        "self-activation-user"
    ];
    var interactionViews = [2, 3, 4, 6, 9, 15, 17, 18, 19, 20, 21];
    var interactionEvents = ["deal-slip-interaction", "account-summary-interaction", "new-limit-view"];

    var biServiceURL;

    function _e2vp(eventSection, eventAction, eventName, eventCategory, viewId) {
        // maps events to virtual page views (there are cases we want to send the event as a pageview for different reasons)
        if (eventSection == "Help" && eventAction == "Show")
            return "vp_help-widget-start";
        if (eventName == "questionnaire-navigation") {
            switch (eventCategory) {
                case "Cdd part 1":
                    return "vp_cdd-page-1";
                case "Cdd part 2":
                    return "vp_cdd-page-2";
                case "Kyc":
                    return "vp_cdd-submit";
            }
        }
        if (eventName == "View" && (viewId == 10 || viewId == 27))
            return "vp_cdd-start";
        if (eventName.match(/^agreement/) && (viewId == 6 || viewId == 15))
            return "vp_missing-information" + eventName.replace(/^agreement/, "");
        if (eventName.match(/^deposit/)) return "vp_" + eventName;
        return null;
    }

    function trace() {
        try {
            /*console.info.apply(console, arguments);*/
        } catch (e) { /*console && console.error(arguments); */ }
    }

    function getproperties(eventname) {
        // returns an object with all the properties that were sent along with the event
        var i = dataLayer.length;
        while (i--) {
            if (dataLayer[i].event && dataLayer[i].event == eventname) {
                var obj = {};
                for (var x in dataLayer[i]) {
                    if (x != "event") obj[x] = dataLayer[i][x];
                }
                return obj;
            }
        }
        return {};
    }

    function dataLayerEventHandler(obj) {
        var eventName = obj.event;
        if (eventName.match(/^[gtm|_]/ig) || (eventName === "interaction" && obj.artificial === true)) {
            return;
        }

        var viewId = obj.ViewId,
            eventSection = gglAnalyticsConfig.GetSection(eventName),
            eventAction = obj.action,
            eventCategory = obj.category,
            interactionView = interactionViews.indexOf(viewId) >= 0,
            interactionEvent = interactionEvents.indexOf(eventName) >= 0,
            ignoreEvent = ignoredEvents.indexOf(eventName) >= 0;

        window.__gaq = window.__gaq || function () {
            window.__gaq.q = window.__gaq.q || [];
            window.__gaq.q.push(arguments);
        };

        try {
            var eventdata = getproperties(eventName);

            // look for the TrackingSessionId and store it in localStorage in case later events will be sent without it
            if (eventdata.TrackingSessionId) {
                window.sessionStorage.setItem("TrackingSessionId", eventdata.TrackingSessionId);
            } else {
                eventdata.TrackingSessionId = window.sessionStorage.getItem("TrackingSessionId");
            }

            // check if SAProcess is passed with the event and store for later use (not all events are sent with the SAProcess)
            if (eventdata.SAProcess) {
                window.sessionStorage.setItem("SAProcess", eventdata.SAProcess);
            } else {
                eventdata.SAProcess = window.sessionStorage.getItem("SAProcess");
            }

            var eventname = eventName;

            if (!eventname || (typeof eventname !== "string") || (eventname.replace(/ /g, "") == "")) {
                dataLayer.push({ event: "unknown" });
                return;
            }

            // look for the ChatBot agent name in the 'personalguide4helpcenter-ready' events
            if (eventName == "personalguide4helpcenter-ready") {
                var agentName = obj.agentName;

                if (agentName && typeof window.hj !== "undefined") {
                    window.__gaq("send", "pageview", "/virtual-pages/" + agentName);
                    window.hj("tagRecording", [agentName]);
                }
            }

            // add the account number to the event
            var accountnumber = trackingData.getProperties().AccountNumber;
            if (accountnumber) eventdata.AccountNumber = accountnumber;

            // when we initiate the Google Analytics tag we also store in memory (window._gadimensions) the list of dimensions we should send back to Google Analytics with each event
            try {
                if (window._gadimensions) {
                    var properties = trackingData.getProperties();
                    var dimensions = {};
                    for (var i in window._gadimensions) {
                        if (typeof window._gadimensions[i] !== "string") continue;
                        if (properties[window._gadimensions[i]]) {
                            dimensions["dimension" + i] = properties[window._gadimensions[i]];
                            delete window._gadimensions[i];
                        }
                    }

                    if (typeof window.hj !== "undefined") {
                        // if HotJar is present, save userId into dimension14 in Google Analytics
                        try {
                            dimensions["dimension14"] = window.hj.pageVisit.property.get("userId");
                        } catch (e) { /*console && console.error(arguments); */ }
                    }
                    window.__gaq("set", dimensions);
                }
            } catch (e) { /*console && console.error(arguments); */ }

            if (eventName == "registration-interaction" && document.location.href.match(/\/Confirm/)) {
                // if here, we should be able to grab the UserWithExperience checkbox. Store it in localStorage for later use
                var userWithExperience = document.getElementsByName(
                    "UserWithExperience"
                );
                if (userWithExperience.length > 0) {
                    for (var idx = 0; idx < userWithExperience.length; idx++) {
                        if (userWithExperience[idx].checked) {
                            window.sessionStorage.setItem(
                                "hasExperience",
                                userWithExperience[idx].value
                            );
                            break;
                        }
                    }
                }
            } else if (trackingData.getProperties().SAProcess) {
                // if SA user, send virtual page with the user's experience
                var hasExperience = window.sessionStorage.getItem("hasExperience");
                window.sessionStorage.removeItem("hasExperience");
                if (hasExperience) {
                    window.__gaq("set", "dimension12", hasExperience);
                    window.__gaq("send", "pageview", "/virtual-pages/vp_experience_" + (hasExperience == "True" ? "true" : "false"));

                    try {
                        window.hj =
                            window.hj ||
                            function () {
                                (window.hj.q = window.hj.q || []).push(arguments);
                            };
                        window.hj("tagRecording", [
                            "vp_experience_" + (hasExperience == "True" ? "true" : "false")
                        ]);
                    } catch (e) {
                        trace();
                    }
                }
            }

            if (eventName == "View") {
                var gglViewName = gglAnalyticsConfig.GetName(viewId);

                window.__gaq("set", {
                    page: "/view/" + viewId + "/" + gglViewName,
                    title: gglViewName
                });
                window.__gaq("send", "pageview");
                eventdata["ItemName"] = gglViewName;
            } else if (eventSection != "None") {
                var eventLabel = eventName === "demo-click" ? "Practice" : eventName === "real-click" ? "Real" : "";

                if (eventSection == "Help" && eventAction == "Click") {
                    var itemName = itemName;
                    var itemType = itemType;
                    if (itemName || itemType)
                        eventLabel += (itemName || "") + " " + (itemType || "");
                }

                window.__gaq("send", "event", eventSection, eventAction, eventLabel);
            }

            var virtualpage = _e2vp(eventSection, eventAction, eventName, eventCategory, viewId);

            if (virtualpage) {
                window.__gaq("send", "pageview", "/virtual_pages/" + virtualpage);
                if (typeof window.hj !== "undefined") {
                    window.hj("tagRecording", [virtualpage]);
                }
            }

            if (!ignoreEvent) {
                var props = [];
                for (var d in eventdata) {
                    props.push(d + "=" + eventdata[d]);
                }
                var img = new Image();
                img.src = biServiceURL + "?name=" + eventname + "&" + props.join("&") + "&random=" + Math.random();
            }

            if (eventName != "interaction" &&
                ((eventName == "View" && interactionView) || interactionEvent)) {
                dataLayer.push({ event: "interaction", artificial: true });
            }
        } catch (e) {
            /*console.error("error in general", e);*/
        }
    }

    function init(_biServiceUrl) {
        biServiceURL = _biServiceUrl;

        dataLayer.subscribers.push(dataLayerEventHandler);
    }

    return {
        init: init
    };
}));
/*global trackingData */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/fbeventslogger', ['tracking/loggers/datalayer'], factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.fbEventsLogger = factory(root.dataLayer);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer) {

    function loadFB(f, b, e, v, n, t, s) {
        if (!f.fbq) {// return;
            n = f.fbq = function () {
                n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments);
            };
            if (!f._fbq) f._fbq = n;
            n.push = n;
            n.loaded = !0;
            n.version = "2.0";
            n.queue = [];
            t = b.createElement(e);
            t.async = !0;
            t.src = v;
            s = b.getElementsByTagName(e)[0];
            s.parentNode.insertBefore(t, s);

            f.fbq('init', '871141973245420');
            f.fbq('track', "PageView");

            dataLayer.push({ "event": "fb-ready" });
        }

        if (window["fbq"]) {
            window.fbq("track", "ViewContent", {
                value: trackingData.getProperties().NumberOfDeposits
            });
        }
    }

    function dataLayerEventHandler(obj) {
        if (!(obj && obj.event && obj.event && obj.event.toLowerCase() == 'login-success')) {
            return;
        }

        loadFB(window, document, "script", "//connect.facebook.net/en_US/fbevents.js");
    }

    function init() {
        if (0 > dataLayer.indexOf(function (e) { return e.event && e.event && e.event.toLowerCase() === 'login-success' })) {
            dataLayer.subscribers.push(dataLayerEventHandler);
        } else {
            loadFB(window, document, "script", "//connect.facebook.net/en_US/fbevents.js");
        }
    }

    return {
        init: init
    };
}));


/*global trackingData */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/hotjareventslogger', ['tracking/loggers/datalayer',
            'LoadDictionaryContent!HotJarConfig', 'handlers/Logger', 'Q', 'handlers/Cookie'
        ], factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.hotJarEventsLogger = factory(root.dataLayer, root.fxTracking.trackingConfig.hotjarconfig, root.Logger);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer, hotJarConfig, logger, Q, cookieHandler) {
    var attempts = 0,
        MAX_ATTEMPS = 40,
        TIMEOUT = 250,
        deferer = Q ? Q.defer() : null,
        alreadyStarted = false;

    function waitForTrackingData() {
        attempts += 1;
        if (attempts > MAX_ATTEMPS || alreadyStarted) return;

        alreadyStarted = true;

        if (
            typeof trackingData == "undefined" ||
            typeof trackingData.getProperties == "undefined"
        ) {
            window.setTimeout(waitForTrackingData, TIMEOUT, true);
        } else {
            try {
                (function (h, o, t, j, a, r) {
                    h.hj = h.hj || function () { (h.hj.q = h.hj.q || []).push(arguments); };
                    h._hjSettings = { hjid: hotJarConfig.hjid, hjsv: hotJarConfig.hjsv, hjdebug: hotJarConfig.hjdebug };
                    if (cookieHandler && "1" === cookieHandler.ReadCookie("fx-enable-hjdebug")) {
                        h._hjSettings.hjdebug = true;
                    }
                    a = o.getElementsByTagName("head")[0];
                    r = o.createElement("script");
                    r.async = 1;
                    r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
                    r.onload = function () {
                        logger.warn('tracking/loggers/hotjareventslogger', 'hotjar loaded');
                        if (deferer) {
                            deferer.resolve();
                        }
                    };
                    r.onerror = function (evnt) {
                        logger.warn('tracking/loggers/hotjareventslogger', 'hotjar script load faill', null, 2);
                        if (deferer) {
                            deferer.reject();
                        }
                    };
                    a.appendChild(r);
                })(window, document, "//static.hotjar.com/c/hotjar-", ".js?sv=");
            } catch (e) {
                logger.warn({ e: e });
                if (deferer) {
                    deferer.reject();
                }
            }
        }
    }

    function dataLayerEventHandler(obj) {
        if (attempts > 0 || !(obj && obj.event === 'hotjar-init')) {
            return;
        }

        waitForTrackingData();
    }

    function init(now) {
        if (hotJarConfig.hjid && hotJarConfig.hjid !== '#') {
            if (now)
                waitForTrackingData();//
            else
                dataLayer.subscribers.push(dataLayerEventHandler);
        }

        if (deferer)
            return deferer.promise;
    }

    return {
        init: init
    };
}));


/*global trackingData, SnapEngage, isNullOrUndefined */
(function (root, factory) {

    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/snapengagechat', ['tracking/loggers/datalayer',
            'LoadDictionaryContent!SnapEngageConfig', 'handlers/general', 'trackingIntExt/TrackingData'
        ], factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.snapEngageChat = factory(root.dataLayer, root.fxTracking.trackingConfig.snapengageconfig, { isNullOrUndefined: isNullOrUndefined }, root.trackingData);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer, snapEngageConfig, general, trackingData) {
    function isSAUser() {
        var sauser;
        try {
            sauser = window.localStorage.getItem("sauser");
        } catch (e) { }

        if (document.location.search.match(/sauser=true/) ||
            trackingData.getProperties().SAProcess ||
            !!sauser) {
            return true;
        }

        return false;
    }

    function getSnapEngageWidgetId() {
        if (isSAUser() && snapEngageConfig.SnapEngageWidgetID_sauser) {
            return snapEngageConfig.SnapEngageWidgetID_sauser
        }

        return snapEngageConfig.SnapEngageWidgetID;
    }

    function getCallbackWidgetId() {
        return snapEngageConfig.CallbackWidgetId
    }

    function loadSnapEngage() {
        var se = document.createElement("script"),
            SnapEngageWidgetId = getSnapEngageWidgetId();

        se.type = "text/javascript";
        se.async = true;
        se.src = "//storage.googleapis.com/code.snapengage.com/js/" + SnapEngageWidgetId + ".js";
        var done = false;
        se.onload = se.onreadystatechange = function () {
            if (
                !done &&
                (!this.readyState ||
                    this.readyState === "loaded" ||
                    this.readyState === "complete")
            ) {
                done = true;
                if (general.isNullOrUndefined(SnapEngageWidgetId)) {
                    var accountNumber = trackingData.getProperties().AccountNumber;
                    if (!general.isNullOrUndefined(accountNumber) && !general.isNullOrUndefined(SnapEngage)) {
                        SnapEngage.setUserName(trackingData.getProperties().AccountNumber);
                        SnapEngage.setUserEmail(accountNumber + "@trader.com");
                    }
                }
            }
        };
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(se, s);
    }

    function dataLayerEventHandler(obj) {
        if (!(obj && obj.event) ||
            (0 > ['start-chat', 'start-callback-request-chat', 'start-proactive-chat'].indexOf(obj.event)) ||
            typeof SnapEngage == "undefined") {

            return;
        }

        var ipCountry = trackingData.getProperties().IPCountry;

        switch (obj.event) {
            case 'start-chat':
                if (ipCountry.match(/(Poland|Italy|France|Spain|Greece|Holland|Germany)/i)) {
                    SnapEngage.setWidgetId(getCallbackWidgetId());
                } else {
                    SnapEngage.setWidgetId(getSnapEngageWidgetId());
                }
                SnapEngage.startLink();
                break;
            case 'start-callback-request-chat':
                try {
                    SnapEngage.setWidgetId(getCallbackWidgetId());
                    SnapEngage.startLink();
                } catch (e) { /*console && console.error(arguments); */ }
                break;
            case 'start-proactive-chat':
                var message = obj['snapengage_message'];
                SnapEngage.openProactiveChat(true, false, message);
                break;
        }
    }

    var attempts = 0;
    function waitForTrackingData() {
        attempts += 1;
        if (attempts > 40) return;

        if (
            typeof trackingData == "undefined" ||
            typeof trackingData.getProperties == "undefined"
        ) {
            window.setTimeout(waitForTrackingData, 250);
        } else {
            loadSnapEngage();

            dataLayer.subscribers.push(dataLayerEventHandler);
        }
    }

    function init() {
        if (!window.SnapEngage) {
            if (document.readyState === 'loading') {  // Loading hasn't finished yet
                document.addEventListener('DOMContentLoaded', waitForTrackingData);
            } else {  // `DOMContentLoaded` has already fired
                waitForTrackingData();
            }
        }
    }

    return {
        init: init
    };
}));
/*global trackingData*/
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/pagenocaptcha', ['tracking/loggers/datalayer', 'tracking/loggers/gglanalyticslogger'], factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.pageNoCaptcha = factory(root.dataLayer);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer) {
    function init() {
        var attempts = 0;
        var waitForAccountNumber = function () {
            attempts += 1;
            if (attempts > 40) return;
            if (
              typeof trackingData == "undefined" ||
              typeof trackingData.getProperties == "undefined" ||
              typeof trackingData.getProperties().AccountNumber == "undefined"
            ) {
                window.setTimeout(waitForAccountNumber, 250);
            } else {
                var data;
                if (trackingData.getProperties().SAProcess) {
                    var userid = trackingData.getProperties().AccountNumber;
                    data = {
                        event: "load-google-analytics",
                        gauserid: userid,
                        gaclientid: ""
                    };
                } else {
                    data = {
                        event: "load-google-analytics",
                        gauserid: "",
                        gaclientid: ""
                    };
                }

                dataLayer.push(data);
            }
        };

        if (null === window.location.href.match(/\/Parse/i)) {
            if (document.location.href.match(/\/login/i)) {
                if (document.location.search.match(/sauser=true/)) {
                    try {
                        window.localStorage.setItem("sauser", true);
                    } catch (e) { }
                }

                var gaclientid = "";
                try {
                    gaclientid = window.localStorage.getItem("gaclientid") || "";
                } catch (e) { }
                var data = {
                    event: "load-google-analytics",
                    gauserid: "",
                    gaclientid: gaclientid
                };

                dataLayer.push(data);
            } else {
                waitForAccountNumber();
            }
        }
    }

    return {
        init: init
    };
}));

/*global trackingData*/
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/pagewithcaptcha',
            ['tracking/loggers/datalayer', 'tracking/loggers/gglanalyticslogger'],
            factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.pageWithCaptcha = factory(root.dataLayer);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer) {
    function init() {
        var attempts = 0;

        var waitForMeta = function () {
            attempts += 1;
            if (attempts > 40) return;
            if (
              typeof trackingData == "undefined" ||
              typeof trackingData.getProperties == "undefined" ||
              typeof trackingData.getProperties().Meta == "undefined"
            ) {
                window.setTimeout(waitForMeta, 250);
            } else {
                var meta = trackingData.getProperties().Meta;
                if (meta.gaclientid) {
                    try {
                        window.localStorage.setItem("gaclientid", meta.gaclientid);
                    } catch (e) { }
                }
                var data = {
                    event: "load-google-analytics",
                    gauserid: "",
                    gaclientid: meta.gaclientid || ""
                };

                dataLayer.push(data);
            }
        };

        if (null !== window.location.href.match(/\/Parse/i)) {
            waitForMeta();
        }
    }

    return {
        init: init
    };
}));

/*global trackingData */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/gglanalyticslogger', [
            'tracking/loggers/datalayer',
            'tracking/loggers/pagenocaptcha',
            'tracking/loggers/pagewithcaptcha'
        ], factory);
    } else {
        root.fxTracking = root.fxTracking || {};
        root.fxTracking.gglAnalyticsLogger = factory(root.dataLayer, root.fxTracking.pageNoCaptcha, root.fxTracking.pageWithCaptcha);
    }
}(typeof self !== 'undefined' ? self : this, function (dataLayer, pageNoCaptcha, pageWithCaptcha) {

    function _loadAnalytics() {
        // store the name of the Analytics object
        window.GoogleAnalyticsObject = 'ga';

        // check whether the Analytics object is defined
        if (!('ga' in window)) {

            // define the Analytics object
            window.ga = function () {

                // add the tasks to the queue
                window.ga.q.push(arguments);

            };

            // create the queue
            window.ga.q = [];

        }

        // store the current timestamp
        window.ga.l = (new Date()).getTime();

        // create a new script element
        var script = document.createElement('script');
        script.src = '//www.google-analytics.com/analytics.js';
        script.async = true;

        // insert the script element into the document
        var firstScript = document.getElementsByTagName('script')[0];
        firstScript.parentNode.insertBefore(script, firstScript);
    }

    function loadAnalytics(obj) {
        if (!(obj && obj.event === 'load-google-analytics')) {
            return;
        }

        _loadAnalytics();

        var gaclientid = obj.gaclientid || '',
            gauserid = obj.gauserid || '',
            sauser;
        try {
            sauser = window.localStorage.getItem("sauser");
        } catch (e) { }

        if (gaclientid != "") {
            window.ga("create", "UA-20661807-41", {
                clientId: gaclientid
            });
        } else if (gauserid != "") {
            window.ga("create", "UA-20661807-41", "auto", {
                userId: gauserid
            });
        } else if (sauser) {
            window.ga("create", "UA-20661807-41", "auto");
        } else {
            window.ga("create", "UA-20661807-28", "auto");
        }

        if (typeof window.__gaq != "undefined") {
            if (window.__gaq.q) {
                for (var i = 0; i < window.__gaq.q.length; i++) {
                    window.ga.apply(window, window.__gaq.q[i]);
                }
            }
        }

        window.__gaq = function () {
            window.ga.apply(window, arguments);
        };

        try {
            var properties = trackingData.getProperties();
            if (properties.AccountNumber) {
                window._gadimensions = {
                    "2": "AccountNumber",
                    "4": "Broker",
                    "5": "DepositCategory",
                    "6": "FirstDealDate",
                    "7": "FolderType",
                    "8": "NumberOfDeals",
                    "9": "NumberOfDeposits",
                    "10": "Serial",
                    "11": "VolumeCategory"
                };

                var dimensions = {};
                for (var gadimension in window._gadimensions) {
                    if (typeof window._gadimensions[gadimension] != "string") {
                        continue;
                    }

                    if (properties[window._gadimensions[gadimension]]) {
                        dimensions["dimension" + gadimension] = properties[window._gadimensions[gadimension]];
                        delete window._gadimensions[gadimension];
                    }
                }

                window.ga("set", dimensions);
            }
        } catch (e) { /*console && console.error(arguments); */ }

        window.ga("send", "pageview");
    }

    function init() {
        dataLayer.subscribers.push(loadAnalytics);

        if (null !== window.location.href.match(/\/Parse/i)) {
            pageWithCaptcha.init();
        } else {
            pageNoCaptcha.init();
        }
    }

    return {
        init: init
    };
}));

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('tracking/loggers/fxtracking.lib',
            [
                'tracking/loggers/datalayer',
                'tracking/googleTagManager',
                'tracking/loggers/fxeventslogger',
                'tracking/loggers/fbeventslogger',
                'tracking/loggers/hotjareventslogger',
                'tracking/loggers/snapengagechat',
                'tracking/loggers/gglanalyticslogger'
            ], factory);
    } else {
        root.fxTracking = root.fxTracking || {};

        root.fxTracking.init = factory(root.dataLayer, root.googleTagManager, root.fxTracking.fxEventsLogger,
                                        root.fxTracking.fbEventsLogger, root.fxTracking.hotJarEventsLogger,
                                        root.fxTracking.snapEngageChat, root.fxTracking.gglAnalyticsLogger)
            .init;
    }
}(typeof self !== 'undefined' ? self : this,
    function (dataLayer, googleTagManager, fxEventsLogger, fbEventsLogger, hotJarEventsLogger, snapEngageChat, gglAnalyticsLogger) {
        function init(gtmId, abTestingConfiguration, biServiceURL) {
            var gtmConfiguration = {},
                libs = {
                    "disable-gtm": 'disableGTM',
                    "disable-gtm-fxtracking": 'disableGTMFXTracking',
                    "disable-gtm-gglanalytics": 'disableGTMGoogleAnalytics',
                    "disable-gtm-fbevents": 'disableGTMFacebookEvents',
                    "disable-gtm-hotjar": 'disableGTMHotjar',
                    "disable-gtm-snapchat": 'disableGTMSnapChat'
                };

            for (var t in libs) {
                if (abTestingConfiguration[t] === true) {
                    gtmConfiguration[libs[t]] = true;
                }
            }

            window.gtmConfiguration = {};

            if (Object.keys(gtmConfiguration).length > 0) {
                window.gtmConfiguration = gtmConfiguration;
            }

            dataLayer.init();

            if ('#' != gtmId && !gtmConfiguration.disableGTM) {
                googleTagManager.Init(gtmId);
            }

            _init(gtmConfiguration, biServiceURL);
        }

        function _init(gtmConfiguration, biServiceURL) {
            if (gtmConfiguration.disableGTMGoogleAnalytics) {
                gglAnalyticsLogger.init();
            }

            if (gtmConfiguration.disableGTMFXTracking) {
                fxEventsLogger.init(biServiceURL);
            }

            if (gtmConfiguration.disableGTMFacebookEvents) {
                fbEventsLogger.init();
            }

            if (gtmConfiguration.disableGTMHotjar) {
                hotJarEventsLogger.init();
            }

            if (gtmConfiguration.disableGTMSnapChat) {
                snapEngageChat.init();
            }
        }

        return {
            init: init
        };

    }));
/* global General */
var TradingEventsHandler = function (
  ko,
  trackingData,
  viewModelsManager,
  general,
  eventsCollector
) {
  var events = {
    SocketConnectionTest: 'socket-connection-test',
    View: 'active-view',
    PresetChanged: 'preset-changed',
    FavoriteInstrumentsReorderDrag: 'favorite-instruments-reorder-drag',
    FavoriteInstrumentsReorderDrop: 'favorite-instruments-reorder-drop',
    FavoriteInstrumentUpdate: 'favorite-instrument-update',
    InstrumentTrade: 'instrument-trade',
    NewDealButton: 'new-deal-click',
    NewLimitButton: 'new-limit-click',
    NewLimitDetails: 'new-limit-details',
    MainTabClick: 'main-tab-click',
    SubTabClick: 'sub-tab-click',
    DealSlipErrorDetails: 'deal-slip-error-details',
    DealSlipView: 'deal-slip-view',
    NewDealAndNewLimitDragged: 'new-deal-dragged',
    DealSlipInteraction: 'deal-slip-interaction',
    DealSlipSubmit: 'deal-slip-submit',
    CloseDeal: 'close-deal',
    DealSlipSwitchInstrument: 'deal-slip-switch-instrument',
    DealSlipSwitchTab: 'deal-slip-switch-tab',
    DealSlipExpandLimit: 'deal-slip-expand-limit',
    DealSlipCollapseLimit: 'deal-slip-collapse-limit',
    DealSlipExpandTools: 'deal-slip-expand-tools',
    DealSlipCollapseTools: 'deal-slip-collapse-tools',
    DealChartExpandTools: 'deal-chart-expand-trade-ticket',
    DealChartCollapseTools: 'deal-chart-collapse-trade-ticket',
    DealSlipToggleEvent: 'deal-slip-toggle',
    NewLimitErrorDetails: 'new-limit-error-details',
    NewLimitView: 'new-limit-view',
    LimitSlipInteraction: 'limit-slip-interaction',
    NewLimitSubmit: 'new-limit-submit',
    NewLimitSuccess: 'new-limit-success',
    DepositIFrameLoaded: 'deposit-iframe-loaded',
    DepositTypeChanged: 'deposit-type-changed',
    UiLoaded: 'ui-loaded',
    DealSlipSuccess: 'deal-slip-success',
    DepositSuccess: 'deposit-success',
    WithdrawalError: 'withdrawal-error',
    DepositFailedData: 'deposit-failed-data',
    DepositFailed: 'deposit-failed',
    DepositAlert: 'deposit-alert',

    SwitchTab: 'switch-tab',
    Search: 'search',
    SearchInteraction: 'search-interaction',
    DealSlipSearch: 'deal-slip-search',
    DealSlipSearchInteraction: 'deal-slip-search-interaction',

    MessageView: 'message-view',
    SmartBannerViewOfferClicked: 'sb-view-offer-clicked',
    SmartBannerDepositClicked: 'sb-deposit-clicked',
    RewardCtaClicked: 'reward-cta-clicked',

    PresetSelectionSaved: 'preset-selection-save',
    BackButtonClick: 'back-button-click',
    TradingButtonClick: 'trading-button-click',
    StopLossChanged: 'stop-loss-changed',
    TakeProfitChanged: 'take-profit-changed',

    InstrumentShowMore: 'instrument-show-more',
    InstrumentShowLess: 'instrument-show-less',
    ClickSundayBannerButtonMain: 'click-sunday-banner-button-main',
    ShowSundayBannerMain: 'show-sunday-banner-main',
    SwitchMainView: 'switch-main-view',

    TutorialViewActive: 'tutorial-view-active',
    TutorialOpen: 'tutorial-open',
    TutorialClose: 'tutorial-close',
    TutorialAgreementVew: 'tutorial-agreement-view',
    TutorialAgreementAgree: 'tutorial-agreement-agree',
    TutorialAgreementDecline: 'tutorial-agreement-decline',

    SignalsMenuClick: 'signals-menu-click',
    SignalsDrillDown: 'signals-drill-down',
    SignalsViewMore: 'signals-view-more',
    SignalsDetailNewDeal: 'signals-detail-new-deal',
    SignalsShortTerm: 'short-term-signal-chart',

    EconomicCalendarMenuClick: 'economic-calendar-menu-click',
    CashBackInstrumentClick: 'cash-back-instrument-click',

    QuestionnaireNavigation: 'questionnaire-navigation',
    QuestionnairePage: 'questionnaire-page',
    QuestionnaireQuestion: 'questionnaire-question',
    QuestionnaireFaq: 'questionnaire-faq',
    SupportInteraction: 'support-interaction',
    DepositFaq: 'deposit-faq',
    DocumentsFaq: 'upload-documents-faq',

    DealSlipChartInteraction: 'deal-slip-chart-interaction',
    ChartInteraction: 'chart-interaction',
    ChartPerformance: 'chart-performance',
    ViewSentiments: 'view-sentiments',

    ClosedDealsEvents: 'closed-deals-events',
    NotificationsSettingsChange: 'notifications-settings-change',

    ToolsChart: 'tools-chart',
    StartCallbackRequestChat: 'start-callback-request-chat',

    AccountHub_Close: 'hub-menu-close',
    AccountHub_Open: 'hub-menu-open',
    AccountMap_Collapse: 'hub-map-collapse',
    AccountMap_Expand: 'hub-map-expand',

    ActionSource: 'action-source',
    AccountState: 'account-state',
    PriceAlertsMenuView: 'price-alerts-menu-view',
    PriceAlertCreate: 'price-alert-create',
    PriceAlertError: 'price-alert-error',
    SlipChangeHighLowTerm: 'deal-slip-change-highlow-term',

    HelpCenter: 'help-center',
    EconomicCalendarTradeCta: 'economic-calendar-trade-cta',
    RedirectLink: 'redirect-link-tracking',
  };

  var questionnaireData = {
    startTime: 0,
    category: '',
    questionnaireType: null,
  };

  var data = {
    viewId: '',
    presetName: '',
    instrumentName: '',
    tradingDirection: '',
    orderDirName: '',
    newDealButton: '',
    newLimitDetails: {},
    depositType: '',
    takeProfitType: 'none',
    stopLossType: 'none',
    tabName: '',
    limit: '',
    enableSLLimit: '',
    enableTPLimit: '',
    tools: '',
    timestamp: '',
    isCashBackInstrumentClick: false,
    actionSource: 'Other',
    existingRefferal: '',
    refferalDescription: '',
  };

  var stateData = {
    fromSearch: {
      Characters: typeof undefined,
      Instrument: typeof undefined,
    },
  };

  var tradeFormMode = '',
    refferingView = '',
    tabHierarchy = 'main tab';

  var init = function () {
    ko.postbox.subscribe(
      events.SocketConnectionTest,
      consumeSocketConnectionTest
    );
    ko.postbox.subscribe(events.SupportInteraction, consumeSupportInteraction);
    ko.postbox.subscribe(events.QuestionnaireFaq, consumeQuestionnaireFaqEvent);
    ko.postbox.subscribe(events.DepositFaq, consumeDepositFaqEvent);
    ko.postbox.subscribe(
      events.QuestionnairePage,
      consumeQuestionnairePageEvent
    );
    ko.postbox.subscribe(
      events.QuestionnaireQuestion,
      consumeQuestionnaireQuestionEvent
    );
    ko.postbox.subscribe(
      events.QuestionnaireNavigation,
      consumeQuestionnaireNavigationEvent
    );
    ko.postbox.subscribe(events.View, consumeViewChangeEvent);
    ko.postbox.subscribe(events.PresetChanged, consumeViewPresetChangeEvent);
    ko.postbox.subscribe(
      events.FavoriteInstrumentsReorderDrag,
      consumeFavoriteInstrumentDrag
    );
    ko.postbox.subscribe(
      events.FavoriteInstrumentsReorderDrop,
      consumeFavoriteInstrumentDrop
    );
    ko.postbox.subscribe(
      events.FavoriteInstrumentUpdate,
      consumeFavoriteInstrumentUpdate
    );
    ko.postbox.subscribe(events.InstrumentTrade, consumeInstrumentTradeEvent);
    ko.postbox.subscribe(events.NewDealButton, consumeNewDealButtonClickEvent);
    ko.postbox.subscribe(
      events.NewLimitButton,
      consumeNewLimitButtonClickEvent
    );
    ko.postbox.subscribe(
      events.NewLimitDetails,
      consumeNewLimitDetailsChangedEvent
    );
    ko.postbox.subscribe(events.MainTabClick, consumeMainTabClickEvent);
    ko.postbox.subscribe(events.SubTabClick, consumeSubTabClickEvent);
    ko.postbox.subscribe(
      events.DealSlipErrorDetails,
      consumeDealSlipErrorEvent
    );
    ko.postbox.subscribe(events.DealSlipView, consumeDealSlipViewEvent);
    ko.postbox.subscribe(
      events.NewDealAndNewLimitDragged,
      consumeNewDealAndNewLimitDraggedEvent
    );
    ko.postbox.subscribe(
      events.DealSlipInteraction,
      consumeDealSlipInteractionEvent
    );
    ko.postbox.subscribe(events.DealSlipSubmit, consumeDealSlipSubmitEvent);
    ko.postbox.subscribe(events.CloseDeal, consumeCloseDealEvent);
    ko.postbox.subscribe(
      events.DealSlipSwitchInstrument,
      consumeDealSlipSwitchInstrumentEvent
    );
    ko.postbox.subscribe(
      events.DealSlipSwitchTab,
      consumeDealSlipSwitchTabEvent
    );
    ko.postbox.subscribe(
      events.DealSlipExpandLimit,
      consumeDealSlipExpandLimitEvent
    );
    ko.postbox.subscribe(
      events.DealSlipCollapseLimit,
      consumeDealSlipCollapseLimitEvent
    );
    ko.postbox.subscribe(
      events.DealSlipToggleEvent,
      consumeDealSlipToggleEvent
    );
    ko.postbox.subscribe(
      events.DealSlipExpandTools,
      consumeDealSlipExpandToolsEvent
    );
    ko.postbox.subscribe(
      events.DealSlipCollapseTools,
      consumeDealSlipCollapseToolsEvent
    );
    ko.postbox.subscribe(
      events.NewLimitErrorDetails,
      consumeNewLimitErrorEvent
    );
    ko.postbox.subscribe(
      events.DepositIFrameLoaded,
      consumeDepositIFrameLoadedEvent
    );
    ko.postbox.subscribe(
      events.DepositTypeChanged,
      consumeDepositTypeChangedEvent
    );
    ko.postbox.subscribe(events.UiLoaded, consumeUiLoadedEvent);
    ko.postbox.subscribe(events.DealSlipSuccess, consumeDealSlipSuccessEvent);
    ko.postbox.subscribe(events.DepositSuccess, consumeDepositSuccessEvent);
    ko.postbox.subscribe(
      events.DepositFailedData,
      consumeDepositFailedDataEvent
    );
    ko.postbox.subscribe(events.DepositFailed, consumeDepositFailedEvent);
    ko.postbox.subscribe(events.WithdrawalError, consumeWithdrawalErrorEvent);
    ko.postbox.subscribe(events.DepositAlert, consumeDepositAlertEvent);
    ko.postbox.subscribe(events.NewLimitView, consumeNewLimitViewEvent);
    ko.postbox.subscribe(
      events.LimitSlipInteraction,
      consumeLimitSlipInteractionEvent
    );
    ko.postbox.subscribe(events.NewLimitSubmit, consumeNewLimitSubmitEvent);
    ko.postbox.subscribe(events.NewLimitSuccess, consumeNewLimitSuccessEvent);

    ko.postbox.subscribe(events.MessageView, consumeMessageViewEvent);
    ko.postbox.subscribe(
      events.SmartBannerViewOfferClicked,
      consumeSmartBannerViewOfferClickedEvent
    );
    ko.postbox.subscribe(
      events.SmartBannerDepositClicked,
      consumeSmartBannerDepositClickedEvent
    );
    ko.postbox.subscribe(events.RewardCtaClicked, consumeRewardCtaClickedEvent);

    ko.postbox.subscribe(
      events.PresetSelectionSaved,
      consumePresetSelectionSavedEvent
    );
    ko.postbox.subscribe(events.TradingButtonClick, consumeTradingButtonClick);
    ko.postbox.subscribe(events.BackButtonClick, consumeBackButtonClickEvent);
    ko.postbox.subscribe(events.StopLossChanged, consumeStopLossChangedEvent);
    ko.postbox.subscribe(
      events.TakeProfitChanged,
      consumeTakeProfitChangedEvent
    );

    ko.postbox.subscribe(
      events.InstrumentShowMore,
      consumeInstrumentShowMoreEvent
    );
    ko.postbox.subscribe(
      events.InstrumentShowLess,
      consumeInstrumentShowLessEvent
    );
    ko.postbox.subscribe(
      events.ClickSundayBannerButtonMain,
      consumeClickSundayBannerButtonMainEvent
    );
    ko.postbox.subscribe(
      events.ShowSundayBannerMain,
      consumeShowSundayBannerMainEvent
    );

    ko.postbox.subscribe(events.SwitchMainView, consumeSwitchMainViewEvent);

    ko.postbox.subscribe(events.Search, consumeSearchEvent);
    ko.postbox.subscribe(
      events.SearchInteraction,
      consumeSearchInteractionEvent
    );
    ko.postbox.subscribe(events.DealSlipSearch, consumeDealSlipSearchEvent);
    ko.postbox.subscribe(
      events.DealSlipSearchInteraction,
      consumeDealSlipSearchInteractionEvent
    );
    ko.postbox.subscribe(events.ViewSentiments, consumeViewSentiments);

    ko.postbox.subscribe(
      events.TutorialViewActive,
      consumeTutorialViewActiveEvent
    );
    ko.postbox.subscribe(events.TutorialOpen, consumeTutorialOpenEvent);
    ko.postbox.subscribe(events.TutorialClose, consumeTutorialCloseEvent);
    ko.postbox.subscribe(
      events.TutorialAgreementVew,
      consumeTutorialAgreementCiewEvent
    );
    ko.postbox.subscribe(
      events.TutorialAgreementAgree,
      consumeTutorialAgreementAgreeEvent
    );
    ko.postbox.subscribe(
      events.TutorialAgreementDecline,
      consumeTutorialAgreementDeclineEvent
    );

    ko.postbox.subscribe(events.SignalsMenuClick, consumeSignalsMenuClick);
    ko.postbox.subscribe(events.SignalsDrillDown, consumeSignalsDrillDown);
    ko.postbox.subscribe(events.SignalsViewMore, consumeSignalsViewMore);
    ko.postbox.subscribe(
      events.SignalsDetailNewDeal,
      consumeSignalsDetailNewDeal
    );
    ko.postbox.subscribe(events.SignalsShortTerm, consumeSignalsShortTerm);
    ko.postbox.subscribe(
      events.EconomicCalendarMenuClick,
      consumeEconomicCalendarClick
    );
    ko.postbox.subscribe(
      events.CashBackInstrumentClick,
      consumeCashBackInstrumentClick
    );

    ko.postbox.subscribe(
      events.DealSlipChartInteraction,
      consumeDealSlipChartInteractionEvent
    );
    ko.postbox.subscribe(events.ChartInteraction, consumeChartInteractionEvent);
    ko.postbox.subscribe(events.ChartPerformance, consumeChartPerformanceEvent);

    ko.postbox.subscribe(events.ClosedDealsEvents, consumeClosedDealsEvents);

    ko.postbox.subscribe(
      events.NotificationsSettingsChange,
      consumeNotificationsSettingsChangeEvent
    );

    ko.postbox.subscribe(events.ToolsChart, consumeToolsChartEvents);
    ko.postbox.subscribe(
      events.StartCallbackRequestChat,
      consumeStartCallbackRequestChatEvents
    );

    ko.postbox.subscribe(events.AccountHub_Close, consumeAccountHub_Close);
    ko.postbox.subscribe(events.AccountHub_Open, consumeAccountHub_Open);
    ko.postbox.subscribe(
      events.AccountMap_Collapse,
      consumeAccountMap_Collapse
    );
    ko.postbox.subscribe(events.AccountMap_Expand, consumeAccountMap_Expand);

    ko.postbox.subscribe(events.ActionSource, consumeActionSource);
    ko.postbox.subscribe(events.AccountState, consumeAccountState);
    ko.postbox.subscribe(
      events.PriceAlertsMenuView,
      consumePriceAlertsMenuView
    );
    ko.postbox.subscribe(events.PriceAlertCreate, consumePriceAlertCreate);
    ko.postbox.subscribe(events.PriceAlertError, consumePriceAlertError);
    ko.postbox.subscribe(
      events.SlipChangeHighLowTerm,
      consumeSlipChangeHighLowTerm
    );

    ko.postbox.subscribe(events.HelpCenter, consumeHelpCenterEvents);
    ko.postbox.subscribe(
      events.EconomicCalendarTradeCta,
      consumeEconomicCalendarTradeCta
    );
    ko.postbox.subscribe(events.RedirectLink, consumeRedirectLinkEvent);
      subscribeMarketInfoEvents();

      ko.postbox.subscribe(
          events.DealChartExpandTools,
          consumeDealChartExpandToolsEvent
      );

      ko.postbox.subscribe(
          events.DealChartCollapseTools,
          consumeDealChartCollapseToolsEvent
      );
  };

  var subscribeMarketInfoEvents = function () {
    Object.keys(eMarketInfoEvents).forEach(function (eKey) {
      var eName = eMarketInfoEvents[eKey];

      ko.postbox.subscribe(eName, function () {
        eventsCollector.consumeEvent(eName, setSlipExpandedAreasInfo());
      });
    });
  };

  var consumeRedirectLinkEvent = function (eventData) {
    eventsCollector.consumeEvent(events.RedirectLink, eventData);
  };

  var consumeSlipChangeHighLowTerm = function (eventData) {
    eventsCollector.consumeEvent(events.SlipChangeHighLowTerm, eventData);
  };

  var consumePriceAlertError = function (eventData) {
    eventsCollector.consumeEvent(events.PriceAlertError, eventData);
  };

  var consumePriceAlertCreate = function () {
    eventsCollector.consumeEvent(events.PriceAlertCreate);
  };

  var consumePriceAlertsMenuView = function () {
    eventsCollector.consumeEvent(events.PriceAlertsMenuView);
  };

  var consumeSocketConnectionTest = function () {
    eventsCollector.consumeEvent(events.SocketConnectionTest);
  };

  var consumeSupportInteraction = function (element) {
    var eventData = { element: element };
    switch (viewModelsManager.VManager.ActiveFormType()) {
      case eForms.ClientQuestionnaire:
      case eForms.Help:
        eventData.category = questionnaireData.category;
        eventData.view = 'questionnaire';
        break;
      case eForms.Deposit:
      case eForms.HelpDeposit:
        eventData.category = 'deposit choice';
        eventData.view = 'deposit';
        break;
      case eForms.ConcretePaymentForm:
      case eForms.HelpConcretePaymentForm:
        eventData.category = 'deposit form';
        eventData.view = 'deposit';
        break;
      case eForms.DepositPending:
      case eForms.DepositSuccess:
      case eForms.HelpDepositThankYou:
        eventData.category = 'deposit confirm';
        eventData.view = 'deposit';
        break;
      case eForms.HelpUploadDocuments:
        eventData.category = 'upload documents';
        eventData.view = 'upload documents';
        break;
      default:
        eventData.category = '';
        eventData.view = viewModelsManager.VManager.ActiveFormName();
    }

    eventsCollector.consumeEvent(events.SupportInteraction, eventData);
  };

  var consumeQuestionnaireFaqEvent = function (questionID) {
    eventsCollector.consumeEvent(events.QuestionnaireFaq, {
      category: questionnaireData.category,
      questionID: questionID,
      view: 'questionnaire',
    });
  };

  var consumeDepositFaqEvent = function (questionID) {
    var eventData = { questionID: questionID };

    switch (viewModelsManager.VManager.ActiveFormType()) {
      case eForms.Deposit:
      case eForms.HelpDeposit:
        eventData.category = 'deposit choice';
        eventData.view = 'deposit';
        break;
      case eForms.ConcretePaymentForm:
      case eForms.HelpConcretePaymentForm:
        eventData.category = 'deposit form';
        eventData.view = 'deposit';
        break;
      case eForms.DepositPending:
      case eForms.DepositSuccess:
      case eForms.HelpDepositThankYou:
        eventData.category = 'deposit confirm';
        eventData.view = 'deposit';
        break;
      case eForms.HelpUploadDocuments:
        eventData.category = 'upload documents';
        eventData.view = 'upload documents';
        break;
      default:
        eventData.category = '';
        eventData.view = viewModelsManager.VManager.ActiveFormName();
    }

    eventsCollector.consumeEvent(events.DepositFaq, eventData);
  };

  var consumeQuestionnairePageEvent = function (eventData) {
    questionnaireData.category = eventData.category;
    if (eventData.questionnaireType === eQuestionnaireType.MIFID) {
      questionnaireData.startTime = 0;
    }
    questionnaireData.questionnaireType = eventData.questionnaireType;
  };

  var consumeQuestionnaireQuestionEvent = function (questionID) {
    var elapsedTime;
    var timeStamp = new Date().getTime();
    // on first question
    if (questionnaireData.startTime === 0) {
      questionnaireData.startTime = timeStamp;
      elapsedTime = 0;
      var questionnaireStartEventName =
        questionnaireData.questionnaireType === eQuestionnaireType.MIFID
          ? 'questionnaire-quiz-start'
          : 'questionnaire-start';

      eventsCollector.consumeEvent(questionnaireStartEventName, {
        category: questionnaireData.category,
      });
    } else {
      elapsedTime = (
        (timeStamp - questionnaireData.startTime) /
        1000
      ).toFixed();
    }

    eventsCollector.consumeEvent(events.QuestionnaireQuestion, {
      category: questionnaireData.category,
      questionID: questionID,
      elapsedTime: elapsedTime,
    });
  };

  var consumeSearchEvent = function (eventData) {
    eventData = eventData || {};
    stateData.fromSearch.Characters = eventData.Characters;
    delete stateData.fromSearch.Instrument;

    eventsCollector.consumeEvent(events.Search, {
      Characters: eventData.Characters,
    });
  };

  var consumeSearchInteractionEvent = function (eventData) {
    eventData = eventData || {};
    stateData.fromSearch.Instrument = eventData.Instrument;

    var instrument;
    if (
      (instrument = $instrumentsManager.GetInstrument(eventData.Instrument.id))
    ) {
      stateData.fromSearch.Instrument.ccyPair = instrument.ccyPair;
    }

    eventsCollector.consumeEvent(events.SearchInteraction, {
      Instrument: stateData.fromSearch.Instrument.ccyPair,
      SearchResult: true,
    });
  };

  var consumeDealSlipSearchEvent = function (eventData) {
    eventData = eventData || {};
    stateData.fromSearch.Characters = eventData.Characters;
    delete stateData.fromSearch.Instrument;

    eventsCollector.consumeEvent(events.DealSlipSearch, {
      Characters: eventData.Characters,
    });
  };

  var consumeDealSlipSearchInteractionEvent = function (eventData) {
    eventData = eventData || {};
    stateData.fromSearch.Instrument = eventData.Instrument;

    var instrument;
    if (
      (instrument = $instrumentsManager.GetInstrument(eventData.Instrument.id))
    ) {
      stateData.fromSearch.Instrument.ccyPair = instrument.ccyPair;
    }

    eventsCollector.consumeEvent(events.DealSlipSearchInteraction, {
      Instrument: stateData.fromSearch.Instrument.ccyPair,
      SearchResult: true,
    });
  };

  var consumeViewChangeEvent = function (viewId) {
    if (data.viewId === viewId) {
      // report only once per view
      data.actionSource = 'Other';
      return;
    }

    if (!general.isEmpty(data.refferalDescription)) {
      data.refferalDescription = '';
    }

    if (!general.isEmpty(data.existingRefferal)) {
      data.refferalDescription = data.existingRefferal;
      data.existingRefferal = '';
    }

    data.viewId = viewId;
    data.instrumentName = '';
    data.tradingDirection = '';
    data.newDealButton = '';
    tradeFormMode = 'Auto';
    questionnaireData.startTime = 0;
    eventsCollector.consumeEvent('View');
  };

  var consumeQuestionnaireNavigationEvent = function (eventData) {
    eventsCollector.consumeEvent(events.QuestionnaireNavigation, eventData);
  };

  var consumeViewPresetChangeEvent = function (presetName) {
    data.presetName = presetName;
    data.instrumentName = '';
    data.tradingDirection = '';
    data.newDealButton = '';
  };

  var consumeFavoriteInstrumentDrag = function (instrumentId) {
    data.instrumentId = instrumentId;
  };

  var consumeFavoriteInstrumentDrop = function () {
    eventsCollector.consumeEvent('favorite-instruments-reorder', {
      instrumentId: data.instrumentId,
    });
  };

  var consumeFavoriteInstrumentUpdate = function (options) {
    if (options.isAddInstrument) {
      eventsCollector.consumeEvent('favorite-instruments-add', {
        instrumentId: options.instrumentId,
      });
    } else if (options.isRemoveInstrument) {
      eventsCollector.consumeEvent('favorite-instruments-remove', {
        instrumentId: options.instrumentId,
      });
    }
  };

  var consumeInstrumentTradeEvent = function (tradingOptions) {
    data.instrumentName = tradingOptions.instrumentName;
    data.tradingDirection =
      general.isDefinedType(tradingOptions.tradingDirection) == false
        ? ''
        : tradingOptions.tradingDirection;
    tradeFormMode = 'Manual';
  };

  var consumeNewDealButtonClickEvent = function () {
    data.newDealButton = 'NewDeal';
    data.presetName = '';
    data.instrumentName = '';
    data.tradingDirection = '';
    tradeFormMode = 'Manual';
  };

  var consumeNewLimitButtonClickEvent = function () {
    tradeFormMode = 'Manual';
  };

  var consumeMainTabClickEvent = function (additionalData) {
    tabHierarchy = 'main tab';

    eventsCollector.consumeEvent(
      'switch-tab',
      Object.assign(
        {
          viewId: data.viewId,
          hierarchy: tabHierarchy,
          presetName: data.presetName,
        },
        additionalData || {}
      )
    );
  };

  var consumeSubTabClickEvent = function () {
    tabHierarchy = 'sub tab';

    eventsCollector.consumeEvent('switch-tab', {
      viewId: data.viewId,
      hierarchy: tabHierarchy,
      presetName: data.presetName,
    });
  };

  var consumeNewLimitViewEvent = function (newLimitViewDetails) {
    data.timestamp = new Date().getTime();

    newLimitViewDetails.displayMode = tradeFormDisplayMode();
    newLimitViewDetails.referrer = getReferrerDescription();
    setAmountVersion(newLimitViewDetails);
    setSlipExpandedAreasInfo(newLimitViewDetails);

    eventsCollector.consumeEvent('new-limit-view', newLimitViewDetails);
  };

  var consumeLimitSlipInteractionEvent = function (
    limitSlipInteractionDetails
  ) {
    setDealSlipCommonProperties(limitSlipInteractionDetails);
    limitSlipInteractionDetails.ElapsedTime = getElapsedTime();
    limitSlipInteractionDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);
    setAmountVersion(limitSlipInteractionDetails);
    setSlipExpandedAreasInfo(limitSlipInteractionDetails);

    eventsCollector.consumeEvent(
      'limit-slip-interaction',
      limitSlipInteractionDetails
    );
  };

  var consumeNewLimitSubmitEvent = function () {
    var newLimitSubmitDetails = {};
    newLimitSubmitDetails.ElapsedTime = getElapsedTime();
    setAmountVersion(newLimitSubmitDetails);
    setSlipExpandedAreasInfo(newLimitSubmitDetails);

    eventsCollector.consumeEvent('new-limit-submit', newLimitSubmitDetails);
  };

  var consumeNewLimitDetailsChangedEvent = function (newLimitDetails) {
    data.newLimitDetails.tradingDirection = newLimitDetails.tradingDirection;
    data.newLimitDetails.dealSize = newLimitDetails.dealSize;
    data.newLimitDetails.isAdvancedView = newLimitDetails.isAdvancedView;
    data.newLimitDetails.expirationType = newLimitDetails.expirationType;
  };

  var consumeUiLoadedEvent = function () {
    var sessionStorage = StorageFactory(StorageFactory.eStorageType.session);

    if (sessionStorage.getItem('registrationSubmitClicked')) {
      sessionStorage.removeItem('registrationSubmitClicked');
      eventsCollector.consumeEvent('registration-success');
      eventsCollector.consumeEvent('login-success');
    }

    if (sessionStorage.getItem('loginSubmitClicked')) {
      sessionStorage.removeItem('loginSubmitClicked');
      eventsCollector.consumeEvent(
        'login-success',
        sessionStorage.getItem('isAutologin')
      );
    }

    if (sessionStorage.getItem('registrationCompleteLoginButtonClicked')) {
      sessionStorage.removeItem('registrationCompleteLoginButtonClicked');
      eventsCollector.consumeEvent('login-success');
    }

    if (sessionStorage.getItem('forgotPasswordResetSubmitClicked')) {
      sessionStorage.removeItem('forgotPasswordResetSubmitClicked');
      eventsCollector.consumeEvent('forgot-password-success');
      eventsCollector.consumeEvent('login-success');
    }
  };

  var setExtendedCommonProperties = function (details) {
    details.TabName = data.tools === 'minimized' ? '' : data.tabName;
    details.Limit = data.limit;
    details.Tools = data.tools;
  };

  function setAmountVersion(details) {
    details.version = 'AmntValue2018';
  }

  function setSlipExpandedAreasInfo(details) {
    var sectionTitles = [
        'TradingSentiment',
        'MarketInfo',
        'HighLow',
        'InstrumentInfo',
      ],
      cmp = window.hasOwnProperty('CustomerProfileManager')
        ? window.CustomerProfileManager
        : null,
      initConfig = window.hasOwnProperty('configuration/initconfiguration')
        ? window.InitConfiguration
        : null,
      profile = !General.isEmptyValue(cmp) ? cmp.ProfileCustomer() : null,
      initSectionsConfig = !General.isEmptyValue(initConfig)
        ? initConfig.MarketInfoSectionsConfiguration
        : {},
      getStatus = function (expanded) {
        return expanded ? 'maximized' : 'minimized';
      },
      result = [];

    details = details || {};

    if (profile) {
      Object.keys(eMarketInfoSectionsProps).forEach(function (prop) {
        if (!General.isEmptyValue(profile[prop])) {
          result.push(
            sectionTitles[eMarketInfoSectionsProps[prop]] +
              ':' +
              getStatus(profile[prop])
          );
        } else {
          result.push(
            sectionTitles[eMarketInfoSectionsProps[prop]] +
              ':' +
              getStatus(initSectionsConfig[prop])
          );
        }
      });
    }

    details.SlipExpandedInfoAreas = result.join(' ');
    return details;
  }

  var setDealSlipCommonProperties = function (details) {
    setExtendedCommonProperties(details);
    setAmountVersion(details);
    details.referrer = getReferrerDescription();
  };

  var consumeDealSlipErrorEvent = function (dealSlipErrorDetails) {
    setDealSlipCommonProperties(dealSlipErrorDetails);

    dealSlipErrorDetails.ElapsedTime = getElapsedTime();
    dealSlipErrorDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);
    setSlipExpandedAreasInfo(dealSlipErrorDetails);

    eventsCollector.consumeEvent('deal-slip-error', dealSlipErrorDetails);
  };

  var consumeDealSlipViewEvent = function (dealSlipViewDetails) {
    data.timestamp = new Date().getTime();
    data.tabName = dealSlipViewDetails.tabName;
    data.limit = dealSlipViewDetails.limit;
    data.tools = dealSlipViewDetails.tools;
    data.instrumentName = dealSlipViewDetails.instrument;
    data.tradingDirection =
      dealSlipViewDetails.orderDir == eOrderDir.Buy
        ? 'ask'
        : dealSlipViewDetails.orderDir == eOrderDir.Sell
        ? 'bid'
        : 'none';
    data.newDealButton =
      dealSlipViewDetails.orderDir == eOrderDir.None ? data.newDealButton : '';
    setDealSlipCommonProperties(dealSlipViewDetails);
    dealSlipViewDetails.displayMode = tradeFormMode;
    if (
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      dealSlipViewDetails.id === stateData.fromSearch.Instrument.id
    ) {
      dealSlipViewDetails.SearchResult = true;
    } else {
      dealSlipViewDetails.SearchResult = false;
      delete stateData.fromSearch.Instrument;
    }

    data.isCashBackInstrumentClick = false;
    setSlipExpandedAreasInfo(dealSlipViewDetails);

    eventsCollector.consumeEvent('deal-slip-view', dealSlipViewDetails);
  };

  var consumeNewDealAndNewLimitDraggedEvent = function (
    newDealAndNewLimitDraggedDetails
  ) {
    setDealSlipCommonProperties(newDealAndNewLimitDraggedDetails);
    newDealAndNewLimitDraggedDetails.ElapsedTime = getElapsedTime();

    eventsCollector.consumeEvent(
      'new-deal-dragged',
      newDealAndNewLimitDraggedDetails
    );
  };

  var consumeDealSlipInteractionEvent = function (dealSlipInteractionDetails) {
    setDealSlipCommonProperties(dealSlipInteractionDetails);
    dealSlipInteractionDetails.ElapsedTime = getElapsedTime();
    dealSlipInteractionDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);
    setSlipExpandedAreasInfo(dealSlipInteractionDetails);

    eventsCollector.consumeEvent(
      'deal-slip-interaction',
      dealSlipInteractionDetails
    );
  };

  var consumeDealSlipSubmitEvent = function (dealSlipSubmitDetails) {
    setDealSlipCommonProperties(dealSlipSubmitDetails);
    data.tradingDirection =
      dealSlipSubmitDetails.orderDir == eOrderDir.Buy
        ? 'ask'
        : dealSlipSubmitDetails.orderDir == eOrderDir.Sell
        ? 'bid'
        : 'none';
    data.orderDirName =
      dealSlipSubmitDetails.orderDir == eOrderDir.Buy
        ? 'Buy'
        : dealSlipSubmitDetails.orderDir == eOrderDir.Sell
        ? 'Sell'
        : 'None';
    data.dealSize = dealSlipSubmitDetails.dealSize;
    data.enableSLLimit = dealSlipSubmitDetails.enableSLLimit;
    data.enableTPLimit = dealSlipSubmitDetails.enableTPLimit;
    dealSlipSubmitDetails.stopLossType = data.stopLossType;
    dealSlipSubmitDetails.takeProfitType = data.takeProfitType;

    dealSlipSubmitDetails.ElapsedTime = getElapsedTime();
    dealSlipSubmitDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);
    setSlipExpandedAreasInfo(dealSlipSubmitDetails);

    eventsCollector.consumeEvent('deal-slip-submit', dealSlipSubmitDetails);
  };

  var consumeCloseDealEvent = function (closeDealInfo) {
    eventsCollector.consumeEvent('close-deal', closeDealInfo);
  };

  var consumeDealSlipSwitchInstrumentEvent = function (
    dealSlipSwitchInstrumentDetails
  ) {
    setDealSlipCommonProperties(dealSlipSwitchInstrumentDetails);

    dealSlipSwitchInstrumentDetails.ElapsedTime = getElapsedTime();
    dealSlipSwitchInstrumentDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      stateData.fromSearch.Instrument.id === dealSlipSwitchInstrumentDetails.id;

    if (!dealSlipSwitchInstrumentDetails.SearchResult) {
      delete stateData.fromSearch.Instrument;
    }

    eventsCollector.consumeEvent(
      'deal-slip-switch-instrument',
      dealSlipSwitchInstrumentDetails
    );
  };

  var consumeDealSlipSwitchTabEvent = function (dealSlipSwitchTabDetails) {
    data.tabName = dealSlipSwitchTabDetails.tabName;
    setDealSlipCommonProperties(dealSlipSwitchTabDetails);

    dealSlipSwitchTabDetails.ElapsedTime = getElapsedTime();
    dealSlipSwitchTabDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);

    eventsCollector.consumeEvent(
      'deal-slip-switch-tab',
      dealSlipSwitchTabDetails
    );
  };

  var consumeDealSlipExpandLimitEvent = function (dealSlipExpandLimitDetails) {
    data.limit = dealSlipExpandLimitDetails.limit;
    setDealSlipCommonProperties(dealSlipExpandLimitDetails);

    dealSlipExpandLimitDetails.ElapsedTime = getElapsedTime();
    dealSlipExpandLimitDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);

    eventsCollector.consumeEvent(
      'deal-slip-expand-limit',
      dealSlipExpandLimitDetails
    );
  };

  var consumeDealSlipCollapseLimitEvent = function (
    dealSlipCollapseLimitDetails
  ) {
    data.limit = dealSlipCollapseLimitDetails.limit;
    setDealSlipCommonProperties(dealSlipCollapseLimitDetails);

    dealSlipCollapseLimitDetails.ElapsedTime = getElapsedTime();
    dealSlipCollapseLimitDetails.SearchResult =
      general.isDefinedType(stateData.fromSearch.Instrument) &&
      general.isDefinedType(stateData.fromSearch.Instrument.id);

    eventsCollector.consumeEvent(
      'deal-slip-collapse-limit',
      dealSlipCollapseLimitDetails
    );
  };

  var consumeDealSlipToggleEvent = function (dealSlipToggleLimitDetails) {
    data.limit = dealSlipToggleLimitDetails.limit;
  };

    var consumeDealSlipExpandToolsEvent = function (dealSlipExpandToolsDetails) {
        data.tools = dealSlipExpandToolsDetails.tools;
        setDealSlipCommonProperties(dealSlipExpandToolsDetails);

        dealSlipExpandToolsDetails.ElapsedTime = getElapsedTime();
        dealSlipExpandToolsDetails.SearchResult =
            general.isDefinedType(stateData.fromSearch.Instrument) &&
            general.isDefinedType(stateData.fromSearch.Instrument.id);

        eventsCollector.consumeEvent(
            'deal-slip-expand-tools',
            dealSlipExpandToolsDetails
        );
    };

    var consumeDealSlipCollapseToolsEvent = function (dealSlipCollapseToolsDetails) {
        data.tools = dealSlipCollapseToolsDetails.tools;
        setDealSlipCommonProperties(dealSlipCollapseToolsDetails);

        dealSlipCollapseToolsDetails.ElapsedTime = getElapsedTime();
        dealSlipCollapseToolsDetails.SearchResult =
            general.isDefinedType(stateData.fromSearch.Instrument) &&
            general.isDefinedType(stateData.fromSearch.Instrument.id);

        eventsCollector.consumeEvent(
            'deal-slip-collapse-tools',
            dealSlipCollapseToolsDetails
        );
    };

    var consumeDealChartExpandToolsEvent = function () {
        eventsCollector.consumeEvent( 'deal-chart-expand-trade-ticket');
    };

    var consumeDealChartCollapseToolsEvent = function () {
        eventsCollector.consumeEvent('deal-chart-collapse-trade-ticket');
    };

  var consumeNewLimitErrorEvent = function (newLimitErrorDetails) {
    newLimitErrorDetails.ElapsedTime = getElapsedTime();
    setAmountVersion(newLimitErrorDetails);
    setSlipExpandedAreasInfo(newLimitErrorDetails);

    eventsCollector.consumeEvent('new-limit-error', newLimitErrorDetails);
  };

  var consumeDepositAlertEvent = function (depositAlertArguments) {
    var text = depositAlertArguments[0],
      redirectUrl = depositAlertArguments[1];

    if (typeof redirectUrl === 'string' && redirectUrl !== '') {
      consumeDepositSuccessEvent();
      return;
    }

    eventsCollector.consumeEvent('deposit-error', {
      type: 'server',
      errorMessage: text,
    });
  };

  var consumeDepositIFrameLoadedEvent = function (iframeDetails) {
    var $depositIframe = $('iframe[id=' + iframeDetails.iframeid + ']');

    $depositIframe.contents().click(function () {
      eventsCollector.consumeEvent('deposit-interaction');
    });

    var depositButtonSearchResult = $depositIframe
      .contents()
      .find('[data-deposit-button]');
    if (depositButtonSearchResult.length == 1) {
      $(depositButtonSearchResult[0]).click(function () {
        eventsCollector.consumeEvent('deposit-submit');
      });
    }
  };

  var consumeDepositTypeChangedEvent = function (depositDetails) {
    data.depositType = depositDetails.depositType;
  };

  var consumeDealSlipSuccessEvent = function (dealSlipSuccessDetails) {
    setDealSlipCommonProperties(dealSlipSuccessDetails);
    dealSlipSuccessDetails.ElapsedTime = getElapsedTime();
    dealSlipSuccessDetails.displayMode = tradeFormMode;
    dealSlipSuccessDetails.type = data.orderDirName;
    dealSlipSuccessDetails.dealSize = data.dealSize;
    dealSlipSuccessDetails.stopLossType = data.stopLossType;
    dealSlipSuccessDetails.takeProfitType = data.takeProfitType;
    dealSlipSuccessDetails.enableSLLimit = data.enableSLLimit;
    dealSlipSuccessDetails.enableTPLimit = data.enableTPLimit;
    setSlipExpandedAreasInfo(dealSlipSuccessDetails);
    trackingData.incrementDealsNumber();
    eventsCollector.consumeEvent('deal-slip-success', dealSlipSuccessDetails);
  };

  var consumeNewLimitSuccessEvent = function (newLimitSuccessDetails) {
    newLimitSuccessDetails.ElapsedTime = getElapsedTime();
    newLimitSuccessDetails.type = data.newLimitDetails.tradingDirection;
    newLimitSuccessDetails.dealSize = data.newLimitDetails.dealSize;
    newLimitSuccessDetails.advancedView = data.newLimitDetails.isAdvancedView;
    newLimitSuccessDetails.expirationType = data.newLimitDetails.expirationType;
    newLimitSuccessDetails.stopLossType = data.stopLossType;
    newLimitSuccessDetails.takeProfitType = data.takeProfitType;
    setAmountVersion(newLimitSuccessDetails);
    setSlipExpandedAreasInfo(newLimitSuccessDetails);

    trackingData.incrementDealsNumber();
    eventsCollector.consumeEvent('new-limit-success', newLimitSuccessDetails);
  };

  var consumeDepositSuccessEvent = function () {
    eventsCollector.consumeEvent('deposit-success');

    window.trackingData.incrementDepositsNumber();
  };

  var consumeDepositFailedDataEvent = function (event) {
    var options = { type: 'server' };

    if (event) {
      options.errorMessage = event.message;
      options.errorMessageKey = event.key;
    }

    eventsCollector.consumeEvent('deposit-error', options);
  };

  var consumeDepositFailedEvent = function (event) {
    var options = { type: 'server' };
    options.errorMessage = event;

    eventsCollector.consumeEvent('deposit-error', options);
  };

  var consumeWithdrawalErrorEvent = function (reason) {
    eventsCollector.consumeEvent('withdrawal-error', { reason: reason });
  };

  var consumeMessageViewEvent = function (messageDetails) {
    eventsCollector.consumeEvent('message-view', {
      text: extractTextFromHtml(messageDetails.text),
      type: messageDetails.type,
    });
  };

  var consumeSmartBannerViewOfferClickedEvent = function (messageDetails) {
    eventsCollector.consumeEvent('sb-view-offer-clicked', {
      text: messageDetails.text,
      type: messageDetails.type,
    });
  };

  var consumeSmartBannerDepositClickedEvent = function (messageDetails) {
    eventsCollector.consumeEvent('sb-deposit-clicked', {
      text: messageDetails.text,
    });
  };

  var consumeRewardCtaClickedEvent = function (messageDetails) {
    eventsCollector.consumeEvent('reward-cta-clicked', {});
  };

  var extractTextFromHtml = function (text) {
    var div = document.createElement('div');
    div.innerHTML = text;
    return div.textContent || div.innerText || '';
  };

  var consumePresetSelectionSavedEvent = function (selectedPresetName) {
    eventsCollector.consumeEvent('switch-tab', {
      viewId: data.viewId,
      presetName: selectedPresetName,
    });
  };

  var consumeTradingButtonClick = function (currentPresetName) {
    data.presetName = currentPresetName;
  };

  var consumeBackButtonClickEvent = function (currentView) {};

  var consumeStopLossChangedEvent = function (type) {
    data.stopLossType = type;
  };

  var consumeTakeProfitChangedEvent = function (type) {
    data.takeProfitType = type;
  };

  var consumeInstrumentShowMoreEvent = function () {
    eventsCollector.consumeEvent('instrument-show-more', {
      TabName: data.presetName,
      tabHierarchy: 'sub tab',
    });
  };

  var consumeInstrumentShowLessEvent = function () {
    eventsCollector.consumeEvent('instrument-show-less', {
      TabName: data.presetName,
      tabHierarchy: 'sub tab',
    });
  };

  var consumeViewSentiments = function (eventData) {
    eventsCollector.consumeEvent(events.ViewSentiments, eventData);
  };

  var consumeClickSundayBannerButtonMainEvent = function (elementId) {
    eventsCollector.consumeEvent('click-sunday-banner-button-main', {
      Element: elementId,
    });
  };

  var consumeShowSundayBannerMainEvent = function (elementId) {
    eventsCollector.consumeEvent('show-sunday-banner-main', {
      Element: elementId,
    });
  };

  var consumeSwitchMainViewEvent = function (options) {
    eventsCollector.consumeEvent('switch-main-view', options);
  };

  var consumeTutorialViewActiveEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(
      'tutorial-events',
      Object.assign({ event: 'view-tutorials-page' }, eventData)
    );
  };

  var consumeTutorialOpenEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(
      'tutorial-events',
      Object.assign({ event: 'tutorial-open' }, eventData)
    );
  };

  var consumeTutorialCloseEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(
      'tutorial-events',
      Object.assign({ event: 'tutorial-close' }, eventData)
    );
  };

  var consumeTutorialAgreementCiewEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(
      'tutorial-events',
      Object.assign({ event: 'agreement-view' }, eventData)
    );
  };

  var consumeTutorialAgreementAgreeEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(
      'tutorial-events',
      Object.assign({ event: 'agreement-agree' }, eventData)
    );
  };

  var consumeTutorialAgreementDeclineEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(
      'tutorial-events',
      Object.assign({ event: 'agreement-decline' }, eventData)
    );
  };

  var consumeSignalsMenuClick = function () {
    eventsCollector.consumeEvent('signals-menu-click');
  };

  var consumeSignalsDrillDown = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent('signals-drill-down', eventData);
  };

  var consumeSignalsViewMore = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent('signals-view-more', eventData);
  };

  var consumeSignalsDetailNewDeal = function (data) {
    var signalData = (data || {}).signalData || {};
    signalData.instrument = signalData.instrument || {};

    var eventData = {
      signalId: signalData.signalId,
      symbol: signalData.symbol,
      instrumentId: signalData.instrument.id,
    };

    eventsCollector.consumeEvent('signals-detail-new-deal', eventData);
  };

  var consumeSignalsShortTerm = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent('short-term-signal-chart', eventData);
  };

  var consumeEconomicCalendarClick = function () {
    eventsCollector.consumeEvent('economic-calendar-menu-click');
  };

  var consumeCashBackInstrumentClick = function () {
    data.isCashBackInstrumentClick = true;
  };

  var consumeDealSlipChartInteractionEvent = function (
    dealSlipChartInteractionDetails
  ) {
    setExtendedCommonProperties(dealSlipChartInteractionDetails);
    dealSlipChartInteractionDetails.ElapsedTime = getElapsedTime();

    eventsCollector.consumeEvent(
      'deal-slip-chart-interaction',
      dealSlipChartInteractionDetails
    );
  };

  var consumeChartInteractionEvent = function (chartInteractionDetails) {
    setExtendedCommonProperties(chartInteractionDetails);

    eventsCollector.consumeEvent('chart-interaction', chartInteractionDetails);
  };

  var consumeChartPerformanceEvent = function (
    consumeChartPerformanceEventDetails
  ) {
    eventsCollector.consumeEvent(
      'chart-performance',
      consumeChartPerformanceEventDetails
    );
  };

  var consumeClosedDealsEvents = function (detailsData) {
    eventsCollector.consumeEvent(events.ClosedDealsEvents, detailsData);
  };

  var consumeNotificationsSettingsChangeEvent = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.NotificationsSettingsChange, eventData);
  };

  var consumeToolsChartEvents = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.ToolsChart, eventData);
  };

  var consumeStartCallbackRequestChatEvents = function (eventData) {
    eventData = eventData || {};

    eventsCollector.consumeEvent(events.StartCallbackRequestChat, eventData);
  };

  var consumeAccountHub_Close = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.AccountHub_Close, eventData);
  };

  var consumeAccountHub_Open = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.AccountHub_Open, eventData);
  };

  var consumeAccountMap_Collapse = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.AccountMap_Collapse, eventData);
  };

  var consumeAccountMap_Expand = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.AccountMap_Expand, eventData);
  };

  var consumeActionSource = function (eventData) {
    data.actionSource = eventData;
  };

  var consumeAccountState = function (eventData) {
    trackingData.updateAccountStatus(eventData);
  };

  var consumeHelpCenterEvents = function (eventData) {
    eventData = eventData || {};
    eventsCollector.consumeEvent(events.HelpCenter, eventData);
  };

  var consumeEconomicCalendarTradeCta = function (eventData) {
    data.existingRefferal =
      eventData.View +
      '+' +
      eventData.Tab +
      '+' +
      eventData.EventCountry +
      '+' +
      eventData.EventId +
      '+' +
      eventData.InstrumentName +
      '+' +
      eventData.CalendarEventDate;
    eventsCollector.consumeEvent(events.EconomicCalendarTradeCta, eventData);
  };
  //var consumeHelpCenterOpenEvents = function (eventData) {
  //    eventData = eventData || {};
  //    eventsCollector.consumeEvent(events.HelpCenterOpen, eventData);
  //};
  //var consumeHelpCenterTabSwitchEvents = function (eventData) {
  //    eventData = eventData || {};
  //    eventsCollector.consumeEvent(events.HelpCenterTabSwitch, eventData);
  //};
  //var consumeHelpCenterInteractionEvents = function (eventData) {
  //    eventData = eventData || {};
  //    eventsCollector.consumeEvent(events.HelpCenterInteraction, eventData);
  //};
  //var consumeHelpCenterCloseEvents = function (eventData) {
  //    eventData = eventData || {};
  //    eventsCollector.consumeEvent(events.HelpCenterClose, eventData);
  //};

  var getReferrerDescription = function () {
    var description = data.viewId;

    if (!general.isEmpty(data.refferalDescription)) {
      return data.refferalDescription;
    }

    if (data.viewId === '1') {
      description += '+main';
    }

    if (data.isCashBackInstrumentClick) {
      return description + '+CashBack';
    }

    if (data.newDealButton != String.empty) {
      return description + '+' + data.newDealButton;
    }

    if (data.presetName != String.empty) {
      description = description + '+' + data.presetName;
    }

    if (data.instrumentName != String.empty) {
      description = description + '+' + data.instrumentName;
    }

    if (data.tradingDirection != String.empty) {
      description = description + '+' + data.tradingDirection;
    }

    return description;
  };

  var tradeFormDisplayMode = function () {
    return tradeFormMode;
  };

  var getRefferingView = function () {
    return refferingView;
  };

  var updateRefferingView = function (viewId) {
    refferingView = viewId;
  };

  function getElapsedTime() {
    return ((new Date().getTime() - data.timestamp) / 1000).toFixed();
  }

  return {
    init: init,
    data: data,
    getReferrerDescription: getReferrerDescription,
    tradeFormDisplayMode: tradeFormDisplayMode,
    getRefferingView: getRefferingView,
    updateRefferingView: updateRefferingView,
  };
};

define("trackingIntExt/TradingEventsHandler", ["knockout","trackingIntExt/TrackingData","devicemanagers/ViewModelsManager","handlers/general","tracking/EventsCollector"], (function (global) {
    return function () {
        var ret, fn;
       fn = function (ko, td, vm, ge, ec) {
				return this.TradingEventsHandler(ko, td, vm, ge, ec);
			};
        ret = fn.apply(global, arguments);
        return ret || global.TradingEventsHandler;
    };
}(this)));

/*global Preloader */
define('fxnet/fxnet',[
	"require",
	"knockout",
	"vendor/knockout.validation",
	"helpers/KOExtensions",
	"Q",
	"generalmanagers/ActivitySupervisor",
	"configuration/PlugInConfiguration",
	"devicemanagers/StatesManager",
	"devicecustommodules/PostLoginAlertController",
	"initdatamanagers/InitialDataManager",
	"managers/RetentionManager",
	"initdatamanagers/Customer",
	"managers/CustomerProfileManager",
	"tracking/PerformanceDataCollector",
	"devicemanagers/ViewModelsManager",
	"cachemanagers/CacheManager",
	"initdatamanagers/InstrumentsManager",
	"initdatamanagers/DealsAmountsManager",
	"cachemanagers/dealsmanager",
	"handlers/Logger",
	"cachemanagers/NotificationsManager",
	"modules/PresetsManager",
	"generalmanagers/SessionSupervisor",
	"modules/permissionsmodule",
	"StateObject!Csm",
	"configuration/initconfiguration",
	"modules/environmentData",
	"tracking/loggers/fxtracking.lib",
	"trackingIntExt/TrackingData",
	"trackingIntExt/TradingEventsHandler",
	"tracking/EventsCollector",
	"global/storagefactory",
	"fxnet/preloader",
], function FxNet(require) {
	//test1022ssss
	var ko = require("knockout"),
		Q = require("Q"),
		PerformanceDataCollector = require("tracking/PerformanceDataCollector"),
		ActivitySupervisor = require("generalmanagers/ActivitySupervisor"),
		PlugInConfiguration = require("configuration/PlugInConfiguration"),
		StatesManager = require("devicemanagers/StatesManager"),
		PostLoginsAlerts = require("devicecustommodules/PostLoginAlertController"),
		InitialDataManager = require("initdatamanagers/InitialDataManager"),
		Customer = require("initdatamanagers/Customer"),
		CustomerProfileManager = require("managers/CustomerProfileManager"),
		RetentionManager = require("managers/RetentionManager"),
		ViewModelsManager = require("devicemanagers/ViewModelsManager"),
		RegistrationManager = require("generalmanagers/RegistrationManager"),
		CacheManager = require("cachemanagers/CacheManager"),
		InstrumentsManager = require("initdatamanagers/InstrumentsManager"),
		DealsAmountsManager = require("initdatamanagers/DealsAmountsManager"),
		dealsManager = require("cachemanagers/dealsmanager"),
		logger = require("handlers/Logger"),
		NotificationManager = require("cachemanagers/NotificationsManager"),
		PresetsManager = require("modules/PresetsManager"),
		SessionSupervisor = require("generalmanagers/SessionSupervisor"),
		permissionsModule = require("modules/permissionsmodule"),
		csmStateObject = require("StateObject!Csm"),
		gtmConfiguration = require("configuration/initconfiguration").GTMConfiguration,
		environmentData = require("modules/environmentData").get(),
		fxTracking = require("tracking/loggers/fxtracking.lib"),
		trackingData = require("trackingIntExt/TrackingData"),
		tradingEventsHandler = require("trackingIntExt/TradingEventsHandler"),
		StorageFactory = require("global/storagefactory"),
		Preloader = require("fxnet/preloader"),
		eventsCollector = require("tracking/EventsCollector");

	var sessionSupervisor = new SessionSupervisor(),
		isLoaded = ko.observable(false),
		isVisible = ko.observable(false),
		isCacheLoaded = ko.observable(false),
		uiRederedDefer = Q.defer(),
		localStorage = StorageFactory(StorageFactory.eStorageType.local),
		sessionStorage = StorageFactory(StorageFactory.eStorageType.session),
		loadingFinished = ko.observable(false),
		csmOutOfDate = ko.observable(false);

	csmStateObject.set(eStateObjectTopics.CsmOutOfDate, false);

	function init() {
		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.Init);

		InitialDataManager.OnTimestamp.Add(function (event) {
			PerformanceDataCollector.registerEventTimestamp(event);
		});
		InitialDataManager.OnInitialScreens.Add(function (screens) {
			PresetsManager.SetAvailableScreens(screens);
		});

		CacheManager.Init();
		StatesManager.Init();
		PostLoginsAlerts.Init();

		csmStateObject.subscribe(eStateObjectTopics.CsmOutOfDate, function (value) {
			csmOutOfDate(value);
		});

		InstrumentsManager.OnUiOrderChanged.Add(RegistrationManager.Update);
		RegistrationManager.OnRegistrationListChanged.Add(CacheManager.Register);
		NotificationManager.OnInstrumentsUpdated.Add(InstrumentsManager.UpdateInstruments);
		NotificationManager.OnMinDealAmountsUpdated.Add(InstrumentsManager.ResetInstrumentsDealAmounts);

		PresetsManager.OnPresetsUpdated.Add(InstrumentsManager.SetPresetIntruments);
		DealsAmountsManager.Init();

    dealsManager.OnDealsRemoved.Add(function logRemovedDeals(removedItems) {
        logger.log('FxNet/logRemovedDeals', removedItems);
    });


		PlugInConfiguration.AdjustCulture();
		//for now implemented only in mobile
		PlugInConfiguration.RegisterContentTemplateComponents();

		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.Start);

		var initialData = InitialDataManager.LoadData().then(function () {
			
			PlugInConfiguration.RegisterComponents(Customer.prop.abTestings.configuration);
			applyBindings();

			PresetsManager.Start();
		});

		return Q.all([waitForHtml(), initialData])
			.then(initUiLayer)
			.then(loadCache)
			.then(exposeUI)
			.then(function () {
				return uiRederedDefer.promise;
			})
			.then(function () {
				ko.postbox.publish("ui-loaded");
			});
	}

	function loadCache() {
		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.CacheLoadStart);

		return CacheManager.LoadData().then(function () {
			PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.CacheLoadEnd);
			isCacheLoaded(true);
		});
	}

	function configTRacking() {
		trackingData.init();
		window.trackingData = trackingData;

		eventsCollector.init(trackingData);

		tradingEventsHandler.init();

		window.tradingEventsHandler = tradingEventsHandler;
	}

	function initUiLayer() {
		return Q.fcall(function () {
			PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.UiLayerStart);

			configTRacking();
			// if not dealer mode
			if (permissionsModule.CheckPermissions("gtm")) {
				var gtmId = Dictionary.GetItem(gtmConfiguration.gtmContentKey, "googleTagManagerId");
				fxTracking.init(gtmId, Customer.prop.abTestings.configuration, environmentData.biServiceURL);
			}

			RetentionManager.UpdateToken()
				.then(function (token) {
					if (permissionsModule.CheckPermissions("apiIM")) {
						RetentionManager.SubscribeToInteractiveMessage(token);
					}

					sessionSupervisor.Start();
					PlugInConfiguration.UpdateScmmTrackingData();
				})
				.done();

			ActivitySupervisor.Start();

			ViewModelsManager.Init(CustomerProfileManager.GetUiVersion(), Customer.prop.startUpForm);
		}).then(function () {
			PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.UiLayerEnd);
		});
	}

	function waitForHtml() {
		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.WaitHtmlStart);

		var defer = Q.defer();

		defer.promise.then(function () {
			PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.WaitHtmlEnd);
		});

		function checkPreloader() {
			if (Preloader.DataObjects.htmlReady) {
				defer.resolve();
				return;
			}

			Preloader.SetHtmlLoadEvent(checkPreloader);
		}

		checkPreloader();

		return defer.promise;
	}

	function applyBindings() {
		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.ApplyBindingsStart);

		PlugInConfiguration.BindKO();

		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.ApplyBindingsEnd);
	}

	function exposeUI() {
		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.SplashScreenRemoved);

		isLoaded(true);

		PlugInConfiguration.AdjustHtml();
		PlugInConfiguration.AddPixel();
		PlugInConfiguration.ExposeUI();

		isVisible(true);
	}

	function uiAfterRender() {
		PerformanceDataCollector.registerEventTimestamp(eFxNetEvents.ExposeUi);
		loadingFinished(true);
		uiRederedDefer.resolve();
	}

	var module = (window.FxNet = {
		Init: init,
		IsLoaded: isLoaded,
		CsmOutOfDate: csmOutOfDate,
		IsVisible: isVisible,
		IsCacheLoaded: isCacheLoaded,
		UiRenderedPromise: uiRederedDefer.promise,
		UiAfterRender: uiAfterRender,
		ViewModelsManager: ViewModelsManager,
		exposeUI: exposeUI,
		hideUI: function () {},
		LocalStorage: localStorage,
		SessionStorage: sessionStorage,
		LoadingFinished: loadingFinished,
	});

	return module;
});

define(
    "currentAppFolder/Configuration/config",
    {
        componentsToPreload: [
            "fx-component-slip-toggle",
            "fx-component-dynamic-title-slip",
            "fx-component-transaction-switchwrap",
            "fx-component-transaction-switcher",
            "fx-component-new-deal-slip",
            "fx-component-new-limit",
            "fx-component-new-pricealert",

            "fx-component-transaction-explanation-text",

            "fx-component-edit-limit",
            "fx-component-edit-closing-limit",
            "fx-component-close-deal",
            
            "fx-component-dropdown-instrument-search",
            "fx-component-tile-dropdown-instrument-search",

            "fx-component-deal-tools",
            "fx-component-chart-tool",
            "fx-component-market-info-tool",
            "fx-component-economic-calendar-tool",
            "fx-component-signals-tool",
            "fx-component-instrument-info-tool",
            "fx-schedule-group",

            "fx-upload-documents-page",

            "fx-component-account-summary",

            "fx-component-cash-back",

            "fx-custom-dropdown"
        ]
    }
);


define('fxnet/devices/web/configuration/app',[
	"require",
	"knockout",
	"Q",
	"fxnet/fxnet",
	"generalmanagers/ErrorManager",
	"modules/KoComponentLoader",
	"currentAppFolder/Configuration/config",
	"LoadDictionaryContent!contentdata",
], function (require) {
	var ko = require("knockout"),
		Q = require("Q"),
		FxNet = require("fxnet/fxnet"),
		ErrorManager = require("generalmanagers/ErrorManager"),
		KoComponentLoader = require("modules/KoComponentLoader"),
		config = require("currentAppFolder/Configuration/config");

	function startApp(components) {
		window.onerror = ErrorManager.onException;
		requirejs.onError = ErrorManager.onRequireError;
		window.componentsLoaded = ko.observable(false);
		var isReact = false;

		if (isReact) {
			require(["fxnet/Store", "modules/ReactComponentLoader"], function (store, ReactComponentLoader) {
				ReactComponentLoader.Register(store);
			});
		}

		// register custom component loader
		KoComponentLoader.Register();

		FxNet.Init()
			.then(function () {
				var promisesArr = [];
				for (var i = 0, length = components.length; i < length; i++) {
					if (KoComponentLoader.Exists(components[i])) {
						promisesArr.push(KoComponentLoader.Preload(components[i]));
					}
				}
				return Q.all(promisesArr).then(function () {
					window.componentsLoaded(true);
				});
			})
			.done();
	}

	return startApp.bind(null, config.componentsToPreload || []);
});


define("preloader-web", function(){});

require(["fxnet/preloader"]);

//# sourceMappingURL=preloader-web.js.map